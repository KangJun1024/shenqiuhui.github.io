<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React 基础篇 —— React Hooks</title>
      <link href="/2019/05/07/20190507155411/"/>
      <url>/2019/05/07/20190507155411/</url>
      
        <content type="html"><![CDATA[<img src="/2019/05/07/20190507155411/react-hooks.jpeg" title="React Hooks"><p><br></p><h2 id="React-Hooks-简介"><a href="#React-Hooks-简介" class="headerlink" title="React Hooks 简介"></a>React Hooks 简介</h2><blockquote class="pullquote default"><p><code>React Hooks</code> 是 <code>16.8</code> 版本中正式加入的特性，配合函数组件使用，在没有 <code>Hooks</code> 之前，函数组件使用场景非常有限，只适合编写纯展示性的 <code>UI</code> 组件，其余复杂的场景不得不使用类组件，而 <code>Hooks</code> 的主要作用是在函数组件中使用原本所不具备的 <code>React</code> 特性。</p></blockquote><a id="more"></a><h2 id="React-Hooks-产生的动机"><a href="#React-Hooks-产生的动机" class="headerlink" title="React Hooks 产生的动机"></a>React Hooks 产生的动机</h2><p>在业务开发中，数据主要存在两种形式，业务数据和 <code>UI</code> 数据，我们需要将这两种数据区分开，而有时数据又在组件之间存在共用关系，情况稍微复杂，参数传递的方式就无法满足需求，于是就会有状态管理进入到项目中（<code>Redux</code>、<code>Mobx</code>）等，会增加开发者的学习成本和项目的维护成本。</p><p>使用 <code>React</code> 的开发者都知道，<code>React</code> 主张组件化，就是把业务页面拆分成多个组件进行组合、嵌套、渲染。为了保证项目质量，开发者会花费大量精力在项目的模块化、状态数据最小化以及功能解耦上，而一部分组件会因为数据状态的共享耦合在一起，这时需要使用高阶组件、属性渲染、渲染回调等更高级的 <code>React</code> 特性去解耦，但是会增加代码的复杂程度、降低代码的可读性，在渲染时也会增加 <code>DOM</code> 的层级。</p><p>上面这些实际问题促成了 <code>React Hooks</code> 的诞生，而在有 <code>Hooks</code> 后官方也越来越推荐使用函数组件，主要原因总结如下。</p><ul><li>为了状态相关逻辑的提取和复用；</li><li>解决复杂组件代码变得难以理解的问题；</li><li>解决类组件带给开发者一些容易混淆的点，比如 <code>this</code> 指向问题；</li><li>由于 <code>JS</code> 解释器在解释 <code>class</code> 关键字时的性能问题，使用函数组件代替。</li></ul><blockquote class="pullquote info"><p><code>React</code> 没有重大变化，完全兼容类组件，可以让开发者不必完全重写现有代码，而是在后续开发中逐步尝试使用 <code>Hooks</code>。</p></blockquote><h2 id="React-Hooks-分类"><a href="#React-Hooks-分类" class="headerlink" title="React Hooks 分类"></a>React Hooks 分类</h2><p><strong><code>React</code> 官方主要给 <code>Hooks</code> 分为两大类：</strong></p><ul><li>基础 <code>Hooks API</code>：<code>useState</code>、<code>useEffect</code>、<code>useContext</code>；</li><li>其他 <code>Hooks API</code>：<code>useReducer</code>、<code>useCallback</code>、<code>useImperativeHandle</code>、<code>useMemo</code>、<code>useRef</code>、<code>useLayoutEffect</code>、<code>useDebugValue</code>。</li></ul><h2 id="React-Hooks-使用规则"><a href="#React-Hooks-使用规则" class="headerlink" title="React Hooks 使用规则"></a>React Hooks 使用规则</h2><p>为了保证 <code>Hooks</code> 在使用时不会出现不可预测的问题，官方制定了一定要遵循的两条使用规则（非建议），在此提前声明。</p><blockquote class="pullquote warning"><p><em><strong>1、只在函数组件内部最顶层调用 <code>Hook</code>，不要在循环、条件判断或者嵌套函数中调用；</strong></em><br><em><strong>2、只能在函数组件中调用 <code>Hook</code>（自定义 <code>Hook</code> 中可以调用 <code>Hook</code>），不要在其他 <code>JavaScript</code> 函数中调用。</strong></em></p></blockquote><h2 id="React-Hooks-API"><a href="#React-Hooks-API" class="headerlink" title="React Hooks API"></a>React Hooks API</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 方法用于在函数组件内部实现组件的状态管理，可以起到类组件中 <code>state</code> 一样的作用。</p><figure class="highlight jsx"><figcaption><span>类组件实现的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Components &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Components</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click!</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面是一个类组件实现的计数器，当前计数器的值在类组件的 <code>state</code> 中进行管理。</p><figure class="highlight jsx"><figcaption><span>Hooks 实现的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>使用 <code>React Hooks</code> 的 <code>useState</code> 实现的计数器和类组件实现的功能完全相同，从 <code>useState</code> 实现的代码可以看出 <code>useState</code> 是一个函数，传入的参数是状态的初始值，返回值是一个数组，数组的第一项是当前状态的值，数组的第二项是改变状态值的方法。</p><figure class="highlight jsx"><figcaption><span>实现每次加 2 的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> countAction = <span class="function">(<span class="params">preCount, n</span>) =&gt;</span> preCount + n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(countAction(count, 2))&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面计数器功能的实现逻辑比较简单，下面来看一个类组件实现的稍微复杂的案例，然后再通过 <code>useState</code> 进行重构。</p><figure class="highlight jsx"><figcaption><span>类组件实现的模态切换功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Modal &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Toggle 组件专门提供切换状态和切换方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 on 的值</span></span><br><span class="line">    <span class="keyword">this</span>.state.on = <span class="keyword">this</span>.props.initial;</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123; <span class="attr">on</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  toggle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">on</span>: !<span class="keyword">this</span>.state.on &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.on, <span class="keyword">this</span>.toggle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Toggle initial=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        (on, toggle) =&gt; (</span><br><span class="line">          &lt;Fragment&gt;</span><br><span class="line">            &lt;Button type=<span class="string">"primary"</span> onClick=&#123;toggle&#125;&gt;</span><br><span class="line">              Open Model</span><br><span class="line">            &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Modal visible=&#123;on&#125; onCancel=&#123;toggle&#125;/</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面代码中的类组件 <code>Toggle</code> 主要的作用就是管理模态框显示的状态和对状态的控制，选择使用 <code>children</code> 并传入一个函数，目的是函数可以在类组件内部通过 <code>children</code> 属性调用，并将 <code>Toggle</code> 内部的状态和方法作为参数传入，进而将功能提供给函数组件，这种高级的用法叫做 “渲染回调”，可以成功的将组件进行解耦，但是这样的方式缺点也显而易见，就是代码的逻辑抽象，可读性差，下面来使用 <code>useState</code> 进行重构。</p><figure class="highlight jsx"><figcaption><span>useState 重构切换模态的功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Modal &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ on, setOn ] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Button type=<span class="string">"primary"</span> onClick=&#123;() =&gt; setOn(<span class="literal">true</span>)&#125;&gt;</span><br><span class="line">        Open Model</span><br><span class="line">      &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Modal visible=&#123;on&#125; onCancel=&#123;() =&gt; setOn(false)&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong>因为 <code>React Hooks</code> 的 <code>useState</code> 让函数组件具备了管理组件状态的能力，所以不需要单独实现 <code>Toggle</code> 组件，代码变得更精简、清晰，更函数式编程，更新粒度更细。</strong></p></blockquote><p><code>useState</code> 解构出的用来更改状态的函数传入的参数支持函数类型，传入函数的参数为上一次的状态值，也就是说当更新状态的新值依赖于上一次的值时，会通过这样的方式解决。</p><figure class="highlight jsx"><figcaption><span>当 useState 更新的状态依赖于上一次的值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prev =&gt; prev + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>正如 <code>useEffect</code> 钩子的命名一样，是在函数组件中专门用来处理副作用的，这个副作用是指某些操作使用了函数组件作用域外的变量，而且这个操作的结果会影响函数组件外部的环境。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次渲染后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初次渲染后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Execute once'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 count 更改时才执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count changed'</span>);</span><br><span class="line">  &#125;, [ count ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count)&#125;&gt;</span><br><span class="line">        Click no change!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面案例是通过 <code>useState</code> 一节中的计数器案例改编，我们增加了每次点击计数器将计数器状态同步到页面标题上的功能，并使用 <code>useEffect</code> 实现，<code>useEffect</code> 函数的参数为回调函数，并在每次页面渲染之后执行（包含首次渲染和更新渲染）。</p><blockquote class="pullquote primary"><p><strong>可以使用 <code>useEffect</code> 替代类组件的生命周期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</strong></p></blockquote><p><code>useEffect</code> 还支持传入第二个参数，类型为数组，数组的值为被监听的状态（被 <code>useState</code> 监听），此时 <code>useEffect</code> 内部会做一次比较，数组中变量的值没发生变化时，传入对应 <code>useEffect</code> 的回调不会执行，当传入 <code>useEffect</code> 的数组为空时，则传入的回调只在函数组件首次渲染时执行一次，作用相当于类组件的声明周期 <code>componentDidMount</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Hooks 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HooksCom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times (hooks)`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 类组件</span></span><br><span class="line"><span class="regexp">class ClassCom extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123; count: 1 &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    document.title = `You clicked $&#123;this.state.count&#125; times (class)`;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidUpdate() &#123;</span></span><br><span class="line"><span class="regexp">    document.title = `You clicked $&#123;this.state.count&#125; times (class)`;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;)&#125;&gt;Click!<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Fragment&gt;</span></span><br><span class="line"><span class="regexp">      &lt;HooksCom /</span>&gt;</span><br><span class="line">      &lt;ClassCom /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>通过上面案例，对于使用了 <code>componentDidMount</code> 生命周期的类组件和使用了 <code>useEffect</code> 的函数组件对于页面标题更改的对比，<code>useEffect</code> 的执行会晚于 <code>componentDidMount</code>。</strong></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChatAPI = &#123;</span><br><span class="line">  handle: <span class="literal">null</span>,</span><br><span class="line">  isOnline: <span class="literal">false</span>,</span><br><span class="line">  login() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOnline = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.handle &amp;&amp; <span class="keyword">this</span>.handle(&#123; <span class="attr">isOnline</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  logout() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOnline = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.handle &amp;&amp; <span class="keyword">this</span>.handle(&#123; <span class="attr">isOnline</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  subscribeToFriendStatus(id, handle) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`订阅好友：<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">  &#125;,</span><br><span class="line">  unsubscribeToFriendStatus(id, handle) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`清理好友：<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.handle = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于渲染好友在线状态的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制好友在线的变量和方法</span></span><br><span class="line">  <span class="keyword">const</span> [ isOnline, setIsOnline ] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置好友状态的函数</span></span><br><span class="line">  <span class="keyword">const</span> handleStatusChange = <span class="function">(<span class="params">status</span>) =&gt;</span> setIsOnline(status.isOnline);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 订阅好友状态</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 清除好友状态</span></span><br><span class="line">      ChatAPI.unsubscribeToFriendStatus(props.friend.id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [ props.friend.id ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;计数器：&#123;props.friend.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;br/</span>&gt;</span><br><span class="line">      &lt;span&gt;</span><br><span class="line">        登录状态：</span><br><span class="line">        &#123;</span><br><span class="line">          isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ show, setShow ] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [ userId, setUserId ] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;用户ID：&#123;userId&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;br/</span>&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        show &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">FriendStatus</span> <span class="attr">friend</span>=<span class="string">&#123;&#123;</span> <span class="attr">id:</span> <span class="attr">userId</span>, <span class="attr">name:</span> '<span class="attr">Hello</span>' &#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(!show)&#125;&gt;显示/关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setUserId(userId + 1)&#125;&gt;增加用户ID<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;增加计数器<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;ChatAPI.login.bind(ChatAPI)&#125;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;ChatAPI.logout.bind(ChatAPI)&#125;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面是一个覆盖比较全的 <code>useEffect</code> 案例，用来实现组件 <code>FriendStatus</code> 内对用户的订阅和取消订阅，其中 <code>App</code> 组件中的 <code>show</code> 状态用来控制 <code>FriendStatus</code> 组件是否渲染，<code>显示/关闭</code> 按钮用来控制 <code>show</code> 的值，<code>FriendStatus</code> 默认登录状态显示 <code>Loading...</code>，<code>登录</code> 和 <code>退出</code> 按钮用来空登录状态的显示（<code>Online</code> 或 <code>Offline</code>），<code>增加用户ID</code> 和 <code>增加计数器</code> 按钮分别用来更改当前用户 <code>ID</code> 和计数器的值，计数器的 <code>count</code> 属性和 <code>setUserId</code> 通过 <code>Render Props</code> 的方式传递给 <code>FriendStatus</code>，我们将使用到的方法统一都放在 <code>ChatAPI</code> 对象上。</p><p>默认渲染 <code>FriendStatus</code> 在控制台发现 <code>useEffect</code> 执行了，并订阅了当前传入的用户，而点击 <code>显示/关闭</code> 按钮时发现取消订阅了用户，这说明组件卸载之前执行了 <code>useEffect</code> 回调内部返回的函数，点击增加计数器按钮，<code>FriendStatus</code> 组件发生了重新渲染，而 <code>useEffect</code> 内部并没有再次对用户进行订阅，原因是指定了 <code>useEffect</code> 的第二个参数，并将用户的 <code>ID</code> 作为元素存入数组内，也就是用户 <code>ID</code> 不发生变化的时候就不会重新执行这个 <code>useEffect</code> 去订阅用户，当点击 <code>增加用户ID</code> 按钮时，控制台首先取消订阅了上一个用户，又订阅了新的用户，这说明 <code>FriendStatus</code> 组件重新渲染时，如果需要执行 <code>useEffect</code>，则会优先执行回调内返回的取消订阅的函数。</p><blockquote class="pullquote default"><p><strong>如果在 <code>useEffect</code> 方法传入的回调中返回一个函数，这个函数会在组件卸载之前执行，或重新渲染需时要执行对应的 <code>useEffect</code> 时优先执行。</strong></p></blockquote><figure class="highlight jsx"><figcaption><span>频繁更新未被监听的变量不变</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的案例是一个状态频繁变化的组件，但是我们给 <code>useEffect</code> 传入的第二个参数为空数组，这就会产生一个 <code>Bug</code>，由于 <code>useEffect</code> 默认只执行一次，并没有执行清除定时器的返回函数，所以导致取到的依然是上一次的状态值，还记得上面一节 <code>useState</code> 中提到使用上一次的状态去更新状态，这里我们可以通过这种方式修复这个 <code>Bug</code>。</p><figure class="highlight jsx"><figcaption><span>解决频繁更新未被监听变量不变的问题</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">prev</span> =&gt;</span> prev + <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>所以说在有些时候，对于 <code>useEffect</code> 第二个参数传入 <code>[ ]</code> 的行为不是绝对安全的，并且不建议这样使用。</strong></p></blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p><code>useReducer</code> 是 <code>useState</code> 的替代方案，用来处理复杂的 <code>state</code> 更新，看到这个名字大家可能会想到 <code>Redux</code> 中的 <code>reducer</code>，其实 <code>useReducer</code> 就是 <code>React Hooks</code> 中用来替代 <code>Redux</code> 解决问题的，让我们从此不需要 <code>Redux</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始 state</span></span><br><span class="line"><span class="keyword">const</span> initalCountState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.payload &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始 state 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initalCountState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>: initalCountState.count + <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initalCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalCountState, init);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      count: &#123; state.count &#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: initalCount &#125;)&#125;</span><br><span class="line">      &gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Counter initalCount=&#123;0&#125; /</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p><code>useReducer</code> 有三个参数，第一个参数为 <code>reducer</code> 函数（根据 <code>action</code> 的类型匹配新的 <code>state</code> 值），第二个参数为监听状态对象 <code>state</code> 的初始值，第三个参数也是一个函数，参数为初始的 <code>state</code>，作用是输出一个新的 <code>state</code> 替换初始的 <code>state</code>，只在最初执行一次。</p><p><code>useReducer</code> 的返回值为数组，数组第一项是监听的 <code>state</code> 对象，第二项是用来触发 <code>state</code> 的函数，参数为 <code>action</code>。</p><figure class="highlight jsx"><figcaption><span>useReducer 不传第三个参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.payload &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initalCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalCount);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      count: &#123; state.count &#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;</span><br><span class="line">          type: <span class="string">'reset'</span>,</span><br><span class="line">          payload: initalCount.count</span><br><span class="line">        &#125;)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Counter initalCount=&#123;&#123; count: 0 &#125;&#125; /</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>这个案例跟之前的稍有差别，去掉了 <code>useReducer</code> 的第三个参数，并将 <code>Counter</code> 组件的入参 <code>initalCount</code> 作为了初始 <code>state</code>。</p><blockquote class="pullquote success"><p><strong>使用 <code>React</code> 进行过项目开发应该都是用过 <code>Redux</code> 和 <code>Mobx</code> 之类的状态管理工具，但其实他们并不是专门针对 <code>React</code> 所设计的，里面都蕴含了一些关于状态管理的编程思想和自己独立的逻辑，也可以在其他框架技术栈中使用，只是和 <code>React</code> 搭配使用时更舒适，而 <code>React hooks</code> 中提供了官方自身的状态管理解决方案，避免依赖第三方库，所以 <code>Facebook</code> 挖来了 <code>Redux</code> 的作者开发了 <code>React hooks</code> 中状态管理相关的 <code>API</code>。</strong></p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>想了解 <code>useContext</code> 首先要了解 <code>context API</code>，即 <code>React.createContext</code> 方法，执行后返回一个对象，其中包含两个属性分别为 <code>Provider</code> 和 <code>Consumer</code>，都为组件，<code>Provider</code> 用于包裹提供状态的容器组件，<code>Consumer</code> 用于包裹消费这个状态的组件，更详细的用法不在这里过多赘述，可以查看 <a href="https://react.docschina.org/docs/context.html" target="_blank">React 官方文档</a>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, setCount &#125; = useContext(myContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      子组件：&#123;count&#125;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;myContext.Provider value=&#123;&#123; count, setCount &#125;&#125;&gt;</span><br><span class="line">      父组件：&#123;count&#125;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;Com /&gt;</span><br><span class="line">    &lt;<span class="regexp">/myContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面是 <code>useContext</code> 的一个简单用法，我们创建了 <code>context</code>，在父组件 <code>App</code> 中创建了 <code>count</code> 和更改 <code>count</code> 的函数 <code>setCount</code>，并将它们通过 <code>context</code> 的 <code>Provider</code> 组件提供给子组件 <code>Com</code>，子组件中调用 <code>useContext</code> 并传入这个创建的 <code>context</code> 对象，返回了父组件所提供的状态数据，并在子组件中点击的方式来更改，此时父、子组件中渲染的 <code>count</code> 都发生了变化。</p><p>上面说 <code>React hooks</code> 中提供了自己的状态管理解决方案，也就是说可以替代 <code>Redux</code> 的工作，实现整个项目的状态管理以及相关状态逻辑的复用，下面就使用 <code>useContext</code> 和 <code>useReducer</code> 来实现一个简单的状态管理逻辑。</p><figure class="highlight jsx"><figcaption><span>reducer.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态（默认值）</span></span><br><span class="line"><span class="keyword">const</span> initalState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出共用的上下文</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 reducer 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> initalState;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出提供状态的函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextProvider = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;myContext.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/myContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的 <code>reducer.js</code> 文件用来提供整个状态管理的核心逻辑，创建了初始的 <code>state</code>，创建了共用的上下文对象，创建了 <code>reducer</code> 函数（通过 <code>action</code> 来匹配并返回新的 <code>state</code>），创建了用来提供 <code>state</code> 和 <code>dispatch</code> 的公共组件 <code>ContextProvider</code>，该组件内部通过创建上下文的 <code>Provider</code> 组件给该组件中间包裹的所有子组件 <code>children</code> 通过 <code>value</code> 提供 <code>state</code> 和 <code>dispatch</code>（通过 <code>useReducer</code> 创建）。</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ContextProvider &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ContextProvider&gt;</span><br><span class="line">        &lt;Counter /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ContextProvider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p><code>App</code> 组件，是提供状态的容器（一般使用根组件），根据 <code>reducer.js</code> 的用法，只需要引入 <code>ContextProvider</code> 组件包裹需要使用状态的子组件，与 <code>react-redux</code> 的 <code>Provider</code> 组件提供 <code>store</code> 的模式相似，这样被 <code>ContextProvider</code> 组件包裹的子组件就可以使用 <code>reducer.js</code> 中所 <code>useReducer</code> 所提供的 <code>state</code> 和 <code>dispatch</code>，<code>Counter</code> 子组件代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myContext &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; state, dispatch &#125; = useContext(myContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Counter count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'reset'</span> &#125;)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure><p>在使用 <code>reducer.js</code> 中实现的状态管理逻辑的组件中，只需要引入 <code>reducer.js</code> 提供的 <code>context</code>，并使用 <code>useContext</code> 就可以解构出 <code>state</code> 和 <code>dispatch</code>，并通过 <code>action</code> 实现三种不同的对状态的 <code>state</code> 的操作。</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p><code>useCallback</code> 是 <code>React</code> 针对函数组件的优化考虑所设计的 <code>Hook API</code>，在函数被渲染时，<code>React</code> 底层是通过调用的方式去创建的，如果函数组件作用域中创建了实现某些功能的函数，则底层每次调用函数组件时，这些函数都会被重新创建，也就是指向新的引用，有了 <code>React Hooks</code> 以后，函数组件中需要的函数可以通过 <code>useCallback</code> 创建。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useCallback, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存储 useCallback 返回的函数</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 useCallback 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestUseCallback</span>(<span class="params">&#123; nums, name &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedCallback = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nums, <span class="string">'Hello world!'</span>);</span><br><span class="line">  &#125;, [ nums ]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'callback 是否相同：'</span>, <span class="built_in">Object</span>.is(fn, memoizedCallback));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nums &gt; '</span>, nums, <span class="string">'name &gt; '</span>, name);</span><br><span class="line">  fn = memoizedCallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;memoizedCallback&#125;&gt;TestUseCallback&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来触发重新 render 的类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    nums: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    name: <span class="string">'hello'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;));</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChangeNum = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">nums</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="attr">name</span>: <span class="string">'world'</span> &#125;);</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; nums, name &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Start editing to see some magic happen!<span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleChangeNum&#125;&gt;修改传入的 nums 值&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TestUseCallback nums=&#123;nums&#125; name=&#123;name&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>在上面的案例中渲染的组件 <code>App</code> 是一个类组件，该组件在挂载后会创建一个定时器，每 <code>3s</code> 更新 <code>state</code> 的 <code>count</code> 值，来完成重渲染，内部的 <code>TestUseCallback</code> 组件也会跟着重渲染，在内部检测 <code>useCallback</code> 创建的函数是否每次都会创建新的，同时打印父组件传递的参数，在通过父组件的点击事件更改的依赖的时候，观察 <code>useCallback</code> 是否会新创建返回的值。</p><blockquote class="pullquote info"><p><strong>执行 <code>useCallback</code> 方法传入的的参数为回调函数和依赖列表（数组），返回值为传入的函数，<code>React</code> 已经将传入的函数注入，只要依赖列表中的依赖没有发生变化，就不会创建新的函数返回，这样就大大减小了每次都在内存中创建新的引用来存储新函数的开销，也同时减少了 <code>GC</code> 的压力。</strong></p></blockquote><figure class="highlight jsx"><figcaption><span>组件中不同方式事件处理函数的区别</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick()&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com2</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Com1</code>：类组件，直接使用箭头函数，每次重新渲染都产生新的函数；</li><li><code>Com2</code>：类组件，在 <code>constructor</code> 中使用 <code>bind</code> 绑定 <code>this</code>，每次重新渲染都使用一个函数；</li><li><code>Com3</code>：函数组件，直接创建函数，每次重新渲染都产生新的函数；</li><li><code>Com4</code>：函数组件，使用 <code>useCallback</code> 创建函数，每次重新渲染都使用一个函数；</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = React.memo(<span class="function">(<span class="params">&#123; a, memo &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Child 渲染'</span>)&#125;</span><br><span class="line">      &lt;span&gt;a: &#123;a&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;memo&#125;&gt;Click in child&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const [ a, setA ] = useState(0);</span></span><br><span class="line"><span class="regexp">  const [ b, setB ] = useState(0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 直接创建的函数</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ const handleClick = () =&gt; console.log('click');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 使用 useCallback 创建的函数</span></span><br><span class="line"><span class="regexp">  const handleClick = useCallback(() =&gt; console.log('click'), []);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;console.log('App 渲染')&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Child a=&#123;a&#125; memo=&#123;handleClick&#125; /</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setA(a + <span class="number">1</span>)&#125;&gt;改变 a&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setB(b + 1)&#125;&gt;改变 b&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面案例中使用了 <code>React.memo</code> 的函数组件优化方法来进一步验证了 <code>useCallback</code> 的作用，方法 <code>React.memo</code> 的参数为一个函数组件，会返回一个高阶组件，作用是当传入的函数组件内部的 <code>props</code> 不发生变化时，则不会重新渲染。</p><p>父组件 <code>App</code> 中使用 <code>useCallback</code> 创建的函数和使用 <code>useState</code> 创建的状态 <code>a</code> 作为参数传递给子组件 <code>Child</code>，并通过点击事件改变 <code>a</code> 和 <code>b</code> 的状态，初次渲染时控制台打印 <code>App 渲染</code> 和 <code>Child 渲染</code>，当点击 <code>改变 a</code> 时，父、子组件同时渲染，是因为子组件 <code>props</code> 中的 <code>a</code> 发生变化，当点击 <code>改变 b</code> 时，父组件重新渲染，但是子组件并没有，说明 <code>useCallback</code> 并没有产生新的函数传递给子组件，当使用 <code>App</code> 组件注释中直接创建的函数时，则点击 <code>改变 b</code>，子组件也会重新渲染，是因为父组件重渲染创建了新的函数，导致子组件的参数发生变化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储两个组件的函数</span></span><br><span class="line"><span class="keyword">let</span> fnn1 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> fnn2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 React.memo 改写的一个渲染耗时的组件（假设很耗时）</span></span><br><span class="line"><span class="keyword">const</span> ExpensiveCom = React.memo(<span class="function">(<span class="params">&#123; onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;console.log('昂贵组件渲染了！')&#125;</span></span><br><span class="line"><span class="xml">    &#123;date.getSeconds()&#125;</span></span><br><span class="line"><span class="xml">    我是一个昂贵的组件！渲染耗时！</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com1</span>(<span class="params">&#123; p1 &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fn'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Com1'</span>, <span class="built_in">Object</span>.is(fnn1, fn));</span><br><span class="line">  fnn1 = fn;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ExpensiveCom</span> <span class="attr">onClick</span>=<span class="string">&#123;fn&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Com2(&#123; p2 &#125;) &#123;</span></span><br><span class="line"><span class="xml">  const fn = useCallback(() =&gt; console.log('fn', p2), [ p2 ]);</span></span><br><span class="line"><span class="xml">  console.log('Com2', Object.is(fnn2, fn));</span></span><br><span class="line"><span class="xml">  fnn2 = fn;</span></span><br><span class="line">  return &lt;ExpensiveCom onClick=&#123;fn&#125; /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [ p1, setP1 ] = useState(0);</span><br><span class="line">  const [ p2, setP2 ] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;每次点击 fn 都是新的&lt;/h2&gt;</span><br><span class="line">      &lt;Com1 p1=&#123;p1&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; setP1(&#123; p1: p1 + 1 &#125;)&#125;</span><br><span class="line">      &gt;p1 + 1&lt;/button&gt;</span><br><span class="line">      &lt;br/&gt;</span><br><span class="line">      &lt;h2&gt;不用重复生成 fn&lt;/h2&gt;</span><br><span class="line">      &lt;Com2 p2=&#123;p2&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; setP2(&#123; p2: p2 + 1 &#125;)&#125;</span><br><span class="line">      &gt;p2 + 1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中假设 <code>ExpensiveCom</code> 是一个渲染非常耗时的 “昂贵” 组件，并在两个不同的容器组件 <code>Com1</code> 和 <code>Com2</code> 中对比，<code>ExpensiveCom</code> 参数是在父组件 <code>Com1</code> 和 <code>Com2</code> 中创建的函数，前者直接创建，后者使用 <code>useCallback</code> 创建，在 <code>App</code> 组件中渲染 <code>Com1</code> 和 <code>Com2</code>，分别传入状态 <code>p1</code> 和 <code>p2</code>，并在 <code>Com1</code> 和 <code>Com2</code> 内部的函数中进行打印，而创建的函数作为 “昂贵” 组件的参数，并作为内部点击的执行函数。</p><p>当在页面点击 <code>p1 + 1</code> 或 <code>p2 + 1</code> 时，都会导致 <code>App</code> 的状态变化，也就是 <code>App</code> 的重渲染，而作为 <code>App</code> 的子组件, <code>Com1</code> 和 <code>Com2</code>，也会跟着重新渲染，点击 <code>p1 + 1</code>，从控制台打印结果看，只有 <code>Com1</code> 内部的 “昂贵” 组件重新渲染，而 <code>Com2</code> 中并没有，是因为 <code>useCallback</code> 中依赖的 <code>p2</code> 没有改变，没有生成新的函数，当点击 <code>p2 + 1</code> 时，<code>Com2</code> 内部的 “昂贵” 组件重新渲染，同时 <code>Com1</code> 内部的 “昂贵” 组件也重新渲染，由此可以看出 <code>Com2</code> 的性能是要优于 <code>Com1</code> 的。</p><blockquote class="pullquote default"><p><strong>在大型的项目中，可能在内层组件中存在非常耗时耗性能的 “昂贵” 组件，如果因为在外层组件中一个函数的更新导致的所有组件重新渲染，显然性能代价是非常大的，所以合理的使用 <code>useCallback</code> 对函数组件进行优化是非常有必要的。</strong></p></blockquote><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 是一种优化手段，接收两个参数，第一个参数是一个函数，第二个参数是依赖列表，返回值是传入函数的返回结果，在函数组件渲染时，其中的 <code>useMemo</code> 只有在依赖列表中的依赖发生变化，才会重新计算函数的结果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 useMemo 的返回结果</span></span><br><span class="line"><span class="keyword">let</span> ch = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于观察是否重渲染的组件</span></span><br><span class="line"><span class="keyword">const</span> Com = <span class="function">(<span class="params">&#123; val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Com 重新渲染了'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;val&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> child1 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'child1 重新计算'</span>)&#125;</span><br><span class="line">      &lt;Com val=&#123;b&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ), [ a ]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  console.log('child1 是否和之前相等', child1 === ch);</span></span><br><span class="line"><span class="regexp">  ch = child1;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  const child2 = (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;console.log('child2 重新计算')&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Com val=&#123;b&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;child1&#125;</span></span><br><span class="line"><span class="regexp">      &#123;child2&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供状态的容器组件</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ a, setA ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [ b, setB ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Parent a=&#123;a&#125; b=&#123;b&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setA(a + <span class="number">1</span>)&#125;&gt;改变 a&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setB(b + 1)&#125;&gt;改变 b&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中 <code>App</code> 组件提供状态 <code>a</code> 和 <code>b</code> 作为参数提供给 <code>Parent</code> 组件，<code>App</code> 中可以通过 <code>改变 a</code> 和 <code>改变 b</code> 按钮更新状态 <code>a</code> 和 <code>b</code>，当 <code>a</code> 和 <code>b</code> 发生变化时导致 <code>Parent</code> 组件重新渲染，内部的 <code>child1</code> 和 <code>child2</code> 分别是通过 <code>useMemo</code> 和直接创建的组件，其中分别渲染 <code>Com</code> 组件，默认情况下 <code>child1</code> 和 <code>child2</code> 都会渲染，点击 <code>改变 a</code>，<code>child1</code> 和 <code>child2</code> 重新渲染，因为 <code>child1</code> 的依赖 <code>a</code> 发生变化，点击 <code>改变 b</code>，发现只有 <code>child2</code> 重新渲染，而再此点击 <code>改变 a</code>，由于都重新渲染导致 <code>child1</code> 和 <code>child2</code> 渲染的值同步了。</p><blockquote class="pullquote primary"><p><strong><code>useMemo</code> 不仅仅可以优化耗时的复杂计算程序，同时可以优化渲染耗时且页面不要求更新的复杂组件，但有一点需要注意，就是不要在传入 <code>useMemo</code> 的函数中执行与渲染无关的操作，如副作用，这类的操作属于 <code>useEffect</code> 的范畴，而不是 <code>useMemo</code>。</strong></p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>在 <code>React</code> 组件中有一个区分方式，受控组件和非受控组件，大多场景应用于表单元素，受控组件就是通过 <code>onChange</code> 事件和 <code>state</code> 实现双向绑定，这里不过多赘述，非受控组件是通过元素的 <code>ref</code> 属性获取 <code>Dom</code> 的引用，进而对表单进行操作，在 <code>React 16.3</code> 以后推荐使用 <code>React.createRef</code> 方法创建。</p><p>类组件中使用 <code>ref</code> 通常是将引用关联到类组件的实例属性上，方便操作，而 <code>useRef</code> 就是为了在函数组件中实现这个功能而存在的，在函数组件中同样可以 <code>React.createRef</code> 来实现，但是函数组件的每一次重新渲染都会导致 <code>ref</code> 对象的重新创建，浪费内存和性能，下面是一个官方的例子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useRef, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef();</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;获取焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;TextInputWithFocusButton /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong><code>useRef</code> 的参数为创建 <code>ref</code> 对象 <code>current</code> 属性的初始值，<code>ref</code> 对象创建后会作为函数组件的实例属性，除非组件卸载，否则不会重新创建。</strong></p></blockquote><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>在介绍 <code>useImperativeHandle</code> 之前一定要清楚 <code>React</code> 关于 <code>ref</code> 转发（也叫透传）的知识点，是使用 <code>React.forwardRef</code> 方法实现的，该方法返回一个组件，参数为函数（<code>props callback</code>，并不是函数组件），函数的第一个参数为父组件传递的 <code>props</code>，第二给参数为父组件传递的 <code>ref</code>，其目的就是希望可以在封装组件时，外层组件可以通过 <code>ref</code> 直接控制内层组件或元素的行为。</p><figure class="highlight jsx"><figcaption><span>一个关于 ref 转发的例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useCallback, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 ref 的转发</span></span><br><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input ref=&#123;ref&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">    &lt;button&gt;&#123;props.children&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件中使用子组件的 ref</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef();</span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> ref.current.focus(), [ ref ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;FancyButton ref=&#123;ref&#125;&gt;Click Me&lt;<span class="regexp">/FancyButton&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClick&#125;&gt;获取焦点&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中创建了一个 <code>FancyButton</code> 组件，内部渲染了一个 <code>button</code> 元素，我们希望在父元素 <code>App</code> 中渲染 <code>FancyButton</code>，并通过传递给 <code>FancyButton</code> 的 <code>ref</code> 直接操作内部的 <code>button</code>。</p><figure class="highlight jsx"><figcaption><span>一个官方的 useImperativeHandle 例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FancyInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="xml">  const fancyInputRef = useRef();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; fancyInputRef.current.focus()&#125;</span><br><span class="line">      &gt;父组件调用子组件的 focus&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面这个例子中与直接转发 <code>ref</code> 不同，直接转发 <code>ref</code> 是将 <code>React.forwardRef</code> 中函数上的 <code>ref</code> 参数直接应用在了返回元素的 <code>ref</code> 属性上，其实父、子组件引用的是同一个 <code>ref</code> 的 <code>current</code> 对象，官方不建议使用这样的 <code>ref</code> 透传，而使用 <code>useImperativeHandle</code> 后，可以让父、子组件分别有自己的 <code>ref</code>，通过 <code>React.forwardRef</code> 将父组件的 <code>ref</code> 透传过来，通过 <code>useImperativeHandle</code> 方法来自定义开放给父组件的 <code>current</code>。</p><p><code>useImperativeHandle</code> 的第一个参数是定义 <code>current</code> 对象的 <code>ref</code>，第二个参数是一个函数，返回值是一个对象，即这个 <code>ref</code> 的 <code>current</code> 对象，这样可以像上面的案例一样，通过自定义父组件的 <code>ref</code> 来使用子组件 <code>ref</code> 的某些方法。</p><blockquote class="pullquote warning"><p><strong><code>useImperativeHandle</code> 和 <code>React.forwardRef</code> 必须是配合使用的，这也是为什么在开头要介绍 <code>ref</code> 的转发。</strong></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;</span><br><span class="line">  useState,</span><br><span class="line">  useRef,</span><br><span class="line">  useImperativeHandle,</span><br><span class="line">  useCallback</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FancyInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ fresh, setFresh ] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> attRef = useRef(<span class="number">0</span>);</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    attRef,</span><br><span class="line">    fresh</span><br><span class="line">  &#125;), [ fresh ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    attRef.current++;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;attRef.current&#125;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Fancy&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setFresh(!fresh)&#125;&gt;刷新&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const fancyInputRef = useRef();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;FancyInput ref=&#123;fancyInputRef&#125; /</span>&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; <span class="built_in">console</span>.log(fancyInputRef.current)&#125;</span><br><span class="line">      &gt;父组件访问子组件的实例属性&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的案例相对于官方的例子意图更明显一些，通过 <code>useImperativeHandle</code> 将子组件的实例属性输出到父组件，而子组件内部通过 <code>ref</code> 更改 <code>current</code> 对象后，组件不会重新渲染，需要改变 <code>useState</code> 设置的状态才能更改。</p><blockquote class="pullquote info"><p><strong><code>useImperativeHandle</code> 方法还支持传入第三个参数，即依赖列表，当监听的依赖发生变化时，<code>useImperativeHandle</code> 才会重新将子组件的实例属性输出到父组件 <code>ref</code> 的 <code>current</code> 属性上，如果为空数组，则不会重新输出。</strong></p></blockquote><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p><code>useLayoutEffect</code> 的使用方法和 <code>useEffect</code> 相同，唯一的区别就是执行时机不一样。</p><figure class="highlight jsx"><figcaption><span>对比 useLayoutEffect 与 useEffect 的执行时机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useLayoutEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Com 渲染'</span>)&#125;</span><br><span class="line">      &lt;h2&gt;Com1&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Com /&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的例子中在 <code>Com</code> 组件中同时使用了 <code>useLayoutEffect</code> 和 <code>useEffect</code>，在页面初次渲染时可以看到控制台打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 执行...</code>。</p><p>当点击 <code>App</code> 组件按钮更新状态导致 <code>Com</code> 重新渲染，打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><p>在刚接触 <code>React Hooks</code> 时，说到执行时机我们一般会和类组件的生命周期去类比，下面是一个 <code>useLayoutEffect</code>、<code>useEffect</code> 与类组件生命周期配合使用的例子。</p><figure class="highlight jsx"><figcaption><span>对比 useLayoutEffect、useEffect 与类组件生命周期的执行时机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useLayoutEffect, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 useLayoutEffect 和 useEffect 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Com 渲染'</span>)&#125;</span><br><span class="line">      &lt;h2&gt;Com1&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生命周期的类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  setCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'App componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'App componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;Com /&gt;</span><br><span class="line">        &#123;<span class="built_in">console</span>.log(<span class="string">'App 渲染'</span>)&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.setCount&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面例子中 <code>useLayoutEffect</code> 和 <code>useEffect</code> 依然在 <code>Com</code> 组件中使用，<code>App</code> 组件为类组件，<code>Com</code> 作为 <code>App</code> 的子组件，在首次渲染时控制台的打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidMount</code> → <code>useEffect 执行...</code>。</p><p>而点击按钮更改状态触发重渲染时，打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidUpdate</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><blockquote class="pullquote default"><p><strong><code>useLayoutEffect</code> 的执行时机要早于 <code>useEffect</code>，<code>useLayoutEffect</code> 的执行在类组件生命周期前，<code>useEffect</code> 的执行在类组件生命周期后，官方的建议是要求我们尽量使用 <code>useEffect</code>，以避免阻塞视觉更新，如果是将代码从类组件重构为 <code>React Hooks</code>，并且使用 <code>useEffect</code> 出现问题，再考虑使用 <code>useLayoutEffect</code>，服务端渲染时使用 <code>useLayoutEffect</code> 会触发警告。</strong></p></blockquote><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p><code>useDebugValue</code> 用于在 <code>React</code> 开发者工具（如果已安装，在浏览器控制台 <code>React</code> 选项查看）中显示 <a href="https://www.overtaking.top/2019/05/07/20190507155411/#%E8%87%AA%E5%AE%9A%E4%B9%89-Hook" target="_blank">自定义 Hook</a> 的标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useDebugValue &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调试自定义 Hook，显示在 devtools 上</span></span><br><span class="line">  useDebugValue(count &gt; num ? <span class="string">'溢出'</span> : <span class="string">'不足'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ count, myCount ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, seCount ] = useMyCount(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; seCount()&#125;&gt;setCount&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面例子中创建了 <code>useMyCount</code> 自定义 <code>Hook</code>，在内部使用 <code>useDebugValue</code> 对 <code>count</code> 的状态进行了调试，在开发工具中显示如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/05/07/20190507155411/usedebugvalue.png" alt="useDebugValue 调试效果图" title>                </div>                <div class="image-caption">useDebugValue 调试效果图</div>            </figure><p><br></p><p><code>useDebugValue</code> 还支持第二个参数，类型为函数，函数的默认参数为 <code>debug</code> 的状态，作用是对 <code>debug</code> 的值进行格式化，官方叫做 “延迟格式化”。</p><figure class="highlight jsx"><figcaption><span>延迟格式化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useDebugValue &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟格式化</span></span><br><span class="line">  useDebugValue(count &gt; num ? <span class="string">'溢出'</span> : <span class="string">'不足'</span>, status =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> status === <span class="string">'溢出'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ count, myCount ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, seCount ] = useMyCount(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; seCount()&#125;&gt;setCount&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的例子只是做了小小的改动，增加了一个格式化函数作为 <code>useDebugValue</code> 的第二个参数，当状态为 <code>不足</code> 时显示 <code>0</code>，为 <code>溢出</code> 时显示 <code>1</code>。</p><blockquote class="pullquote info"><p><strong>提示：我们不推荐你向每个自定义 <code>Hook</code> 使用 <code>useDebugValue</code>，只有自定义 <code>Hook</code> 被复用时才最有意义。</strong></p></blockquote><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>在开篇介绍 <code>React Hooks</code> 产生的动机时，提到了在类组件中使用 “高阶组件” 和 “渲染回调” 的方式对状态逻辑进行复用和解耦会导致渲染嵌套的层级增多以及代码可读性差的问题，在 <code>React 16.8</code> 以后可以通过自定义 <code>Hook</code> 来解决这些问题。</p><figure class="highlight jsx"><figcaption><span>一个没有解决问题的例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Counter1 /&gt;</span><br><span class="line">      &lt;Counter2 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面实现了两个计数器，都有自动增加状态的更新数组的功能，并且都是使用 <code>React Hooks</code> 实现的，很明显我们可以将更新状态的逻辑抽离出来，下面是通过自定义 <code>Hook</code> 改写的例子。</p><figure class="highlight jsx"><figcaption><span>使用自定义 Hook 对状态逻辑进行抽离</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = useNumber();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = useNumber();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Counter1 /&gt;</span><br><span class="line">      &lt;Counter2 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>使用自定义 <code>Hook</code> 就很容易的实现了状态逻辑的复用和解耦，代码简单易读，也避免了 “高阶组件” 和 “渲染回调” 造成渲染层级增加的问题。</p><blockquote class="pullquote primary"><p><strong>注意：官方建议在创建自定义 <code>Hook</code> 时，也采用 <code>use</code> 开头的命名方式，以保持命名的默认约定，便于识别。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><code>React Hooks</code> 出现后让我们对使用 <code>React</code> 编程如释重负，好的技术就是应该越用越简单，编写大家都读得懂的代码才是好代码，上面就是在学习完 <code>React Hooks</code> 后的一些总结，最后附上相关案例的 <a href="https://github.com/shenqiuhui/react-hooks-examples" target="_blank">Guthub 地址</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hooks </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 获取对象属性名的方法和区别</title>
      <link href="/2019/04/17/20190417112536/"/>
      <url>/2019/04/17/20190417112536/</url>
      
        <content type="html"><![CDATA[<img src="/2019/04/17/20190417112536/get-object-key.png" title="JavaScript 获取对象属性名的方法和区别"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>JavaScript</code> 中想获取某一个对象的属性名，有多种方法可供选择。</p><ul><li><code>for in</code></li><li><code>Object.keys</code></li><li><code>Object.getOwnPropertyNames</code></li><li><code>Object.getOwnPropertySymbols</code></li><li><code>Reflect.ownKeys</code></li></ul><p>在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。</p><a id="more"></a><h2 id="创建对象案例"><a href="#创建对象案例" class="headerlink" title="创建对象案例"></a>创建对象案例</h2><p>下面来创建一个对象的案例让这些方法来获取属性，再通过结果来看区别。</p><figure class="highlight js"><figcaption><span>父类，继承自 Object.prototype</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'symbolParent'</span>)]: &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>子类，继承自 parent</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">  c: &#123;</span><br><span class="line">    value: <span class="number">4</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    value: <span class="number">5</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'symbolChild'</span>)]: &#123;</span><br><span class="line">    value: <span class="number">6</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面我们创建了一个对象 <code>parent</code>，上面创建了两个普通属性 <code>a</code>（可枚举）、<code>b</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolParent</code>，创建了一个对象 <code>child</code> 继承自 <code>parent</code>，上面创建了两个普通属性 <code>c</code>（可枚举）、<code>d</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolChild</code>。</p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>从结果来看，<code>for...in</code> 先遍历并获取到了自身的部分属性名，又获取到了继承的部分属性名。</p><blockquote class="pullquote info"><p><strong>总结：<code>for...in</code> 可以遍历自身和继承的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c"]</span></span><br></pre></td></tr></table></figure><p>从结果来看，<code>Object.keys</code> 返回了一个数组，里面存储获取的属性的键名，不能获取继承的属性名，只能获取自身的部分属性名，这种效果相当于 <code>for...in</code> 与 <code>hasOwnProperty</code> 方法的组合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.hasOwnProperty(k)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>总结：<code>Object.keys</code> 只能遍历自身的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c", "d"]</span></span><br></pre></td></tr></table></figure><p>从结果看，<code>Object.getOwnPropertyNames</code> 方法返回了一个数组，存储获取对象属性的键名。</p><blockquote class="pullquote danger"><p><strong>总结：<code>Object.getOwnPropertyNames</code> 只能遍历自身的（包含不可枚举）、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Symbol(symbolChild)]</span></span><br></pre></td></tr></table></figure><p>从结果看，<code>Object.getOwnPropertySymbols</code> 方法返回了一个数组，存储的都是 <code>Symbol</code> 类型的键，说明是专门用来处理 <code>Symbol</code> 类型的。</p><blockquote class="pullquote default"><p><strong>总结：<code>Object.getOwnPropertySymbols</code> 只能遍历自身 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c", "d", Symbol(symbolChild)]</span></span><br></pre></td></tr></table></figure><p><code>Reflect.ownKeys</code> 的返回值为数组，存储遍历到的属性名。</p><blockquote class="pullquote success"><p><strong>总结：<code>Reflect.ownKeys</code> 可以遍历自身的所有属性（包含不可枚举和 <code>Symbol</code> 类型）。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 基础知识总结</title>
      <link href="/2019/04/16/20190416160637/"/>
      <url>/2019/04/16/20190416160637/</url>
      
        <content type="html"><![CDATA[<img src="/2019/04/16/20190416160637/typescript.jpeg" title="Typescript"><p><br></p><h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><blockquote class="pullquote info"><p><code>TypeScript</code> 是由微软开发的开源编程语言（后面简称 <code>TS</code>），是 <code>JavaScript</code> 的超集（后面简称 <code>JS</code>），由于 <code>JS</code> 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 <code>Bug</code> 和风险，而 <code>TS</code> 更适合大型企业应用，是因为 <code>TS</code> 需要编译成 <code>JS</code> 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。</p></blockquote><a id="more"></a><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/04/16/20190416160637/ts-js.png" alt="TypeScript 与 JavaScript 关系图" title>                </div>                <div class="image-caption">TypeScript 与 JavaScript 关系图</div>            </figure><p><br></p><p><code>TS</code> 是前端开发工程化新的趋势，目前很多的开源项目内部都是用 <code>TS</code> 编写，也有很多大牛在推广 <code>TS</code>，目前使用 <code>TS</code> 开发的典型项目有 <code>VSCode</code>、<code>Angular6</code>、<code>Vue3</code> 和 <code>React16</code> 等。</p><h2 id="如何使用-TS"><a href="#如何使用-TS" class="headerlink" title="如何使用 TS"></a>如何使用 TS</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用 <code>TS</code> 之前应该先进行全局安装。</p><figure class="highlight bash"><figcaption><span>安装 TS 的命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure><p>全局安装后会提供 <code>tsc</code> 命令，<code>tsc -v</code> 可以查看当前安装 <code>TS</code> 版本。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>我们可以通过命令单独对文件进行编译，也可以编译整个项目的 <code>TS</code> 文件。</p><figure class="highlight bash"><figcaption><span>编译单个文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>块级作用域变量名检测，两个文件（无论 <code>JS</code> 还是 <code>TS</code>）不允许有相同的变量名。</strong></p></blockquote><p>编译整个项目的 <code>TS</code> 文件需要在项目中设置 <code>tsconfig.json</code> 的配置文件，快速生成配置文件命令如下。</p><figure class="highlight bash"><figcaption><span>生成 tsconfig.json 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>生成 <code>TS</code> 配置文件以后，编译命令 <code>tsc</code> 不需要再指定文件名，会默认读取 <code>tsconfig.json</code> 文件的配置进行编译，关于 <code>tsconfig.json</code> 属性详解请看 <code>TO DO</code>。</p><p>当 <code>TS</code> 文件发生变化时，可以通过 <code>--watch</code> 参数进行实时监听，并当 <code>TS</code> 文件变化时实时编译，也可以把命令配置在 <code>package.json</code> 中通过 <code>npm</code> 执行。</p><figure class="highlight"><figcaption><span>package.json 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "tsc",</span><br><span class="line">    "start": "tsc --watch"</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS-的数据类型"><a href="#TS-的数据类型" class="headerlink" title="TS 的数据类型"></a>TS 的数据类型</h2><p>在 <code>TS</code> 中提供了强大的类型系统，编译时帮助我们对代码中定义的数据类型和值进行检查，如果使用支持 <code>TS</code> 比较好的编辑器，如 <code>VSCode</code>，可以在代码编写时及时发现错误。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="基本数据类型定义"><a href="#基本数据类型定义" class="headerlink" title="基本数据类型定义"></a>基本数据类型定义</h4><p><code>TS</code> 中包含了 <code>JS</code>，所以 <code>TS</code> 也有 <code>6</code> 种基本数据类型，<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'panda'</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> merried: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = Symbol();</span><br></pre></td></tr></table></figure><p>上面声明变量的值与所定义的数据类型必须严格符合，否则编译时报错（编辑器默认就会报错，后面统一说成报错）。</p><p><code>undefined</code> 和 <code>null</code> 是其他基本类型的子类型，类型定义为 <code>undefined</code> 的变量只能赋值 <code>undefined</code>，类型定义为 <code>null</code> 的变量只能赋值 <code>null</code>，类型定义为其他的可以赋值为 <code>undefined</code> 和 <code>null</code>。</p><figure class="highlight ts"><figcaption><span>默认不会报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果想让其他类型的赋值也必须严格与其定义相对应，可以通过配置 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性实现，也被叫做严格类型检查模式。</p><figure class="highlight"><figcaption><span>tsconfig.json 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    "strictNullChecks": true</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类型-any"><a href="#数据类型-any" class="headerlink" title="数据类型 any"></a>数据类型 any</h4><p>希望定义的数据类型可以赋值任何值，可以将数据类型定义为 <code>any</code>，这样相当于没有使用类型校验，等同于直接使用 <code>JS</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span> = <span class="number">18</span>;</span><br><span class="line">value = <span class="string">'hello world'</span>;</span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line">value = <span class="literal">null</span>;</span><br><span class="line">value = <span class="literal">undefined</span>;</span><br><span class="line">value = Symbol();</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p>上面代码中的赋值操作不会报任何错误，因为变量的值类型定义为了 <code>any</code>。</p></blockquote><h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><p>在 <code>TS</code> 中，如果定义的变量没有定义类型，则会对变量的类型进行推测，同样可以在代码编译阶段按照推测的类型校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num = <span class="string">'hello'</span>; <span class="comment">// 报错，不能将类型“"hello"”分配给类型“number”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'world'</span>;</span><br><span class="line">str = <span class="number">1</span>; <span class="comment">// 报错，不能将类型“1”分配给类型“string”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value; <span class="comment">// let value: any</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>类型推论规则：</strong></p><ul><li><strong>从报错的结果可以看出，<code>TS</code> 中声明变量如果没有指定值的类型，则会默认将声明变量时赋值数据的类型定义为该变量的值类型；</strong></li><li><strong>当声明变量没有直接赋值时，<code>TS</code> 会将变量的值类型定义为 <code>any</code>。</strong></li></ul></blockquote><h4 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h4><p><code>TS</code> 也包含基本包装类，基本数据类型是没有方法的（只有对象可以调用对应原型上的方法），在基本数据类型调用方法时是先进行包装过程，把基本类型包装成对象类型。</p><figure class="highlight ts"><figcaption><span>基本数据类型调用方法的包装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num.toFixed(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Number(num).toFixed(2);</span></span><br></pre></td></tr></table></figure><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>有些时候定义的变量在不同场景会赋不同类型的值，我们想要指定这个变量只接受某几个固定类型的值，可以使用联合类型的方式。</p><figure class="highlight ts"><figcaption><span>联合类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">'hello'</span>;</span><br><span class="line">value = <span class="number">10</span>;</span><br><span class="line">value = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>被定义联合类型的变量可以指定符合联合类型中任意一种类型的值，定义时不同的数据类型用 <code>|</code> 隔开，当被赋值不符合联合类型时会报错。</p><blockquote class="pullquote warning"><p><strong>上面联合类型的写法如果多处相同会让代码冗余，在 <code>TS</code> 中提供了 <code>type</code> 关键字来声明类型，用法如下。</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冗余的写法</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> z: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后...</span></span><br><span class="line"><span class="keyword">type</span> MyType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">let</span> x: MyType = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> y: MyType = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> z: MyType = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>被定义联合类型的变量可以通过类型断言指定为更具体的类型，不可以指定联合类型中不包含的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">value = <span class="string">'hello'</span>;</span><br><span class="line">value = <span class="number">10</span>;</span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((value <span class="keyword">as</span> <span class="built_in">string</span>).length); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>断言的语法是将变量使用 <code>as</code> 关键字指定要断言的类型，上面代码中因为变量 <code>value</code> 值最后已经是布尔，而强行将 <code>value</code> 指定为 <code>string</code> 类型去获取 <code>length</code> 属性报错，因为布尔值无法调用 <code>length</code> 属性。</p><h4 id="值的联合"><a href="#值的联合" class="headerlink" title="值的联合"></a>值的联合</h4><p>值的联合（又叫字面量联合）与联合类型不同的是，联合类型只是指定了变量的值类型必须为哪几种，而值的联合则限定了变量的值，变量赋值必须是值的联合中的其中某一个，否则报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: <span class="number">1</span> | <span class="number">6</span> | <span class="number">10</span>;</span><br><span class="line">point = <span class="number">10</span>;</span><br><span class="line">point = <span class="string">'hello'</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> level: <span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'C'</span>;</span><br><span class="line">level = <span class="string">'B'</span>;</span><br><span class="line">level = <span class="string">'b'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 <code>TS</code> 中，数组是引用类型，定义一个数组类型时需要定义数组内部元素的类型。</p><figure class="highlight ts"><figcaption><span>普通数组类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: <span class="built_in">string</span>[] = [<span class="string">'Jim'</span>, <span class="string">'Peter'</span>];</span><br><span class="line"><span class="keyword">let</span> ages: <span class="built_in">number</span>[] = [<span class="number">18</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>泛型定义（泛型会在后面详细说明）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'Jim'</span>, <span class="string">'Peter'</span>];</span><br><span class="line"><span class="keyword">let</span> ages: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">18</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>上面两种方式定义的数组内元素类型必须统一，如果让数组内部元素类型不同该怎么办，在 <code>TS</code> 中有一种特殊的数组类型定义叫做 “元组类型”（<code>tuple</code>）。</p><figure class="highlight ts"><figcaption><span>元组类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Jim'</span>, <span class="number">18</span>];</span><br></pre></td></tr></table></figure><p><strong>元组类型和数组类型的特点如下表：</strong></p><table><thead><tr><th style="text-align:left">元组</th><th style="text-align:left">数组</th></tr></thead><tbody><tr><td style="text-align:left">元素可以是不同类型</td><td style="text-align:left">元素必须为相同类型</td></tr><tr><td style="text-align:left">有预定的长度</td><td style="text-align:left">没有预定的长度</td></tr><tr><td style="text-align:left">用于表示一个结构</td><td style="text-align:left">用于表示一个列表</td></tr></tbody></table><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型是 <code>JS</code> 中所不包含的数据类型，通过 <code>enum</code> 关键字定义，在业务需求中经常会出现某个业务类型对应固定的值，前后端交互的参数都是通过这个值进行约束和传递的。</p><h4 id="普通枚举"><a href="#普通枚举" class="headerlink" title="普通枚举"></a>普通枚举</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Gender &#123;</span><br><span class="line">  BOY,</span><br><span class="line">  GIRL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">  MONDAY = <span class="string">'1'</span>,</span><br><span class="line">  TUESDAY = <span class="string">'2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>编译后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Gender;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Gender</span>) </span>&#123;</span><br><span class="line">  Gender[Gender[<span class="string">"BOY"</span>] = <span class="number">0</span>] = <span class="string">"BOY"</span>;</span><br><span class="line">  Gender[Gender[<span class="string">"GIRL"</span>] = <span class="number">1</span>] = <span class="string">"GIRL"</span>;</span><br><span class="line">&#125;)(Gender || (Gender = &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Week;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Week</span>) </span>&#123;</span><br><span class="line">  Week[<span class="string">"MONDAY"</span>] = <span class="string">"1"</span>;</span><br><span class="line">  Week[<span class="string">"TUESDAY"</span>] = <span class="string">"2"</span>;</span><br><span class="line">&#125;)(Week || (Week = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>从编译结果来看，枚举类型编译成 <code>JS</code> 后帮助我们创建了一个类似于映射表的同名对象，所以可以在 <code>TS</code> 中通过对象属性的方式获取枚举的值。</p><figure class="highlight ts"><figcaption><span>获取枚举值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Gender.BOY); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Week.MONDAY); <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure><h4 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h4><p>常数枚举的的语法是在创建枚举的 <code>enum</code> 关键字前使用 <code>const</code> 声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  RED,</span><br><span class="line">  YELLOW,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [Colors.RED, Colors.YELLOW, Colors.BLUE];</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>编译后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">0</span> <span class="comment">/* RED */</span>, <span class="number">1</span> <span class="comment">/* YELLOW */</span>, <span class="number">2</span> <span class="comment">/* BLUE */</span>];</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>常数枚举与普通枚举的不同是，在编译阶段不会为枚举的类型创建对象，使用枚举类型值的位置直接编译成对应的枚举值。</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数类型定义"><a href="#参数类型定义" class="headerlink" title="参数类型定义"></a>参数类型定义</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在函数中经常会定义可选参数，即非必传，但是 <code>TS</code> 中函数如果按照上面方式定义在调用时不传会报错，可选参数的类型定义如下。</p><figure class="highlight ts"><figcaption><span>可选参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">people</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people(<span class="string">'jim'</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>?:</code> 替代 <code>:</code>，即代表该参数为可选参数，在 <code>TS</code> 中也支持使用默认参数和剩余参数，使用方式如下。</p><figure class="highlight ts"><figcaption><span>默认参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">sum: <span class="built_in">number</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>剩余参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">prefix: <span class="built_in">string</span>, ...args: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix + args.reduce(<span class="function">(<span class="params">sum, val</span>) =&gt;</span> sum + val, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="string">'$'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>在使用默认参数和剩余参数时，设置的参数初始值和传入的剩余参数与定义类型不符合，则会报错。</p><h4 id="返回值类型定义"><a href="#返回值类型定义" class="headerlink" title="返回值类型定义"></a>返回值类型定义</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊的返回值类型：</strong></p><ul><li><code>never</code>：是其他类型的子类型，代表不会出现的值，作为没有返回值的返回类型，函数无法执行完；</li><li><code>void</code>：表示没有任何类型，指函数没有返回值，函数可以正常执行完，如果一个函数没有返回值，则 <code>TS</code> 认为返回值为 <code>void</code> 类型。</li></ul><figure class="highlight ts"><figcaption><span>never 为返回值类型的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">nerver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">nerver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个函数返回值设置为 <code>never</code>，因为抛错和死循环导致都没有执行完毕，此时函数编译不会报错。</p><figure class="highlight ts"><figcaption><span>void 为返回值类型的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>fn2</code> 函数只在非严格检查模式下不会报错，非严格检查模式下返回值类型被定义为 <code>void</code> 的函数可以返回 <code>null</code> 和 <code>undefined</code>。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>之前的函数参数和返回值类型定义是函数声明的方式，声明函数同样有另外一种方式，函数表达式，即给变量赋值为函数，那如何为接收函数的变量定义类型呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fullName: <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">fullName = <span class="function"><span class="keyword">function</span> (<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>括号中 <code>x</code> 和 <code>y</code> 代表定义参数的类型，箭头后代表定义返回值的类型，也可以使用 <code>type</code> 关键字进行声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fn = <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fullName: Fn = <span class="function"><span class="keyword">function</span> (<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>赋值函数的参数类型必须与变量声明的函数参数类型严格一致，返回值同理。</strong></p></blockquote><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是强类型语言中的特性，在 <code>Java</code> 中代表多个同名函数参数不相同，而在 <code>TS</code> 中有所不同，代表为同一个函数提供多个参数类型及返回值定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">type</span> MyType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载限定函数 double</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">boolean</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: MyType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) <span class="keyword">return</span> val + val;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) <span class="keyword">return</span> <span class="number">2</span> * val;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) <span class="keyword">return</span> !val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double(<span class="string">'hello'</span>); <span class="comment">// hellohello</span></span><br><span class="line">double(<span class="number">5</span>); <span class="comment">// 10</span></span><br><span class="line">double(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>重载限定某个函数的方式只有函数声明、函数名、参数及返回值的类型，而没有函数体。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p><code>TS</code> 类的定义与 <code>JS</code> 相同，使用 <code>class</code> 关键字声明，但可以直接对属性、方法定义参数类型和返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  getName(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">'neil'</span>;</span><br><span class="line">p.getName(); <span class="comment">// neil</span></span><br></pre></td></tr></table></figure><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>在 <code>TS</code> 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为，并可以定义存取器的参数及返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  myName: <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">myName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(newVal: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// neil</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'jim'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// jim</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>上面都在类中定义属性，也可以使用参数属性进行简化，代码如下。</p><figure class="highlight ts"><figcaption><span>简化前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>简化后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> myName: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.myName); <span class="comment">// neil</span></span><br></pre></td></tr></table></figure><p><code>public</code> 修饰符写在 <code>constructor</code> 的参数前，代表创建一个与参数同名的公有属性。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>在 <code>TS</code> 中可以在类中定义只读属性，只需要通过 <code>readonly</code> 修饰符修饰即可，只在编译阶段进行检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> readonly myName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.myName); <span class="comment">// neil</span></span><br><span class="line">p.myName = <span class="string">'jim'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>不同类别的（非互斥）的修饰符可以同时修饰一个变量，使用空格隔开。</strong></p></blockquote><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>类与类之间通过 <code>extends</code> 关键字实现继承，子类继承父类后拥有父类的属性和方法，可以增强代码的复用性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  hobby: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, hobby: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">    <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">  &#125;</span><br><span class="line">  getHobby(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hobby;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child(<span class="string">'neil'</span>, <span class="number">20</span>, <span class="string">'swim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.getHobby()); <span class="comment">// swim</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getName()); <span class="comment">// neil</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getAge()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>在 <code>TS</code> 的类中有三种访问控制修饰符，分别为 <code>public</code>、<code>protected</code> 和 <code>private</code>。</p><ul><li><code>public</code>：公有的属性，所有地方都能访问；</li><li><code>protected</code>：受保护的的属性，只能在自己和自己的子类中被访问；</li><li><code>private</code>：私有属性，只有自己内部可以访问。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> money: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, money: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.money = money;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.money);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name, age, money</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age, money);</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.money); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中 <code>name</code> 属性可以通过父类的实例访问、子类的实例访问，父类的 <code>getName</code> 方法访问，子类的 <code>getName</code> 方法访问，<code>age</code> 属性可以只能通过父类和子类的 <code>getAge</code> 方法访问，<code>money</code> 属性只能通过父类 <code>getMoney</code> 方法访问，其他不被允许的访问方式都会报错。</p><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>在 <code>TS</code> 中给类定义私有属性和方法的修饰符为 <code>static</code>，与 <code>JS</code> 的类相同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Father &#123;</span><br><span class="line">  <span class="keyword">static</span> myName: <span class="built_in">string</span> = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">static</span> getMyName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Father.myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Father.myName); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.getMyName()); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种抽象的概念，使用 <code>abstract</code> 关键字定义，无法被实例化（无法使用 <code>new</code>），只能被继承。</p><p>抽象类的内部包含抽象方法和抽象属性，同样使用 <code>abstract</code> 关键字定义，抽象方法不能在抽象类中实现，具体实现细节只能在抽象类的子类中实现，而且必须实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">abstract</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">abstract</span> speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'喵喵喵'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>继承抽象类的子类中必须包含所有抽象类中所定义的内容，继承中这种子类覆盖抽象类所定义抽象方法的行为叫做 “重写”，多个子类创建不同的抽象方法的现象被叫做 “多态”。</strong></p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口是 <code>TS</code> 中的核心之一，主要有两个作用：</strong></p><ul><li>用于描述或约束一种对象结构，描述属性的名称和值的类型；</li><li>用来表示行为的抽象，让类去实现接口。</li></ul><h3 id="接口的定义和使用"><a href="#接口的定义和使用" class="headerlink" title="接口的定义和使用"></a>接口的定义和使用</h3><p><code>TS</code> 中使用 <code>interface</code> 关键字来定义接口，接口成员可以是属性或方法名，多个成员可以使用分号、逗号或换行隔开，主要定义属性的名称和值的类型。</p><figure class="highlight ts"><figcaption><span>定义接口，使用接口创建对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: UserInterface = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面 <code>UserInterface</code> 接口创建的对象 <code>user</code>，属性和值的类型必须与定义的接口严格对应。</p><figure class="highlight ts"><figcaption><span>让类去实现定义的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Flyable &#123;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bird <span class="keyword">implements</span> Flyable &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bird fly'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让类实现一个接口使用 <code>implements</code> 关键字，接口在定义方法时与抽象类非常类似，只需要定义方法和类型，不需要具体实现，在实现接口的类中对方法进行具体实现。</p><figure class="highlight ts"><figcaption><span>一个类实现多个接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> Speakable &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Eatable &#123;</span><br><span class="line">  food: <span class="built_in">string</span>;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Speakable, Eatable &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>;</span><br><span class="line">  food: <span class="string">'cake'</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat cake'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong>继承与实现接口的区别是，一个类可以实现多个接口，一个接口可以被多个类实现，而一个父类（包含抽象类）可以被多个类所继承，一个子类只能继承一个父类（单继承）。</strong></p></blockquote><h3 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h3><p>接口中可以定义只读属性，这样通过接口创建的对象的值在修改时会报错，可以在定义接口属性是加上 <code>readonly</code> 修饰符实现。</p><figure class="highlight ts"><figcaption><span>接口的只读属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>;</span><br><span class="line">  name: <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// 1</span></span><br><span class="line">p.name = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h3><p>在上面接口定义时，创建的对象和实现接口类的属性方法都必须与接口定义的属性名、类型一致，其实在接口定义时也可以定义一些非必须的可选属性，在使用接口创建对象或使用类实现接口时，这样的属性不定义不会报错。</p><figure class="highlight ts"><figcaption><span>接口的可选属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Person = &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  name: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义接口的可选属性与函数定义可选参数类似，都是使用 <code>?:</code> 替代原本的 <code>:</code> 即代表可选。</p><h3 id="接口的未知属性"><a href="#接口的未知属性" class="headerlink" title="接口的未知属性"></a>接口的未知属性</h3><p>当接口中存在可选属性时，也只是满足某些属性可以在使用接口时（对象、类），可选属性可以不创建，但是如果对象和类上扩展了未知的其他任意属性，则编译会报错，此时定义接口未知属性，可以解决编译时报错的问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  [proName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong><code>proName</code> 名字是任意的，可以随意取，<code>string</code> 代表属性的类型，<code>any</code> 代表属性值的类型，上面的写法不固定，可以根据需求定义，只需满足 <code>[name: type]: type</code> 的结构即可。</strong></p></blockquote><p>根据上面的未知属性格式可以衍生出 “可索引接口” 专门用来限制长度未知的数组、属性名和属性个数未知的对象。</p><p><strong>可索引接口限制数组和对象：</strong></p><figure class="highlight ts"><figcaption><span>限制数组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userArr: UserInterface = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">userArr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">1</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面的数组 <code>userArr</code> 内的的索引为数字类型，满足可索引接口的要求，但是使用 <code>UserInterface</code> 约束后，所有项必须是字符串，如果改成其他类型则会报错。</p><figure class="highlight ts"><figcaption><span>限制对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userObj: UserInterface = &#123;</span><br><span class="line">  jim: <span class="string">'1'</span>,</span><br><span class="line">  bob: <span class="string">'2'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的对象 <code>userObj</code> 使用 <code>UserInterface</code> 约束后，键和值必须都为字符串，否则报错。</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口的继承同类的继承相同，使用 <code>extends</code> 关键字实现，下面是一段接口继承的代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父接口</span></span><br><span class="line"><span class="keyword">interface</span> Speakable &#123;</span><br><span class="line">  speak(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子接口</span></span><br><span class="line"><span class="keyword">interface</span> SpeakChinese <span class="keyword">extends</span> Speakable &#123;</span><br><span class="line">  speakChinese(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现接口</span></span><br><span class="line"><span class="keyword">class</span> ChinesePerson <span class="keyword">implements</span> SpeakChinese &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'speak'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  speakChinese() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你好'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>当类实现的接口继承了其他的接口，那这个类的内部需要同时实现子接口和父接口的属性和方法。</strong></p></blockquote><h3 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h3><p>函数型接口专门对函数或方法传入的参数和返回值进行约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Discount &#123;</span><br><span class="line">  (price: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dFun: Discount = discount;</span><br></pre></td></tr></table></figure><p>上面代码中 <code>Discount</code> 接口内部括号内代表参数类型定义，后面代表返回值类型，函数 <code>discount</code> 定义的参数和返回值类型必须与 <code>Discount</code> 接口内部定义的类型保持一致。</p><h3 id="构造函数型接口"><a href="#构造函数型接口" class="headerlink" title="构造函数型接口"></a>构造函数型接口</h3><p>在 <code>TS</code> 中存在对构造函数或类的实例化的类型约束，即在执行 <code>new</code> 操作的时候进行约束检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被约束实例化动作的类</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束实例化的接口</span></span><br><span class="line"><span class="keyword">interface</span> WithNameClazz &#123;</span><br><span class="line">  <span class="keyword">new</span> (name: <span class="built_in">string</span>): Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params">clazz: WithNameClazz, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> clazz(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = createAnimal(Animal, <span class="string">'hellop'</span>);</span><br></pre></td></tr></table></figure><p>上面代码的 <code>interface</code> 中，<code>new</code> 代表约束的动作为实例化操作，<code>name</code> 为参数，<code>string</code> 为参数的类型，而 <code>Animal</code> 代表返回值需要是一个 <code>Animal</code> 类的实例。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>“泛型” 是指在定义函数、接口和类的时候，不预先指定具体的类型，而在使用的时候再进行指定的一种特性。</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>在介绍泛型函数之前先创建一个普通的函数，参数为长度和值，返回一个长度为传入长度、内部元素都为传入值的数组。</p><figure class="highlight ts"><figcaption><span>为使用泛型定义的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">len: <span class="built_in">number</span>, val: <span class="built_in">any</span></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: <span class="built_in">any</span>[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result[i] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray(<span class="number">3</span>, <span class="string">'x'</span>)); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><p>在上面函数中我们类型都是提前进行定义，包括参数、返回值和函数内部变量，这样如果函数内给数组每一项赋值操作没有使用 <code>val</code> 参数传入的值，而是使用其他值，这样无法进行限定，下面使用泛型重新编写上面的函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">len: <span class="built_in">number</span>, val: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result[i] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="number">1</span>)); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面的 <code>T</code> 是泛型的占位符，代表 <code>Type</code> 的意思，也可以使用其他字母代替（类比函数的形参），真正定义类型的时候是在函数调用时传入的。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyArray&lt;T&gt; &#123;</span><br><span class="line">  list: T[] = [];</span><br><span class="line">  add(val: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">  getFirst(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = <span class="keyword">new</span> MyArray&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myArray.add(<span class="number">1</span>);</span><br><span class="line">myArray.add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray.getFirst());</span><br></pre></td></tr></table></figure><p>泛型类与泛型函数相似，都是通过占位符 <code>T</code> 占位，在真正实例化的时候传入类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>上面接口一节中接口内部属性及函数型接口等，成员类型也可以使用泛型进行约束，在某个具体的对象使用接口或类实现接口时传入具体类型，下面是一个函数型接口使用泛型的例子。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SUM&lt;T&gt; &#123;</span><br><span class="line">  (a: T, b: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum2: SUM&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="keyword">function</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>泛型占位符（上面为 <code>T</code>）只在约束的函数、类和接口内部可以使用，可类比函数的形参。</strong></p></blockquote><h3 id="默认泛型类型"><a href="#默认泛型类型" class="headerlink" title="默认泛型类型"></a>默认泛型类型</h3><p>默认泛型类型指的是定义泛型的默认值，被约束的函数、类或者接口在使用时不传入具体类型，则会使用默认类型，编译时会检查是否符合这个默认类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyArray&lt;T = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  list: T[] = [];</span><br><span class="line">  add(val: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = <span class="keyword">new</span> MyArray();</span><br><span class="line">myArray.add(<span class="number">1</span>);</span><br><span class="line">myArray.add(<span class="string">'a'</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="定义多个泛型"><a href="#定义多个泛型" class="headerlink" title="定义多个泛型"></a>定义多个泛型</h3><p>上面的泛型中都只使用了一个占位符 <code>T</code>，其实泛型是允许有多个的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt;(<span class="params">tuple: [A, B]</span>): [<span class="title">B</span>, <span class="title">A</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(swap&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;([<span class="string">'a'</span>, <span class="number">1</span>])); <span class="comment">// [1, 'a']</span></span><br></pre></td></tr></table></figure><p>上面方法中定义了两个泛型，函数参数为一个元组类型的数组，函数返回值为两项交换后的数组。</p><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><p>在函数或类中使用泛型，由于预先不知道泛型的具体类型，所以不能随便使用泛型约束变量的属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span>&gt;(<span class="params">val: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h3><p>如果一定要在函数或类中使用泛型约束变量的属性和方法时，可以预先通过接口定义使用的属性和方法，再通过泛型去继承这个接口即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> LengthWise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">LengthWise</span>&gt;(<span class="params">val: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger&lt;<span class="built_in">number</span>&gt;(<span class="string">'hello'</span>); <span class="comment">// 报错</span></span><br><span class="line">logger&lt;<span class="built_in">string</span>&gt;(<span class="string">'hello'</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="泛型的流程控制"><a href="#泛型的流程控制" class="headerlink" title="泛型的流程控制"></a>泛型的流程控制</h3><p>在定义泛型的时候能够加入逻辑分支，可以使泛型更加灵活。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  nameFish: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Water &#123;</span><br><span class="line">  nameWater: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  nameBird: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sky &#123;</span><br><span class="line">  nameSky: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Condition&lt;T&gt; = T <span class="keyword">extends</span> Fish ? Water : Sky;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> con: Condition&lt;Fish&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了四个接口 <code>Fish</code>、<code>Bird</code>、<code>Water</code> 和 <code>Sky</code>，定义一个 <code>Condition</code> 类型和泛型，如果泛型为 <code>Fish</code> 则继承 <code>Water</code>，否则继承 <code>Sky</code>，在变量 <code>con</code> 使用类型 <code>Condition</code> 时，传入 <code>Fish</code> 接口。</p><h3 id="泛型的别名"><a href="#泛型的别名" class="headerlink" title="泛型的别名"></a>泛型的别名</h3><p>泛型可以使用 <code>type</code> 关键字定义别名，还记得在基本数据类型一节数组的定义中有泛型的定义方式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br></pre></td></tr></table></figure><p>其实上面的 <code>Array</code> 就是定义泛型的别名，<code>&lt;string&gt;</code> 则是在调用这个泛型时传入的具体类型，看了下面例子就明白了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型别名</span></span><br><span class="line"><span class="keyword">type</span> Cart&lt;T&gt; = &#123; list: T[] &#125; | T[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型别名</span></span><br><span class="line"><span class="keyword">let</span> cart1: Cart&lt;<span class="built_in">string</span>&gt; = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">let</span> cart2: Cart&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  list: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>JS</code> 中有很多类数组对象，如 <code>arguments</code>、获取的 <code>DOM</code> 元素集合等等，每一种类数组对象 <code>TS</code> 都定义了对应的泛型别名，下面看两个案例。</p><figure class="highlight ts"><figcaption><span>arguments 对象的泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> params: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">    result += params[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>DOM 节点类数组对象的泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">let</span> children: HTMLCollection = root.children;</span><br><span class="line"><span class="keyword">let</span> childNodes: NodeListOf&lt;ChildNode&gt; = root.childNodes;</span><br></pre></td></tr></table></figure><p>上面用来定义 <code>arguments</code> 类数组对象的泛型别名为 <code>IArguments</code>，获取 <code>DOM</code> 节点的元素节点集合的泛型别名为 <code>HTMLCollection</code>，而全部子节点的泛型别名为 <code>NodeListOf&lt;ChildNode&gt;</code>，如果使用 <code>VSCode</code> 编辑器，可以将鼠标放在变量前面会自动提示对应的泛型别名。</p><blockquote class="pullquote info"><p><strong>接口和泛型别名的区别：</strong></p><ul><li><strong>接口会创建一个新的名称，而别名不会（只是用 <code>type</code> 关键字创建了一个变量）；</strong></li><li><strong>别名不能被继承和实现；</strong></li><li><strong>定义一个类型的时候使用接口，要使用联合类型或者元组类型时，类型别名会更合适。</strong></li></ul></blockquote><h2 id="结构类型系统"><a href="#结构类型系统" class="headerlink" title="结构类型系统"></a>结构类型系统</h2><p>如果传入的变量和声明的类型不匹配，<code>TS</code> 会进行兼容性检查，不是基于定义的类型名称来决定的，而是基于类型的组成结构。</p><h3 id="基本数据类型的兼容性"><a href="#基本数据类型的兼容性" class="headerlink" title="基本数据类型的兼容性"></a>基本数据类型的兼容性</h3><p>基本数据类型也有兼容性判断，如果赋值过程中右侧值的类型符合左侧值的类型，则不会报错，如果左侧类型定义含有 <code>toString</code> 方法的约束，则右侧值凡是可以通过 <code>toString</code> 转换成字符串的都不会报错，赋值时如果右侧值传入的属性多余左侧定义的值时也会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> str1: <span class="built_in">string</span>;</span><br><span class="line">num1 = str1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num2: &#123;</span><br><span class="line">  toString(): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str2: <span class="built_in">number</span>;</span><br><span class="line">num2 = str2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="string">'male'</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="枚举的兼容性"><a href="#枚举的兼容性" class="headerlink" title="枚举的兼容性"></a>枚举的兼容性</h3><p>默认的枚举类型与数字类型兼容，数字类型与枚举类型兼容，不同的枚举类型之间是不兼容的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  RED,</span><br><span class="line">  YELLOW,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容数字类型</span></span><br><span class="line"><span class="keyword">let</span> colorRed: <span class="built_in">number</span> = Colors.RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容枚举类型</span></span><br><span class="line"><span class="keyword">let</span> colorYello: Colors;</span><br><span class="line">colorYello = Colors.Red;</span><br><span class="line">colorYello = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="函数的兼容性"><a href="#函数的兼容性" class="headerlink" title="函数的兼容性"></a>函数的兼容性</h3><p>比较函数的兼容性时要先比较函数的参数，再比较函数的返回值。</p><h4 id="参数的兼容性"><a href="#参数的兼容性" class="headerlink" title="参数的兼容性"></a>参数的兼容性</h4><figure class="highlight ts"><figcaption><span>参数的类型比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SumFunc = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> sum: SumFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错的赋值</span></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错的赋值</span></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的类型检查可以兼容少传参数或不传参数，但是多传参数会报错。</p><h4 id="参数的双向协变"><a href="#参数的双向协变" class="headerlink" title="参数的双向协变"></a>参数的双向协变</h4><p>参数的双向协变是指变量定义的参数类型去兼容变量赋值定义的参数类型，或者变量赋值的参数类型去兼容定义的参数类型，只要有一个成立即可，所谓兼容必须是包含的关系。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogFunc = <span class="function">(<span class="params">val: <span class="built_in">number</span> | <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> log: LogFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量定义类型兼容赋值定义类型</span></span><br><span class="line">log = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量赋值类型兼容变量定义的类型</span></span><br><span class="line">log = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回值的兼容性"><a href="#返回值的兼容性" class="headerlink" title="返回值的兼容性"></a>返回值的兼容性</h4><figure class="highlight ts"><figcaption><span>返回值的类型比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetPerson = <span class="function"><span class="params">()</span> =&gt;</span> &#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> getPerson: GetPerson;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错的赋值</span></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span>, age: <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span>, age: <span class="number">20</span>, gender: <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错的赋值</span></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能调用 age 属性的方法</span></span><br><span class="line">getPerson().age.toFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>返回值可以兼容多返回的属性，属性少了会报错，因为可能会调用返回值缺失属性的方法。</p><h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">let</span> c1: Child = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Parent = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">let</span> c2: Child = <span class="keyword">new</span> Parent(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>父类和子类能不能赋值给限制了父类或子类泛型的变量，能不能赋值和是父类或子类没任何关联，主要看属性是否满足，而上面 <code>p2</code> 没有报错的原因是子类的实例继承了父类的属性，所以提供了父类泛型所要求的属性，而 <code>c2</code> 报错是因为父类的实例并没有提供子类泛型要求的属性。</p><h3 id="接口的兼容性"><a href="#接口的兼容性" class="headerlink" title="接口的兼容性"></a>接口的兼容性</h3><p>在检查参数类型时，并不是真正的比较接口类型，而是比较具体的属性是否兼容。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">a: Animal</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName(p); <span class="comment">// hello;</span></span><br></pre></td></tr></table></figure><p>上面的代码中定义了两个接口 <code>Animal</code> 和 <code>Person</code>，<code>Person</code> 定义的属性更多，当一个符合 <code>Person</code> 的对象传给参数用 <code>Animal</code> 约束的函数时，检测的是接口的属性，只要提供的属性不比约束的属性少，则不会报错。</p><h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><p>泛型在判断兼容性的时候会先判断具体类型，再进行兼容性的判断，即用到了就会比较，没用到就不会比较。</p><figure class="highlight ts"><figcaption><span>空接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>属性使用了泛型的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">x = y; <span class="comment">// 报错，因为 number 类型的属性不能赋值给 string 类型的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">interface</span> NotEmptyString&#123;</span><br><span class="line">  data: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NotEmptyNumber&#123;</span><br><span class="line">  data: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xString: NotEmptyString;</span><br><span class="line"><span class="keyword">let</span> yNumber: NotEmptyNumber;</span><br><span class="line">xString = yNumber; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>类型保护就是一些表达式在编译时，能通过类型信息确保某个具体作用域内变量的类型。</p><h3 id="typeof-和-instanceof-类型保护"><a href="#typeof-和-instanceof-类型保护" class="headerlink" title="typeof 和 instanceof 类型保护"></a>typeof 和 instanceof 类型保护</h3><figure class="highlight ts"><figcaption><span>typeof 类型保护</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val.repeat(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法因为使用 <code>typeof</code> 做了类型判断，所以分别在 <code>if</code> 判断的作用域内 <code>val</code> 的值会变成判断后对应的类型，可以调用类型对应的方法，而在判断的外面无法确认值的类型，调用方法编译时报错。</p><figure class="highlight ts"><figcaption><span>instanceof 类型保护</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bird &#123;</span><br><span class="line">  nameBird: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">  nameDog: stirng;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.nameBird;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.nameDog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>typeof</code> 类似，使用 <code>instanceof</code> 判断了函数 <code>getName</code> 是否是 <code>Bird</code> 和 <code>Dog</code> 类的实例，判断的作用域内可以获取判断结果对应类上定义的属性。</p><h3 id="null-类型保护"><a href="#null-类型保护" class="headerlink" title="null 类型保护"></a>null 类型保护</h3><p>之前我们提到过在 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性设置为 <code>true</code> 时，则会对 <code>null</code> 进行严格检查，此时下面代码将会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的报错就是由于对 <code>null</code> 的类型保护引起的，有如下解决方法。</p><figure class="highlight ts"><figcaption><span>方法一</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>方法二</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式第一种是通过设置初始值的方式来保证在调用字符串方法时 <code>str</code> 的值已经是一个字符串类型，第二种则是通过判断直接返回，没有走到调用字符串方法的代码，类型检查自然不会报错，下面还有一个稍微复杂的案例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str.tirm()); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  log();</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>str</code> 调用 <code>tirm</code> 方法的代码封装在了函数 <code>log</code> 内部，当 <code>log</code> 调用时 <code>str</code> 的值已经变为了字符串，但是还是报错了，原因是代码编译阶段由上至下一行一行解析，所以解析函数 <code>log</code> 的时候就已经在函数内部报错了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str!.tirm());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  log();</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在 <code>log</code> 函数中，<code>str</code> 调用 <code>tirm</code> 方法时加了一个 <code>!</code>，意思为强行调用，不管类型是否符合都会调用，相当于忽略了函数 <code>getFirstLetter</code> 的参数类型检查。</p><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>上面的强制调用方式虽然通能过编译，但是在运行时有报错的风险，应该慎用，在 <code>JS</code> 中有一个提案叫链判断运算符，针对上面情况，会先判断是否为字符串再去调用字符串方法，这样写起来比较繁琐，而链判断运算符就是用来解决这个问题，通过 <code>?.</code> 来调用。</p><figure class="highlight js"><figcaption><span>链判断运算符的几种用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a?.b;</span><br><span class="line"><span class="comment">// 如果 a 不含有 b 属性则返回 undefined，否则返回 a.b，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b;</span><br><span class="line"></span><br><span class="line">a?.[b];</span><br><span class="line"><span class="comment">// 如果 a 不含有键为 b 变量值的属性则返回 undefined，否则返回 a[b]，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[b];</span><br><span class="line"></span><br><span class="line">a?.b()</span><br><span class="line"><span class="comment">// 如果 a 不含 b 属性则返回 undefined，否则执行 a.b()</span></span><br><span class="line"><span class="comment">// 如果 a.b 不是一个函数抛出类型错误，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b();</span><br><span class="line"></span><br><span class="line">a?.()</span><br><span class="line"><span class="comment">// 如果 a 不是函数则返回 undefined，否则执行 a()，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a();</span><br></pre></td></tr></table></figure><h3 id="可辨识的联合类型"><a href="#可辨识的联合类型" class="headerlink" title="可辨识的联合类型"></a>可辨识的联合类型</h3><p>可辨识的联合类型是指，通过联合类型中的共同属性进行类型保护的一种技巧，通过同属性值的判断可以确定联合类型中的具体类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> WarningButton &#123;</span><br><span class="line">  <span class="keyword">class</span>: <span class="string">'warning'</span>;</span><br><span class="line">  name1: <span class="string">'modified'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> DangerButton &#123;</span><br><span class="line">  <span class="keyword">class</span>: <span class="string">'danger'</span>;</span><br><span class="line">  name2: <span class="string">'delete'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义联合类型</span></span><br><span class="line"><span class="keyword">type</span> Button = WarningButton | DangerButton;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getButton</span>(<span class="params">button: Button</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (button.class === <span class="string">'warning'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> button.name1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (button.class === <span class="string">'danger'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> button.name2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h3><p>在可辨识的联合类型中如果没有共同的属性，共同属性判断不同值区分的方法行不通，这时可以用 <code>in</code> 操作符和不同属性判断进行类型保护。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  talon: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'talon'</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.talon);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'leg'</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.leg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p><code>TS</code> 中的上面用到的类型保护大部分为表达式，其实可以不使用这些表达式，通过自定义类型保护函数的方式实现同样的效果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  talon: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型保护函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBird</span>(<span class="params">animal: Bird | Dog</span>): <span class="title">animal</span> <span class="title">is</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// return (animal as Bird).talon &gt; 0;</span></span><br><span class="line">  <span class="keyword">return</span> (&lt;Bird&gt;animal).talon &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isBird(animal)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.talon);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.leg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的自定义保护函数 <code>isBird</code> 中参数类型与 <code>getNumber</code> 参数一致，返回值的 <code>animal is Bird</code> 是一个类型谓词，语法为 <code>param is type</code>，代表返回是否满足 <code>Bird</code> 接口，由于 <code>animal</code> 并不知道自己符合哪一个接口，所以使用类型断言指定成了 <code>Bird</code>，<code>isBird</code> 代码中注释和非注释两种方式都可以实现类型断言，这样自定义类型检查函数 <code>isBird</code> 就可以在 <code>getNumber</code> 中使用并实现类型保护。</p><h2 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型表示为将多个类型合并为一个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取的是接口的并集</span></span><br><span class="line"><span class="keyword">type</span> BirdMan = Bird &amp; Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口必须包含两个接口所有的属性和方法</span></span><br><span class="line"><span class="keyword">let</span> birdMan: BirdMan = &#123;</span><br><span class="line">  name: <span class="string">'niao'</span>,</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fly'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="typeof-获取类型"><a href="#typeof-获取类型" class="headerlink" title="typeof 获取类型"></a>typeof 获取类型</h3><p>在 <code>TS</code> 使用时如果数据内容在变化，要不停的更改对应的接口，此时可以使用 <code>typeof</code> 关键字快速获取一个变量的类型。</p><figure class="highlight ts"><figcaption><span>先定义类型，后定义变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>先定义变量，后定义接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People = <span class="keyword">typeof</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">p: People</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取的类型定义 <code>People</code> 是根据 <code>p</code> 对象的属性和值生成，然后可以使用获取的类型去限制其他对象。</p><h3 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h3><p><code>TS</code> 中的索引访问操作符指可以通过 <code>[]</code> 获取一个类型的子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义嵌套类型接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 对象，包含 name 属性</span></span><br><span class="line">  job: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 成员为对象组成的数组，对象中含有 name 和 level 属性</span></span><br><span class="line">  hobbies: &#123; name: <span class="built_in">string</span>; level: <span class="built_in">number</span> &#125;[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Person 接口 job 对象中 name 属性的类型定义为 FEJob 的类型</span></span><br><span class="line"><span class="keyword">let</span> FEJob: Person[<span class="string">"job"</span>] = &#123;</span><br><span class="line">  name: <span class="string">"FE"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中任意一项中 level 属性的类型作为 hobbyLevel 的类型</span></span><br><span class="line"><span class="keyword">let</span> hobbyLevel: Person[<span class="string">'hobbies'</span>][<span class="number">0</span>][<span class="string">'level'</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p><code>TS</code> 中定义的关键字 <code>keyof</code> 是索引类型查询操作符，用来定义类型，当定义一个获取对象属性值的函数，传入的值为对象和属性名，这样属性名参数的类型定义为 <code>string</code> 不准确，因为很可能传入一个对象本身没有的属性字符串，<code>keyof</code> 就是用来解决类似这样问题的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">'male'</span> | <span class="string">'female'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 keyof 定义类型</span></span><br><span class="line"><span class="keyword">type</span> PersonKey = keyof Person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValueByKey</span>(<span class="params">p: Person, key: PersonKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>: person: Person = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getValueByKey(person, <span class="string">'name'</span>); <span class="comment">// hello</span></span><br><span class="line">getValueByKey(person, <span class="string">'say'</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>在某一个类型定义中使用 <code>in</code> 操作符和 <code>keyof</code> 操作符批量映射修改一个新的类型定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">'male'</span> | <span class="string">'female'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射 Person 接口定义的类型，把每一个属性都变成可选的</span></span><br><span class="line"><span class="keyword">type</span> PartPerson = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof Person]?: Person[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: PartPerson = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中 <code>keyof Person</code> 取到了 <code>Person</code> 接口的每一个属性的类型，<code>key</code> 通过运算符 <code>in</code>（批量映射）代表获取的每一个属性名，<code>?:</code> 代表可选，<code>Person[key]</code> 代表对应的值。</p><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p>在 <code>TS</code> 内部内置了一些工具类型来帮助我们更好、更方便的使用类型系统。</p><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p><code>Partial</code> 可以将传入类型定义的属性由非可选变为可选，功能跟映射类型一节实现的功能非常相似，只是具体被映射的类型是通过参数传入的，所以底层是使用泛型实现的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Partial</span></span><br><span class="line"><span class="keyword">let</span> p: Partial&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial 的原理</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]?: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p><code>Required</code> 可以将传入类型定义的属性变为必选，使用 <code>-?:</code> 替换原有的 <code>:</code> 也可以实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Required</span></span><br><span class="line"><span class="keyword">let</span> p: Required&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Required 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyRequired&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]-?: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p><code>Readonly</code> 可以将传入类型定义的属性每一项都加上 <code>readonly</code> 修饰符来实现属性的只读。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Readonly</span></span><br><span class="line"><span class="keyword">let</span> p: Readonly&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'world'</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Readonly 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [key <span class="keyword">in</span> keyof T]: T[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p><code>Pick</code> 可以摘取传入类型定义的属性中的某一项返回。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Pick</span></span><br><span class="line"><span class="keyword">let</span> p: Pick&lt;Person, <span class="string">'name'</span>&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> K]: T[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置条件类型"><a href="#内置条件类型" class="headerlink" title="内置条件类型"></a>内置条件类型</h3><p>还记得在泛型一节中提到了泛型的流程控制，在 <code>TS</code> 中内置了一些常用的条件类型。</p><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">Exclude&lt;T, U&gt; <span class="comment">// 从 T 可分配给的类型中排除 U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">Extract&lt;T, U&gt; <span class="comment">// 从 T 可分配的类型中提取 U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = Extract&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="number">10</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">NonNullable&lt;T&gt; <span class="comment">// 从 T 中排除 null 和 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = NonNullable&lt;<span class="built_in">string</span> | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="literal">null</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">ReturnType&lt;T&gt; <span class="comment">// 获取函数类型的返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">"hello"</span>, age: <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo = ReturnType&lt;<span class="keyword">typeof</span> getUserInfo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: UserInfo = &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">InstanceType&lt;T&gt; <span class="comment">// 获取构造函数类型的实例类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name</span>) &#123;&#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P = InstanceType&lt;<span class="keyword">typeof</span> Person&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: P = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'myName'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 实现一个提交自动检测的 Git Hook</title>
      <link href="/2019/04/09/20190409024640/"/>
      <url>/2019/04/09/20190409024640/</url>
      
        <content type="html"><![CDATA[<img src="/2019/04/09/20190409024640/git-hooks-location.png" title="Git Hook"><p><br></p><h2 id="什么是-Git-Hook"><a href="#什么是-Git-Hook" class="headerlink" title="什么是 Git Hook"></a>什么是 Git Hook</h2><blockquote class="pullquote info"><p><code>Git Hook</code> 是能在 <code>Git</code> 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 <code>.git/hooks</code> 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 <code>.sample</code>，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。</p></blockquote><a id="more"></a><h2 id="实现-Hook-功能介绍"><a href="#实现-Hook-功能介绍" class="headerlink" title="实现 Hook 功能介绍"></a>实现 Hook 功能介绍</h2><p>本次将使用 <code>NodeJS</code> 实现一个 <code>Git Hook</code>，功能为在提交代码之前检测功能如下：</p><ul><li>检测是否为 <code>Git</code> 项目；</li><li>检测邮箱是否符合规格；</li><li>检测代码是否含有冲突；</li><li>自动执行 <code>Eslint</code>，并检测问题。</li></ul><h2 id="需求的由来"><a href="#需求的由来" class="headerlink" title="需求的由来"></a>需求的由来</h2><p>在开始代码的编写之前，一定要清楚，团队开发时为什么需要这样的 <code>hook</code>，下面列举的场景，可能都会对团队项目持续集成的历史树造成污染，或在协同开发时对团队成员造成麻烦。</p><p><strong>邮箱错误：</strong>当团队 <code>Gitlab</code> 仓库对邮箱格式进行了严格的限制，必须为公司邮箱才可以进行推送，这样很可能导致邮箱配错时进行了提交，而推送时发现邮箱错了，要对本地的 <code>commit</code> 记录修正，再重新进行推送。</p><blockquote class="pullquote warning"><p><strong>容易造成邮箱设置错误的常见原因：</strong></p><ul><li><strong>维护不同团队的开源项目太多，不同项目需要配置不同的邮箱，很可能导致邮箱配置错误；</strong></li><li><strong>当团队中有外包开发人员，且由于权限问题同一套代码是存放在两个仓库，正式员工需要在本地项目中通过 <code>remote</code> 来同时指定两个仓库地址，并在本地代码修改后拉取外包仓库的代码进行合并，同时同步到正式仓库和外包仓库，如果正式仓库对推送过来的提交邮箱格式进行了严格的限制，并且外包提交记录的邮箱错误，就导致正式员工合并后的提交被正式仓库拒绝，如果使用 <code>rebase</code> 强行修正错误的邮箱，变基后的 <code>commit</code> 哈希发生变化可能与远端仓库不一致，需要进行强推到两个仓库，并全员的本地回滚到变基之前。</strong></li></ul></blockquote><p><strong>代码冲突：</strong>开发时和其他人同时修改了相同部分造成冲突，如果冲突不能及时被发现，提交并推送到远端是对远端仓库的污染，也可能其他开发人员正好拉取了这样的代码，会对团队造成麻烦。</p><blockquote class="pullquote danger"><p><strong>容易造成冲突未及时处理的原因：</strong></p><ul><li><strong>项目过大，文件较多；</strong></li><li><strong>编辑器不智能；</strong></li><li><strong>前端项目使用了路由懒加载，不切换到冲突代码所在的路由，项目不会报错。</strong></li></ul></blockquote><p><strong>Eslint：</strong>有些团队的项目对代码规范要求高，并为了减小线上 <code>Bug</code> 率，会在项目中集成 <code>Eslint</code> 对代码风格进行检查，通常都是在命令行手动执行检测命令，有些时候可能忘记执行命令进行检测，就将代码进行了提交和推送。</p><blockquote class="pullquote default"><p>为了规避上面的情况，所以才有了这次关于 <code>Git Hook</code> 的需求，以及下面的代码实现，目的是防患于未然，将大家在开发时容易犯的错误或对项目代码持续集成和管理的潜在风险扼杀在摇篮中。</p></blockquote><h2 id="目录结构及文件简介"><a href="#目录结构及文件简介" class="headerlink" title="目录结构及文件简介"></a>目录结构及文件简介</h2><p><pre>git-hooks<br>  |- default-events.js<br>  |- default-rules.js<br>  |- git-checker.js<br>  |- pre-commit.js</pre></p><ul><li><code>default-events.js</code>：用来编写默认的检测事件；</li><li><code>default-rules.js</code>：用来管理默认检测事件用到的规则（正则）；</li><li><code>git-checker.js</code>：用来构建 <code>Hook</code> 的核心逻辑；</li><li><code>pre-commit.js</code>：用来编写执行检测的调用逻辑。</li></ul><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在编写这个 <code>hook</code> 之前需要用到一个第三方模块 <a href="https://www.npmjs.com/package/husky" target="_blank">husky</a>，这个模块的作用是根据项目中 <code>package.json</code> 的配置来向 <code>.git/hooks</code> 中的脚本写入我们的逻辑，项目中需要安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky</span><br></pre></td></tr></table></figure><h2 id="代码设计思路分析"><a href="#代码设计思路分析" class="headerlink" title="代码设计思路分析"></a>代码设计思路分析</h2><p>设计这个 <code>hook</code> 时提供了 <code>Git</code> 目录检测、邮箱验证、冲突检测、和执行 <code>Eslint</code> 的功能，当然我们希望检测函数不是强制的，是可以选择性使用，而使用者也可以编写自己需要的检测函数来覆盖其他的场景。</p><p>我们希望项目中的 <code>husky</code> 配置如下：</p><figure class="highlight"><figcaption><span>使用 hook 项目的 package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "node git-hooks/pre-commit"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>husky</code> 帮我们执行了 <code>git-hooks/pre-commit.js</code> 文件，我们希望使用者的用法如下：</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/pre-commit.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GitChecker = <span class="built_in">require</span>(<span class="string">'./git-checker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commitChecker = <span class="keyword">new</span> GitChecker(<span class="string">'pre-commit'</span>, &#123;</span><br><span class="line">  <span class="comment">// default event names</span></span><br><span class="line">  defaultEventNames: [<span class="string">'isGit'</span>, <span class="string">'email'</span>, <span class="string">'conflict'</span>, <span class="string">'eslint'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// your costom rules</span></span><br><span class="line">  &#125;,</span><br><span class="line">  checkEvents: &#123;</span><br><span class="line">    <span class="comment">// your custom check events</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">commitChecker.checkStart();</span><br></pre></td></tr></table></figure><p>上面的用法通过创建实例来创建 <code>checker</code>，即 “检测者”，调用 <code>checkStart</code> 方法帮助我们检测，创建实例的参数为 <code>options</code>，类型为对象。</p><p>上面的用法既可以让用户通过配置 <code>options</code> 的 <code>defaultEventNames</code> 属性来选择性的使用默认的检测函数，又可以通过 <code>checkEvents</code> 属性来让使用者编写检测函数。</p><p><code>rules</code> 属性是来存放使用者编写检测函数时使用的正则，会和默认检测函数中的正则合并，我们专门用 <code>default-rules.js</code> 文件来管理默认检测函数中使用的正则。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-rules.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  emailCheck: <span class="regexp">/\S+((@youemail\.com)|(@enterprise\.com))(\n|\r\n)*$/</span>,</span><br><span class="line">  conflictCheck: <span class="string">'^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\s'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="GitChecker-类的实现"><a href="#GitChecker-类的实现" class="headerlink" title="GitChecker 类的实现"></a>GitChecker 类的实现</h2><p>我们需要一个工厂创造 “检测者”，取名为 <code>GitChecker</code>，在 <code>GitChecker</code> 中需要使用发布订阅模式，对检测函数进行注册，并在执行实例的 <code>checkStart</code> 方法时依次执行，代码如下。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/git-checker.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultRules = <span class="built_in">require</span>(<span class="string">'./default-rules'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultEvents = <span class="built_in">require</span>(<span class="string">'./default-events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 GitChecker 类并继承 EventEmitter，目的是继承 on 和 emit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitChecker</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止使用者 options 内部属性传错，进行初始化</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      rules = &#123;&#125;,</span><br><span class="line">      defaultEventNames = [],</span><br><span class="line">      checkEvents = &#123;&#125;</span><br><span class="line">    &#125; = options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并默认检测函数使用的正则和用户自定义检测函数使用的正则统一管理</span></span><br><span class="line">    <span class="keyword">this</span>.rules = <span class="built_in">Object</span>.assign(defaultRules, rules);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并用户选择使用的默认检测函数和自定义检测函数</span></span><br><span class="line">    <span class="keyword">this</span>.checkEvents = <span class="built_in">Object</span>.assign(</span><br><span class="line">      <span class="keyword">this</span>.getDefaultEvents(defaultEventNames),</span><br><span class="line">      checkEvents</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.type = type; <span class="comment">// git 操作类型</span></span><br><span class="line">    <span class="keyword">this</span>.isCommit = <span class="literal">true</span>; <span class="comment">// 当前是否可以被提交</span></span><br><span class="line">    <span class="keyword">this</span>.gitConfigEnvs = [<span class="string">'local'</span>, <span class="string">'global'</span>, <span class="string">'system'</span>]; <span class="comment">// 取邮箱时的环境</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将提交状态更改为禁止，绑定 this 是为了防止在检测函数内解构更改指向</span></span><br><span class="line">    <span class="keyword">this</span>.forbiddenCommit = <span class="keyword">this</span>.forbiddenCommit.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.init(); <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="comment">// 将检测函数常用方法挂载到实例上</span></span><br><span class="line">    <span class="keyword">this</span>.log = log;</span><br><span class="line">    <span class="keyword">this</span>.exec = exec;</span><br><span class="line">    <span class="keyword">this</span>.chalk = chalk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册当前类型 git 操作对应的检测函数</span></span><br><span class="line">    <span class="keyword">this</span>.register(<span class="keyword">this</span>.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getDefaultEvents(eventsNames) &#123;</span><br><span class="line">    <span class="keyword">return</span> eventsNames.reduce(<span class="function">(<span class="params">memo, eventName</span>) =&gt;</span> &#123;</span><br><span class="line">      memo[<span class="string">`<span class="subst">$&#123;eventName&#125;</span>CheckTask`</span>] = defaultEvents[<span class="string">`<span class="subst">$&#123;eventName&#125;</span>CheckTask`</span>];</span><br><span class="line">      <span class="keyword">return</span> memo;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  register(type) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.checkEvents).forEach(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 订阅事件，每一个函数传入当前实例，方便取实例上的属性和方法</span></span><br><span class="line">      <span class="keyword">this</span>.on(type, () =&gt; <span class="keyword">this</span>.checkEvents[event](<span class="keyword">this</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forbiddenCommit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isCommit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> checkStart() &#123;</span><br><span class="line">    log(chalk.green(<span class="string">'开始代码检测'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布执行检测函数</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.emit(<span class="keyword">this</span>.type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束后结束当前 git 操作进程</span></span><br><span class="line">    <span class="keyword">this</span>.checkEnd();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkEnd() &#123;</span><br><span class="line">    <span class="comment">// 如果当前状态为不可提交，则退出进程号不为 0，git 规定</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isCommit) process.exit(<span class="number">1</span>);</span><br><span class="line">    log(chalk.green(<span class="string">'检测通过'</span>));</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = GitChecker;</span><br></pre></td></tr></table></figure><p>在上面的设计中之所以将一些常用方法都挂载在了实例上，目的是为了让使用者编写自定义检测函数时不再需要引入依赖，和更方便的获取实例上的属性、方法，当然也方便了我自己编写默认检测函数。</p><h2 id="默认检测函数的实现"><a href="#默认检测函数的实现" class="headerlink" title="默认检测函数的实现"></a>默认检测函数的实现</h2><p>由于检测工厂 <code>GitChecker</code> 已经将自己创建的 “检测者” 塞入了检测函数的参数中去，那就可以把所有的默认检测函数放入一个 <code>default-events.js</code> 文件中统一管理。</p><h3 id="检测目录是否被-Git-管理"><a href="#检测目录是否被-Git-管理" class="headerlink" title="检测目录是否被 Git 管理"></a>检测目录是否被 Git 管理</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.isGitCheckTask = <span class="function">(<span class="params">&#123; exec, log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 git 命令，如果跑出异常证明不是一个 git 管理的项目</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(<span class="string">'git status'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    log(chalk.red(<span class="string">'错误：当前不是一个git项目目录'</span>));</span><br><span class="line">    forbiddenCommit(); <span class="comment">// 更改提交状态太为不能提交</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>检测是否为一个 <code>Git</code> 所管理的项目只需执行 <code>git status</code> 来检测一下文件变化，如果抛出异常则说明不被 <code>Git</code> 所管理。</p><h3 id="检测邮箱是否合规"><a href="#检测邮箱是否合规" class="headerlink" title="检测邮箱是否合规"></a>检测邮箱是否合规</h3><blockquote class="pullquote primary"><p>上一个方法使用了从参数解构的方式获取实例属性和方法，为了更便于理解这个方法正常使用参数。</p></blockquote><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">exports.emailCheckTask = <span class="function">(<span class="params">checker</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> checkEmailEnvs = <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取出正则和获取 git 邮箱的环境参数集合</span></span><br><span class="line">    <span class="keyword">const</span> gitConfigEnvs = checker.gitConfigEnvs;</span><br><span class="line">    <span class="keyword">const</span> rules = checker.rules;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取邮箱的 git 命令</span></span><br><span class="line">    <span class="keyword">const</span> command = <span class="string">`git config --<span class="subst">$&#123;gitConfigEnvs[i]&#125;</span> user.email`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取邮箱成功，则校验邮箱是否合规</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> userEmail = checker.exec(command).toString();</span><br><span class="line">      <span class="keyword">const</span> isValidate = rules.emailCheck.test(userEmail);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isValidate) &#123;</span><br><span class="line">        checker.log(checker.chalk.red(<span class="string">'错误：请使用正确的邮箱提交代码'</span>));</span><br><span class="line">        checker.log(checker.chalk.yellow(<span class="string">`你当前的邮箱是：<span class="subst">$&#123;userEmail&#125;</span>`</span>));</span><br><span class="line">        checker.forbiddenCommit();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checker.log(checker.chalk.green(<span class="string">'邮箱校验通过'</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === gitConfigEnvs.length) &#123;</span><br><span class="line">        checker.log(checker.chalk.red(<span class="string">'错误：请设置git的提交邮箱'</span>));</span><br><span class="line">        checker.forbiddenCommit();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checkEmailEnvs(i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  checkEmailEnvs(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>在 <code>Git</code> 中有三个参数设置邮箱，分别 <code>--local</code>、<code>--global</code>、<code>--system</code>，分别对应项目、用户和系统三个环境，顺序即为获取优先级，所以获取也是如此。</p></blockquote><p>该方法使用了递归的思想实现，从优先级最高的环境开始获取邮箱，如果取到邮箱则进行验证，没取到则选择优先级次之的环境获取，直到取到邮箱为止，若都取不到则提示用户设置邮箱，如果取到邮箱，校验不通过则提示用户当前邮箱，并提醒用户设置正确的邮箱。</p><h3 id="检测冲突"><a href="#检测冲突" class="headerlink" title="检测冲突"></a>检测冲突</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exports.conflictCheckTask = <span class="function">(<span class="params">checker</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对文件进行正则匹配的 git 命令</span></span><br><span class="line">  <span class="keyword">const</span> command = <span class="string">`git grep -n -P -E "<span class="subst">$&#123;rules.conflictCheck&#125;</span>"`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有成功匹配，则抛出异常，成功匹配打印冲突代码</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> conflicts = checker.exec(command, &#123; <span class="attr">encoding</span>: <span class="string">'utf-8'</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (conflicts) &#123;</span><br><span class="line">      checker.log(checker.chalk.red(<span class="string">'错误：发现冲突，请解决后再提交'</span>));</span><br><span class="line">      checker.log(checker.chalk.red(<span class="string">'错误代码：'</span>));</span><br><span class="line">      checker.log(checker.chalk.red(conflicts.trim()));</span><br><span class="line">      checker.forbiddenCommit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    checker.log(checker.chalk.green(<span class="string">'未发现冲突'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>在上面的 <code>Git</code> 命令中，<code>-n</code> 为显示匹配文件的行号，因为 <code>shell</code> 的正则支持不全，<code>-P</code> 和 <code>-E</code> 是为了支持正则扩展，保证正则生效。</p></blockquote><h3 id="执行-Eslint"><a href="#执行-Eslint" class="headerlink" title="执行 Eslint"></a>执行 Eslint</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.eslintCheckTask = <span class="function">(<span class="params">&#123; exec, log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(<span class="string">'lint-staged'</span>);</span><br><span class="line">    log(chalk.green(<span class="string">'Eslint 校验通过'</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    log(chalk.red(<span class="string">'错误：Eslint 校验不通过'</span>));</span><br><span class="line">    forbiddenCommit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><code>Eslint</code> 本身具备检测冲突的功能，检测冲突的函数更适用于没有集成 <code>Eslint</code> 的项目，如果项目已经集成了 <code>Eslint</code> 可以不适用检测冲突函数。</p></blockquote><h2 id="关于扩展"><a href="#关于扩展" class="headerlink" title="关于扩展"></a>关于扩展</h2><p>当需求变更，需要在 <code>push</code> 之间执行某些脚本应该怎么办，可以在 <code>git-hooks</code> 文件夹增加一个 <code>pre-push.js</code> 文件，文件内容如下。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/pre-push.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GitChecker = <span class="built_in">require</span>(<span class="string">'./git-checker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pushChecker = <span class="keyword">new</span> GitChecker(<span class="string">'pre-push'</span>, &#123;</span><br><span class="line">  defaultEventNames: [<span class="string">'isGit'</span>, <span class="string">'email'</span>], <span class="comment">// default event names</span></span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// your costom rules</span></span><br><span class="line">  &#125;,</span><br><span class="line">  checkEvents: &#123;</span><br><span class="line">    myHook: <span class="function">(<span class="params">&#123; log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      log(chalk.red(<span class="string">'check prev push'</span>));</span><br><span class="line">      forbiddenCommit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">commitChecker.checkStart();</span><br></pre></td></tr></table></figure><p>由于我们的 <code>hook</code> 依赖于 <code>husky</code>，所以项目 <code>package.json</code> 中的 <code>husky</code> 也有所修改如下。</p><figure class="highlight"><figcaption><span>使用 hook 项目的 package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "node git-hooks/pre-commit",</span><br><span class="line">      "pre-push": "node git-hooks/pre-push"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote class="pullquote success"><p>以上就是本次 <code>Git Hook</code> 的使用场景和实现，也希望通过本文，能让大家对 <code>Git Hook</code> 的相关知识有一定了解，另附赠 <code>Github</code> 地址 <a href="https://github.com/shenqiuhui/git-hooks/tree/master" target="_blank">https://github.com/shenqiuhui/git-hooks/tree/master</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Git </tag>
            
            <tag> 命令行 </tag>
            
            <tag> 代码管理/版本控制 </tag>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 系列之 Github 团队协作</title>
      <link href="/2019/03/27/20190327025116/"/>
      <url>/2019/03/27/20190327025116/</url>
      
        <content type="html"><![CDATA[<img src="/2019/03/27/20190327025116/github.jpeg" title="Github 团队协作"><p><br></p><h2 id="Github-的由来"><a href="#Github-的由来" class="headerlink" title="Github 的由来"></a>Github 的由来</h2><blockquote class="pullquote default"><p><code>Github</code> 的诞生是由于 <code>Git</code> 的局限性，尽管当时 <code>Git</code> 对于代码的管理以及团队协作方面已经非常出色，但是 <code>Git</code> 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 <code>Git</code> 特性的代码平台的诉求成为必然，<code>Github</code> 就这样诞生了。</p></blockquote><a id="more"></a><h2 id="如何在-Github-高效的搜索项目"><a href="#如何在-Github-高效的搜索项目" class="headerlink" title="如何在 Github 高效的搜索项目"></a>如何在 Github 高效的搜索项目</h2><p>如今 <code>Github</code> 已经非常火爆，也因此被戏称为 “世界最大的同性交友平台”，在 <code>Github</code> 上托管的仓库数量巨大，这对在 <code>Github</code> 上寻找需要的开源项目造成了困扰，其实在 <code>Github</code> 上搜索项目也有一定的技巧，下面我们就来说一下如何高效的找到自己需要的开源项目。</p><p>在登录 <code>Github</code> 后，让搜索项目的搜索框获取焦点并敲下回车键，会跳转到一个搜索页面，这个页面上点击 <code>Advanced search</code>（高级搜索）就会跳转到高级搜索页面。</p><ul><li><code>From these owners</code>：按照作者名搜索，格式 <code>user:username</code>；</li><li><code>In these repositories</code>：按照仓库名称搜索，格式 <code>repo:username/reponame</code>；</li><li><code>Created on the dates</code>：按照创建日期搜索，格式 <code>created:&lt;YYYY-MM-DD</code>；</li><li><code>Written in this language</code>：按照语言进行搜索，格式 <code>language:JavaScript</code>；</li><li><code>With this many stars</code>：按照星星数查找，格式 <code>stars:&gt;1000</code>；</li></ul><blockquote class="pullquote info"><p>上面列举只是常用的部分搜索方式和格式，具体可以查看 <a target="_blank" href="https://github.com/search/advanced">https://github.com/search/advanced</a>，也可以不通过高级搜索的页面直接将规则写在 <code>Github</code> 主页的搜索框内，多个搜索规则可同时使用，格式之间用空格隔开，当然也可以按照内容是否在哪一个文件中来搜索，如 <code>partcontent in readme</code>。</p></blockquote><h2 id="Organizations（组织）"><a href="#Organizations（组织）" class="headerlink" title="Organizations（组织）"></a>Organizations（组织）</h2><p>在 <code>Github</code> 中的仓库可以创建在个人仓库中，也可以创建在组织中，创建在个人仓库时项目的管理者只有项目的所有者，不方便团队层面的管理和协作，如果想要多人共同的管理项目可以通过组织的形式进行。</p><p><strong>创建组织步骤如下：</strong></p><ul><li>个人信息 <code>setting</code>；</li><li>进入界面点击左侧 <code>Organizations</code>；</li><li>点击右上角 <code>new organization</code>；</li><li>填好组织信息后点击下方 <code>Create organization</code>。</li></ul><p>添加后的组织会出现在用户 <code>setting</code> 页面的 <code>Organizations</code> 选项中，点击进入某个组织，可以添加 <code>Github</code> 中可以搜索到的成员进行协同开发，可以在组织下新建仓库，可以创建团队对仓库做更精细化的管理，也可以对团队里的每个成员针对仓库设置读写权限。</p><h2 id="怎样选择适合团队的工作流"><a href="#怎样选择适合团队的工作流" class="headerlink" title="怎样选择适合团队的工作流"></a>怎样选择适合团队的工作流</h2><p>一个团队在协作的时候一定会分工到所有人完成的工作变成一个产品的过程，“工作流” 对于研发团队来讲，可以理解成分支管理的流程。</p><h3 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h3><p>主干开发是围绕着一条主开发分支进行开发，团队所有成员的 <code>commit</code> 都及时的集成在这条主分支，让团队其他成员第一时间知道。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/master-flow.png" alt="主分支开发工作流" title>                </div>                <div class="image-caption">主分支开发工作流</div>            </figure><p><br></p><blockquote class="pullquote warning"><p><strong>适用团队：</strong></p><ul><li><strong>适用于开发团队系统设计和开发能力强，有快速迭代场景，并且有一套有效的特性切换的实施机制（发布系统），保证上线后无序修改代码就能够修改系统行为；</strong></li><li><strong>适用于组件开发的团队（一些基础服务的部门，专门造轮子），成员能力强，人员少，沟通顺畅，用户升级、切换组件成本低。</strong></li></ul></blockquote><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p><code>Git Flow</code> 工作流定义了一个围绕项目发布的严格分支模型，工作流虽然复杂，但提供了一个健壮的用于管理大型项目的框架，具体的工作流程如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/git-flow.png" alt="Git Flow 工作流" title>                </div>                <div class="image-caption">Git Flow 工作流</div>            </figure><p><br></p><ul><li><code>master</code>：专门用来存储正式发布的历史；</li><li><code>develop</code>：作为功能的集成分支，可以多团队同时在 <code>develop</code> 分支集成；</li><li><code>feature</code>：专门用来开发某一个新功能，仅仅只和 <code>develop</code> 交互；</li><li><code>release</code>：发布（提测）分支，当快要到达发既定发布时间，从 <code>develop</code> 分支分出用来 <code>bugfix</code>，上线和 <code>master</code> 进行合并，同时和 <code>develop</code> 进行合并；</li><li><code>hotfix</code>：上线后从 <code>master</code> 分出用来修复线上 <code>Bug</code>。</li></ul><blockquote class="pullquote success"><p><strong>适用团队：</strong></p><ul><li><strong>适用于对项目质量要求较高，不具备主干开发能力，有预定发布周期且需要严格执行发布流程的团队。</strong></li></ul></blockquote><h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p><code>Github Flow</code> 工作流就是基于 <code>master</code> 的某一个 <code>commit</code> 拉一条特性分支进行开发，在开发完毕后在重新集成到 <code>master</code> 的工作流。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/github-flow.png" alt="Github 工作流" title>                </div>                <div class="image-caption">Github 工作流</div>            </figure><p><br></p><blockquote class="pullquote primary"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，随时集成随时发布，分支集成时经历代码评审和自动化测试，通过后就可立即发布的应用。</strong></li></ul></blockquote><h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><p><code>Github Flow</code> 是在 <code>Github Flow</code> 的基础上做了一些优化，新增了平行的 <code>production</code> 分支，用于随时准备发布上线，也可以多一些针对不同测试环境的待测试分支。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/gitlab-flow.png" alt="Gitlab 工作流" title>                </div>                <div class="image-caption">Gitlab 工作流</div>            </figure><p><br></p><blockquote class="pullquote danger"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，需要逐个通过测试环境的验证才能发布的应用；</strong></li><li><strong>适用同一个时间节点项目发布出去会有多个版本同时存在的情况，如通信类型的项目不同版本配合不同的硬件。</strong></li></ul></blockquote><h2 id="Create-pull-request"><a href="#Create-pull-request" class="headerlink" title="Create pull request"></a>Create pull request</h2><p>在多人开发的项目或开源项目中，其他人拉出一条分支进行开发，在上线之前需要合并到 <code>master</code> 主分支，需要提交 <code>pull request</code>，在 <code>Github</code> 项目页面点击上面的 <code>Pull requests</code> 按钮，上面有两个选项：</p><ul><li><code>base</code>：目标分支；</li><li><code>compare</code>：合并的特性分支。</li></ul><p>在选好 <code>base</code>（目标分支） 和 <code>compare</code>（合并的特性分支） 后，点击下方 <code>Create pull request</code>，填写提交的描述信息后再次点击 <code>Create pull request</code>，此时会在下方显示与目标分支相比新增的提交信息并自动检查冲突。</p><blockquote class="pullquote info"><p><strong><code>pull request</code> 有三种模式：</strong></p><ul><li><strong><code>Create a merge commit</code>：直接将某一个特性分支通过 <code>merge</code> 的方式合并到 <code>master</code>；</strong></li><li><strong><code>Squash and merge</code>：会将特性分支的所有变更集组合成一个 <code>commit</code> 合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立；</strong></li><li><strong><code>Rebase and merge</code>：会将特性分支变更集直接合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立。</strong></li></ul></blockquote><p>选择 <code>pull request</code> 模式后，需要对这个 <code>pull request</code> 进行再次确认，填写确认信息并点击 <code>Confirm merge</code> 确认合并，在完成合并后 <code>Github</code> 会给我们提供删除特性分支的快捷按钮 <code>Delete branch</code>，一般会等到项目稳定后才会删除特性分支。</p><h2 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h2><p><code>Issues</code> 用于追踪需求和任务，在开源项目中使用者发现 <code>Bug</code> 或有新的需求都是通过 <code>Issues</code> 提出，在 <code>Issues</code> 的 <code>Labels</code> 中有开发者设置的代表当前处理状态的标签，通过 <code>Issue</code> 上的状态标签可以知道 <code>Issue</code> 的处理进度。</p><h3 id="创建-Issue"><a href="#创建-Issue" class="headerlink" title="创建 Issue"></a>创建 Issue</h3><p><strong>创建 <code>Issue</code> 的步骤：</strong></p><ul><li>点击项目的 <code>Issues</code> 进入 <code>Issues</code> 页面；</li><li>点击 <code>New Issue</code>;</li><li>填写 <code>Issues</code> 的标题及内容；</li><li>点击 <code>Submit new issue</code> 创建 <code>Issue</code>。</li></ul><h3 id="创建-Issue-模版"><a href="#创建-Issue-模版" class="headerlink" title="创建 Issue 模版"></a>创建 Issue 模版</h3><p><strong><code>Issues</code> 的类型不是单一的，项目的所有者是可以给项目的 <code>Issues</code> 添加分类模版的，操作如下：</strong></p><ul><li>进入项目的 <code>Setting</code> 页面；</li><li>点击 <code>Issues</code> 选项的 <code>Set up templates</code> 按钮进入设置页面；</li><li><p>通过下拉框选择 <code>Issues</code> 模版的类型，分类如下：</p><ul><li><code>Bug report</code>：用来提出项目中的 <code>Bug</code>；</li><li><code>Feature request</code>：用来提出新的需求和功能；</li><li><code>Custom issue template</code>：自定义的模版类型，由项目所有者创建时决定具体用途。</li></ul></li><li>点击 <code>Preview and edit</code> 对添加的 <code>Issue</code> 模版进行编辑，编辑后点击 <code>Close preview</code> 保存编辑的内容；</li><li>添加 <code>Issues</code> 模版后点击 <code>Propose changes</code>；</li><li>添加本次修改的记录，同时可以选择用 <code>master</code> 分支还是新创建分支来管理这些 <code>Issues</code>；</li><li>点击 <code>Commit changes</code> 则会生成模版，再次执行创建 <code>Issues</code> 的步骤时可以看到设置的模版，点击模版对应的 <code>Get started</code> 快速生成对应的模版。</li></ul><blockquote class="pullquote default"><p>在编辑模版后，模版会生成对应 <code>markdown</code> 文件被保存在项目中的 <code>.github/ISSUE_TEMPLATE</code> 路径下。</p></blockquote><p><code>Issues</code> 更大的好处是，在追踪需求和任务的同时，任何人都可以在下面对这个 <code>Issue</code> 中的内容进行评论交流，甚至可以直接 <code>@</code> 评论者、项目所有者、开发者、甚至是项目的整个团队，有助于快速解决 <code>Issue</code> 中提出的问题。</p><h2 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h2><p>在开源项目开发时可以为当前项目的某个正在进行的迭代创建 <code>Project</code>，创建的 <code>Project</code> 类似于一个看板的形式，可以非常便捷的管理正在进行修复的 <code>Issue</code> 和 <code>pull request</code>（需要在创建 <code>Issue</code> 和 <code>pull request</code> 时选中关联这个 <code>Project</code>）。</p><p><strong>创建 <code>Project</code> 步骤如下：</strong></p><ul><li>进入项目的 <code>Projects</code> 页面；</li><li>点击 <code>Create a project</code>；</li><li>填写项目的名称和描述并点击下方 <code>Create project</code>。</li></ul><p><strong>在看板中分别对应四个区域如下：</strong></p><ul><li><code>To do</code>：将要完成的任务；</li><li><code>In progress</code>：正在进行中的任务；</li><li><code>Needs review</code>：需要复盘的任务；</li><li><code>Reviewer approved</code>：已经审核通过的任务。</li></ul><p>任务可以通过拖动来改变当前的进度和状态，可以非常便捷的实现项目的任务进度监控和管理，有效的推进项目进程。</p><h2 id="分支保护"><a href="#分支保护" class="headerlink" title="分支保护"></a>分支保护</h2><p>在 <code>Github</code> 的项目中，可以对指定的分支定义规则来进行保护，防止强制推送、以及分支被删除等操作，目的是为了防止误操作对重要分支造成无法挽回的后果。</p><p>可以通过项目的 <code>Setting</code> 进入，选中左侧的 <code>Branches</code> 选项，点击 <code>Add rule</code> 来添加保护规则，<code>Branch name pattern</code> 内制定要保护的分支名字，<code>Rule settings</code> 中可以设置分支保护规则。</p><p><strong>可选规则（可根据需求多选）如下：</strong></p><ul><li><p><code>Require pull request reviews before merging</code>：选中该项后所有的提交合并都必须通过 <code>pull request</code> 进行，下面有三个子选项如下：</p><ul><li><code>Required approving reviews</code>：同意 <code>pull request</code> 的人数，就是说设置后必须有对应设置的人数的相关人员批准，才可以合并；</li><li><code>Dismiss stale pull request approvals when new commits are pushed</code>：勾选后在有新的 <code>pull request</code> 时会撤销旧的 <code>pull request</code>；</li><li><code>Require review from Code Owners</code>：勾选该项后，<code>pull request</code> 必须通过项目所有者的通过才能进行合并。</li></ul></li><li><p><code>Require status checks to pass before merging</code>：在合并前必须通过状态检查才能合并，状态检查如下：</p><ul><li><code>Require branches to be up to date before merging</code>：要求分支在合并之前是最新的。</li></ul></li><li><code>Require signed commits</code>：勾选该项后要求在提交时验证签名；</li><li><code>Include administrators</code>：加入管理员执行所有限制的配置。</li></ul><blockquote class="pullquote success"><p>上面的配置我们通过要保护分支的安全级别自行选择。</p></blockquote><h2 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h2><p><code>Wiki</code> 是 <code>Github</code> 提供的说明文档功能，点击项目上的 <code>Wiki</code> 选项进入文档页面，在项目从来没有编辑过稳当页面时，会默认出现 <code>Create the first page</code> 按钮，点击则会跳转编辑 <code>Wiki</code> 的页面，可以输入 <code>Wiki</code> 标题、内容和提交信息，内容支持 <code>Markdown</code> 语法编写。</p><p>当已经创建过一个 <code>Wiki page</code> 后再次进入项目的 <code>Wiki</code> 页面，会在右上角显示 <code>Edit</code> 和 <code>New page</code> 按钮，分别用于修改和新增 <code>Wiki page</code>，在左侧有所有 <code>Wiki page</code> 的列表，最下面是 <code>Wiki</code> 的仓库地址，也可以通过编辑器在本地创建 <code>Wiki page</code>，编写后通过 <code>Git</code> 推送到 <code>Wiki</code> 仓库。</p><p>在 <code>Wiki</code> 页面还有两个扩展功能，分别为 <code>Add a custom footer</code> 和 <code>Add a custom sidebar</code>，用于创建自定义底部和侧边栏（如编写目录等）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote warning"><p><code>Github</code> 管理项目实现协同开发是非常便捷的，在 <code>Github</code> 中每一个的操作的参与者和被参与者都会收到 <code>Github</code> 邮件进行通知，进入邮件链接也可以直接对项目变化进行 <code>code review</code>，在企业级项目中目前 <code>Gitlab</code> 的私有仓库更火爆，基本功能与 <code>Github</code> 大同小异，在基本功能的基础上增加了更高级的功能和内置的持续集成插件，有兴趣可以尝试探究一下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 代码管理/版本控制 </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 系列之实战技及巧注意事项总结</title>
      <link href="/2019/03/15/20190315115008/"/>
      <url>/2019/03/15/20190315115008/</url>
      
        <content type="html"><![CDATA[<img src="/2019/03/15/20190315115008/git.png" title="Git 实战技及注意事项"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Git</code> 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 <code>Git</code> 的基础上来详细总结一下这些注意事项。</p></blockquote><a id="more"></a><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><p>在日常开发时，我们经常都是在某一个分支下进行的，<code>commit</code> 操作也是在某些分支上进行，换句话说我们的每一个提交一般来讲都是与分支挂钩的，在 <code>Git</code> 中有一种情况，我们所修改的代码不与任何一个分支有关连，这种情况下叫做分离头指针。</p><p>那么如何操作才能实现分离头指针呢，在开发时我们可能会对某一个 <code>commit</code> 非常的感兴趣，并希望在这个 <code>commit</code> 下去做一些事情，可以执行下面命令实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br></pre></td></tr></table></figure><p>当切换分支后对某些文件做一些修改，并重新 <code>commit</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'分离头指针测试'</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>执行上面命令后我们发现新的 <code>commit</code> 信息后面不在对应某一个分支，而是 <code>HEAD</code>，这种情况下就代表着我们的 <code>Git</code> 目前已经处于分离头指针的状态了。</p><p>分离头指针是 “双刃剑” 有好处也有坏处，在分离头指针的状态下所有的 <code>commit</code> 在重新切换分支时，会被 <code>Git</code> 当作无用提交回收掉，因为这些提交没有跟任何分支有所联系。</p><blockquote class="pullquote warning"><p><em><strong>优点：尝试性的 <code>commit</code> 可以在分离头指针的状态下进行；</strong></em><br><em><strong>缺点：当发布需要到其他分支修复问题或紧急发布时，切分支后会导致分离头指针状态下的 <code>commit</code> 丢失。</strong></em></p></blockquote><p>在切换分支后，如果还想保留分离头指针状态下的提交，可以为这个提交创建一个新的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名 分离头指针状态的提交（哈希值）</span><br></pre></td></tr></table></figure><h2 id="修改本地-commit"><a href="#修改本地-commit" class="headerlink" title="修改本地 commit"></a>修改本地 commit</h2><h3 id="修改最近一次提交"><a href="#修改最近一次提交" class="headerlink" title="修改最近一次提交"></a>修改最近一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><code>--amend</code> 可以将暂存区新存入的内容同时提交到最近的一次 <code>commit</code> 中，而不会生成新的 <code>commit</code>，同时也可以修改 <code>commit</code> 时的提交信息。</p></blockquote><h3 id="修改任意一次提交"><a href="#修改任意一次提交" class="headerlink" title="修改任意一次提交"></a>修改任意一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i a4d56bb</span><br></pre></td></tr></table></figure><p>该操作为 <code>git rebase</code> 命令的交互模式，即输入 <code>-i</code> 命令，后面所输入的 <code>commit</code> 哈希值并不是要修改的 <code>commit</code>，而是要修改的 <code>commit</code> 的父级 <code>commit</code> 哈希值，在执行命令后会弹出修改的交互界面如下。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pick 52f3935 add css file</span><br><span class="line"><span class="deletion">- pick 91bd053 change css</span></span><br><span class="line"><span class="addition">+ reword 91bd053 change css</span></span><br><span class="line"></span><br><span class="line"># Rebase a4d56bb..91bd053 onto a4d56bb (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>从上面的信息来看第一条代表当前要修改的 <code>commit</code>，第二条代表该分支最新的 <code>commit</code>，下面注释为修改参数，由于要修改提交信息，所以此处将第一行的 <code>pick</code> 修改成 <code>reword</code> 并保存，保存后会弹出下一个修改提交信息的界面如下。</p><figure class="highlight diff"><figcaption><span>第二个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- css content</span></span><br><span class="line"><span class="addition">+ add css content</span></span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto a4d56bb</span><br><span class="line"># Last command done (1 command done):</span><br><span class="line">#    reword 9e4f711 add css content</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick c220cf2 change css</span><br><span class="line"># You are currently editing a commit while rebasing branch 'test' on 'a4d56bb'.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.css</span><br></pre></td></tr></table></figure><p>该界面上为 <code>commit</code> 的 <code>message</code>，修改后保存，就完成了对该 <code>commit</code> 的修改，值得注意的是，使用 <code>git log</code> 查看历史可以发现，修改 <code>commit</code> 时指定的父级 <code>commit</code> 后所有的 <code>commit</code> 哈希值都会发生变化。</p><figure class="highlight plain"><figcaption><span>commit 后的提示信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[detached HEAD de48b04] add css content</span><br><span class="line"> Date: Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 index.css</span><br><span class="line">Successfully rebased and updated refs/heads/test.</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>可以看出，其实使用 <code>git rebase</code> 命令修改 <code>commit</code> 的原理也是分离头指针，只是在分离头指针修改 <code>commit</code> 后又重新将当前分支的指针指回了最新的 <code>commit</code>。</p></blockquote><h3 id="将多个连续的-commit-合并成一个"><a href="#将多个连续的-commit-合并成一个" class="headerlink" title="将多个连续的 commit 合并成一个"></a>将多个连续的 commit 合并成一个</h3><p>将多个 <code>commit</code> 合并成一个的原理与修改任意一个 <code>commit</code> 的原理相同，都是通过 <code>git rebase</code> 命令的交互模式实现的（<code>-i</code>），参数为合并几个 <code>commit</code> 的父级 <code>commit</code> 哈希值。</p><figure class="highlight bash"><figcaption><span>查看历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># edd2400 (HEAD -&gt; test) add content to readme</span></span><br><span class="line"><span class="comment"># 50a015c add background css</span></span><br><span class="line"><span class="comment"># 15237d2 change css</span></span><br><span class="line"><span class="comment"># 4a8fd80 add css content</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><p>现在我们尝试将 <code>50a015c</code>、<code>15237d2</code> 和 <code>4a8fd80</code> 这三个 <code>commit</code> 合并成一个，与修改 <code>commit</code> 唯一不同的是被修改的 <code>commit</code> 参数不再是 <code>reword</code>，而是 <code>squash</code>，多个要合并的 <code>commit</code> 之中有一个目标 <code>commit</code>，这个 <code>commit</code> 的参数必须是 <code>pick</code>。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pick 4a8fd80 add css content</span><br><span class="line"><span class="deletion">- pick 15237d2 change css</span></span><br><span class="line"><span class="deletion">- pick 50a015c add background css</span></span><br><span class="line"><span class="addition">+ squash 15237d2 change css</span></span><br><span class="line"><span class="addition">+ squash 50a015c add background css</span></span><br><span class="line">pick edd2400 add content to readme</span><br><span class="line"></span><br><span class="line"># Rebase 5149bad..edd2400 onto 5149bad (4 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>对上面的交互界面保存后同样会弹出第二个交互界面，合并多个 <code>commit</code> 与修改单个 <code>commit</code> 不同的是，第二个界面会展示所有被合并 <code>commit</code> 的信息，我们可以为合并后的 <code>commit</code> 添加一个新的 <code>message</code>。</p><figure class="highlight diff"><figcaption><span>第二个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+ css changes</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"># This is the 1st commit message:</span><br><span class="line"></span><br><span class="line">add css content</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line"></span><br><span class="line">change css</span><br><span class="line"></span><br><span class="line"># This is the commit message #3:</span><br><span class="line"></span><br><span class="line">add background css</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 5149bad</span><br><span class="line"># Last commands done (3 commands done):</span><br><span class="line">#    squash 15237d2 change css</span><br><span class="line">#    squash 50a015c add background css</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick edd2400 add content to readme</span><br><span class="line"># You are currently rebasing branch 'test' on '5149bad'.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.css</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看合并提交后的历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2c84584 (HEAD -&gt; test) add content to readme</span></span><br><span class="line"><span class="comment"># ac001bc css changes</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><h3 id="将多个间隔的-commit-合并成一个"><a href="#将多个间隔的-commit-合并成一个" class="headerlink" title="将多个间隔的 commit 合并成一个"></a>将多个间隔的 commit 合并成一个</h3><p>上面的 <code>commit</code> 合并方式可能满足不了需求，有些时候我们想把对同一个文件的提交或同一类操作的提交合并成一个，但是在历史 <code>commit</code> 中要合并的树是间隔的，使用 <code>git rebase</code> 命令同样可以做到。</p><figure class="highlight bash"><figcaption><span>查看历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 23d6939 (HEAD -&gt; test) append content into readme</span></span><br><span class="line"><span class="comment"># 178ea29 link css in html</span></span><br><span class="line"><span class="comment"># 2c84584 add content to readme</span></span><br><span class="line"><span class="comment"># ac001bc css changes</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><p>在之前使用 <code>git rebase</code> 命令时都是将操作 <code>commit</code> 的父级 <code>commit</code> 作为参数，如果我们要操作的 <code>commit</code> 已经没有父级 <code>commit</code>，接下来在合并多个间隔的 <code>commit</code> 时来测试一下这样的情况，接下来将 <code>7f73a76</code> 和 <code>178ea29</code> 两个关于 <code>html</code> 文件的操作合并成一个。</p><figure class="highlight bash"><figcaption><span>执行命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f73a76</span><br></pre></td></tr></table></figure><p>由于我们要操作的 <code>commit</code> 已经没有了父级，所以我们就在执行命令时传入这个 <code>commit</code>，在弹出的第一个交互界面我么明显能看到其实上面是少了我们要操作的 <code>commit</code>，所以需要手动补上，而间隔的 <code>commit</code> 要移动到和合并的目标 <code>commit</code> 连续的位置。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ pick 7f73a76</span></span><br><span class="line"><span class="addition">+ squash 178ea29 link css in html</span></span><br><span class="line">pick 4a8fd80 add css content</span><br><span class="line">pick 5149bad new READ.md</span><br><span class="line">pick ac001bc css changes</span><br><span class="line">pick 2c84584 add content to readme</span><br><span class="line"><span class="deletion">- pick 178ea29 link css in html</span></span><br><span class="line">pick 23d6939 append content into readme</span><br><span class="line"></span><br><span class="line"># Rebase 7f73a76..23d6939 onto 7f73a76 (5 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>在保存后出现如下报错信息，是因为 <code>commit</code> 的父节点是我们新增上去导致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">The previous cherry-pick is now empty, possibly due to conflict resolution.</span><br><span class="line">If you wish to commit it anyway, use:</span><br><span class="line"></span><br><span class="line">    git commit --allow-empty</span><br><span class="line"></span><br><span class="line">Otherwise, please use &apos;git reset&apos;</span><br><span class="line">interactive rebase in progress; onto 7f73a76</span><br><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 7f73a76</span><br><span class="line">Next commands to do (5 remaining commands):</span><br><span class="line">   squash 178ea29 link css in html</span><br><span class="line">   pick 5149bad new READ.md</span><br><span class="line">You are currently rebasing branch &apos;test&apos; on &apos;7f73a76&apos;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">Could not apply 7f73a76...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>git status 提示信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 7f73a76</span><br><span class="line">Next commands to do (5 remaining commands):</span><br><span class="line">   squash 178ea29 link css in html</span><br><span class="line">   pick 5149bad new READ.md</span><br><span class="line">  (use &quot;git rebase --edit-todo&quot; to view and edit)</span><br><span class="line">You are currently rebasing branch &apos;test&apos; on &apos;7f73a76&apos;.</span><br><span class="line">  (all conflicts fixed: run &quot;git rebase --continue&quot;)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>想继续合并</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>想还原回合并之前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><p>如果在继续合并后没有出现第二个交互界面（与合并连续 <code>commit</code> 类似，用来新增合并后 <code>commit</code> 的信息），说明合并时出现冲突，此时需要解决冲突后将新的变更提交到暂存区，再重新执行合并命令。</p><figure class="highlight bash"><figcaption><span>查看合并后的历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4d4f771 (HEAD -&gt; test) append content into readme</span></span><br><span class="line"><span class="comment"># a83f526 add content to readme</span></span><br><span class="line"><span class="comment"># 463fd85 css changes</span></span><br><span class="line"><span class="comment"># 7e44e19 new READ.md</span></span><br><span class="line"><span class="comment"># 753ebcd about html changes</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：当前对 <code>commit</code> 的变更和合并操作只是对 <code>commit</code> 做了整理，并没有改变文件内容，并且这些操作仅限于要修改或合并的 <code>commit</code> 还没有共享到集成分支上去，如果已经推送到远端，进行上面操作会对其他协同开发的人员造成麻烦和困扰。</strong></em></p></blockquote><h3 id="删除后提交的-commit"><a href="#删除后提交的-commit" class="headerlink" title="删除后提交的 commit"></a>删除后提交的 commit</h3><p>在开发中有这样一种情景，就是我们在修改代码时提交了一个或者几个新的 <code>commit</code>，但是发现有更好的方案，想要删除这些 <code>commit</code>，这时可以通过将 <code>HEAD</code> 指针重新指向这些 <code>commit</code> 之前的提交，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>这样的操作会导致工作区、暂存区的代码都会到这个 <code>commit</code> 的状态，当然也有 “后悔药”，可以使用 <code>git reflog</code> 找到所有的 <code>commit</code> 版本号 包含已删除），再通过同样的方式将 <code>HEAD</code> 的指针指回去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard 已删除的版本号</span><br></pre></td></tr></table></figure><h2 id="忽略上传的文件"><a href="#忽略上传的文件" class="headerlink" title="忽略上传的文件"></a>忽略上传的文件</h2><p>在开发过程中，有些文件是不需要我们上传到远端的，可能因为这个文件对于开发项目来讲是无用的，如编辑器自动生成的 <code>.idea</code> 等，或者这个文件夹非常的大，如 <code>node_modules</code>，我们可以通过 <code>.gitignore</code> 文件来配置。</p><p>在 <code>.gitignore</code> 文件中有很多规则，在此不去讨论，在这里我们要说的是如果某些想要忽略的文件由于失误没有被写进 <code>.gitignore</code>，被推送到远端后，想忽略这个文件，并在下次推送的时候让远端不再有这个文件该怎么做。</p><figure class="highlight bash"><figcaption><span>先将要忽略的文件添加到 .gitignore，然后执行下面命令对之前添加的文件进行删除操作</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件名/文件夹</span><br></pre></td></tr></table></figure><h2 id="在开发当中处理紧急发布（CR）任务"><a href="#在开发当中处理紧急发布（CR）任务" class="headerlink" title="在开发当中处理紧急发布（CR）任务"></a>在开发当中处理紧急发布（CR）任务</h2><p>在开发时经常有这样一种场景，在上一版本代码上线以后，突然发现线上出现 <code>Bug</code> 需要修复并紧急上线，而这个时候刚好又在同一个分支上已经有了其他的新代码，此时需要将代码还原到线上版本，并保证当前开发代码不丢失，待问题修复后，将新开发的代码合并到修复后的代码上继续开发，当然根据实际情况的不同，复杂程度也会有所差别，下面是一些思路。</p><figure class="highlight bash"><figcaption><span>当前代码跟要修复代码在同一条分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复代码后合并到 dev 发布测试环境验证，通过后发布</span></span><br><span class="line"></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续开发</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>当前代码跟要修复的代码不在同一条分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 master 分支创建一条新分支</span></span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git checkout -b 修复问题分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复问题并提测</span></span><br><span class="line"></span><br><span class="line">git checkout 测试分支</span><br><span class="line">git merge 修复问题分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证通过后合并到 master 发布，继续回到开发新功能分支将修复代码集成进来并继续开发</span></span><br><span class="line"></span><br><span class="line">git checkout 开发分支</span><br><span class="line">git rebase 测试分支</span><br></pre></td></tr></table></figure><p>当然上面的思路仅供参考，因为不同的团队规则有所差异，问题的复杂度也不尽相同，在某些特殊时候可能要本地代码回退版本，需要借助 <code>git reset</code> 命令实现。</p><h2 id="non-fast-forwards-和-fast-forwards"><a href="#non-fast-forwards-和-fast-forwards" class="headerlink" title="non-fast-forwards 和 fast-forwards"></a>non-fast-forwards 和 fast-forwards</h2><p>在实际项目开发中我们将本地代码推送到远端的时候可能会遇到下面这样的报错信息。</p><figure class="highlight bash"><figcaption><span>推送代码时的错误信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to <span class="string">'git@github.yourRepository.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p><code>fast-forwards</code> 是指将本地分支推送到远端，<code>tree</code> 上两个分支拥有共同的 “祖先”，可以自动合并成一个 <code>tree</code>，而 <code>non-fast-forwards</code> 正好相反，两个分支的 <code>tree</code> 是完全独立的，没有任何联系，一般会造成这种现象的原因是推送的目标分支和我们当前分支拥有不同的代码，所以我们需要将推送的目标分支和本地分支的 <code>tree</code> 整理成 <code>fast-forwards</code> 的状态。</p><p>实现方式就是先拉取远端分支在本地进行处理（如果有冲突先处理冲突），变成 <code>fast-forwards</code> 状态后再进行推送，拉取远端分支可以使用 <code>fetch</code> 或 <code>pull</code>，区别在于 <code>fetch</code> 拉取回来的代码仍然是 <code>non-fast-forwards</code> 状态，需要手动 <code>merge</code> 进行合并或 <code>rebase</code> 操作（因为有些团队比较喜欢线性的提交记录以便追溯），而 <code>pull</code> 将 <code>fetch</code> 和 <code>merge</code> 这两个步骤合二为一。</p><blockquote class="pullquote info"><p><em><strong>注意：使用 <code>fetch</code> 拉取代码在进行 <code>merge</code> 时存在一种特殊情况，就是这个仓库的代码是第一次被拉取到本地（与本地分支没有共同的提交），且与本地代码的差异是新建仓库时添加 <code>README.md</code> 等文件造成的，则需要在 <code>merge</code> 时加上 <code>--allow-unrelated-histories</code> 参数去允许历史上完全独立的两棵树进行合并，达到 <code>fast-forwards</code> 的状态。</strong></em></p></blockquote><figure class="highlight bash"><figcaption><span>合并不相关的树</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 本地分支 --allow-unrelated-histories 远端分支</span><br></pre></td></tr></table></figure><p>执行命令后会弹出交互界面可以修改本次合并的 <code>message</code>。</p><h2 id="Git-多人单分支集成协作"><a href="#Git-多人单分支集成协作" class="headerlink" title="Git 多人单分支集成协作"></a>Git 多人单分支集成协作</h2><h3 id="多人协同开发时本地仓库与远端的同步"><a href="#多人协同开发时本地仓库与远端的同步" class="headerlink" title="多人协同开发时本地仓库与远端的同步"></a>多人协同开发时本地仓库与远端的同步</h3><p>在项目的开发迭代中，我们习惯每一个版本迭代都新建一个分支开发，并推送到远端，如果多个人同时要在这个分支开发该迭代的新功能，而以前又已经克隆过这个项目到本地，此时除了这条分支的创建者以外，其他人查看远端分支时是看不见这个新建分支的，需要执行以下命令对仓库进行同步并开发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步新分支信息</span></span><br><span class="line">git fetch 地址别名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新分支</span></span><br><span class="line">git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取新分支到本地</span></span><br><span class="line">git checkout -b 新分支名 地址别名/新分支名</span><br></pre></td></tr></table></figure><p>还有一种场景也需要通过上面的方式来同步仓库信息，就是在 <code>Github</code> 中帮助别人的项目修复 <code>Issue</code> 或贡献代码时，首先需要 <code>Fork</code> 别人的仓库，但是 <code>Fork</code> 过来的仓库代码并不会随着原作者仓库的代码更新而更新，为了在开发之前使 <code>Fork</code> 的仓库和原作者仓库代码及分支保持一致，执行上面命令，开发完毕后再通过给原作者提交 <code>push request</code> 的方式让原作者进行代码审核并合并到原始仓库。</p><h3 id="不同人修改不同文件的处理方式"><a href="#不同人修改不同文件的处理方式" class="headerlink" title="不同人修改不同文件的处理方式"></a>不同人修改不同文件的处理方式</h3><p>在实际开发中，两个人在一条分支开发，当 <code>A</code> 同学修改了 <code>a</code> 文件，<code>B</code> 同学修改了 <code>b</code> 文件时，此时 <code>B</code> 同学先进行了提交，<code>A</code> 同学并不知道的情况下，在 <code>A</code> 同学推送代码到远端时会变成 <code>non-fast-forwards</code> 状态（推送失败），并提示超前一个版本，落后一个版本，意思是本地代码有一个提交远端没有，远端代码有一个提交本地没有，一般情况下大多数的处理是选择先拉去远端代码进行合并，再推送到远端。</p><p>由于两个人修改的是不同文件，在拉取远端代码后合并会比较顺利，并不会产生冲突，但同时产生新的问题，就是多了一条关于合并的提交记录，如果想让提交的历史树更干净整洁，也有另一种做法，就是推送失败的一方主动将本地 <code>commit</code> 回退到与远端完全一致的 <code>commit</code> 版本，主动拉取代码与工作区合并，再重新提交到本地版本库并推送到远端。</p><figure class="highlight bash"><figcaption><span>撤销本地新的提交</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset 与远端相同的提交</span><br></pre></td></tr></table></figure><h3 id="不同的人修改相同文件不同区域的处理方式"><a href="#不同的人修改相同文件不同区域的处理方式" class="headerlink" title="不同的人修改相同文件不同区域的处理方式"></a>不同的人修改相同文件不同区域的处理方式</h3><p>我们将上面 <code>A</code>、<code>B</code> 两个同学的操作场景稍微做些改动，就是两个人同时操作了同一个文件的不同区域，此时如果 <code>B</code> 先提交到远端，<code>A</code> 不知情的情况下推送代码到远端，一样会变成 <code>non-fast-forwards</code>，同样可以通过上面的方式处理，<code>Git</code> 比较智能，可以将两个平行的修改过不同区域的文件进行合并，变成 <code>fast-forwards</code> 状态。</p><h3 id="不同的人修改相同文件相同区域的处理方式"><a href="#不同的人修改相同文件相同区域的处理方式" class="headerlink" title="不同的人修改相同文件相同区域的处理方式"></a>不同的人修改相同文件相同区域的处理方式</h3><p>依然沿用上面 <code>A</code>、<code>B</code> 同学的操作场景，不同的是这次两人修改了相同文件的相同区域，<code>B</code> 先提交到远端，<code>A</code> 在提交到远端时有因为状态为 <code>non-fast-forwards</code> 被拒绝，同样的方式处理时发现了新的问题，代码虽然成功拉合并，但是控制台报错了。</p><figure class="highlight bash"><figcaption><span>合并后报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Auto-merging yourfile</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> yourfile</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>由于两个人操作了同一个区域导致 <code>Git</code> 无法判断两个内容应该怎样去保留或替换，所以将合并失败的错误抛出让开发者认为的介入。</p><blockquote class="pullquote danger"><p><strong>在解决冲突时可能存在的情况：</strong></p><ul><li><em><strong>两人将都要保留的功能代码写在了相同文件的相同区域，这种情况需要都保留；</strong></em></li><li><em><strong>两个人开发功能重复了，需要进行沟通协商决定保留哪一个。</strong></em></li></ul></blockquote><p>在手动处理冲突对文件进行合并时，可以通过 <code>git status</code> 查看合并后的状态，如果这个人为的合并是需要的可以创建一个新的提交推送到远端，如果觉得没有处理好，可以执行下面命令还原到合并之前。</p><figure class="highlight bash"><figcaption><span>撤销合并</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><h3 id="不同的人同时变更文件名的处理方式"><a href="#不同的人同时变更文件名的处理方式" class="headerlink" title="不同的人同时变更文件名的处理方式"></a>不同的人同时变更文件名的处理方式</h3><p>在不同人同时修改同一个文件名时，<code>Git</code> 时无法处理的，当然会变成 <code>non-fast-forwards</code> 状态，在通过常规的处理后，本地会出现两个文件，分别为两人所更改的文件名，这时需要两个人进行协商，保留协商后的文件名，删除多余的文件并推送到远端让其他人进行同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm oldfilename</span><br><span class="line">git add newfilename</span><br><span class="line">git commit -m <span class="string">'merge message'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>在一个人修改文件名，其他人修改内容的情况下，<code>Git</code> 的文件内容都是通过 <a href="https://www.overtaking.top/2019/03/10/20190310233856/#tree%E3%80%81commit%E3%80%81blob-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank">blob</a> 对象进行存储，而非文件的形式，所以当多人协同某个人对文件名进行变更时 <code>Git</code> 可以非常智能的检测并同步。</p></blockquote><h3 id="禁止在已共享的集成分支使用强推"><a href="#禁止在已共享的集成分支使用强推" class="headerlink" title="禁止在已共享的集成分支使用强推"></a>禁止在已共享的集成分支使用强推</h3><p>“强推” 是指使用 <code>git push -f</code> 将本地分支推送到远端，之前在多人写作中远程分支拒绝推送的原因都是因为 <code>non-fast-forwards</code> 状态，我们可以理解为这是 <code>Git</code> 防止代码被推送到远端而产生冲突的一种保护机制，而 “强推” 就是忽略了 <code>non-fast-forwards</code> 状态强行将代码推送到远端。</p><blockquote class="pullquote danger"><p>在大部分团队中都是禁止在集成分支使用这条命令的，可能会在远端产生冲突只是原因之一，操作不正确也可能导致远端集成分支整个团队的提交历史丢失的严重后果，比如当前本地分支版本远远落后于远端，此时直接推送会进入 <code>non-fast-forwards</code> 状态，远端拒绝推送，而向远端 “强推”，远端在这个本地版本库 <code>HEAD</code> 指向的 <code>commit</code> 之后所有的提交历史都将丢失。</p></blockquote><h3 id="禁止在已共享的集成分支上做变基操作"><a href="#禁止在已共享的集成分支上做变基操作" class="headerlink" title="禁止在已共享的集成分支上做变基操作"></a>禁止在已共享的集成分支上做变基操作</h3><p>还记得前面 <a href="https://www.overtaking.top/2019/03/15/20190315115008/#修改本地-commit">修改本地 commit</a> 一节中强调 <code>rebase</code> 操作只适用于修改本地还未同步到远端的 <code>commit</code>，这是因为如果对已经同步到远端的进行了变基操作会导致 <code>commit</code> 的版本号发生变化，如果推送到远端，此时协同开发的人是基于远端旧的 <code>commit</code> 之上在做新的开发，会导致无法将本地代码推送到远端。</p><blockquote class="pullquote warning"><p>有些团队严令禁止对集成分支做变基操作，被称作 “<code>rebase</code> 黄金定律”，如果一定要对集成分支做变基操作的，一定要在当前远端最后的 <code>commit</code> 之后做变基操作。</p></blockquote><p>如果不幸真的有同事这样去做了，我们虽然会很恼火，但也还是有办法去解决这样的问题，可以直接执行下面命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>或者分为两步走，把远端变基后的分支 <code>fetch</code> 到本地，再再把本地的当前分支基于 <code>fetch</code> 下来的远端分支做 <code>rebase</code> 操作，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase 地址别名/分支名</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p>本文内容是自己在对 <code>Git</code> 的学习和工作中总结的笔记，另外想了解 <code>rebase</code> 和 <code>merge</code> 更详细的信息推荐阅读 <a href="https://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank">git rebase vs git merge 详解</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 命令行 </tag>
            
            <tag> 代码管理/版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 系列之 .git 内部刨析</title>
      <link href="/2019/03/10/20190310233856/"/>
      <url>/2019/03/10/20190310233856/</url>
      
        <content type="html"><![CDATA[<img src="/2019/03/10/20190310233856/git.jpg" title=".git 内部刨析"><p><br></p><h2 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h2><figure class="highlight plain"><figcaption><span>文件内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><code>ref</code> 代表引用，<code>refs/heads/master</code> 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支时，<code>HEAD</code> 文件中的 <code>ref</code> 值会随着切换的分支变化。</p></blockquote><a id="more"></a><h2 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h2><figure class="highlight bash"><figcaption><span>config 文件基本内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = <span class="literal">true</span></span><br><span class="line">bare = <span class="literal">false</span></span><br><span class="line">logallrefupdates = <span class="literal">true</span></span><br><span class="line">ignorecase = <span class="literal">true</span></span><br><span class="line">precomposeunicode = <span class="literal">true</span></span><br><span class="line">[user]</span><br><span class="line">name = yourname</span><br><span class="line">email = youremail</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><code>[core]</code> 代表当前 <code>Git</code> 管理中的主要配置，<code>[user]</code> 代表用户配置，随着 <code>Git</code> 管理的不断复杂，所有的配置项都将被存放在 <code>config</code> 文件中。</p></blockquote><h2 id="refs-文件夹"><a href="#refs-文件夹" class="headerlink" title="refs 文件夹"></a>refs 文件夹</h2><h3 id="分支-heads"><a href="#分支-heads" class="headerlink" title="分支 heads"></a>分支 heads</h3><p><code>heads</code> 文件夹存储的是本地所有分支文件，文件名与分之名一一对应，文件内容为当前分支所在的提交历史记录的 <code>commit</code> 对象。</p><figure class="highlight bash"><figcaption><span>查看 heads 文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/refs/heads</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  3 systemname  staff   96  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..</span></span><br><span class="line"><span class="comment"># -rw-r--r--  1 systemname  staff   41  2 24 17:31 master</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看分支文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/tags/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># ef5aaed0707989ebc069efcd842424f6315ab4e2</span></span><br><span class="line"></span><br><span class="line">git cat-file -t ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>其实使用 <code>git checkout</code> 命令切换分支时，就是在更改 <code>HEAD</code> 文件的引用内容，即上面提到的 <code>ref: refs/heads/branchname</code>，进而找到 <code>heads</code> 文件夹内对应的分支文件内的提交记录，将工作区代码还原到该提交记录的版本。</p></blockquote><h3 id="标签-tags"><a href="#标签-tags" class="headerlink" title="标签 tags"></a>标签 tags</h3><p>在项目开发中，经常会在某些阶段达到某一个 “里程碑”，比如版本从 <code>v0.0.1</code> 开发到 <code>v1.0.0</code>，可以专门为这个版本的 <code>commit</code> 打上一个标签，而 <code>refs/tags</code> 文件夹就是用来存放这些标签的（文件名与标签名相同），每一个标签文件内存储的是这个 “里程碑” 提交的历史记录的 <code>tag</code> 对象，<code>tag</code> 对象中存储着当前标签对应历史版本的 <code>commit</code> 对象。</p><figure class="highlight bash"><figcaption><span>查看 tags 文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/refs/tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  6 systemname  staff  192  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..</span></span><br><span class="line"><span class="comment"># -rw-r--r--  1 systemname  staff   41  2 15 18:33 1.0.0</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看标签文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/tags/1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ef5aaed0707989ebc069efcd842424f6315ab4e2</span></span><br><span class="line"></span><br><span class="line">git cat-file -p ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># object bcadbfea5e937e9b5eaed113dd8149c86124d72a</span></span><br><span class="line"><span class="comment"># type commit</span></span><br><span class="line"><span class="comment"># tag 1.0.0</span></span><br><span class="line"><span class="comment"># tagger yourusername &lt;youruseremail&gt; 1550212832 +0800</span></span><br><span class="line"></span><br><span class="line">git cat-file -t bcadbfea5e937e9b5eaed113dd8149c86124d72a</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>我们可以使用 <code>git cat-file</code> 命令查看。</p></blockquote><h2 id="objects-文件夹"><a href="#objects-文件夹" class="headerlink" title="objects 文件夹"></a>objects 文件夹</h2><h3 id="查看-objects-内部"><a href="#查看-objects-内部" class="headerlink" title="查看 objects 内部"></a>查看 objects 内部</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/objects</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  72 systemname  staff  2304  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  13 systemname  staff   416  3 14 15:43 ..</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   4 systemname  staff   128  2 24 17:29 00</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   3 systemname  staff    96  2 24 17:29 f9</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   2 systemname  staff    64  2 12 16:59 info</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   2 systemname  staff    64  2 12 16:59 pack</span></span><br></pre></td></tr></table></figure><p>在 <code>objects</code> 文件夹中，除了 <code>info</code> 和 <code>pack</code> 存储的都是十六进制命名的文件夹，在文件夹内部存储着以哈希值命名的文件，在 <code>Git</code> 中的策略是将十六进制文件名和哈希值的文件名进行组合，使用 <code>git cat-file</code> 可以查看该完整哈希值的对象类型，肯能为 <code>tree</code>、<code>blob</code>、<code>commit</code>。</p><blockquote class="pullquote default"><p><code>Git</code> 对象：</p><ul><li><code>tree</code>：树对象，存储内容为 <code>blob</code> 对象的哈希值和对应的文件名称；</li><li><code>blob</code>：存储文件内容，只要文件内容相同，则始终生成唯一一个 <code>blob</code> 对象；</li><li><code>commit</code>：存储提交的相关信息。</li></ul></blockquote><h3 id="tree、commit、blob-对象的关系"><a href="#tree、commit、blob-对象的关系" class="headerlink" title="tree、commit、blob 对象的关系"></a>tree、commit、blob 对象的关系</h3><p>在 <code>Git</code> 中最重要的就是这三个对象，以及他们之间的关系，这对于理解 <code>Git</code> 的原理非常有帮助，下面有一张关系图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/10/20190310233856/git-objects.png" alt="tree、commit、blob 关系图" title>                </div>                <div class="image-caption">tree、commit、blob 关系图</div>            </figure><p><br></p><p><code>commit</code> 对象中，<code>tree</code> 代表提交时所在的树，一个 <code>commit</code> 对象只会对应一棵树，<code>tree</code> 对象存储的只是当前 <code>commit</code> 时，所有文件目录的一个 “快照”，<code>tree</code> 对象中的 <code>tree</code> 对象代表该文件夹中还有文件夹，<code>tree</code> 中的 <code>blob</code> 对象代表文件，<code>blob</code> 对象中存储的是文件内容，<code>Git</code> 在这里存储时忽略文件名，只要文件内容一样就只会存储一份，大大的节约了存储空间。</p><blockquote class="pullquote info"><p><code>blob</code> 对象是在将文件增加到暂存区后创建的，<code>commit</code> 和 <code>tree</code> 对象在进行提交操作后创建。</p></blockquote><h2 id="hooks-文件夹"><a href="#hooks-文件夹" class="headerlink" title="hooks 文件夹"></a>hooks 文件夹</h2><p><code>hooks</code> 文件夹，默认存储了一系列的 <code>hook</code> 文件，用于在执行某些特定的 <code>Git</code> 命令时，在某个声明周期执行，内部可以编写 <code>shell</code> 脚本，也可以通过 <code>hasky</code> 等 <code>npm</code> 包来介入。</p><figure class="highlight bash"><figcaption><span>例如下面文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">pre-commit.sample <span class="comment"># 提交前执行</span></span><br><span class="line">pre-push.sample <span class="comment"># 推送前执行</span></span><br><span class="line">pre-rebase.sample <span class="comment"># 变基前执行</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>上面的文件默认扩展名为 <code>sample</code>，即默认不生效，要想在某个 <code>Git</code> 操作时可以执行对应的 <code>hook</code> 文件，只需要去掉对应 <code>hook</code> 文件的扩展名即可。</strong></em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 命令行 </tag>
            
            <tag> 代码管理/版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack4 —— 基础篇</title>
      <link href="/2018/10/02/20181002041434/"/>
      <url>/2018/10/02/20181002041434/</url>
      
        <content type="html"><![CDATA[<p>为什么需要构建工具？</p><ul><li>转换 ES6+ 语法</li><li>转换 JSX/ Vue 指令</li><li>CSS 前缀补全/预处理器（less，sass）</li><li>压缩混淆/图片压缩</li></ul><p>为什么选择 Webpack？</p><ul><li>社区生态丰富</li><li>配置灵活和插件化扩展</li><li>官方更新迭代速度快</li></ul><p>entry</p><p>两种场景：SPA，多页应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/pages/app.js'</span>,</span><br><span class="line">    adminApp: <span class="string">'./src/pages/adminApp.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 JS 表现 —— 代理模式</title>
      <link href="/2018/09/29/20180929025641/"/>
      <url>/2018/09/29/20180929025641/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/29/20180929025641/proxy.jpg" title="代理模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li></ul><h2 id="代理模式概念"><a href="#代理模式概念" class="headerlink" title="代理模式概念"></a>代理模式概念</h2><p>由于某些情况下一个对象不能直接引用另一个对象，所以需要代理对象在这两个对象之间起到中介作用或者实现控制，这样的模式叫 “代理模式”。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/29/20180929025641/proxy-uml.jpg" alt="代理模式 UML 图" title>                </div>                <div class="image-caption">代理模式 UML 图</div>            </figure><p><br></p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设无法客户端无法直接使用这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Google</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span>(url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span> is google`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能通过代理操作 Google 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.google = <span class="keyword">new</span> Google();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.google.get(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>();</span><br><span class="line"><span class="keyword">let</span> result = proxy.get(<span class="string">'http://www.google.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// http://www.google.com is google</span></span><br></pre></td></tr></table></figure><p>假设 <code>Google</code> 类我们无法直接使用，只有 <code>Proxy</code> 可以使用 <code>Google</code>，我们可以通过 <code>Proxy</code> 类去操作使用 <code>Google</code> 类，此时 <code>Proxy</code> 类就是一个代理。</p><h2 id="ES6-的-Proxy"><a href="#ES6-的-Proxy" class="headerlink" title="ES6 的 Proxy"></a>ES6 的 Proxy</h2><p>在 <code>ES6</code> 标准以后，<code>JavaScript</code> 提供了原生的代理模式 <code>Proxy</code> 类，可以代理其他对象，并在对象属性的获取和赋值时增加拦截。</p><figure class="highlight js"><figcaption><span>ES6 Proxy 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lucy = &#123;</span><br><span class="line">  name: <span class="string">'lucy'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  height: <span class="number">165</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lucyMother = <span class="keyword">new</span> <span class="built_in">Proxy</span>(lucy, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.age - <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'height'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.height + <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'boyfriend'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val.age &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'太老了'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val.salary &lt; <span class="number">20000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'太穷了'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.name); <span class="comment">// lucy</span></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.height); <span class="comment">// 170</span></span><br><span class="line"></span><br><span class="line">lucyMother.boyfriend = &#123;</span><br><span class="line">  age: <span class="number">42</span>,</span><br><span class="line">  salary: <span class="number">25000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 太老了</span></span><br><span class="line"></span><br><span class="line">lucyMother.boyfriend = &#123;</span><br><span class="line">  age: <span class="number">36</span>,</span><br><span class="line">  salary: <span class="number">18000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 太穷了</span></span><br></pre></td></tr></table></figure><p>上面是一个接地气的案例，创建一个对象存储 <code>lucy</code> 的基本信息，使用代理创建 <code>lucyMother</code> 为 <code>lucy</code> 找男朋友，通过代理对象获取 <code>lucy</code> 的基本信息时会虚报年龄和身高，而在设置男朋友对象时会检查是否符合要求。</p><h2 id="代理模式、适配器模式和装饰器模式"><a href="#代理模式、适配器模式和装饰器模式" class="headerlink" title="代理模式、适配器模式和装饰器模式"></a>代理模式、适配器模式和装饰器模式</h2><p>从代码实现来看，代理模式、适配器模式、装饰器模式非常的相似，非常容易混淆，但其实是有本质区别的。</p><blockquote class="pullquote info"><ul><li><strong>代理模式和适配器模式：代理模式不会改变原有的接口，代理类和被代理的类属性方法使用方式完全一致，而适配器模式是因为旧的接口无法使用，通过适配器创建新的接口去兼容旧的接口；</strong></li><li><strong>代理模式和装饰器模式：装饰器功能会保证被装饰类功能正常使用的情况下新增功能，而代理模式保证原有接口，但会改变原来的接口的功能；</strong></li><li><strong>适配器模式和装饰器模式：装饰器是对一个类的包装，而适配器更多是去建立提供接口的类与无法适配的类之间的联系。</strong></li></ul></blockquote><h2 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是浏览器事件注册的一种优化手段，如果同类型的元素非常多，且都有相同的事件，如列表，则不必给每一个元素注册这个事件，而是将事件注册给父元素，即将事件委托给父元素，避免了相同事件的重复注册，这种优化利用了 “代理模式”，又称事件代理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件委托<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ulList = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    ulList.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event.target.innerHTML);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中，委托给父元素的事件触发后，可以通过事件对象的属性 <code>target</code> 获取到具体触发事件的子元素。</p><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>图片懒加载是一个提高用户体验的功能，也是非常常见的，原因是浏览器向服务器请求资源图片是需要等待的，由于网络等因素的影响会导致等待的时间更长，此时我们需要一个 <code>loading</code> 图片来过渡，这就是图片懒加载的基本需求。</p><figure class="highlight js"><figcaption><span>node 服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/loading.gif'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendFile(path.resolve(<span class="string">'img'</span>, <span class="string">'loading.gif'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/img/:name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    res.sendFile(path.join(__dirname, req.path));</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面服务器模拟了懒加载图片响应慢的场景，<code>loading</code> 图片立即响应，其他图片则延迟 <code>3s</code> 响应。</p><figure class="highlight html"><figcaption><span>Dom 结构</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-src</span>=<span class="string">"/img/bg1.jpg"</span>&gt;</span>图片1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-src</span>=<span class="string">"/img/bg2.jpg"</span>&gt;</span>图片2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bgimg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>没有实现懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'menu'</span>);</span><br><span class="line"><span class="keyword">let</span> bgimg = <span class="built_in">document</span>.getElementById(<span class="string">'bgimg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> background = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  bgimg.appendChild(img)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">menu.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> src = event.target.dataset.src;</span><br><span class="line">  background.setSrc(src);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码是没有实现懒加载的，当点击按钮向服务器请求图片时，并没有加入 <code>loading</code> 图片过渡，之所以说图片懒加载应用了 “代理模式” 并不是指懒加载功能本身，而是我们的实现方式，编写的代码质量要高至少要遵循单一职责原则和开放封闭原则，就是说最好不要直接在上面伙计的函数中增加 <code>loading</code> 过渡的逻辑，而是把这个过渡功能交给代理对象去处理。</p><figure class="highlight js"><figcaption><span>使用代理对象实现 loading 过渡</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'menu'</span>);</span><br><span class="line"><span class="keyword">let</span> bgimg = <span class="built_in">document</span>.getElementById(<span class="string">'bgimg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求图片的对象</span></span><br><span class="line"><span class="keyword">let</span> background = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  bgimg.appendChild(img)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 loading 过度的代理对象</span></span><br><span class="line"><span class="keyword">let</span> proxyBackground = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    background.setSrc(<span class="keyword">this</span>.src);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      background.setSrc(<span class="string">'./img/loading.gif'</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听获取图片的事件中使用的是代理对象 proxyBackground</span></span><br><span class="line">menu.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> src = event.target.dataset.src;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止缓存</span></span><br><span class="line">  proxyBackground.setSrc(<span class="string">`<span class="subst">$&#123;src&#125;</span>?time=<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的实现方式就符合 “代理模式”，<code>background</code> 对象是提供基本功能，而<code>proxyBackground</code>（代理对象）增强了基本功能，却并没有改变接口的使用方式，依然通过 <code>setSrc</code> 方法去请求图片。</p><h3 id="防抖代理"><a href="#防抖代理" class="headerlink" title="防抖代理"></a>防抖代理</h3><p>防抖的作用是在做一个操作时不需要很频繁，如搜索查询，在连续输入时如果每次触发输入事件都向后端发送请求，性能是极差的，我们希望的是连续输入只在最后一次统一发送请求，这种处理叫做防抖处理，是前端优化的手段。</p><figure class="highlight html"><figcaption><span>未使用防抖代理处理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"ipt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">'ipt'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'发送请求了'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    ipt.addEventListener(<span class="string">'input'</span>, post);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码未使用防抖代理，每次输入都会打印 “发送请求了”。</p><figure class="highlight html"><figcaption><span>使用防抖代理优化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"ipt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">'ipt'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'发送请求了'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 代理函数去执行 post</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> debouncePost = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      clearInterval(timer);</span></span><br><span class="line"><span class="javascript">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        post();</span></span><br><span class="line"><span class="undefined">      &#125;, 500);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;)();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  ipt.addEventListener(<span class="string">'input'</span>, debouncePost);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用防抖代理函数优化后，保留了原有功能的基础上进行了增强，实现了连续输入停止 <code>500ms</code> 后统一发送一次请求，防抖的实现方式有很多种，包括并不限于函数式编程等，而上面代码使用了 “代理模式” 实现 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>使用 “代理模式” 的场景在后端会更多，比如代理跨域，<code>Nginx</code> 代理等等，还有一点需要注意的是，“代理模式” 并非单一的，对于同一个对象，可以有多个代理对象去增强不同的功能，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/6.proxy" target="_blank">案例地址</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 JS 表现 —— 装饰器模式</title>
      <link href="/2018/09/28/20180928030105/"/>
      <url>/2018/09/28/20180928030105/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/28/20180928030105/decorator.jpg" title="装饰器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li></ul><h2 id="装饰器模式概念"><a href="#装饰器模式概念" class="headerlink" title="装饰器模式概念"></a>装饰器模式概念</h2><p>“装饰器模式” 是结构型模式之一，在不改变原有对象结构的前提下，给对象添加新功能，也可以理解 “装饰器模式” 是将一个对象嵌入另一个对象之中，相当于一个对象被另一个对象包装，包装其他对象的对象被称为 “装饰器”。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/28/20180928030105/decorator-uml.jpg" alt="装饰器模式 UML 图" title>                </div>                <div class="image-caption">装饰器模式 UML 图</div>            </figure><p><br></p><h2 id="装饰器模式和适配器模式"><a href="#装饰器模式和适配器模式" class="headerlink" title="装饰器模式和适配器模式"></a>装饰器模式和适配器模式</h2><figure class="highlight js"><figcaption><span>装饰器模式案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Duck</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat(food) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>吃<span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器类 TangDuck，装饰 Duck 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TangDuck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duck = <span class="keyword">new</span> Duck(name);</span><br><span class="line">  &#125;</span><br><span class="line">  eat(food) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duck.eat(food);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'说谢谢'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tangDuck = <span class="keyword">new</span> TangDuck(<span class="string">'唐老鸭'</span>);</span><br><span class="line">tangDuck.eat(<span class="string">'苹果'</span>);</span><br><span class="line"><span class="comment">// 唐老鸭吃苹果</span></span><br><span class="line"><span class="comment">// 说谢谢</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>适配器模式案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Power</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line">  charge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'220V'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.power = <span class="keyword">new</span> Power();</span><br><span class="line">  &#125;</span><br><span class="line">  chargeTransform() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">this</span>.power.charge();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;v&#125;</span> =&gt; 12V`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 Power 的使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.adaptor = <span class="keyword">new</span> Adaptor(Power);</span><br><span class="line">  &#125;</span><br><span class="line">  use() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.adaptor.chargeTransform());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面分别是 “装饰器模式” 和 “适配器模式” 的案例，但直接看代码可能会将两者混淆，原因是 “适配器” 和 “装饰器” 的类都存在了一个被装饰或者适配转换的类的引用，不同的是，“装饰器” 仅仅是对某一个类进行包装，并不会改变原来类的结构，而 “适配器” 的作用更多是去建立一个类和另一个类之间的关系和转换。</p><h2 id="装饰器模式和继承"><a href="#装饰器模式和继承" class="headerlink" title="装饰器模式和继承"></a>装饰器模式和继承</h2><p>通过上一节，我们已经知道了什么是 “装饰器模式”，下面有一个更直观的例子，我们有一个基础类 <code>Coffee</code>，组成是咖啡加水，这个基础上可以加奶、糖、冰，希求是可以组合加入上面的其他原料，并计算出对应的价格，大家可能第一时间想到的是继承的方式实现。</p><figure class="highlight js"><figcaption><span>继承的实现方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;water&#125;</span> + 咖啡`</span></span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加奶咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加糖咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加糖加奶咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarMilkCoffee</span> <span class="keyword">extends</span> <span class="title">SugarCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加奶加糖咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkSugarCoffee</span> <span class="keyword">extends</span> <span class="title">MilkCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从继承的代码看，虽然可以实现给咖啡任意加入其他原料，但是每一种不同的排列组合都需要单独创建类，当原料种类众多时，则难以管理代码，下面是 “装饰器模式” 的实现。</p><figure class="highlight js"><figcaption><span>装饰器模式的实现方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;water&#125;</span> + 咖啡`</span></span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 冰`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line"><span class="keyword">let</span> milkCoffee = <span class="keyword">new</span> MilkCoffee(coffee);</span><br><span class="line"><span class="keyword">let</span> sugarCoffee = <span class="keyword">new</span> SugarCoffee(milkCoffee);</span><br><span class="line"><span class="keyword">let</span> iceCoffee = <span class="keyword">new</span> IceCoffee(sugarCoffee);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(milkCoffee.make(<span class="string">'水'</span>), milkCoffee.cost());</span><br><span class="line"><span class="built_in">console</span>.log(sugarCoffee.make(<span class="string">'水'</span>), sugarCoffee.cost());</span><br><span class="line"><span class="built_in">console</span>.log(iceCoffee.make(<span class="string">'水'</span>), iceCoffee.cost());</span><br></pre></td></tr></table></figure><p>从 “装饰器模式” 的实现代码来看，我们只需要创建和原料相同多的类就可以了，其他的方式加料只需要对上一个类进行包装即可，部分加料的顺序，当类的种类越多时，“装饰器” 的意义则体现的越明显。</p><blockquote class="pullquote info"><p><strong>装饰器模式有时候会优于继承，尤其是很多的类通过继承存在排列组合的关系时，则使用 “装饰器模式” 可以更好更高效的解决问题。</strong></p></blockquote><h2 id="装饰器模式和-AOP-编程"><a href="#装饰器模式和-AOP-编程" class="headerlink" title="装饰器模式和 AOP 编程"></a>装饰器模式和 AOP 编程</h2><p>在软件业，<code>AOP</code> 为 <code>Aspect Oriented Programming</code> 的缩写，意为面向切面编程，通过预编译方式和运行其动态代理实现程序功能统一维护的一种技术。</p><p>在 <code>JavaScript</code> 中的 <code>AOP</code> 就是在函数之前或之后添加一些额外的逻辑，而不需要修改函数本身逻辑。</p><figure class="highlight js"><figcaption><span>AOP 编程的案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给函数扩展 before 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给函数扩展 after 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params">money, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`花 <span class="subst">$&#123;money&#125;</span> 元钱买 <span class="subst">$&#123;goods&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 before 方法给函数增加前切面</span></span><br><span class="line">buy = buy.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'向媳妇要 1 元钱'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 before 方法给函数增加后切面</span></span><br><span class="line">buy = buy.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'还给媳妇 0.2 元钱'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0.8</span>, <span class="string">'盐'</span>);</span><br><span class="line"><span class="comment">// 向媳妇要 1 元钱</span></span><br><span class="line"><span class="comment">// 花 0.8 元钱买 盐</span></span><br><span class="line"><span class="comment">// 还给媳妇 0.2 元钱</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong><code>AOP</code> 编程是由 “装饰器模式” 进化而来，或者说 “装饰器模式” 属于 <code>AOP</code> 编程的一种。</strong></p></blockquote><h2 id="装饰器模式的应用"><a href="#装饰器模式的应用" class="headerlink" title="装饰器模式的应用"></a>装饰器模式的应用</h2><h3 id="监控埋点"><a href="#监控埋点" class="headerlink" title="监控埋点"></a>监控埋点</h3><p>埋点分析，是网站分析的一种常用的数据采集方法，埋点主要分为服务器层面的埋点和客户端层面的埋点，服务器层面的埋点主要是通过客户端的请求进行分析，客户端层面的埋点分为代码埋点、自动化埋点，第三方埋点（百度、友盟等）。</p><figure class="highlight html"><figcaption><span>一个埋点的简单案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>埋点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-name</span>=<span class="string">"wetermelon"</span> <span class="attr">id</span>=<span class="string">"wetermelon"</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-name</span>=<span class="string">"apple"</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> wetermelon = <span class="built_in">document</span>.getElementById(<span class="string">'wetermelon'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> apple = <span class="built_in">document</span>.getElementById(<span class="string">'apple'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加切面</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">        afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 事件处理函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">`你点击了<span class="subst">$&#123;<span class="keyword">this</span>.dataset.name&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    click = click.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 向服务器发送统计数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="javascript">      img.src = <span class="string">`http://localhost:3000/report?name=<span class="subst">$&#123;<span class="keyword">this</span>.dataset.name&#125;</span>`</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 给所有的</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'button'</span>)).forEach(<span class="function"><span class="params">button</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      button.addEventListener(<span class="string">'click'</span>, click);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>负责统计点击次数的服务</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储按钮的点击次数</span></span><br><span class="line"><span class="keyword">const</span> goods = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/report'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = req.query.name;</span><br><span class="line">  <span class="keyword">if</span> (goods[name]) &#123;</span><br><span class="line">    goods[name]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    goods[name] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.json(goods);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的埋点就是通过 <code>AOP</code> 的方式在点击事件后添加了切面，用来向服务器发送请求，符合 “单一职责原则”，可以使点击事件和埋点逻辑进行 “解耦”，服务器在接收到请求之后立即对点击次数进行统计并储存，也可以通过调用 <code>report</code> 接口来获取当前各个按钮的点击次数。</p><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>“装饰器模式” 的思想同样可以用在表单校验，通常表单校验逻辑是在 <code>submit</code> 事件触发时提交之前发生的，我们经常会将校验逻辑和提交逻辑写在一起，形成 “强耦合”，下面我们使用 <code>AOP</code> 的方式来实现表单校验，对校验逻辑和提交逻辑进行 “解耦”。</p><figure class="highlight html"><figcaption><span>应用于表单校验</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单校验<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">  密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit-btn"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submit-btn'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加切面函数</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> result = beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">        result &amp;&amp; _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 表单提交事件</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'提交表单'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 验证用户名</span></span></span><br><span class="line"><span class="javascript">    submit = submit.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>).value;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!username) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> alert(<span class="string">'请输入用户名'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 验证</span></span></span><br><span class="line"><span class="javascript">    submit = submit.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>).value;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!password) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> alert(<span class="string">'请输入密码'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    submitBtn.addEventListener(<span class="string">'click'</span>, submit);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 <code>JavaScript</code> 中 “装饰器模式” 和 <code>AOP</code> 编程非常相似，应用也非常多，如 <code>axios</code> 中对请求、响应的拦截方法，<code>Koa</code> 中间件，都包含这样的编程思想，而在 <code>ES6</code> 之后 <code>JavaScript</code> 已经支持了原生的 “装饰器” 语法，使用起来更方便，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/5.decorator" target="_blank">案例地址</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 JS 表现 —— 适配器模式</title>
      <link href="/2018/09/27/20180927230432/"/>
      <url>/2018/09/27/20180927230432/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/27/20180927230432/adapter.jpg" title="适配器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li></ul><h2 id="适配器模式的概念"><a href="#适配器模式的概念" class="headerlink" title="适配器模式的概念"></a>适配器模式的概念</h2><p>“适配器模式” 是指类的使用者和类的接口定义格式不符合时，通过一个中间类进行转换。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/27/20180927230432/adapter-uml.jpg" alt="适配器模式 UML 图" title>                </div>                <div class="image-caption">适配器模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Power</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line">  charge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'220V'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.power = <span class="keyword">new</span> Power();</span><br><span class="line">  &#125;</span><br><span class="line">  chargeTransform() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">this</span>.power.charge();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;v&#125;</span> =&gt; 12V`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 Power 的使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.adaptor = <span class="keyword">new</span> Adaptor(Power);</span><br><span class="line">  &#125;</span><br><span class="line">  use() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.adaptor.chargeTransform());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> notepad = <span class="keyword">new</span> Notepad(Power);</span><br><span class="line">notepad.use(); <span class="comment">// 220V =&gt; 12V</span></span><br></pre></td></tr></table></figure><p>上面代码中有三个类，<code>Power</code> 类为电源，提供 <code>220V</code> 电压，<code>Notepad</code> 为我们的电子设备，使用电压 <code>22V</code>，明显两个类是不匹配的，此时的 <code>Adaptor</code> 就是一个适配器，作用是连接 <code>Power</code> 与 <code>Notepad</code>，将 <code>220V</code> 转换为 <code>22V</code>。</p><blockquote class="pullquote warning"><p><strong>适配器模式中，通常作为适配器的类内部会存储被转换类实例的引用。</strong></p></blockquote><h2 id="适配器模式的应用"><a href="#适配器模式的应用" class="headerlink" title="适配器模式的应用"></a>适配器模式的应用</h2><h3 id="适配参数和返回数据"><a href="#适配参数和返回数据" class="headerlink" title="适配参数和返回数据"></a>适配参数和返回数据</h3><p>在浏览器通过 <code>Ajax</code> 与服务端交互时，封装的请求方法会有默认参数，如果传入了参数则使用传入的参数，如果没有传入，则使用默认的参数，这是参数的适配。</p><p>在请求响应后，后端会返回给我们 <code>JSON</code> 格式的数据，我们在使用时希望转换成对象使用，这个转换的适配是数据接口的适配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    dataType: <span class="string">'JSON'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  initParams(options, defaultOptions); <span class="comment">// 适配参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数适配器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initParams</span>(<span class="params">options, defaultOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> options) &#123;</span><br><span class="line">    defaultOptions[attr] = options[attr] || defaultOptions[attr];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> defaultOptions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据适配器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tranformData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器</span></span><br><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">'www.pandashen.com'</span>,</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  success(json) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = tranformData(json); <span class="comment">// 适配返回数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="适配转换-Promise"><a href="#适配转换-Promise" class="headerlink" title="适配转换 Promise"></a>适配转换 Promise</h3><p>在 <code>NodeJS</code> 的 <code>fs</code> 模块中有很多异步的方法，比如 <code>readFile</code>，读取文件获取结果后想要继续读取下一个文件，以此类推就产生了 “回调地狱”，代码的可读性和维护性会变差，我们可以通过 “适配器模式” 将这些方法转化为 <code>Promise</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配成 Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="literal">null</span>, ...args, (err, data) =&gt; &#123;</span><br><span class="line">        err ? reject(err) : resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配后的方法</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line">readFile(<span class="string">'index.txt'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="适配技术栈变更后的旧代码"><a href="#适配技术栈变更后的旧代码" class="headerlink" title="适配技术栈变更后的旧代码"></a>适配技术栈变更后的旧代码</h3><p>在一些老项目是 <code>jQuery</code> 的技术栈，请求也使用的是自带的 <code>$.ajax</code>，如果一天项目中决定移除 <code>jQuery</code>，请求方法 <code>$.ajax</code> 自然也跟着移除了，假设我们想使用 <code>fetch</code> 来代替 <code>$.ajax</code>，则要修改大量的代码，这时 “适配器模式” 可以对 <code>fetch</code> 进行适配，让我们继续沿用 <code>$.ajax</code> 的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="built_in">window</span>.$ = &#123;</span><br><span class="line">  ajax(options) &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(options.url, &#123;</span><br><span class="line">      method: options.type || <span class="string">'GET'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringifily(options.data || &#123;&#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $.ajax 的旧代码</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'pandashen.com/info'</span>,</span><br><span class="line">  type: <span class="string">'POST'</span>,</span><br><span class="line">  dataType: <span class="string">'json'</span>,</span><br><span class="line">  data: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“适配器模式” 是很常用的设计模式之一，<code>Vue</code> 的 <code>computed</code> 计算属性和 <code>Koa</code> 兼容 <code>1.x</code> 版本和 <code>2.x</code> 版本中间件插件 <code>koa-convert</code> 都应用了 “适配器模式”，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/4.adapter" target="_blank">案例地址</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 JS 表现 —— 单例模式</title>
      <link href="/2018/09/26/20180926201447/"/>
      <url>/2018/09/26/20180926201447/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/26/20180926201447/single.jpg" title="单例模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li></ul><h2 id="普通单例模式"><a href="#普通单例模式" class="headerlink" title="普通单例模式"></a>普通单例模式</h2><p>“单例模式” 就是通过类创建实例后，每次创建和获取都返回同一个实例，下面是 “单例模式” 最基本的实现。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/26/20180926201447/singleton-uml.jpg" alt="单例模式 UML 图" title>                </div>                <div class="image-caption">单例模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>ES6 写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getInstance(name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>.instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = Person.getInstance(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = Person.getInstance(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>ES5 写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = Person.getInstance(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = Person.getInstance(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面分别用 <code>ES6</code> 和 <code>ES5</code> 的方式实现了一个基本的单例模式，创建 <code>Person</code> 的实例时需要通过 <code>getInstance</code> 静态方法，这样第一次会创建一个实例，再次调用时会将之前创建的实例返回，达到单例的目的。</p><blockquote class="pullquote danger"><p><strong>上面单例模式的缺点：</strong></p><p><strong>1、类的使用者必须要知道这是一个单例的类，创建和获取实例必须通过调用 <code>getInstance</code> 方法实现；</strong><br><strong>2、并不能真正阻止类的使用者通过 <code>new</code> 关键字创建出新的实例。</strong></p></blockquote><h2 id="透明单例模式"><a href="#透明单例模式" class="headerlink" title="透明单例模式"></a>透明单例模式</h2><p>“透明单例模式” 可以解决上面普通 “单例模式” 的不足，希望可以直接使用 <code>new</code> 关键字来创建类的实例，如果已经创建，再次通过 <code>new</code> 创建，则会返回之前创建的实例。</p><figure class="highlight js"><figcaption><span>透明单例模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> Person(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> Person(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>“透明单例模式” 的原理是创建一个自执行函数，内部创建一个私有变量 <code>instance</code> 用来存储创建的实例，并通过闭包返回一个构造函数，用变量 <code>Person</code> 接收，当使用 <code>new</code> 创建实例时，先检测私有变量 <code>instance</code> 是否有值，如果没值则创建实例，如果有值则直接返回 <code>instance</code>（利用 <code>new</code> 关键字和构造创建实例的原理实现）。</p><blockquote class="pullquote info"><p><strong>缺点：违反了单一职责原则（一个函数只做一件事），自执行函数返回的构造函数已经不止单纯用作构建实例，同时处理了单例的判断逻辑。</strong></p></blockquote><h2 id="单例与构建分离"><a href="#单例与构建分离" class="headerlink" title="单例与构建分离"></a>单例与构建分离</h2><p>针对上面 “透明单例模式” 的缺点，下面将构造函数单例处理与构建逻辑进行分离。</p><figure class="highlight js"><figcaption><span>单例逻辑与构建逻辑分离</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的构造函数</span></span><br><span class="line"><span class="keyword">const</span> CreatePerson = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> CreatePerson(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> CreatePerson(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码将单例的逻辑与构造函数的逻辑进行了分离，真正用于构造实例的类是 <code>Person</code>，用于处理单例逻辑的是自执行函数返回的函数，使用 <code>CreatePerson</code> 变量接收，这个函数也同时约定好被当做构造函数使用（通过 <code>new</code> 关键字调用和直接执行效果相同）。</p><blockquote class="pullquote primary"><p><strong>缺点：生成的新构造函数名字（<code>CreatePerson</code>）是固定的，用来创建实例的这个类（<code>Person</code>）也是固定的，不够灵活。</strong></p></blockquote><h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>下面支持不同的构造函数创建实例，并且可以使用原本构造函数的对应方法，就是把上面案例不灵活的地方变得灵活。</p><figure class="highlight js"><figcaption><span>封装变化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CreateSingle = <span class="function"><span class="keyword">function</span> (<span class="params">Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> SingleConstructor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      Constructor.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现原型继承</span></span><br><span class="line">  SingleConstructor.prototype = <span class="built_in">Object</span>.create(Constructor.prototype);</span><br><span class="line">  <span class="keyword">return</span> SingleConstructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dailog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dailog.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的构造函数并生成实例</span></span><br><span class="line"><span class="keyword">const</span> CreatePerson = CreateSingle(Person);</span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> CreatePerson(<span class="string">'hello'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> CreatePerson(<span class="string">'world'</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CreateDailog = CreateSingle(Dailog);</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> CreateDailog(<span class="string">'model'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> CreateDailog(<span class="string">'view'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面我们把创建单例的逻辑进行了封装变成了一个通用的逻辑，对于不同构造函数所创建实例，只需要传入这个构造函数并生成新的构造函数，需要注意的是，新的构造函数无法继承原构造函数的原型方法，所以通过继承实现的。</p><h2 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在编写代码时，我们有时候需要人为的创建命名空间，以防止变量的相互污染，这是可以使用 “单例模式” 来实现。</p><figure class="highlight js"><figcaption><span>创建命名空间的方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储工具方法</span></span><br><span class="line"><span class="keyword">const</span> utils = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间</span></span><br><span class="line">utils.define = <span class="function"><span class="keyword">function</span> (<span class="params">namespace, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取命名空间的数组</span></span><br><span class="line">  <span class="keyword">const</span> namespaces = namespace.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后一项为设定方法的属性名</span></span><br><span class="line">  <span class="keyword">const</span> methodName = namespaces.pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量存储当前命名空间的引用，默认为 utils（根命名空间）</span></span><br><span class="line">  <span class="keyword">let</span> current = utils;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; namespaces.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentNamespace = namespaces[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当某一个命名空间没有时，则创建这个命名空间（单例模式）</span></span><br><span class="line">    <span class="keyword">if</span> (!current[currentNamespace]) &#123;</span><br><span class="line">      current[currentNamespace] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则让当前命名空间指向已有的命名空间</span></span><br><span class="line">    current = current[currentNamespace];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将传入的函数设定给最后一级命名空间的属性上</span></span><br><span class="line">  current[methodName] = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>命名空间的创建和使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过命名空间定义方法</span></span><br><span class="line">utils.define(<span class="string">'dom.class.addClass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dom.class.addClass'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.define(<span class="string">'string.trim'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'string.trim'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.define(<span class="string">'event.prevent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'event.prevent'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">utils.dom.class.addClass(<span class="string">'title'</span>); <span class="comment">// dom.class.addClass</span></span><br><span class="line">utils.string.trim(<span class="string">' hello '</span>); <span class="comment">// string.trim</span></span><br><span class="line">utils.event.prevent(); <span class="comment">// event.prevent</span></span><br></pre></td></tr></table></figure><p>上面代码的设计希望通过 <code>utils</code> 对象的 <code>define</code> 方法按照传入的表示命名空间的字符串去创建方法，基本实现思路和逻辑是，当一个属性是第一次出现时，创建一个对象作为该命名空间，当再次出现时则不会重复创建命名空间（因为会出现覆盖的问题），而是沿用之前创建的命名空间。</p><h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p><code>LRU</code> 全称为 <code>Least Recently Used</code>，为最近使用的意思，缓存的方式为访问一个元素时，则将其标记为活跃，当存储时，如果超出容量则删除最不常用的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(capacity) &#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="keyword">this</span>.members = [];</span><br><span class="line">  &#125;</span><br><span class="line">  put(key, val) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldestIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> oldestAge = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.members.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> member = <span class="keyword">this</span>.members[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.age &gt; oldestAge) &#123;</span><br><span class="line">        oldestAge = member.age;</span><br><span class="line">        oldestIndex = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.key === key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.members[i] = &#123; key, val, <span class="attr">age</span>: <span class="number">0</span> &#125;;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        member.age++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.members.length &gt;= <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.members.splice(oldestIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.members.push(&#123; key, val, <span class="attr">age</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(key) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.members.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> member = <span class="keyword">this</span>.members[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.key === key) &#123;</span><br><span class="line">        member.age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> member.val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个创建 <code>LRU</code> 缓存的类，用数组管理成员，<code>put</code> 方法用于新增成员，<code>get</code> 方法用于访问成员，当访问成员时，成员的 <code>age</code> 清零，代表最近活跃，当新增元素时，如果该元素已存在，则做覆盖操作，如果不存在，则推入数组中，<code>age</code> 设置为零，其他成员 <code>age</code> 自增，若数组超出容量时，先找到 <code>age</code> 最大的元素删除，再讲新的元素推入数组，上面是一个直观但性能较差的实现，如果有兴趣可以使用链表进行优化。</p><figure class="highlight js"><figcaption><span>使用 LRU 缓存</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'1'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '1', val: 1, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'2'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '1', val: 1, age: 1 &#125;, &#123; key: '2', val: 2, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'3'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '2', val: 2, age: 1 &#125;, &#123; key: '3', val: 3, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'2'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '2', val: 'hello', age: 0 &#125;, &#123; key: '3', val: 3, age: 1 &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“单例模式” 是设计模式中非常好理解的一个，使用还是非常广泛的，在 <code>Redux</code> 等众多的第三方库中也有所体现，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/3.single" target="_blank">案例地址</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 JS 表现 —— 工厂模式</title>
      <link href="/2018/09/25/20180925190503/"/>
      <url>/2018/09/25/20180925190503/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/25/20180925190503/factory.jpg" title="工厂模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li></ul><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>“简单工厂模式” 是由一个工厂对象决定创建出哪一种产品类的实例。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/simple-factory-uml.jpg" alt="简单工厂模式 UML 图" title>                </div>                <div class="image-caption">简单工厂模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>直接创建子类实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  grow() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am growing!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建子类的实例</span></span><br><span class="line"><span class="keyword">let</span> apple = <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line"><span class="keyword">let</span> orange = <span class="keyword">new</span> Orange(<span class="string">'橘子'</span>, <span class="string">'酸'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>上面创建子类实例的方式是直接使用 <code>new</code> 关键字直接创建，这种创建方式使产生的实例和具体的类紧紧的耦合在一起，并依赖于类的具体实现，如果在子类可能随时发生变化的代码中，将对维护造成麻烦，使用 “简单工厂模式” 可以对产生的实例和具体的类进行解耦，且不必关心子类的具体实现和在未来是否发生变化。</p><figure class="highlight js"><figcaption><span>使用简单工厂模式创建子类的实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  grow() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am growing!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create(type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'apple'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'orange'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'no constructor!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简单工厂创建子类实例</span></span><br><span class="line"><span class="keyword">let</span> apple = Factory.create(<span class="string">'apple'</span>);</span><br><span class="line"><span class="keyword">let</span> orange = Factory.create(<span class="string">'orange'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>从上面代码看，我们只需要通过类型就可以得到某一个子类的实例，不需要知道子类是谁，以及具体实现，并在工厂 <code>Factory</code> 中做了错误处理，可以不必担心未来某一个子类发生变化或者被删除的问题。</p><figure class="highlight js"><figcaption><span>简单工厂经典案例 —— jQuery</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery 的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JQuery</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (selector) &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    <span class="keyword">let</span> elements = <span class="built_in">document</span>.querySelectorAll(selector);</span><br><span class="line">    <span class="keyword">this</span>.length = elements.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>[i] = elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>].innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂函数</span></span><br><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 li 标签并调用 html 方法</span></span><br><span class="line"><span class="keyword">let</span> html = $(<span class="string">'li'</span>).html();</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>简单工厂经典案例 —— React 虚拟 DOM</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟 DOM 的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(tagName, attrs, children) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tagName = tagName;</span><br><span class="line">    <span class="keyword">this</span>.attrs = attrs;</span><br><span class="line">    <span class="keyword">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在 React 对象上的简单工厂函数</span></span><br><span class="line">React.createElement = <span class="function"><span class="keyword">function</span> (<span class="params">tagName, attrs, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(tagName, attrs, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>简单工厂模式的缺点：不满足开放封闭原则，内部可以随意修改，新增、修改子类都需要修改工厂类内部代码，在扩展的过程中工厂类的代码将会越来越臃肿。</strong></p></blockquote><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>“工厂方法模式” 可以规避 “简单工厂模式” 的缺点，又称为多态性工厂模式，核心的工厂类不再负责创建出哪一种产品类的实例，而是将具体创建的工作交给子类去做。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/factory-method-uml.jpg" alt="工厂方法模式 UML 图" title>                </div>                <div class="image-caption">工厂方法模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>基本的工厂方法模式使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  create () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— OrangeFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrangeFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">let</span> apple = AppleFactory.create();</span><br><span class="line"><span class="keyword">let</span> orange = OrangeFactory.create();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>上面是一个基础的 “工厂方法模式” 使用，解决了 “简单工厂模式” 扩展的问题（遵循开放封闭原则），创建实例虽然不耦合具体的类，但是耦合工厂的子类，下面可以通过文件拆分进行解耦。</p><figure class="highlight js"><figcaption><span>plant.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Plant;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>factory.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  create () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Factory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>apple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plant = <span class="built_in">require</span>(<span class="string">'./plant'</span>);</span><br><span class="line"><span class="keyword">const</span> Factory = <span class="built_in">require</span>(<span class="string">'./factory'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = AppleFactory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>orange.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plant = <span class="built_in">require</span>(<span class="string">'./plant'</span>);</span><br><span class="line"><span class="keyword">const</span> Factory = <span class="built_in">require</span>(<span class="string">'./factory'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— OrangeFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrangeFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = OrangeFactory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>setting.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置文件，将要创建实例的类型与对应的工厂关联起来</span></span><br><span class="line"><span class="keyword">const</span> setting = &#123;</span><br><span class="line">  apple: <span class="string">'./apple'</span>,</span><br><span class="line">  orange: <span class="string">'./orange'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = setting;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>use.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setting = <span class="built_in">require</span>(<span class="string">'./setting'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apple = <span class="built_in">require</span>(setting[<span class="string">'apple'</span>]).create();</span><br><span class="line"><span class="keyword">let</span> orange = <span class="built_in">require</span>(setting[<span class="string">'orange'</span>]).create();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>使用上面这样的 “工厂方法模式”，扩展时只需要新增一个文件，在文件中定义具体创建实例的类和工厂类就可以了，一般会有一个配置文件将要创建实例的类型和对应的工厂关联起来，创建对应的实例只需通过类型和配置文件找到对应的工厂执行 <code>create</code> 方法即可。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>“抽象工厂模式” 是指当有多个抽象角色时，可以提供一个接口，不必指定 “产品” 具体的情况下，创建多个产品族中的产品对象。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/abatract-factory-uml.jpg" alt="抽象工厂模式 UML 图" title>                </div>                <div class="image-caption">抽象工厂模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 —— Icon</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类 —— Button</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— AppleIcon 苹果图标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleIcon</span> <span class="keyword">extends</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Mac 的图标'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— AppleButton 苹果按钮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleButton</span> <span class="keyword">extends</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Mac 的按钮'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— WindowsIcon Windows 图标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsIcon</span> <span class="keyword">extends</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Windows 的图标'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— WindowsButton Windows 按钮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsButton</span> <span class="keyword">extends</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Windows 的按钮'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;&#125; <span class="comment">// 创建图标</span></span><br><span class="line">  createButton() &#123;&#125; <span class="comment">// 创建按钮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory 用于创建苹果族产品实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppleIcon();</span><br><span class="line">  &#125;</span><br><span class="line">  createButton() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppleButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— WindowsFactory 用于创建 Windows 族产品实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowsIcon();</span><br><span class="line">  &#125;</span><br><span class="line">  createButton() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowsButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建苹果工厂实例</span></span><br><span class="line"><span class="keyword">let</span> appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建苹果族产品</span></span><br><span class="line">appleFactory.createIcon().render(); <span class="comment">// 绘制 Mac 的图标</span></span><br><span class="line">appleFactory.createButton().render(); <span class="comment">// 绘制 Mac 的按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Windows 工厂实例</span></span><br><span class="line"><span class="keyword">let</span> wondowsFactory = <span class="keyword">new</span> WindowsFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Windows 族产品</span></span><br><span class="line">wondowsFactory.createIcon().render(); <span class="comment">// 绘制 Windows 的图标</span></span><br><span class="line">wondowsFactory.createButton().render(); <span class="comment">// 绘制 Windows 的按钮</span></span><br></pre></td></tr></table></figure><p>在上面案例中，按照 “抽象工厂模式” 的说法，多个抽象角色指的是 <code>Apple</code> 和 <code>Windows</code>，<code>Icon</code> 和 <code>Button</code>，工厂分为 <code>AppleFactory</code> 和 <code>WindowsFactory</code> 两类，可以分别创建对应产品的 <code>Icon</code> 和 <code>Button</code> 实例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>上面几种工厂模式中，“简单工厂模式” 在框架开发中使用居多，“工厂方法模式” 更多在一些比较老的且复杂的项目中用作业务模块封装和抽象，“抽象工厂模式” 在前端并不常用，应用于后端偏多，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/2.factory" target="_blank">案例地址</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 基础篇 —— Router 4.0 的基本使用</title>
      <link href="/2018/09/21/20180921182754/"/>
      <url>/2018/09/21/20180921182754/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/21/20180921182754/react-router.png" title="React Router"><p><br></p><h2 id="React-路由简介"><a href="#React-路由简介" class="headerlink" title="React 路由简介"></a>React 路由简介</h2><blockquote class="pullquote info"><p>在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，<code>React</code> 全家桶中也有配套的路由系统，在路由 <code>2.0</code> 版本时叫做 <code>react-router</code>，在路由 <code>4.0</code> 时更名为 <code>react-router-dom</code>，我们本次就针对较新版本的 <code>Router</code> 系统进行介绍。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>为了方便演示如何 <code>Router</code>，我们使用 <code>create-react-app</code> 创建一个 <code>React</code> 项目，并删除 <code>src</code> 文件夹内多余文件，创建我们需要的文件 <code>index.js</code>，目录结构如下。</p><p><pre>react-router<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- src<br>  | |- pages<br>  | | |- Add.js<br>  | | |- Detail.js<br>  | | |- Home.js<br>  | | |- Index.js<br>  | | |- List.js<br>  | | |- Login.js<br>  | | |- Logo.js<br>  | | |- MenuLink.js<br>  | | |- Profile.js<br>  | | |- Protected.js<br>  | | |- User.js<br>  | |- App.js<br>  | |- index.css<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><p>其中主组件为 <code>App</code>，在 <code>index.js</code> 中渲染，<code>index.js</code> 代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>而 <code>App</code> 组件主要用来渲染菜单导航和路由组件，我们将在下面完善代码。</p><h2 id="HashRouter-和-BrowserRouter"><a href="#HashRouter-和-BrowserRouter" class="headerlink" title="HashRouter 和 BrowserRouter"></a>HashRouter 和 BrowserRouter</h2><p>在 <code>React Router</code> 中，给我们提供了一些路由相关的组件，其中最重要的就是实现路由的 <code>HashRouter</code> 和 <code>BrowserRouter</code>，我们知道浏览器的 <code>hash</code> 值发生变化会阻止页面的跳转，而 <code>HashRouter</code> 就是利用这个特性实现的，通过监听 <code>onhanshchange</code> 事件在 <code>hash</code> 值改变的时候做出响应，<code>BrowserRouter</code> 则是利用 <code>H5</code> 的新 <code>History API</code> 的 <code>pushState</code> 方法构造的的历史记录集合来实现的。</p><p>通常情况下，在开发的时候使用 <code>HashRouter</code> 更多，而在真正上线时替换成 <code>BrowserRouter</code>，两种 <code>Router</code> 在地址栏上的表现上区别只是是否含有 <code>#</code>，两种 <code>Router</code> 的使用如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— HashRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* 路由相关代码 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— BrowserRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* 路由相关代码 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>其实就是使用 <code>React Router</code> 中提供的这两种类型的路由组件对路由相关的 <code>JSX</code> 进行包裹。</p><h2 id="Route-和-Link-组件"><a href="#Route-和-Link-组件" class="headerlink" title="Route 和 Link 组件"></a>Route 和 Link 组件</h2><p><code>Route</code> 组件是用来定义路由跳转的切换组件的区域，通过 <code>path</code> 属性定义匹配的路由，<code>component</code> 属性来定义渲染的组件，渲染后就是一个 <code>div</code> 标签，<code>Link</code> 是用来点击跳转路由的，通常用来定义导航栏内容，通过 <code>to</code> 属性设置匹配的路由，需要与 <code>Route</code> 的 <code>path</code> 一一对应，点击后可切换到对应的路由组件，渲染后为一个 <code>a</code> 标签。</p><h3 id="创建路由跳转的组件"><a href="#创建路由跳转的组件" class="headerlink" title="创建路由跳转的组件"></a>创建路由跳转的组件</h3><p>下面我们来创建三个路由对应的组件，分别为首页、用户、个人中心，对应的组件分别为 <code>Home.js</code>、<code>User.js</code>、<code>Profile.js</code></p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Home.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;主页&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;用户&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Profile.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Profile</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;个人中心&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="配合使用-Route-和-Link"><a href="#配合使用-Route-和-Link" class="headerlink" title="配合使用 Route 和 Link"></a>配合使用 Route 和 Link</h3><p>使用 <code>Link</code> 和 <code>Route</code> 配合使用如下，点击 <code>Link</code> 会在类名 <code>container</code> 的元素种加载路由路径对应的组件。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ul className=<span class="string">"nav"</span>&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/profile"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div className="container"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/</span>home<span class="string">" component=&#123;Home&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user<span class="string">" component=&#123;User&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/profile<span class="string">" component=&#123;Profile&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/HashRouter&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>启动项目后上面的代码已经可以帮助我们实现页面路由的切换，但是上面的代码 <code>Link</code> 和 <code>Route</code> 组件混在一起，我们其实可以将 <code>App</code> 拆分成两个组件，一个用来存放 <code>Link</code> 部分，一个用来存放 <code>Route</code> 部分，创建 <code>Index</code> 组件，将 <code>Link</code> 的部分抽取出去，代码修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Index&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;a className=<span class="string">"navbar-brand"</span>&gt;管理系统&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;ul className=<span class="string">"nav"</span>&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/profile"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="container"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修改之后 <code>Index</code> 组件专门用来维护导航组件 <code>Link</code>，<code>App</code> 组件专门用来维护路由组件 <code>Route</code>，这样代码看起来就不那么混乱了。</p><h3 id="Route-组件的-exact-属性"><a href="#Route-组件的-exact-属性" class="headerlink" title="Route 组件的 exact 属性"></a>Route 组件的 exact 属性</h3><p>上面我们所定义的路由为一级路由，在路由匹配并成功加载对应组件后，如果组件又由多个组件组成，并有类似导航的操作（当然不仅限于导航）来控制其他的组件视图的切换，则需要匹配二级路由，这就出现了一个问题，我们以 <code>/user</code> 为例，假设添加一个新的路由 <code>/user/add</code>，那么 <code>React</code> 会由上到下依次匹配，<code>/user/add</code> 中包含 <code>/user</code>，因此会同时渲染两个组件，这不是我们希望的。</p><p>在 <code>React</code> 内部给我们提供了解决方案，就是给路由设置严格匹配，我们只需要让 <code>/user</code> 对应的 <code>Route</code> 组件添加 <code>exact</code> 属性，并将值设置为 <code>true</code> 即可，所以匹配 <code>/user/add</code> 时就不会出现 <code>/user</code> 对应的路由组件也被渲染的情况，当然也可以将 <code>exact</code> 简写到 <code>Route</code> 组件上省略赋值为 <code>true</code> 的过程。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 exact</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Index&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Switch-组件"><a href="#Switch-组件" class="headerlink" title="Switch 组件"></a>Switch 组件</h2><p>因为 <code>React</code> 的路由是由上至下依次进行匹配的，如果有两个同名路由进行匹配，会同时加载两个组件，这也是我们需要优化的，<code>React Router</code> 的 <code>Switch</code> 组件就是来做这件事的，只需要将多个 <code>Route</code> 组件包裹起来，就可以实现只要成功匹配一个路由就不再继续匹配。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Switch 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt; &#123;<span class="comment">/* 同名路由 */</span>&#125;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 <code>Switch</code> 组件优化后，启动项目就可以发现只渲染了一个 <code>User</code> 组件。</p><h2 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a>Redirect 组件</h2><p>在 <code>React</code> 开发中经常遇到路径输入错误的情况，通常情况有两种处理方式，第一种是跳转到一个 <code>404</code> 页面，第二种方式是将页面路由重定向到主页，而 <code>React Router</code> 提供的 <code>Redirect</code> 组件就是帮助我们在所有路由都匹配失败时重定向的，使用时通常放在最后一个 <code>Route</code> 组件的下面用来 “兜底”，使用 <code>to</code> 属性来定义重定向的路由。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Redirect 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt; &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：不能放在 <code>Route</code> 组件的上面，因为放在上面不会匹配任何的路由，而会直接重定向到设置的页面。</strong></em></p></blockquote><p>对于路由都没有匹配而返回 <code>404</code> 页面我们这里也简单说一下，但是这样的用法非常少，使用 <code>Redirect</code> 重定向到指定页面的方式会更多一些。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 匹配失败跳转 404 页面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> component=&#123;<span class="built_in">Error</span>&#125;/&gt; &#123;<span class="comment">/* Error 组件代表 404 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>由于其他的路由都匹配失败，最后会和 <code>/</code> 匹配，所以会显示 <code>Error</code> 组件，这里的 <code>Route</code> 的组件也必须放在最下面来 “兜底”。</p><h2 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h2><h3 id="实现二级路由"><a href="#实现二级路由" class="headerlink" title="实现二级路由"></a>实现二级路由</h3><p>在了解 <code>React Router</code> 的基本使用后，我们用同样的知识点来给 <code>User</code> 组件写一个二级路由，<code>User</code> 中有一个子导航，分别对应用户列表 <code>List</code> 组件和添加用户 <code>Add</code> 组件，代码的套路与之前相同。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="解决默认路径不匹配的问题"><a href="#解决默认路径不匹配的问题" class="headerlink" title="解决默认路径不匹配的问题"></a>解决默认路径不匹配的问题</h3><p>当通过 <code>React Router</code> 访问 <code>/user</code> 的时候，会先加载 <code>User</code> 组件，再加载 <code>User</code> 内部的组件包括子导航，但是 <code>/user</code> 的路径既没有和 <code>/user/add</code> 匹配，也没有和 <code>/user/list</code> 匹配，这样渲染了一个空的类名为 <code>sub-containe</code> 的 <code>div</code> 标签，我们应该让 <code>User</code> 组件加载时子路由默认可以匹配一个路由组件，解决方式如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— Redirect 组件重定向的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Redirect to="</span>/user/list<span class="string">"/&gt; &#123;/* 重定向到 List 组件 */&#125;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的方式是使用 <code>Redirect</code> 组件重定向的方式实现的，但是这样访问的 <code>/user</code>，路径会自动改变为 <code>/user/list</code>，感觉上有一些奇怪，当然还有另外的解决方式。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— Route 组件严格匹配</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser<span class="string">" exact component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的方式是当匹配到了 <code>/user</code> 的路由也加载默认要渲染的 <code>List</code> 组件实现的，但是为了防止向下继续匹配，可以添加 <code>exact</code> 设置严格匹配，进一步优化可以使用 <code>Switch</code> 组件，让路由成功匹配一次后不再向下匹配。</p><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>我们经常会遇到一个场景，就是在某些交互之后实现页面的自动跳转，而对于 <code>React</code> 搭建的单页面应用来说就是路由切换，在 <code>React</code> 中都最初是通过 <code>Link</code> 组件的点击手动实现的路由切换，那么怎么通过纯编程的方式在某些交互后自动切换路由呢，其实 <code>React Router</code> 的 <code>Route</code> 组件会给内部渲染的组件传递路由相关的三个参数 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>三个属性值均为对象，<code>history</code> 上存储了 <code>length</code> 属性代表当前支持存入历史记录的数量，也同样存储了 <code>location</code>，用来存储路由路径的相关信息，还有用来操作路由跳转的方法 <code>go</code>（传入数字代表前进或后退几页）、<code>goBack</code>（后退）、<code>goForward</code>（前进）、<code>replace</code>（用其他路由替换当前历史）、<code>push</code>，其中最常用的就是 <code>push</code> 方法，下面会着重介绍，<code>match</code> 中存储了一些路由匹配的相关信息，如 <code>url</code>，即浏览器输入的路径，真正匹配的路径 <code>path</code> 属性以及是代表否严格匹配的 <code>isExact</code> 属性，在 <code>match</code> 中最重要的是 <code>params</code> 属性，值为对象，用来存储路由参数，这个我们放在后面来说。</p><p>下面在 <code>Add</code> 组件中添加一输入框和按钮，当点击按钮是将输入框的数据存入 <code>localStorage</code> 中，并自动将路由跳转到 <code>/user/list</code>，即渲染 <code>List</code> 组件，然后将数据取出渲染到 <code>List</code> 组件中，这是一个很常见的需求，添加数据然后跳到详情页的场景，下面是 <code>Add</code> 组件中的实现。</p><figure class="highlight js"><figcaption><span>路径：&#126;react-router/src/pages/Add.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  input = React.createRef() <span class="comment">// 非受控组件取值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单提交事件</span></span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault(); <span class="comment">// 取消默认的页面跳转事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从 localStorage 获取已有数据</span></span><br><span class="line">    <span class="keyword">const</span> lists = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新数据</span></span><br><span class="line">    lists.push(&#123;</span><br><span class="line">      id: lists.length + <span class="number">1</span>,</span><br><span class="line">      username: <span class="keyword">this</span>.input.current.value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入 localStorage</span></span><br><span class="line">    localStorage.setItem(<span class="string">'lists'</span>, <span class="built_in">JSON</span>.stringify(lists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编程式导航，自动跳转到 List</span></span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/user/list'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;form className=<span class="string">"form"</span> onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">          &lt;label htmlFor=<span class="string">"username"</span> className=<span class="string">"control-label"</span>&gt;用户名&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input</span></span><br><span class="line"><span class="regexp">            className="form-control"</span></span><br><span class="line"><span class="regexp">            type="text"</span></span><br><span class="line"><span class="regexp">            id="username"</span></span><br><span class="line"><span class="regexp">            ref=&#123;this.input&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          &lt;br/&gt;</span><br><span class="line">          &lt;input type=<span class="string">"submit"</span> className=<span class="string">"btn btn-success"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们通过 <code>Route</code> 传递给渲染组件的 <code>history</code> 的 <code>push</code> 方法实现了路由的自动跳转，<code>push</code> 方法接收的参数就是将要跳转的路径字符串，<code>List</code> 组件代码如下。</p><figure class="highlight js"><figcaption><span>路径：&#126;react-router/src/pages/List.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">    <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                  &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;td&gt;&#123;username&#125;&lt;/</span>td&gt;</span><br><span class="line">                &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">              )</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tbody&gt;</span><br><span class="line">      &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>取出 <code>localStorage</code> 中的数据在 <code>List</code> 中渲染时有两点注意，第一是取出数据和设置状态应该在 <code>render</code> 渲染 <code>JSX</code> 之前，这样在没有执行 <code>render</code> 时会合并状态并只渲染一次，也就是说 <code>componentWillMount</code> “钩子” 和 <code>render</code> “钩子” 的 <code>return</code> 语句前更新状态都是可以的，如果在 <code>componentDidMount</code> “钩子” 中更新会导致组件渲染两次，在 <code>React</code> 开发中如果获取数据的过程是同步的（<code>localStorage</code> 取值是同步的），不需要渲染两次。</p><p>第二点是在使用表格元素 <code>table</code> 渲染时，必须要含有 <code>thead</code> 和 <code>tbody</code>，这是 <code>React</code> 规定的，不可以省略。</p><h2 id="路由参数的传递"><a href="#路由参数的传递" class="headerlink" title="路由参数的传递"></a>路由参数的传递</h2><p>现在在我们的 <code>List</code> 组件表格中，点击每一行都可以跳转到学生 <code>ID</code> 对应的详情 <code>Detail</code> 组件中，由于每一个学生的 <code>ID</code> 不同渲染的详情也不相同，此时需要将学生 <code>ID</code> 作为路由参数进行传递，并在 <code>Detail</code> 内渲染对应的内容，由于 <code>Detail</code> 组件的渲染与 <code>List</code> 组件是同一区域，所以仍然是二级路由，我们需要在 <code>User</code> 组件中进行添加。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— 增加 Detail 二级路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"><span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">'./Detail'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser<span class="string">" exact component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/detail/:id<span class="string">" component=&#123;Detail&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>React Router</code> 中，我们通过给路由后面添加 <code>/:paramname</code> 的方式添加参数，也可以通过 <code>/:paramname/:paramname</code> 传递多个参数（形参），由于在 <code>List</code> 中点击表格的的某行的单元格跳转路由，所以 <code>List</code> 组件修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">    <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                  &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                    &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;td&gt;&lt;Link to=&#123;`/u</span>ser/detail/$&#123;id&#125;<span class="string">`&#125;&gt;&#123;username&#125;&lt;/Link&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                  &lt;/tr&gt;</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">              &#125;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &lt;/tbody&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>List</code> 组件中，同样使用 <code>Link</code> 组件对要点击切换路由的节点进行包裹，并用 <code>to</code> 属性设置跳转的路由和路由参数（实参），现在点击就可以实现从 <code>List</code> 组件到 <code>Detail</code> 组件的切换，如果我们有些 <code>List</code> 的数据想在跳转到 <code>Detail</code> 组件时直接带过去，则可以使用另一种写法如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数和数据</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">      <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">      <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                  &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;td&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;Link to=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                      pathname: `/u</span>ser/detail/$&#123;id&#125;<span class="string">`,</span></span><br><span class="line"><span class="string">                      state: username</span></span><br><span class="line"><span class="string">                    &#125;&#125;&gt;&#123;username&#125;&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                  &lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;/tr&gt;</span></span><br><span class="line"><span class="string">              )</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &lt;/tbody&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>不同的是给 <code>to</code> 属性传入的值从一个代表路由的字符串变成了一个对象，而把路由的字符串作为了 <code>pathname</code> 属性的值，<code>state</code> 属性则代表了路由跳转传给渲染组件的数据，还记得渲染的组件使用 <code>Route</code> 组件包裹的，会传入 <code>history</code>、<code>loacltion</code> 和 <code>match</code> 三个属性，同样的，通过点击 <code>Link</code> 传递的路由参数和数据都可以在 <code>props</code> 上获取到，前者通过 <code>location.state</code> 或者 <code>history.location.state</code> 上获取到，后者可以通过 <code>match.params</code> 上获取到，那么 <code>Detail</code> 组件将传递过来的参数渲染，代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Detail.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Detail</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">user</span>: &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 有值说明是点击过来的，否则是地址栏输入的</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">this</span>.props.location.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由参数</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.match.params.id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是点击过来的直接将数据设置给 state，否则去 localStorage 取值设置给 state</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: &#123; id, <span class="attr">username</span>: data &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> user = users.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: &#123; id, <span class="attr">username</span>: user.username &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.user.id&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt; ------- &lt;/</span>span&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.user.username&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>这里有两点注意点，首先通过组件 <code>props.match.params</code> 获取的路由参数都是字符串格式，如果原本类型为数字，使用时应转换成数字类型，其次是传递的数据，也就是组件通过 <code>props.location.state</code> 获取的数据，只有在通过 <code>Link</code>组件点击过去才会存在，在地址栏输入为 <code>undefined</code>，所以防止用户刷新页面导致数据丢失，应该在两种情况下处理不同的获取数据的逻辑。</strong></em></p></blockquote><h2 id="withRouter-函数"><a href="#withRouter-函数" class="headerlink" title="withRouter 函数"></a>withRouter 函数</h2><p>在之前的编程式导航中我们使用了 <code>Route</code> 传递给渲染组件的 <code>props.history.push</code> 方法实现的，现在假设我们要对一个不是路由跳转的组件，通过点击事件来获取 <code>history</code>、<code>location</code> 和 <code>match</code> 属性，并使用 <code>history</code> 上的路由设置方法进行跳转路由，这应该如何实现呢？</p><p>其实 <code>React Route</code> 给我们提供了一个函数 <code>withRouter</code> 方法，在调用该方法时，则会返回一个新的组件，当然其实这是一个高阶组件的应用，<code>withRouter</code> 方法内部帮我们在传入的组件外层包装了一层 <code>Route</code> 组件，并传入了 <code>history</code>、<code>location</code> 和 <code>match</code> 属性作为参数，所以当我们使用返回的组件时可以通过 <code>props</code> 属性获取 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>下面针对我们之前的 <code>Index</code> 组件的内的 “管理系统” 的标签抽出一个新的组件，并将这个组件添加点击可以跳转到登录页 <code>Login</code> 组件的功能，<code>Login</code> 组件为一级路由，所以我们应该修改 <code>App</code> 组件，添加一个 <code>/login</code> 的路由，<code>Login</code> 和修改后的 <code>App</code> 组件如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Login 组件路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/Login'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;/&gt; &#123;<span class="comment">/* 添加登录页路由 */</span>&#125;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt; &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Login.js —— 添加登录和退出功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'login'</span>, <span class="string">'ok'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.removeItem(<span class="string">'login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>Login</code> 中顺便添加了两个按钮来模拟 “登录” 和 “退出”，并给按钮添加了事件，在登录时向 <code>localStorage</code> 中添加 <code>login</code> 属性，在退出时清除这个属性，以模拟登录状态。</p><p>抽取出 <code>Logo</code> 后的 <code>Index</code> 组件也应该添加一个新的导航为 “登录”，<code>Login</code> 组件和修改后的 <code>Index</code> 组件如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 抽出 Logo 组件并添加登录导航</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;Link to="/</span>home<span class="string">"&gt;首页&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/user<span class="string">"&gt;用户&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/profile<span class="string">"&gt;个人中心&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/login<span class="string">"&gt;登录&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Logo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  change = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"navbar-brand"</span> onClick=&#123;<span class="keyword">this</span>.change&#125;&gt;管理系统&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Logo);</span></span><br></pre></td></tr></table></figure><p>通过 <code>Logo</code> 案例的代码我们可以看出，其实最后导出的并不是 <code>Logo</code> 组件，而是使用 <code>withRouter</code> 函数包装后返回的高阶组件，<code>withRouter</code> 方法内部帮我们搞定了 <code>Logo</code> 组件的 <code>props</code> 没有 <code>history</code>、<code>location</code> 和 <code>match</code> 属性的问题。</p><h2 id="受保护的路由"><a href="#受保护的路由" class="headerlink" title="受保护的路由"></a>受保护的路由</h2><p>以前在点击个人中心时会直接渲染 <code>Profile</code> 组件，在给 <code>Login</code> 组件添加 “登录” 和 “退出” 之后，再次点击个人中心时，应该先对登录状态进行验证，如果 <code>localStorage</code> 中存在 <code>login</code> 属性，则渲染 <code>Profile</code> 的 <code>Route</code> 组件，否则重定向到登录页，如果在登录页点击登录后再重新跳回个人中心（从哪来回哪去）。</p><p>这就需要我对 <code>App</code> 组件路由部分的代码进行修改，使用高阶组件来添加登录验证逻辑，当然，这个高阶组件不是 <code>React Router</code> 提供的，需要我们自己来实现，这种做法被官方称作 “受保护的路由”。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加受保护的路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/Login'</span>;</span><br><span class="line"><span class="keyword">import</span> Protected <span class="keyword">from</span> <span class="string">'./pages/Protected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &#123;<span class="comment">/* 添加受保护的路由 */</span>&#125;</span><br><span class="line">            &lt;Protected path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;/&gt;</span><br><span class="line">            &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们重写了 <code>App</code> 组件中个人中心对应的路由，将原来的 <code>Route</code> 组件用高阶组件 <code>Protected</code> 代替，也就等于是将原本传入的参数 <code>path</code> 和 <code>component</code> 传入了高阶组件 <code>Protected</code>，下面来看一下高阶组件 <code>Protected</code> 的实现。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Protected.js —— 添加受保护的路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Protected</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> login = localStorage.getItem(<span class="string">'login'</span>);</span><br><span class="line">    <span class="keyword">return</span> login ?</span><br><span class="line">    &lt;Route &#123;...this.props&#125;/&gt; :</span><br><span class="line">    &lt;Redirect to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">'/login'</span>, <span class="attr">state</span>: &#123; <span class="string">'from'</span>: <span class="string">'/profile'</span> &#125;&#125;&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Protected</code> 获取登录状态，存在时直接渲染了 <code>Route</code> 组件，并将 <code>path</code> 和 <code>component</code> 参数传入，如果不存在则渲染 <code>Redirect</code> 组件重定向到登录页，传入的参数同 <code>Link</code> 组件的规则相同，<code>pathname</code> 代表重定向的路径，<code>state</code> 代表带过去的数据，我们这里添加了一个 <code>from</code> 属性，用来记录渲染登录页的来源，即个人中心。</p><p>接下来就是 <code>Login</code> 组件中在点击登录后验证是否存在 <code>state</code>，如果存在则返回存储的 <code>from</code> 对应的路由，即个人中心，不存在则跳回首页，<code>Login</code> 修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Login.js —— 完善登录功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'login'</span>, <span class="string">'ok'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一个路由传递的 state</span></span><br><span class="line">    <span class="keyword">const</span> prevPathDate = <span class="keyword">this</span>.props.location.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在 state 则返回来源对应的页面，否则回主页</span></span><br><span class="line">    <span class="keyword">if</span> (prevPathDate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(prevPathDate.from);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(<span class="string">'/home'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.removeItem(<span class="string">'login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样 “受保护的路由” 功能就实现了，其实就是在跳转路由之前起到了一个 “拦截” 的作用，经常的使用场景是权限管理，这是一个路由的应用，也是一个高阶组件的应用，这样的应用在大型复杂的 <code>React</code> 中会频繁使用，还是比较重要的。</p><h2 id="NavLink-组件"><a href="#NavLink-组件" class="headerlink" title="NavLink 组件"></a>NavLink 组件</h2><p>在实际项目开发中，我们经常遇到导航标签被选中时被添加一个代表 “激活” 的类名，用于添加与其他导航选项不同的样式，<code>React Router</code> 已经给我们提供了 <code>NavLink</code> 组件用于实现这个功能，<code>NavLink</code> 组件具备 <code>Link</code> 组件所有的功能，唯一不同的就是 <code>NavLink</code> 组件在被选中时不止发生路由跳转，还会给渲染后的 <code>a</code> 标签添加一个名为 <code>active</code> 的 <code>class</code> 属性，而我们只需要通过 <code>css</code> 去给类名 <code>active</code> 设置样式即可。</p><figure class="highlight css"><figcaption><span>路径：&#126;react-router/src/index.css —— 激活样式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好激活样式以后，我们只需要在 <code>Index</code> 组件中引入激活样式的 <code>css</code> 文件并将 <code>Link</code> 组件替换成 <code>NavLink</code> 组件即可。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入激活样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;NavLink to="/</span>home<span class="string">"&gt;首页&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/user<span class="string">"&gt;用户&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/profile<span class="string">"&gt;个人中心&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/login<span class="string">"&gt;登录&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="自定义导航组件实现激活"><a href="#自定义导航组件实现激活" class="headerlink" title="自定义导航组件实现激活"></a>自定义导航组件实现激活</h2><p><code>React Router</code> 在给我们提供的导航组件 <code>NavLink</code> 功能有限，只会给内部的 <code>a</code> 标签在选中时添加 <code>active</code> 类名，如果我们想实现给一个 <code>li</code> 标签添加 <code>active</code> 就需要我们自己封装一个组件来实现这个功能，其实还是通过高阶组件来实现的，首先我们定义这个高阶组件的名字为 <code>MenuLink</code>，将 <code>Index</code> 组件中的 <code>li</code> 标签和 <code>NavLink</code> 组件统一替换成 <code>MenuLink</code> 组件，代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"><span class="keyword">import</span> MenuLink <span class="keyword">from</span> <span class="string">'./MenuLink'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;MenuLink to="/</span>home<span class="string">"&gt;首页&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/user<span class="string">"&gt;用户&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/profile<span class="string">"&gt;个人中心&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/login<span class="string">"&gt;登录&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在实现 <code>MenuLink</code> 组件之前我们分析一下实现思路，首先我们依然模拟 <code>NavLink</code> 的方式给 <code>MenuLink</code> 传入了 <code>to</code> 属性，值为将要跳转的路由，所以我们应该在 <code>MenuLink</code> 组件中来接收这个路由，而 <code>MenuLink</code> 内部一定是包含 <code>li</code> 和 <code>Link</code> 组件的，我们可以将这个 <code>to</code> 属性传递给 <code>Link</code> 组件，如果想要通过激活状态给外层的 <code>li</code> 标签设置状态我们需要知道是否匹配了路由，并可以通过 <code>match</code> 属性获得，所以在 <code>li</code> 的外层应该有 <code>Route</code> 组件配合，因为只有 <code>Route</code> 组件才会将 <code>history</code>、<code>location</code> 和 <code>match</code> 作为参数传递给其内部渲染的组件。</p><p>这就要说到 <code>Route</code> 组件的渲染模式，在传入 <code>component</code> 属性时，只有匹配组件才会渲染内部组件，我们显然是需要时时刻刻都渲染内部的 <code>li</code> 和 <code>Link</code>，并通过点击 <code>Link</code> 渲染真正的路由组件，所以我们需要用到第二种渲染方式，就是通过 <code>children</code> 属性指定时刻需要渲染的组件，实现代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/MenuLink.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Route path=&#123;<span class="keyword">this</span>.props.to&#125; children=&#123;(&#123; match &#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;li className=&#123;match ? <span class="string">'active'</span> : <span class="string">''</span>&#125;&gt;</span><br><span class="line">            &lt;Link to=&#123;<span class="keyword">this</span>.props.to&#125;&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中由于 <code>children</code> 组件并不需要操作状态和使用生命周期 “钩子”，所以我们直接使用了函数组件实现，因为 <code>active</code> 类名添加给了 <code>li</code>，所以我们需要在 <code>MenuLink</code> 组件中引入样式文件 <code>index.css</code> 并将修改，代码如下。</p><figure class="highlight css"><figcaption><span>路径：&#126;react-router/src/index.css —— 激活样式修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-class">.active</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>本篇通过一个简单的案例使用了由 <code>React Router</code> 所提供的，开发中常用的功能，但美中不足的是并没有使用一些 <code>UI</code> 库或者 <code>CSS</code> 样式来美化，为了更明显的看到 <code>React Router</code> 各个功能使用后的效果，建议大家在实现上面代码的同时自己添加一些 <code>CSS</code> 样式。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 基础篇 —— 组件间的参数传递</title>
      <link href="/2018/09/19/20180919002629/"/>
      <url>/2018/09/19/20180919002629/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/19/20180919002629/react-props-transmit.png" title="React 组件间参数传递"><p><br></p><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><blockquote class="pullquote default"><p>每一个可以组件化开发的前端框架如 <code>React</code>、<code>Vue</code>，组件间的参数传递都是一定会谈论的话题，而 <code>React</code> 中数据传递是单向的，也被称为单向数据流，即数据只能从父组件传递到子组件，而子组件只需要通过 <code>props</code> 属性渲染即可，如果顶层组件的某个属性的值改变了，<code>React</code> 将由外向内遍历整个组件树，将使用了该属性的组件重新渲染。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先使用 <code>create-react-app</code> 脚手架创建 <code>React</code> 项目，项目生成后删除 <code>src</code> 文件目录下的多余文件，留下 <code>index.js</code>，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app transfer-props</span><br></pre></td></tr></table></figure><p><strong>该项目最后的目录结构如下：</strong></p><p><pre>transfer-props<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- src<br>  | |- components<br>  | | |- App.js<br>  | | |- Child.js<br>  | | |- Parent.js<br>  | |- context.js<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><h2 id="父组件传参给子组件"><a href="#父组件传参给子组件" class="headerlink" title="父组件传参给子组件"></a>父组件传参给子组件</h2><p>创建一个最外层组件 <code>App</code>，并在 <code>index.js</code> 中进行渲染。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>App</code> 组件内部状态中含有 <code>users</code> 属性，值为数组，含有 <code>title</code> 属性，现在要将这两个参数传递给 <code>Parent</code> 组件，传参方式如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Parent</code> 组件中接收到参数，要根据参数中数组的数量来渲染下一个子组件 <code>Child</code>，<code>Child</code> 组件中需要使用父组件 <code>users</code> 数组的学生 <code>id</code>，传参如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; users, title &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">            users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              return (</span></span><br><span class="line"><span class="regexp">                &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 <code>Child</code> 组件，用来渲染学生的基本信息，在 <code>Parent</code> 中我们已经将参数传递，最后看看在 <code>Child</code> 中的接收。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Child.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id, name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;span&gt;&#123;id&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;&#123;name&#125;&lt;/</span>span&gt;</span><br><span class="line">        &lt;span&gt;&#123;age&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>注意：子组件接收父组件的 <code>props</code> 属性是只读的，不可以修改，修改会报错。</strong></em></p></blockquote><p>其实在这个过程中参数经历了三个组件，都是由父组件传向子组件，可以看出 <code>React</code> 单向数据流的特点，但是子组件是不可以通过某些操作直接修改父组件的数据的，下面来看看子组件如何修改父组件的数据。</p><h2 id="子组件修改父组件的数据"><a href="#子组件修改父组件的数据" class="headerlink" title="子组件修改父组件的数据"></a>子组件修改父组件的数据</h2><p>在 <code>React</code> 中如果要修改父组件的参数，可以给子组件传入一个修改父组件参数的函数，然后在子组件中执行这个函数，就可以实现父组件数据的更新。</p><p>我们创建一个与 <code>Parent</code> 组件平行的 <code>Input</code> 组件，两个组件都是 <code>App</code> 的直接子组件，在 <code>Input</code> 组件内通过某些操作给父组件的状态中的 <code>users</code> 属性新增一条数据。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">    <span class="keyword">this</span>.props.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 <code>Input</code> 组件，在修改时没有直接使用按钮的点击事件，而是添加了 <code>form</code> 标签并使用 <code>submit</code> 事件，是因为可以使用 <code>H5</code> 的自带的校验功能，但是使用 <code>form</code> 会自动提交页面，所以在执行 <code>submit</code> 事件时应取消默认事件，然后调用父组件传来的方法 <code>addStudent</code>，并传入输入框获取的值（非受控组件的取值方式），父组件 <code>App</code> 修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 push 添加</span></span><br><span class="line">    <span class="comment">// this.state.users.push(&#123; id: this.state.users.length + 1, ...val &#125;);</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">        &lt;Input addStudent=&#123;<span class="keyword">this</span>.addStudent&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>首先父组件 <code>App</code> 应该创建 <code>addStudent</code> 方法作为参数传递给子组件 <code>Input</code>，而在 <code>addStudent</code> 方法内部通过 <code>push</code> 和 <code>setState</code> 两种方式进行添加，发现都可以更新状态和视图，区别是 <code>push</code> 操作的原来的引用，而 <code>setState</code> 创建了新的引用空间。</p><blockquote class="pullquote info"><p><em><strong>注意：在 <code>React</code> 所有状态的更改都不建议操作原来的引用，通常做法都是通过 <code>setState</code> 返回一个新的 <code>state</code>（创建新的引用），使用解构赋值的方式来保留原始数据，用新数据覆盖旧数据，原因是在 <code>React</code> 类组件种有一个 <code>PureComponent</code> 纯组件类型，对 <code>shouldComponentUpdate</code> 生命周期 “钩子” 做了优化，使用了 <code>props</code> 和 <code>state</code> 的浅比较，所以在纯组件类型操作原来的引用是无法更新视图的。</strong></em></p></blockquote><h2 id="context-实现跨组件传参"><a href="#context-实现跨组件传参" class="headerlink" title="context 实现跨组件传参"></a>context 实现跨组件传参</h2><p>在上面的案例当中，父子组件关系的层级是三层，无论是普通的数据还是修改父组件的事件都是作为参数一级一级往下传的，如果组件的层级多了，当跨组件传参时是非常不方便的（通常三级还可以接受）。</p><p>跨组件传参是指父级组件与非直接子组件的传参、同级组件之间的传参，同级之间可以找到相同的父级，没有相同的父级就创造相同的父级，最后将问题统一到了父级组件与非直接子组件的传参传递。</p><p>在 <code>React</code> 中给我们提供了 <code>context</code> API 用来实现组件树数据的共享，分为新旧两个版本，这里旧版和新版的 API 都会介绍。</p><h3 id="旧版-context"><a href="#旧版-context" class="headerlink" title="旧版 context"></a>旧版 context</h3><p>在旧版的 <code>context</code> 需要配合属性类型检测的 <code>prop-types</code> 模块共同使用，需要在共同的父组件上定义一个方法 <code>getChildContext</code>，返回值为一个对象，对象中存储的是当前要传递给其他子组件的数据，同时还有一个静态属性 <code>childContextTypes</code>，值为一个对象，属性的值与 <code>getChildContext</code> 方法内返回的对象的属性一一对应，并用 <code>prop-types</code> 模块对每一个传递给子组件属性的数据类型进行定义，在使用父组件传递属性的子组件中需要定义静态属性 <code>contextTypes</code> 对所使用的属性的数据类型进行校验，需要父组件与 <code>childContextTypes</code> 内的定义一致，然后可以通过子组件实例的 <code>context</code> 属性获取，我们可以使用 <code>context</code> 将上面的案例修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>; <span class="comment">// 引入参数类型检测模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义参数类型</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    state: PropTypes.object,</span><br><span class="line">    addStudent: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上下文对象传给子组件的参数</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state: <span class="keyword">this</span>.state,</span><br><span class="line">      addStudent: <span class="keyword">this</span>.addStudent</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 不再需要传参 */</span>&#125;</span><br><span class="line">        &lt;Parent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">        &lt;Input&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面只是将 <code>APP</code> 组件中原本传给子组件的参数去掉，按照要求添加了 <code>getChildContext</code> 方法和 <code>childContextTypes</code> 静态属性。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型检测与父组件定义的类型对应</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    addStudent: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上下文对象上获取父组件的方法并执行</span></span><br><span class="line">    <span class="keyword">this</span>.context.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Input</code> 组件中定义 <code>contextTypes</code> 属性，将 <code>addStudent</code> 方法从原来的 <code>props</code> 获取改为了从 <code>context</code> 上获取。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类型检测与父组件定义的类型对应</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    state: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 从 context 对象上获取 state 并解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; users, title &#125; = <span class="keyword">this</span>.context.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">            users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              return (</span></span><br><span class="line"><span class="regexp">                &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Parent</code> 组件中同样定义 <code>contextTypes</code> 属性，将 <code>state</code> 属性从原来的 <code>props</code> 获取改为了从 <code>context</code> 上获取。</p><h3 id="新版-context"><a href="#新版-context" class="headerlink" title="新版 context"></a>新版 context</h3><p>新版 <code>context</code> 其实是 <code>React</code> 对象提供给我们的方法 <code>createContext</code> 实现的，方法在调用时返回一个对象，对象上有两个组件分别为 <code>Provider</code>（提供者）和 <code>Consumer</code>（消费者），由于两个配合使用的组件必须有同一次调用 <code>createContext</code> 时创建，所以我们单独创建文件 <code>context.js</code> 代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/context.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到处上下文对象的组件</span></span><br><span class="line"><span class="keyword">export</span> &#123; Provider, Consumer &#125;;</span><br></pre></td></tr></table></figure><p>还是之前的案例，我们可以使用新版 <code>context</code> 修改如下。</p><figure class="highlight js"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'../context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;&#123;</span><br><span class="line">        addStudent: <span class="keyword">this</span>.addStudent,</span><br><span class="line">        state: <span class="keyword">this</span>.state</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">          &lt;Input addStudent=&#123;<span class="keyword">this</span>.addStudent&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供参数的父组件 <code>App</code> 应该使用 <code>Provider</code> 进行包裹，将传入的参数以 <code>value</code> 为参数名（规定），传入 <code>context</code> 对象中。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">'../context.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">    <span class="keyword">this</span>.props.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (&#123; addStudent &#125;) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;form onSubmit=&#123;e =&gt; &#123;</span><br><span class="line">                <span class="comment">// 取消默认事件</span></span><br><span class="line">                e.preventDefault();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">                addStudent(&#123;</span><br><span class="line">                  name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">                  age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;&#125;&gt;</span><br><span class="line">                姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>form&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在使用 “提供者” 提供数据的 “消费者” 子组件中，应该引入与 <code>Provider</code> 对应的 <code>Consumer</code> 组件，用 <code>Consumer</code> 组件替换原本组件返回的 <code>JSX</code>，内部传入一个函数，函数的形参即为 <code>context</code> 对象，函数内部返回值为原本子组件返回的 <code>JSX</code>，子组件使用父组件的属性可直接从函数的形参获取或解构。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">'../context.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (&#123; users, title &#125;) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                  &#123;</span></span><br><span class="line"><span class="regexp">                    /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">                    users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                      return (</span></span><br><span class="line"><span class="regexp">                        &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">                      )</span><br><span class="line">                    &#125;)</span><br><span class="line">                  &#125;</span><br><span class="line">                &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>div&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Parent</code> 作为 <code>App</code> 的子组件，修改的方式同 <code>Input</code> 组件相同，如上面代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>关于 <code>React</code> 组件之间传参的各中放式上面基本介绍完了，但是这些传参方式并不能满足于所有的需求，如果是两个毫不相关的组件并且距离共同的父组件层级比较远，即使使用 <code>context</code> 的方式也会显得有些无力，组件间互相传参的需求比较多代码也会冗余和繁琐，因此就有了 <code>Redux</code>、<code>Mobx</code> 等数据状态管理工具，可以将各个组件的状态数据统一管理，各个组件的之间的参数都更容易获取，关于数据状态管理相关的内容我也会在后面的博客中继续更新，敬请期待吧 ^ ^。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 基础篇 —— 生命周期详解</title>
      <link href="/2018/09/15/20180915194439/"/>
      <url>/2018/09/15/20180915194439/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/15/20180915194439/react-life-cycle.png" title="React 生命周期"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>本篇文章主要内容针对 <code>React</code> 类组件的生命周期展开，会详细介绍生命周期 “钩子” 的执行和用法，如果一点也不了解 <code>React</code> 的同学建议先学习一下 <code>React</code> 比较基础的内容，当然也可以看我的文章 <a href="https://www.overtaking.top/2018/09/10/20180910025959/" target="_blank">React 基础篇 —— 带你走进 React 世界</a>。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先使用 <code>create-react-app</code> 脚手架创建一个 <code>React</code> 项目，脚手架工具的安装和项目创建命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app life-cycle</span><br></pre></td></tr></table></figure><p>创建项目后删除 <code>src</code> 目录中的无用文件，只留下 <code>index.js</code> 入口文件即可。</p><h2 id="类组件的生命周期"><a href="#类组件的生命周期" class="headerlink" title="类组件的生命周期"></a>类组件的生命周期</h2><h3 id="静态属性-defaultProps"><a href="#静态属性-defaultProps" class="headerlink" title="静态属性 defaultProps"></a>静态属性 defaultProps</h3><p><code>defaultProps</code> 是用来给 <code>React</code> 类组件设置参数初始值的，也是最早执行的，算不算生命周期说法不一，但是觉得有必要说一下，因为在 <code>React 15.x</code> 版本的时候可以用 <code>React.createClass</code> 创建类组件，组件中有与 <code>defaultProps</code> 静态属性作用相同的生命周期 “钩子” <code>getDefaultProps</code>，随着 <code>React 16.x</code> 版本废弃了 <code>React.createClass</code>，也就使用 <code>defaultProps</code> 属性替代了 <code>getDefaultProps</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>启动项目后，发现页面上成功的渲染了节点中的数字，这说明设置初始值生效了。</p><h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p><code>constructor</code> 是 <code>ES6</code> 中类的写法中给实例设置属性的钩子，在类的实例被创建时执行，下面是对比 <code>defaultProps</code> 静态属性执行顺序的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(props.number); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>从上面案例中可以看到当执行 <code>constructor</code> 时，<code>props</code> 对象中的 <code>num</code> 属性已经有值了，这也充分说明了说明 <code>constructor</code> 是晚于 <code>defaultProps</code> 执行的。</p><h3 id="状态对象-state"><a href="#状态对象-state" class="headerlink" title="状态对象 state"></a>状态对象 state</h3><p>在 <code>React</code> 中，每一个类组件都有一个属于自己的状态，可以使用 <code>setState</code> 方法更新状态，在 <code>React 15.x</code> 中，通过 <code>React.createClass</code> 创建类组件，使用对应的生命周期 “钩子” <code>getInitialState</code> 来创建，同样的，<code>React 16.x</code> 废弃了 <code>React.createClass</code>，创建 <code>state</code> 的过程自然由新的方式代替。</p><p>创建 <code>state</code> 的方式大概有两种，分别是在 <code>constructor</code> 中创建或者直接创建 <code>state</code> 属性，代码如下。</p><figure class="highlight jsx"><figcaption><span>第一种创建 state 的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 state 方式 2</span></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>第二种创建 state 的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.num); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 state</span></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>从上面可以看出直接创建 <code>state</code> 属性的方式与创建静态属性 <code>defaultProps</code> 类似，执行要早于 <code>constructor</code>。</p><h3 id="componentWillMount-钩子"><a href="#componentWillMount-钩子" class="headerlink" title="componentWillMount 钩子"></a>componentWillMount 钩子</h3><p><code>componentWillMount</code> 生命周期 “钩子” 在组件将要挂载时执行，也就是说在组件挂载前会调用 <code>componentWillMount</code>，整个组件的生命周期中只执行一次，一般用于发送当前组件需要的 <code>Ajax</code> 请求获取数据。</p><p>在 <code>React 16.3</code> 版本中标识了该 “钩子” 会被在未来版本中废弃，目前仍然可以使用，在 <code>componentWillMount</code> 的可以迁移到 <code>constructor</code>，但不能包含 <code>setState</code> 操作，因为 <code>constructor</code> 中无法调用 <code>setState</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="number">3</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br></pre></td></tr></table></figure><p>从上面的打印结果可以看出 <code>componentWillMount</code> “钩子” 的执行是晚于 <code>constructor</code> 的，从页面渲染 <code>3</code> 的结果来看，在 <code>componentWillMount</code> “钩子” 中已经可以使用 <code>setState</code> 更改状态了。</p><h3 id="render-钩子"><a href="#render-钩子" class="headerlink" title="render 钩子"></a>render 钩子</h3><p><code>render</code> 钩子的主要作用是返回组件内部要被渲染的 <code>JSX</code>，即所谓的挂载过程，将上面例子简单修改一下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br></pre></td></tr></table></figure><p>从打印结果可以看出 <code>constructor</code> 最先执行，其次是 <code>componentWillMount</code>，最后是 <code>render</code>，由于状态或属性的更新可能导致组件重新渲染，所以 <code>render</code> 可能会被执行多次。</p><h3 id="componentDidMount-钩子"><a href="#componentDidMount-钩子" class="headerlink" title="componentDidMount 钩子"></a>componentDidMount 钩子</h3><p><code>componentDidMount</code> 生命周期 “钩子” 在组件挂载后执行，一般会将一些依赖于 <code>DOM</code> 的操作放在该 “钩子” 内执行，整个生命周期只执行一次。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br></pre></td></tr></table></figure><p>执行顺序：<code>constructor</code> → <code>componentWillMount</code> → <code>render</code> → <code>componentDidMount</code>。</p><h3 id="componentWillUpdate-钩子"><a href="#componentWillUpdate-钩子" class="headerlink" title="componentWillUpdate 钩子"></a>componentWillUpdate 钩子</h3><p>在调用 <code>setState</code> 更新数据后会触发 <code>render</code> 钩子对组件重新渲染，在执行 <code>render</code> 前会调用 <code>componentWillUpdate</code> 钩子，即将要更新时执行（此时状态和页面都没更新），钩子默认有三个参数，分别为 <code>nextProps</code>、<code>nextState</code> 和 <code>nextContext</code>，即更新后的属性对象、状态对象和上下文对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextContext'</span>, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// nextContext &#123;&#125;</span></span><br><span class="line"><span class="comment">// render</span></span><br></pre></td></tr></table></figure><p>从执行点击事件后的结果来看，在重新渲染之前 <code>componentWillUpdate</code> 早于 <code>render</code> 执行，而在 <code>componentWillUpdate</code> 执行时 <code>state</code> 的状态还未更新。</p><h3 id="componentDidUpdate-钩子"><a href="#componentDidUpdate-钩子" class="headerlink" title="componentDidUpdate 钩子"></a>componentDidUpdate 钩子</h3><p>在调用 <code>setState</code> 更新数据后执行 <code>render</code> 钩子对组件重新渲染，渲染后会立即调用 <code>componentDidUpdate</code> 钩子，此时 <code>state</code> 状态和页面都已经更新，钩子默认有三个参数，分别为 <code>prevProps</code>、<code>prevState</code> 和 <code>prevContext</code>，即更新前的属性对象、状态对象和上下文对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevProps'</span>, prevProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevState'</span>, prevState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevContext'</span>, prevContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// prevProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// prevState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// prevContext &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>触发点击事件后的执行顺序为：<code>componentWillUpdate</code> → <code>render</code> → <code>componentDidUpdate</code>。</p><h3 id="shouldComponentUpdate-钩子"><a href="#shouldComponentUpdate-钩子" class="headerlink" title="shouldComponentUpdate 钩子"></a>shouldComponentUpdate 钩子</h3><p>在使用 <code>setState</code> 更改状态时，其实还会默默的执行 <code>shouldComponentUpdate</code> “钩子”，该钩子有返回值，不使用该 “钩子” 的情况下默认返回值为 <code>true</code>，若使用该 “钩子” 必须指定布尔类型的返回值 <code>true</code> 或 <code>false</code>，当返回值为 <code>true</code> 时代表更新状态和视图，否则不更新，只要使用 <code>setState</code> 就会触发该 “钩子”，该钩子有三个参数，与 <code>componentWillUpdate</code> “钩子” 相同。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextContext'</span>, nextContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// nextContext &#123;&#125;</span></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br></pre></td></tr></table></figure><p>当 <code>shouldComponentUpdate</code> “钩子” 返回值为 <code>true</code> 时，触发点击事件后的执行顺序为：<code>shouldComponentUpdate</code> → <code>componentWillUpdate</code> → <code>render</code> → <code>shouldComponentUpdate</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125; 不断更新</span></span><br></pre></td></tr></table></figure><p>当 <code>shouldComponentUpdate</code> “钩子” 返回值为 <code>false</code> 时，触发点击事件后只有 <code>shouldComponentUpdate</code> 执行了，并且随着触发点击事件的次数增加，<code>nextState</code> 参数的状态不断变化，但是 <code>state</code> 和页面都不更新。</p><h3 id="componentWillUnmount-钩子"><a href="#componentWillUnmount-钩子" class="headerlink" title="componentWillUnmount 钩子"></a>componentWillUnmount 钩子</h3><p><code>componentWillUnmount</code> “钩子” 会在组件卸载之前触发，卸载组件需调用 <code>ReactDOM</code> 的 <code>unmountComponentAtNode</code> 方法，并传入一个根节点，将会卸载这个根节点内部的所有组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 卸载组件</span></span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Kill&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUnmount</span></span><br></pre></td></tr></table></figure><p><code>componentWillUnmount</code> 钩子一般用来在卸载组件之前清除可能会调用 <code>setState</code> 的异步操作，为了防止在卸载组件后继续更新状态而报错。</p><h2 id="复合组件的生命周期"><a href="#复合组件的生命周期" class="headerlink" title="复合组件的生命周期"></a>复合组件的生命周期</h2><blockquote class="pullquote info"><p>上面着重介绍了单个类组件的生命周期，有的生命周期由于一个组件不容易演示，所以放在了这节中，这节也会将复合组件的生命周期执行顺序进行分析，并阐明一些使用的注意事项。</p></blockquote><h3 id="复合组件渲染生命周期的执行顺序"><a href="#复合组件渲染生命周期的执行顺序" class="headerlink" title="复合组件渲染生命周期的执行顺序"></a>复合组件渲染生命周期的执行顺序</h3><p>在复合组件中，父组件套着子组件，两个组件都有自己的生命周期，那么执行顺序会是怎么样的，看下面案例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-componentWillMount</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillMount</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-componentDidMount</span></span><br><span class="line"><span class="comment">// parent-componentDidMount</span></span><br></pre></td></tr></table></figure><p>从上面的执行顺序可以看出，在执行父组件生命周期的时候，执行 <code>render</code> 会渲染子组件，渲染子组件会将子组件的生命周期优先执行，等子组件完成渲染继续父组件的渲染，即继续执行父组件渲染后的生命周期。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num - <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-child&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击子组件更新按钮</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// clild-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击父组件更新按钮</span></span><br><span class="line"><span class="comment">// parent-componentWillUpdate</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// clild-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// parent-componentDidUpdate</span></span><br></pre></td></tr></table></figure><p>当子组件更新时，父组件不会重新渲染，只会执行子组件的生命周期，当父组件更新时，子组件也会重新渲染，此时当父组件执行 <code>render</code> 时会执行子组件更新相关的生命周期，在继续执行父组件更新相关的生命周期。</p><p>点击父组件更新按钮生命周期的执行顺序：<code>parent-componentWillUpdate</code> → <code>parent-render</code> → <code>child-componentWillUpdate</code> → <code>clild-render</code> → <code>child-componentDidUpdate</code> → <code>parent-componentDidUpdate</code>。</p><p>点击子组件更新按钮生命周期的执行顺序：<code>child-componentWillUpdate</code> → <code>clild-render</code> → <code>child-componentDidUpdate</code>。</p><blockquote class="pullquote warning"><p><em><strong>注意：如果更新父组件时，不希望子组件重新渲染，可以通过子组件的 <code>shouldComponentUpdate</code> “钩子” 将返回值设置为 <code>false</code> 的方式来控制。</strong></em></p></blockquote><h3 id="componentWillReceiveProps-钩子"><a href="#componentWillReceiveProps-钩子" class="headerlink" title="componentWillReceiveProps 钩子"></a>componentWillReceiveProps 钩子</h3><p>当传入组件的参数，即 <code>props</code> 发生变化时，<code>componentWillReceiveProps</code> “钩子” 执行，该钩子有一个参数，代表下一次更新的 <code>props</code> 对象，执行该 “钩子” 时，<code>props</code> 并没有更新，也就是说是在 <code>props</code> 变化之前执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillReceiveProps'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowProps, '</span><span class="keyword">this</span>.props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter n=&#123;<span class="keyword">this</span>.state.num&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-componentWillUpdate</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillReceiveProps</span></span><br><span class="line"><span class="comment">// nowProps &#123; n: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123; n: 1 &#125;</span></span><br><span class="line"><span class="comment">// child-shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// parent-componentDidUpdate</span></span><br></pre></td></tr></table></figure><p>点击父组件更新按钮后，父子组件生命周期的执行顺序如下：</p><p><code>parent-componentWillUpdate</code> → <code>parent-render</code> → <code>child-componentWillReceiveProps</code> → <code>child-shouldComponentUpdate</code> → <code>child-componentWillUpdate</code> → <code>child-render</code> → <code>child-componentDidUpdate</code> → <code>parent-componentDidUpdate</code>。</p><p>由此可以说明 <code>componentWillReceiveProps</code> 钩子在 <code>shouldComponentUpdate</code> 之前执行。</p><blockquote class="pullquote default"><p><em><strong>注意：<code>componentWillReceiveProps</code> “钩子” 在第一次渲染父子组件时不执行，在 <code>React 16.x</code> 版本中被标记为 “已废弃”。</strong></em></p></blockquote><h2 id="关于-setState-在生命周期中的使用"><a href="#关于-setState-在生命周期中的使用" class="headerlink" title="关于 setState 在生命周期中的使用"></a>关于 setState 在生命周期中的使用</h2><p>在 <code>React</code> 生命周期 “钩子” 中，只有 <code>componentWillMount</code>、<code>componentDidMount</code> 和 <code>componentWillReceiveProps</code> 中可以调用 <code>setState</code>。</p><p>原因是 <code>setState</code> 方法会触发 <code>render</code> “钩子” 执行，而 <code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>componentDidUpdate</code> 是在 <code>render</code> 后触发，包括在 <code>render</code> 中调用 <code>setState</code>，都会出现更新 “死循环” 的现象，最后造成堆栈溢出，而 <code>componentWillUnmount</code> “钩子” 执行时，组件将被卸载，在此时更新状态毫无意义。</p><blockquote class="pullquote warning"><p><em><strong>注意：在 <code>componentWillReceiveProps</code> 中使用 <code>setState</code>，其目的是为了将新更改的属性更新为该组件的状态，但 <code>React</code> 官方不建议这样使用。</strong></em></p></blockquote><h2 id="React-生命周期流程图"><a href="#React-生命周期流程图" class="headerlink" title="React 生命周期流程图"></a>React 生命周期流程图</h2><p>下面是一张关于目前版本比较常用的 <code>React</code> 生命周期 “钩子” 执行顺序的流程图，帮助大家快速理解 <code>React</code> 生命周期中各个钩子函数的执行过程。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/15/20180915194439/react-lifecycle-raw.png" alt="React 生命周期流程图" title>                </div>                <div class="image-caption">React 生命周期流程图</div>            </figure><p><br></p><h2 id="React-16-3-新增生命周期"><a href="#React-16-3-新增生命周期" class="headerlink" title="React 16.3 新增生命周期"></a>React 16.3 新增生命周期</h2><h3 id="getDerivedStateFromProps-静态方法"><a href="#getDerivedStateFromProps-静态方法" class="headerlink" title="getDerivedStateFromProps 静态方法"></a>getDerivedStateFromProps 静态方法</h3><p><code>getDerivedStateFromProps</code> 是一个类组件的静态方法，用来替代 <code>componentWillReceiveProps</code> “钩子”，在传入的属性变化之前执行，方法的参数与 <code>componentWillReceiveProps</code> 相同，是更新的属性对象，该方法要求必须返回一个状态对象的返回值，且使用该方法的组件必须含有 <code>state</code>，不能和 <code>componentWillMount</code> “钩子” 同时使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-getDerivedStateFromProps'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: nextProps.n &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter n=&#123;<span class="keyword">this</span>.state.num&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-getDerivedStateFromProps</span></span><br><span class="line"><span class="comment">// nextProps &#123; n: 1 &#125;</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>点击父组件的更新按钮钩子的执行顺序如下：<code>parent-render</code> → <code>child-render</code> → <code>child-getDerivedStateFromProps</code> → <code>child-componentDidUpdate</code>。</p><blockquote class="pullquote primary"><p><em><strong>注意：<code>getDerivedStateFromProps</code> 除了上面叙述的用法的注意事项，与 <code>componentWillReceiveProps</code> 相比还有两个优势，第一点是默认第一次渲染时也会执行该方法，第二点是不需要在通过调用 <code>setState</code> 将新的 <code>props</code> 转换成组件的状态，可以直接通过方法的返回值设置状态。</strong></em></p></blockquote><h3 id="getSnapshotBeforeUpdate-钩子"><a href="#getSnapshotBeforeUpdate-钩子" class="headerlink" title="getSnapshotBeforeUpdate 钩子"></a>getSnapshotBeforeUpdate 钩子</h3><p><code>getSnapshotBeforeUpdate</code> “钩子” 用于替代 <code>componentWillUpdate</code> “钩子”，不能与 <code>componentWillMount</code> “钩子” 同时使用，必须与 <code>componentDidUpdate</code> “钩子” 同时使用，需返回一个值或者 <code>null</code>，该值会传给 <code>componentWillUpdate</code> “钩子” 的第三个参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getSnapshotBeforeUpdate'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prop) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prop'</span>, prop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// getSnapshotBeforeUpdate</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// prop 123</span></span><br></pre></td></tr></table></figure><p>点击更新按钮执行顺序为：<code>render</code> → <code>getSnapshotBeforeUpdate</code> → <code>componentDidUpdate</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>以上就是关于 <code>React</code> 生命周期的内容，涵盖了在 <code>React</code> 开发中对生命周期大部分的应用，也是 <code>React</code> 知识体系中非常重要的部分，<code>React</code> 生命周期和 <code>Vue</code> 相比的特点是名字长，不容易记，希望大家在学习理解之后多巩固，孰能生巧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 基础篇 —— 带你走进 React 世界</title>
      <link href="/2018/09/10/20180910025959/"/>
      <url>/2018/09/10/20180910025959/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/10/20180910025959/react.png" title="React 16"><p><br></p><h2 id="React-介绍"><a href="#React-介绍" class="headerlink" title="React 介绍"></a>React 介绍</h2><blockquote class="pullquote default"><p><code>React</code> 是前端最流行的框架之一，由 Facebook 产出，由于其独特的 <code>JSX</code> 语法与组件化开发模式，将原本前端基于 <code>DOM</code> 的编程方式变成了基于组件和数据编程，给前端带来的益处是颠覆性的，因为我们知道 <code>DOM</code> 操作是 “昂贵” 的，<code>React</code> 在提高应用性能的同时又大大提高了开发效率，所以受到很多前端开发者的支持，也就有了庞大的生态，如今 <code>React</code> 已经成为前端工程师之必备技术栈。</p></blockquote><a id="more"></a><h2 id="创建-React-项目"><a href="#创建-React-项目" class="headerlink" title="创建 React 项目"></a>创建 React 项目</h2><p>在创建 <code>React</code> 项目时，可以使用当下最流行的脚手架 <code>create-react-app</code> 和 <code>generator-react-webpack</code>，前者是由 Facebook 官方出品，后者是第三方构建工具。</p><h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><p><code>create-react-app</code> 适用于大部分项目，集成了对 <code>React</code>、<code>JSX</code>、<code>ES6</code> 和 <code>Flow</code> 的支持，支持热更新，默认情况下无需对 <code>Webpack</code> 进行配置，如果要单独配置 <code>Webpack</code>，需要执行命令弹出配置项，下面命令分别对应安装脚手架工具、构建项目和弹出配置项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹射 Webpack 配置文件</span></span><br><span class="line">npm run eject</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：创建 <code>React</code> 项目时，项目名称不能含大写字母，使用 <code>eject</code> 命令弹出配置项的过程不可逆。</strong></em></p></blockquote><h3 id="generator-react-webpack"><a href="#generator-react-webpack" class="headerlink" title="generator-react-webpack"></a>generator-react-webpack</h3><p><code>generator-react-webpack</code> 适用于构建大型项目，它是需要 <code>yeoman</code> 的支持，几乎具备了 <code>create-react-app</code> 的全部功能，不同的是默认可以对 <code>Webpack</code> 进行配置，生成项目需要手动创建项目根目录，安装脚手架工具和构建项目的命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架及依赖</span></span><br><span class="line">npm install -g yo generator-react-webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目根目录</span></span><br><span class="line">mkdir project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目目录</span></span><br><span class="line"><span class="built_in">cd</span> project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">yo react-webpack</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>我们本次使用 <code>create-react-app</code> 来构建一个项目，并弹出配置项，<code>src</code> 目录为我们主要的开发文件，必须含有一个入口文件 <code>index.js</code>，所以我们在构建项目后删除 <code>src</code> 中的无用文件，目录结构如下（可以通过 <code>npm run start</code> 启动项目）。</p><p><pre>react-demo<br>  |- config<br>  | |- jest<br>  | | |- cssTransform.js<br>  | | |- fileTransform.js<br>  | |- env.js.js<br>  | |- paths.js<br>  | |- webpack.config.dev.js<br>  | |- webpack.config.prod.js<br>  | |- webpackDevServer.config.js<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- scripts<br>  | |- build.js<br>  | |- start.js<br>  | |- test.js<br>  |- src<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><h2 id="探索-React"><a href="#探索-React" class="headerlink" title="探索 React"></a>探索 React</h2><h3 id="引入-React-变量必须大写"><a href="#引入-React-变量必须大写" class="headerlink" title="引入 React 变量必须大写"></a>引入 React 变量必须大写</h3><p><code>React</code> 的核心模块分为两个，分别为 <code>react</code> 和 <code>react-dom</code>，前者为 <code>React</code> 的核心逻辑，后者为 <code>React</code> 的渲染逻辑，在 <code>React</code> 中规定引入 <code>react</code> 模块的变量名必须大写。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染到页面</span></span><br><span class="line">ReactDOM.render(h1, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>如果向上面代码中将引入 <code>react</code> 的变量小写，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error1.png" alt="React 变量错写报错" title>                </div>                <div class="image-caption">React 变量错写报错</div>            </figure><p><br></p><p>该报错信息的意思是当前使用了 <code>JSX</code>，必须要有一个大写的 <code>React</code>，从而可以看出这是 <code>React</code> 所规定的，当将接收 <code>react</code> 的变量改成大写后，页面正常渲染。</p><h3 id="React-必须有-createElement-方法"><a href="#React-必须有-createElement-方法" class="headerlink" title="React 必须有 createElement 方法"></a>React 必须有 createElement 方法</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个大写的 React 对象</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>为了进一步验证，上面代码中创建一个名为 <code>React</code> 的对象，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error2.png" alt="React 没有 createElement 方法报错" title>                </div>                <div class="image-caption">React 没有 createElement 方法报错</div>            </figure><p><br></p><p>这个报错非常明显的在告诉我们，<code>React</code> 对象中缺少了 <code>createElement</code> 方法，我们将代码修改如下后发现报错信息消失。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个大写的 React 对象</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  createElement() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>页面 “白屏” 是因为并没有使用 <code>react-dom</code> 进行渲染，我们定义的 <code>h1</code> 是一个组件，同时也是 <code>JSX</code>，所以会调用 <code>createElement</code> 对 <code>JSX</code> 进行解析。</p><h3 id="解析后的-JSX-长什么样"><a href="#解析后的-JSX-长什么样" class="headerlink" title="解析后的 JSX 长什么样"></a>解析后的 JSX 长什么样</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 JSX 解析后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(h1);</span><br></pre></td></tr></table></figure><p>打开 Chorme 浏览器控制台查看打印结果如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/virtualDOM.png" alt="JSX 解析后的虚拟 DOM 结构" title>                </div>                <div class="image-caption">JSX 解析后的虚拟 DOM 结构</div>            </figure><p><br></p><p>从结果可以看出 <code>createElement</code> 方法最终将 <code>JSX</code> 解析成了一个对象结构，其中 <code>props</code> 带表属性对象，其中的 <code>children</code> 代表子元素，也就是文本节点 <code>hello world</code>，<code>type</code> 代表标签类型为 <code>h1</code>，这样用来表述 <code>DOM</code> 结构的对象被称为虚拟 <code>DOM</code>。</p><h3 id="模拟解析和渲染过程"><a href="#模拟解析和渲染过程" class="headerlink" title="模拟解析和渲染过程"></a>模拟解析和渲染过程</h3><p>在上面我们知道了 <code>React</code> 可以自动将 <code>JSX</code> 转换成虚拟 <code>DOM</code>，而 <code>ReactDOM</code> 的 <code>render</code> 方法将虚拟 <code>DOM</code> 渲染成了真实的 <code>DOM</code>，用法如下。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  hello</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染到页面</span></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>查看页面可以看到正常渲染了，现在就用前面对 <code>React</code> 的了解来简单模拟解析与渲染的过程，代码如下。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 React 对象和 createElement 方法</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  createElement(type, props, ...children) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; type, props, children &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  hello</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染的 render 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是字符串说明是文本节点，创建文本节点并插入到父元素中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> container.appendChild(<span class="built_in">document</span>.createTextNode(vnode));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是字符串说明是元素节点，解构元素类型、属性和子元素的数组</span></span><br><span class="line">  <span class="keyword">let</span> &#123; type, props, children &#125; = vnode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建元素</span></span><br><span class="line">  <span class="keyword">let</span> tag = <span class="built_in">document</span>.createElement(type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环添加属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    tag.getAttribute(key, props[key]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环子元素，并递归创建子元素</span></span><br><span class="line">  children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    render(child, tag);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将元素插入到容器中，root</span></span><br><span class="line">  container.appendChild(tag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染虚拟 DOM</span></span><br><span class="line">render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>通过上面实现的代码同样可以完成渲染，当然仅限于简单结构，<code>React</code> 内部的实现更为复杂，兼容了多种组件类型和复杂的 <code>DOM</code> 结构。</p><h3 id="JSX-最外层只能有一个元素"><a href="#JSX-最外层只能有一个元素" class="headerlink" title="JSX 最外层只能有一个元素"></a>JSX 最外层只能有一个元素</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在对上面代码中的 <code>JSX</code> 进行渲染时会有如下报错信息。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error3.png" alt="JSX 没有唯一父元素包裹报错" title>                </div>                <div class="image-caption">JSX 没有唯一父元素包裹报错</div>            </figure><p><br></p><p>上面的报错信息告诉我们 <code>JSX</code> 元素必须包裹在一个闭合的标签内，所以说在写 <code>JSX</code> 语法的时候我们必须保证最外层只有一个元素节点。</p><h2 id="React-的基本使用"><a href="#React-的基本使用" class="headerlink" title="React 的基本使用"></a>React 的基本使用</h2><p>在 <code>JSX</code> 全称为 <code>JavaScript XML</code>，但是和普通的 <code>HTML</code> 相比，有一些不同的用法，如元素属性 <code>class</code>、<code>for</code>、<code>style</code>、<code>dangerouslyInnerHTML</code> 以及注释写法等等。</p><h3 id="className-属性"><a href="#className-属性" class="headerlink" title="className 属性"></a>className 属性</h3><p>在 <code>JSX</code> 语法中，在标签中应使用 <code>className</code> 替代 <code>HTML</code> 中的 <code>class</code> 属性，因为在 JavaScript 中 <code>class</code> 为关键字。</p><figure class="highlight jsx"><figcaption><span>class 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"active"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><h3 id="htmlFor-属性"><a href="#htmlFor-属性" class="headerlink" title="htmlFor 属性"></a>htmlFor 属性</h3><p>在 <code>HTML</code> 中，通过点击 <code>label</code> 标签让 <code>input</code> 输入框获取焦点是很常见的，只需要让 <code>label</code> 标签 <code>for</code> 属性的值与 <code>input</code> 标签的 <code>id</code> 值相等即可，但是在 <code>JSX</code> 中这这样的写法会报错，必须将 <code>label</code> 标签的 <code>for</code> 属性使用 <code>htmlFor</code> 替代，代码如下。</p><figure class="highlight jsx"><figcaption><span>for 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;label htmlFor="username"&gt;用户名&lt;/</span>label&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h3><figure class="highlight jsx"><figcaption><span>style 属性错误的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: red;"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在 <code>JSX</code> 中关于 <code>style</code> 属性的写法发生了变化，如果用 <code>HTML</code> 中的写法会报错，错误信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error4.png" alt="JSX 中 style 属性错误写法报错" title>                </div>                <div class="image-caption">JSX 中 style 属性错误写法报错</div>            </figure><p><br></p><p>报错信息中明确的告诉我们 <code>style</code> 属性必须是一个含有代表样式键值的对象，而不是一个字符串，并给出正确的结构，正确的写法如下。</p><figure class="highlight jsx"><figcaption><span>style 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> '<span class="attr">red</span>'&#125;&#125;&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：在解析 <code>JSX</code> 的过程中，<code>&lt;</code> 和 <code>&gt;</code> 包裹 <code>JSX</code> 元素，元素属性中最外层的 <code>{</code> 和 <code>}</code> 包裹 <code>JS</code> 代码，而内层的 <code>{</code> 和 <code>}</code> 则代表一个 <code>JS</code> 对象，所以 <code>style</code> 是被两层 “花括号” 所包裹，并不是 <code>mustache</code> 语法。</strong></em></p></blockquote><h3 id="取值表达式"><a href="#取值表达式" class="headerlink" title="取值表达式"></a>取值表达式</h3><p>在 <code>JSX</code> 中，所有的 <code>JS</code> 代码都可以写在 <code>JSX</code> 元素起始和闭合标签中间的 <code>{</code> 和 <code>}</code> 内，会将执行结果渲染到该元素上。</p><figure class="highlight jsx"><figcaption><span>取值表达式的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &lt;p&gt;hello&lt;<span class="regexp">/p&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let el = (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;&#123;fn()&#125;&lt;/</span>h1&gt;</span><br><span class="line">    &lt;div&gt;&#123;str&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&#123;JSON.stringify(obj)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;div&gt;&#123;<span class="literal">true</span> ? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>nihao<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>启动项目可以看到页面上已经成功的渲染了 <code>hello</code>、<code>world</code>、<code>{ hello: &#39;world&#39; }</code> 和 <code>nihao</code>，上面三元运算符结果如果为 <code>null</code> 则不会渲染这个节点，<code>viod 0</code> 与 <code>null</code> 作用相同。</p><h3 id="dangerouslySetInnerHTML-属性"><a href="#dangerouslySetInnerHTML-属性" class="headerlink" title="dangerouslySetInnerHTML 属性"></a>dangerouslySetInnerHTML 属性</h3><p>在 <code>JSX</code> 中，如果想要把一个含有标签元素的字符串插入到某一个节点中，应该使用 <code>dangerouslySetInnerHTML</code> 替代原生 <code>JS</code> 中的 <code>innerHTML</code>。</p><figure class="highlight jsx"><figcaption><span>dangerouslySetInnerHTML 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'&lt;h1&gt;hello&lt;/h1&gt;'</span>;</span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> <span class="attr">str</span>&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>dangerouslySetInnerHTML</code> 属性的值为对象，将要插入的 <code>HTML</code> 字符串作为对象中 <code>__html</code> 属性的值即可，设置 <code>dangerouslySetInnerHTML</code> 属性的 <code>JSX</code> 元素中不能有任何的子元素。</p><blockquote class="pullquote danger"><p><em><strong>注意：<code>dangerouslySetInnerHTML</code> 属性非常危险，容易引发 <code>XSS</code> 攻击，轻易不要使用。</strong></em></p></blockquote><h3 id="JSX-中注释的写法"><a href="#JSX-中注释的写法" class="headerlink" title="JSX 中注释的写法"></a>JSX 中注释的写法</h3><p>在 <code>JSX</code> 的 <code>DOM</code> 结构中，如果需要对代码进行注释不能使用 <code>JS</code> 中的 <code>// 注释</code>，也不能使用 <code>HTML</code> 中的 <code>&lt;!-- 注释 --&gt;</code>，注释必须使用 <code>{ }</code> 包裹，写法如下。</p><figure class="highlight jsx"><figcaption><span>注释在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 name=<span class="string">"hi"</span>&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* 这是注释，支持多行 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;world&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="Fragment-组件"><a href="#Fragment-组件" class="headerlink" title="Fragment 组件"></a>Fragment 组件</h3><p>在 <code>React 16.3</code> 中提供了一个组件，类似于原生 <code>JS</code> 中的文档碎片，可以将多个元素包裹起来，却不会被渲染，用法如下。</p><figure class="highlight jsx"><figcaption><span>Fragment 组件的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;world&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="循环动态创建-JSX-结构"><a href="#循环动态创建-JSX-结构" class="headerlink" title="循环动态创建 JSX 结构"></a>循环动态创建 JSX 结构</h3><p>在 <code>React</code> 中不存在过多的 API，最大的特点就是 <code>JSX</code> 语法可以将 <code>JS</code> 与 <code>HTML</code> 混写，借助原生 <code>JS</code> 的方法实现功能，比如可以使用循环创建 <code>JSX</code> 结构。</p><figure class="highlight jsx"><figcaption><span>循环在 JSX 中的应用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><p><strong>上面成功的渲染除了一个列表，但是有两点需要注意：</strong></p><ul><li>第一点是循环一定要使用具有返回值的方法，如 <code>map</code>、<code>filter</code> 等；</li><li>第二点是每一个循环出来的 <code>JSX</code> 元素必须绑定一个 <code>key</code> 属性，可以使用数据的 <code>id</code>（优先），也可以使用数组的索引。</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote class="pullquote info"><p>在上面所有代码中的 <code>JSX</code> 都很不优雅，如果一个项目非常大，这样的混乱的结构是难以维护的，组件就是为了更好的维护和复用相同的 <code>JSX</code> 结构以及提高工作效率而存在的。</p></blockquote><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>在 <code>React</code> 中可以通过函数创建组件，函数名称就是组件名，必须大写，必须有返回值，可以为 <code>JSX</code>，也可以为 <code>null</code>，通过单闭合和双闭合两种方式调用组件，可以通过属性传参，并通过函数组件的第一个参数接收，实现代码如下。</p><figure class="highlight jsx"><figcaption><span>函数组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Build</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;props.content&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render((</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Build title="1" content="1xx"&gt;&lt;/</span>Build&gt; &#123;<span class="comment">/* 双闭合 */</span>&#125;</span><br><span class="line">    &lt;Build title=<span class="string">"2"</span> content=<span class="string">"2xx"</span>/&gt; &#123;<span class="comment">/* 单闭合 */</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">), window.root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><em><strong>缺点 1：在函数组件内部 <code>this</code> 为 <code>undefined</code>；</strong></em><br><em><strong>缺点 2：在函数组件内部没有状态，即只能使用通过属性传递的参数，却没有更改的能力；</strong></em><br><em><strong>缺点 3：函数组件没有生命周期，无法使用生命周期 “钩子” 完成一些操作。</strong></em></p></blockquote><p>由于函数组件的缺陷，所以更适合渲染一些静态的不需要数据变化的结构，如果想要让传入的属性变化可以通过不断执行 <code>React.render</code> 的方式不断更新传入组件参数的值，下面是一个时钟案例，通过函数组件实现时间的变化。</p><figure class="highlight jsx"><figcaption><span>函数组件多次渲染</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;当前时间&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;props.time&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 每秒渲染一次组件</span></span><br><span class="line"><span class="regexp">setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Clock time=&#123;new Date().toLocaleString()&#125;/</span>&gt;,</span><br><span class="line">    <span class="built_in">window</span>.root</span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>类组件解决了函数组件所有的缺陷，是通过类声明的。</p><figure class="highlight jsx"><figcaption><span>类组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constructor(props) &#123;</span></span><br><span class="line">  <span class="comment">//   super(props);</span></span><br><span class="line">  <span class="comment">//   this.state = &#123;</span></span><br><span class="line">  <span class="comment">//     time: new Date().toLocaleString();</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等价于 constructor 的写法，更简洁</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染组件</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的类组件中，我们同样使用了一个简单的时钟功能，可以看出类组件即有 <code>this</code>，又能创建和更新状态，也可以通过生命周期进行一些操作。</p><p>所有的类组件都需要继承 <code>React.Component</code>，这样就可以使用 <code>React.Component</code> 的原型方法 <code>setState</code> 对状态进行更新，每次更新，都会使组件重新渲染，但是只会重新渲染变化的 <code>DOM</code>，这是 <code>ReactDOM</code> 通过 <code>diff</code> 算法所做的优化。</p><h3 id="类组件中添加事件"><a href="#类组件中添加事件" class="headerlink" title="类组件中添加事件"></a>类组件中添加事件</h3><p>在平时开发中每个组件都会有一些对应的功能，这就需要事件的配合，在类组建中绑定事件大概有四种方式，我们还是用上面的时钟案例，给该组件添加一个按钮，在点击时卸载这个组件。</p><figure class="highlight jsx"><figcaption><span>方式 1：使用箭头函数直接绑定事件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ 卸载组件的方法</span></span><br><span class="line"><span class="regexp">          ReactDOM.unmountComponentAtNode(window.root);</span></span><br><span class="line"><span class="regexp">        &#125;&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>方式 2：使用 bind 绑定函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面两种方式都有一个共同的问题，箭头函数的方式在每次执行 <code>render</code> 时都会创建新的箭头函数，而将函数作为原型方法，通过 <code>bind</code> 是为了修正方法内部的 <code>this</code> 指向，但是每次执行 <code>render</code> 时，<code>bind</code> 也会返回一个新的函数。</p><figure class="highlight jsx"><figcaption><span>方式 3：在方式 2 的基础上提前生成函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.fn = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.fn&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>这样就解决了上面每次执行 <code>render</code> 就创建新函数的问题，但是这样的写法并不优雅，又产生了新的问题，所有的事件执行函数全都添加到了组件的实例上，而且代码会随着事件的增加而越来越乱。</p><figure class="highlight jsx"><figcaption><span>方式 4：使用 ES7 语法将原型方法使用箭头函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>ES7</code> 的新语法，既解决了事件处理函数方法内部 <code>this</code> 指向问题，又解决了每次执行 <code>render</code> 创建新函数的问题。</p><h3 id="卸载组件后不能再更新状态"><a href="#卸载组件后不能再更新状态" class="headerlink" title="卸载组件后不能再更新状态"></a>卸载组件后不能再更新状态</h3><p>还是上面的时钟案例，我们知道卸载一个组件应该使用 <code>ReactDOM.unmountComponentAtNode</code> 方法，参数一个组件，执行后会卸载这个组件内部所有的组件。</p><p>当真正点击时钟组件的按钮去卸载组件，组件虽然成功卸载了，但是控制台报错了，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error5.png" alt="卸载组件后更新状态报错" title>                </div>                <div class="image-caption">卸载组件后更新状态报错</div>            </figure><p><br></p><p>这个报错信息的意思是告诉我们在组件卸载后不能再通过 <code>setState</code> 更新状态，所以我们要在组件卸载之前先清空调用 <code>setState</code> 的定时器，代码修改如下。</p><figure class="highlight jsx"><figcaption><span>完整的时钟组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件将要卸载时清空定时器</span></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在这个组件中用到了两个生命周期 “钩子”，<code>componentDidMount</code> 钩子在组件挂载后执行，类似于原生 <code>JS</code> 的 <code>window.onload</code>，<code>componentWillUnmount</code> 钩子在组件将要卸载之前执行，后面会涉及更多生命周期钩子，我们会在这个 <code>React</code> 基础篇系列文章中一一说明。</p><h3 id="类组件的参数传递"><a href="#类组件的参数传递" class="headerlink" title="类组件的参数传递"></a>类组件的参数传递</h3><figure class="highlight jsx"><figcaption><span>类组件传参第一种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;this.props.age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 分别传入想要的属性</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>类组件传参第二种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 传入整个对象</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person &#123;...p&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面两种传参方式第一种是将对象中希望传入的属性传递给组件，第二种方式是将整个对象通过解构的方式直接传递给组件，而组件中可以在 <code>constructor</code> 中的第一个参数接收 <code>props</code>，也可以直接使用 <code>this.props</code>，因为 <code>React</code> 在组件创建实例调用 <code>super</code> 之前就已经将 <code>props</code> 作为了实例属性。</p><h3 id="组件参数的类型校验"><a href="#组件参数的类型校验" class="headerlink" title="组件参数的类型校验"></a>组件参数的类型校验</h3><p>在 <code>React</code> 组件传递参数时，是通过 <code>props</code> 取出传入的参数直接使用，传入的值类型并没有做任何的校验，这就可能造成传参时出现错误，在 <code>React</code> 生态中有一个第三方模块 <code>prop-types</code> 可以规定参数的类型，并对传入的参数进行校验，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prop-types</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用 prop-types 校验传给组件的参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123;</span><br><span class="line">  name: <span class="string">'panda'</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  gender: <span class="string">'男'</span>,</span><br><span class="line">  hobby: [<span class="string">'basketball'</span>, <span class="string">'swim'</span>],</span><br><span class="line">  pos: &#123; <span class="attr">x</span>: <span class="number">433</span>, <span class="attr">y</span>: <span class="number">822</span> &#125;,</span><br><span class="line">  salary: <span class="number">5000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义默认属性，React 自带</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name: <span class="string">'shen'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义属性类型</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired, <span class="comment">// 类型必须为字符串，必填项</span></span><br><span class="line">    age: PropTypes.number, <span class="comment">// 类型必须为数字</span></span><br><span class="line">    gender: PropTypes.oneOf([<span class="string">'男'</span>, <span class="string">'女'</span>]), <span class="comment">// 性别只能为男或女</span></span><br><span class="line">    hobby: PropTypes.arrayOf(PropTypes.string), <span class="comment">// 数组成员类型必须是字符串</span></span><br><span class="line">    pos: PropTypes.shape(&#123; <span class="comment">// 限制模型内部类型</span></span><br><span class="line">      x: PropTypes.number.isRequired,</span><br><span class="line">      y: PropTypes.number.isRequired</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数为原对象，第二个参数为当前属性，第三个参数为类</span></span><br><span class="line">    salary(obj, key, P) &#123;</span><br><span class="line">      <span class="comment">// 自行校验</span></span><br><span class="line">      <span class="keyword">if</span> (obj[key] &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'工资太低'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person &#123;...p&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>prop-types</code> 必须在类组件上添加一个静态属性 <code>propTypes</code>，在内部定义属性的类型，其中 <code>isRequired</code> 为必填项，如果没有传参会报错，在检测是会优先检测 <code>React</code> 的静态属性 <code>defaultProps</code>，即默认属性，如果 <code>defaultProps</code> 存在则视为已经有该参数。</p><p><code>oneOf</code> 方法参数为一个数组，传给组件对应的参数值必须是传给 <code>oneOf</code> 数组中的其中一项，否则会报错，<code>arrayOf</code> 方法用于限制数组成员的类型，<code>shape</code> 方法用于限属性值为对象的内部属性类型，参数为对象。</p><p>在 <code>propTypes</code> 静态属性中以传入的属性名作为方法名，则该方法为自定义校验该属性的函数，参数的前三项为原对象，属性名和所属类，可以在函数内部自行实现校验逻辑。</p><h3 id="setState-更新状态"><a href="#setState-更新状态" class="headerlink" title="setState 更新状态"></a>setState 更新状态</h3><p>在前面的时钟组件中已经简单的使用过 <code>setState</code>，在这里我们会对 <code>setState</code> 的用法通过一个计数器案例来做详细说明。</p><figure class="highlight jsx"><figcaption><span>计数器案例 1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的计数器中，当我们点击按钮时会执行 <code>handleClick</code>，而在 <code>handleClick</code> 内部调用了两次 <code>setState</code> 更新状态，但是我们启动项目后发现只有一次是有效的，这也说明了一个问题，<code>setState</code> 是异步执行的，最后一次执行的会覆盖前一次，其实在 <code>setState</code> 方法调用时支持传入一个回调函数，代码如下。</p><figure class="highlight jsx"><figcaption><span>计数器案例 2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>setState</code> 传入的回调会在更新状态成功后执行，所以将代码修改后两次 <code>setState</code> 都生效了，<code>render</code> 执行了两次，这样的写法如果调用 <code>setState</code> 次数多了就形成了 “回调地狱”，<code>setState</code> 还有另一种用法如下。</p><figure class="highlight jsx"><figcaption><span>计数器案例 3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123; <span class="attr">num</span>: prevState.num + <span class="number">1</span> &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123; <span class="attr">num</span>: prevState.num + <span class="number">1</span> &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>setState</code> 方法可直接传入一个函数，函数的参数为上一次更新的 <code>state</code>，也就是 <code>this.state</code>，此时执行 <code>setState</code> 只更新状态，不重新渲染，当最后一次更新状态后统一渲染一次。</p><blockquote class="pullquote info"><p><em><strong>更新组件有两种方式，一种是重新调用 <code>render</code> 并传入新的属性值，一种是通过组件调用 <code>setState</code> 重新设置状态。</strong></em></p></blockquote><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>对于组件的分类除了可以按照组件的创建方式分为函数组件和类组件，还有另外一种分类方式，就是受控组件和非受控组件，简单来说 “受控” 和 “非受控” 就是指是否受到状态的控制，这种分类方式多用于表单元素，同时也指对于表单元素数据的不同处理方式。</p><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>下面是一个受控组件的写法，输入框的初始值是通过 <code>value</code> 和 <code>defaultValue</code> 属性绑定的状态的值。</p><figure class="highlight jsx"><figcaption><span>受控组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg1: <span class="string">'hello'</span>,</span><br><span class="line">    msg2: <span class="string">'world'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.msg1&#125;/&gt; &#123;<span class="comment">/* 报错 */</span>&#125;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> defaultValue=&#123;<span class="keyword">this</span>.state.msg2&#125;/&gt; &#123;<span class="comment">/* 不报错 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面的代码中是两种绑定初始值的方式，使用 <code>defaultValue</code> 属性可以正常的将状态中的属性作为初始值绑定到页面的输入框内，但是随着输入的变化并没更新状态的作用，而使用 <code>value</code> 做了同样的绑定后，虽然页面正常显示初始值，但是控制台报错了，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error6.png" alt="受控组件赋初始值报错" title>                </div>                <div class="image-caption">受控组件赋初始值报错</div>            </figure><p><br></p><p>输入框的值可以通过输入改变，但受控组件要求状态的值要随着输入框内的值改变而更新，而报错信息告诉我们想要达到这样的目的必须要给表单元素绑定一个 <code>onChange</code> 事件，这个功能其实就是输入框与数据的双向绑定，修改后的实现如下。</p><figure class="highlight jsx"><figcaption><span>受控组件 —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeHandler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">msg</span>: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面的代码中在 <code>onChange</code> 事件中调用了 <code>setState</code> 并更新了状态，但是如果有多个输入框，要保证 <code>onChange</code> 事件的复用，实现不同的输入框输入时 <code>onChange</code> 事件时更新不同的状态，实现如下。</p><figure class="highlight jsx"><figcaption><span>受控组件 —— 多个输入框复用 onChange</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg1: <span class="string">'hello'</span>,</span><br><span class="line">    msg2: <span class="string">'world'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeHandler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = e.target.name;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; [val]: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"msg1"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg1&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg1&#125;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"msg2"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg2&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg2&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面通过给 <code>input</code> 标签添加和状态的变量名相同的 <code>name</code> 属性，在触发 <code>onChange</code> 事件时用 <code>name</code> 属性作为更新状态数据的键值。</p><blockquote class="pullquote default"><p><em><strong>受控组件的好处是，可以实时对输入框输入的值进行校验，并可以随着输入框的内容更新而更新状态，进而更新视图。</strong></em></p></blockquote><h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p>非受控组件与受控组件相比就是直接操作 <code>DOM</code> 来操作表单元素，直接操作 <code>DOM</code> 可以在 <code>componentDidMount</code> 生命周期内（DOM 完全挂载），写法如下。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— 直接操作 DOM（不建议）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>);</span><br><span class="line">    username.value = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(username.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;UnControl&gt;&lt;/</span>UnControl&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>当然在 <code>React</code> 中并不会这么写，<code>React</code> 专门给我们提供了操作 <code>DOM</code> 属性 <code>ref</code>，用法如下。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— ref 常用写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 打印输入框的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.userDom.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span> ref=&#123;dom =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.userDom = dom;</span><br><span class="line">        &#125;&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">UnControl</span>&gt;</span><span class="tag">&lt;/<span class="name">UnControl</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>ref</code> 属性的方式通常会在其中传入一个函数，这个函数的参数就是当前表单元素对应的 <code>DOM</code>，通常情况下会使用类组件的一个属性来存储这个 <code>DOM</code>，方便在其他的事件或生命周期 “钩子” 中使用。</p><p>在 <code>React 16.3</code> 中推出了操作非受控组件的新的 API <code>React.createRef</code> 方法，返回值是一个对象，将这个对象绑定在表单元素的 <code>ref</code> 上，则可以通过这个对象的 <code>current</code> 属性获取这个表单元素的 <code>DOM</code> 元素。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— React 16.3 新 API</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  userDom = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 打印输入框的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.userDom.current.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span> ref=&#123;<span class="keyword">this</span>.userDom&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">UnControl</span>&gt;</span><span class="tag">&lt;/<span class="name">UnControl</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>我们其实把 <code>React.createRef</code> 的返回值存储为了类组件的一个属性，并将这个属性传入 <code>ref</code>，这样可以在其他的事件或生命周期 “钩子” 中操作 <code>DOM</code>，如果存在多个这样的表单元素，许多次调用 <code>React.createRef</code>，并分别将存储返回值的类组件属性传入各个表单的 <code>ref</code> 中。</p><blockquote class="pullquote warning"><p><em><strong>非受控组件的好处是，操作 <code>DOM</code> 方便，可以与更多基于 <code>DOM</code> 操作的第三方库结合。</strong></em></p></blockquote><h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><p>复合组件指的就是存在父子关系的组件嵌套，在 <code>React</code> 中有两种形式的父子组件嵌套，第一种是直接将子组件在父组件中引入，并放在父组件 <code>render</code> 方法返回的 <code>JSX</code> 中。</p><figure class="highlight jsx"><figcaption><span>复合组件 —— 第一种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是父组件</span><br><span class="line">        &lt;Child/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件</span></span><br><span class="line"><span class="regexp">class Child extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;这是子组件&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>我们前面提到过组件可以通过单闭合或者双闭合的方式调用，第二种方式就是利用双闭合的调用方式，在父组件中引入子组件，把父组件中某些 <code>JSX</code> 放在双闭合的子组件标签中，作为参数传递给子组件，在子组件中通过 <code>props</code> 的 <code>children</code> 属性进行接收，并放入对应的位置。</p><figure class="highlight jsx"><figcaption><span>复合组件 —— 第二种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是父组件</span><br><span class="line">        &lt;Child&gt;</span><br><span class="line">          &lt;div&gt;父组件传递给子组件的 JSX&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Child&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件</span></span><br><span class="line"><span class="regexp">class Child extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        这是子组件</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>这是系列关于 <code>React</code> 基础的文章，本篇是关于 <code>React</code> 的一些基础知识，也包含了一些 <code>React 16</code> 版本的一些新增内容，比较适合不了解 <code>React</code> 框架的同学们从零开始入门，在后面会陆续更新关于复合组件参数传递、生命周期等内容。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型检测 </tag>
            
            <tag> ES7 </tag>
            
            <tag> React </tag>
            
            <tag> 脚手架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koa2 洋葱模型 —— compose 串联中间件的四种实现</title>
      <link href="/2018/09/06/20180906170854/"/>
      <url>/2018/09/06/20180906170854/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/06/20180906170854/compose-logo.png" title="Koa 洋葱模型"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Koa</code> 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 <code>Express</code> 支持了异步，所以编码时经常使用 <code>async/await</code>，提高了可读性，使代码变得更优雅，上一篇文章 <a href="https://www.overtaking.top/2018/09/02/20180902141819/" target="_blank">NodeJS 进阶 —— Koa 源码分析</a>，也对 “洋葱模型” 和实现它的 <code>compose</code> 进行分析，由于个人觉得 <code>compose</code> 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 <code>compose</code>。</p></blockquote><a id="more"></a><h2 id="洋葱模型案例"><a href="#洋葱模型案例" class="headerlink" title="洋葱模型案例"></a>洋葱模型案例</h2><p>如果你已经使用 <code>Koa</code> 对 “洋葱模型” 这个词一定不陌生，它就是 <code>Koa</code> 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面的写法我们按照官方推荐，使用了 <code>async/await</code>，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 <code>next</code>，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 <code>Koa</code> 源码中，这一功能是靠一个 <code>compose</code> 方法实现的，我们本文四种实现 <code>compose</code> 的方式中实现同步和异步，并附带对应的案例来验证。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在真正创建 <code>compose</code> 方法之前应该先做些准备工作，比如创建一个 <code>app</code> 对象来顶替 <code>Koa</code> 创建出的实例对象，并添加 <code>use</code> 方法和管理中间件的数组 <code>middlewares</code>。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Koa 创建的实例</span></span><br><span class="line"><span class="keyword">const</span> app = &#123;</span><br><span class="line">  middlewares: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 use 方法</span></span><br><span class="line">app.use = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  app.middlewares.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.compose.....</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><p>上面的模块中导出了 <code>app</code> 对象，并创建了存储中间件函数的 <code>middlewares</code> 和添加中间件的 <code>use</code> 方法，因为无论用哪种方式实现 <code>compose</code> 这些都是需要的，只是 <code>compose</code> 逻辑的不同，所以后面的代码块中会只写 <code>compose</code> 方法。</p><h2 id="Koa-中-compose-的实现方式"><a href="#Koa-中-compose-的实现方式" class="headerlink" title="Koa 中 compose 的实现方式"></a>Koa 中 compose 的实现方式</h2><p>首先介绍的是 <code>Koa</code> 源码中的实现方式，在 <code>Koa</code> 源码中其实是通过 <code>koa-compose</code> 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 <code>compose</code> 的原理，所以 <code>ctx</code> 参数就被去掉了，因为我们不会使用它，重点是 <code>next</code> 参数。</p><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所有中间件都执行完跳出</span></span><br><span class="line">    <span class="keyword">if</span> (index === app.middlewares.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第 index 个中间件并执行</span></span><br><span class="line">    <span class="keyword">const</span> route = app.middlewares[index];</span><br><span class="line">    <span class="keyword">return</span> route(<span class="function"><span class="params">()</span> =&gt;</span> dispatch(++index));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出第一个中间件函数执行</span></span><br><span class="line">  dispatch(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是同步的实现，通过递归函数 <code>dispatch</code> 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 <code>dispatch</code>，传入的参数 <code>+1</code>，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 <code>1 3 5 6 4 2</code> 的情况执行，测试例子如下（同步上、异步下）。</p><figure class="highlight js"><figcaption><span>文件：sync-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">"./app"</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：async-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">"./app"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> fn(); <span class="comment">// 调用异步函数</span></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose();</span><br></pre></td></tr></table></figure><p>我们发现如果案例中按照 <code>Koa</code> 的推荐写法，即使用 <code>async</code> 函数，都会通过，但是在给 <code>use</code> 传参时可能会传入普通函数或 <code>async</code> 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 <code>Koa</code> 中 <code>compose</code> 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。</p><blockquote class="pullquote warning"><p><em><strong>注意：后面 <code>compose</code> 的其他实现方式中，都是使用 <code>sync-test.js</code> 和 <code>async-test.js</code> 验证，所以后面就不再重复了。</strong></em></p></blockquote><h3 id="升级为支持异步"><a href="#升级为支持异步" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所有中间件都执行完跳出，并返回一个 Promise</span></span><br><span class="line">    <span class="keyword">if</span> (index === app.middlewares.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第 index 个中间件并执行</span></span><br><span class="line">    <span class="keyword">const</span> route = app.middlewares[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行后返回成功态的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(<span class="function"><span class="params">()</span> =&gt;</span> dispatch(++index)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出第一个中间件函数执行</span></span><br><span class="line">  dispatch(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>async</code> 函数中 <code>await</code> 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 <code>async-test.js</code> 进行测试，发现结果为 <code>1 3 hello(3s后) 5 6 4 2</code>。</p><h2 id="Redux-旧版本-compose-的实现方式"><a href="#Redux-旧版本-compose-的实现方式" class="headerlink" title="Redux 旧版本 compose 的实现方式"></a>Redux 旧版本 compose 的实现方式</h2><h3 id="同步的实现-1"><a href="#同步的实现-1" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> app.middlewares.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> () =&gt; b(a), () =&gt; &#123;&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 <code>middlewares</code> 中存储的三个中间件函数分别为 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于使用的是 <code>reduceRight</code> 方法，所以是逆序归并，第一次 <code>a</code> 代表初始值（空函数），<code>b</code> 代表 <code>fn3</code>，而执行 <code>fn3</code> 返回了一个函数，这个函数再作为下一次归并的 <code>a</code>，而 <code>fn2</code> 作为 <code>b</code>，依次类推，过程如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)));</span><br></pre></td></tr></table></figure><p>由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 <code>fn1</code>，如果调用 <code>next</code> 则会执行 <code>fn2</code>，如果同样调用 <code>next</code> 则会执行 <code>fn3</code>，<code>fn3</code> 已经是最后一个中间件函数了，再次调 <code>next</code> 会执行我们最初传入的空函数，这也是为什么要将 <code>reduceRight</code> 的初始值设置成一个空函数，就是防止最后一个中间件调用 <code>next</code> 而报错。</p><p>经过测试上面的代码不会出现顺序错乱的情况，但是在 <code>compose</code> 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 <code>use</code> 的中间件函数既可以是普通函数，又可以是 <code>async</code> 函数，这就要我们的 <code>compose</code> 完全支持异步。</p><h3 id="升级为支持异步-1"><a href="#升级为支持异步-1" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">    app.middlewares.reduceRight(</span><br><span class="line">      (a, b) =&gt; <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(b(a)),</span><br><span class="line">      () =&gt; <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    )()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 <code>next</code> 后又调用了 <code>then</code>），都处理成了 Promise，保证了 <code>reduceRight</code> 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 <code>async</code> 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 <code>compose</code> 就可以调用 <code>then</code> 方法执行后续逻辑。</p><h2 id="Redux-新版本-compose-的实现方式"><a href="#Redux-新版本-compose-的实现方式" class="headerlink" title="Redux 新版本 compose 的实现方式"></a>Redux 新版本 compose 的实现方式</h2><h3 id="同步的实现-2"><a href="#同步的实现-2" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> app.middlewares.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> arg =&gt; a(<span class="function"><span class="params">()</span> =&gt;</span> b(arg)))(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Redux</code> 新版本中将 <code>compose</code> 的逻辑做了些改动，将原本的 <code>reduceRight</code> 换成 <code>reduce</code>，也就是说将逆序归并改为了正序，我们不一定和 <code>Redux</code> 源码完全相同，是根据相同的思路来实现串行中间件的需求。</p><p>个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于 <code>reduce</code> 并没有传入初始值，所以此时 <code>a</code> 为 <code>fn1</code>，<code>b</code> 为 <code>fn2</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 reduce 的返回值，下一次将作为 a</span></span><br><span class="line">arg =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(arg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 reduce 的返回值，下一次将作为 a</span></span><br><span class="line">arg =&gt; <span class="function">(<span class="params">arg =&gt; fn1((</span>) =&gt;</span> fn2(arg)))(<span class="function"><span class="params">()</span> =&gt;</span> fn3(arg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于...</span></span><br><span class="line">arg =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(arg)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行最后返回的函数连接中间件，返回值等价于...</span></span><br><span class="line">fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)));</span><br></pre></td></tr></table></figure><p>所以在调用 <code>reduce</code> 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 <code>fn3</code>，也就是第三个中间件，这样保证了在最后一个中间件调用 <code>next</code> 时不会报错。</p><h3 id="升级为支持异步-2"><a href="#升级为支持异步-2" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><p>下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">    app.middlewares.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> a(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(b(arg)));</span><br><span class="line">    &#125;)(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve())</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 <code>compose</code> 也返回 Promise。</p><h2 id="使用-async-函数实现"><a href="#使用-async-函数实现" class="headerlink" title="使用 async 函数实现"></a>使用 async 函数实现</h2><p>这个版本是我在之前在学习 <code>Koa</code> 源码时偶然在一位大佬的一篇分析 <code>Koa</code> 原理的文章中看到的（翻了半天实在没找到链接），在这里也拿出来和大家分享一下，由于是利用 <code>async</code> 函数实现的，所以默认就是支持异步的，因为 <code>async</code> 函数会返回一个 Promise。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自执行 async 函数返回 Promise</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义默认的 next，最后一个中间件内执行的 next</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="keyword">async</span> () =&gt; <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next</span></span><br><span class="line">    <span class="comment">// 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createNext</span>(<span class="params">middleware, oldNext</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> middleware(oldNext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向遍历中间件数组，先把 next 传给最后一个中间件函数</span></span><br><span class="line">    <span class="comment">// 将新的中间件函数存入 next 变量</span></span><br><span class="line">    <span class="comment">// 调用下一个中间件函数，将新生成的 next 传入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = app.middlewares.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      next = createNext(app.middlewares[i], next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>next</code> 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 <code>next</code>，而数组 <code>middlewares</code> 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 <code>createNext</code> 作用是返回一个新的可以执行数组中最后一个中间件的 <code>async</code> 函数，并传入了初始的 <code>next</code>，这个返回的 <code>async</code> 函数作为新的 <code>next</code>，再取到倒数第二个中间件，调用 <code>createNext</code>，又返回了一个 <code>async</code> 函数，函数内依然是倒数第二个中间件的执行，传入的 <code>next</code> 就是上次新生成的 <code>next</code>，这样依次类推到第一个中间件。</p><p>因此执行第一个中间件返回的 <code>next</code> 则会执行传入的上一个生成的 <code>next</code> 函数，就会执行第二个中间件，就会执行第二个中间件中的 <code>next</code>，就这样直到执行完最初定义的 <code>next</code>，通过案例的验证，执行结果与洋葱模型完全相同。</p><p>至于异步的问题，每次执行的 <code>next</code> 都是 <code>async</code> 函数，执行后返回的都是 Promise，而最外层的自执行 <code>async</code> 函数返回的也是 Promise，也就是说 <code>compose</code> 最后返回的是 Promise，因此完全支持异步。</p><blockquote class="pullquote info"><p><em><strong>这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>或许你看完这几种方式会觉得，还是 <code>Koa</code> 对于 <code>compose</code> 的实现方式最容易理解，你也可能和我一样在感慨 <code>Redux</code> 的两种实现方式和 <code>async</code> 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想，写出 <code>compose</code> 这种优雅又高逼格的代码，路漫漫其修远兮，愿你在技术的路上 “一去不复返”。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> async/await </tag>
            
            <tag> Koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 进阶 —— Koa 源码分析</title>
      <link href="/2018/09/02/20180902141819/"/>
      <url>/2018/09/02/20180902141819/</url>
      
        <content type="html"><![CDATA[<img src="/2018/09/02/20180902141819/koa-cover.png" title="Koa 源码解析"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><code>Koa 2.x</code> 版本是当下最流行的 NodeJS 框架，同时社区涌现出一大批围绕 <code>Koa 2.x</code> 的中间件以及基于 <code>Koa 2.x</code> 封装的企业级框架，如 <code>egg.js</code>，然而 <code>Koa</code> 本身的代码却非常精简，精简到所有文件的代码去掉注释后还不足 <code>2000</code> 行，本篇就围绕着这 <code>2000</code> 行不到的代码抽出核心逻辑进行分析，并压缩成一版只有 <code>200</code> 行不到的简易版 <code>Koa</code>。</p></blockquote><a id="more"></a><h2 id="Koa-分析过程"><a href="#Koa-分析过程" class="headerlink" title="Koa 分析过程"></a>Koa 分析过程</h2><p>在下面的内容中，我们将对 <code>Koa</code> 所使用的功能由简入深的分析，首先会给出使用案例，然后根据使用方式，分析实现原理，最后对分析的功能进行封装，封装过程会从零开始并一步一步完善，代码也是从少到多，会完整的看到一个简版 <code>Koa</code> 诞生的过程，在此之前我们打开 <a href="https://github.com/koajs/koa/tree/master/lib" target="_blank">Koa 源码地址</a>。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/koa-dir.png" alt="Koa 文件目录" title>                </div>                <div class="image-caption">Koa 文件目录</div>            </figure><p><br></p><p>通过上面对 <code>Koa</code> 源码目录的截图，发现只有 <code>4</code> 个核心文件，为了方便理解，封装简版 <code>Koa</code> 的文件目录结构也将严格与源码同步。</p><h2 id="搭建基本服务"><a href="#搭建基本服务" class="headerlink" title="搭建基本服务"></a>搭建基本服务</h2><p>在引入 <code>Koa</code> 时我们需要创建一个 <code>Koa</code> 的实例，而启动服务是通过 <code>listen</code> 监听一个端口号实现的，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过使用我们可以分析出 <code>Koa</code> 导出的应该是一个类，或者构造函数，鉴于 <code>Koa</code> 诞生的时间以及基于 <code>node v7.6.0</code> 以上版本的情况来分析，正是 <code>ES6</code> 开始 “横行霸道” 的时候，所以推测 <code>Koa</code> 导出的应该是一个类，打开源码一看，果然如此，所以我们也通过 <code>class</code> 的方式来实现。</p><p>而从启动服务的方式上看，<code>app.listen</code> 的调用方式与原生 <code>http</code> 模块提供的 <code>server.listen</code> 几乎相同，我们分析，<code>listen</code> 方法应该是对原生 <code>http</code> 模块的一个封装，启动服务的本质还是靠 <code>http</code> 模块来实现的。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 请求回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>上面的代码初步实现了我们上面分析出的需求，为了防止代码冗余，我们将创建服务的回调抽取成一个 <code>handleRequest</code> 的实例方法，内部的逻辑在后面完善，现在可以创建这个 <code>Koa</code> 类的实例，通过调用实例的 <code>listen</code> 方法启动一个服务器。</p><h2 id="上下文对象-ctx-的封装"><a href="#上下文对象-ctx-的封装" class="headerlink" title="上下文对象 ctx 的封装"></a>上下文对象 ctx 的封装</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>Koa</code> 还有一个很重要的特性，就是它的 <code>ctx</code> 上下文对象，我们可以调用 <code>ctx</code> 的 <code>request</code> 和 <code>response</code> 属性获取原 <code>req</code> 和 <code>res</code> 的属性和方法，也在 <code>ctx</code> 上增加了一些原生没有的属性和方法，总之 <code>ctx</code> 给我们要操作的属性和方法提供了多种调用方式，使用案例如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 原生的 req 对象的 url 属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(ctx.req.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.req.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.response.req.url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Koa 扩展的 url</span></span><br><span class="line">  <span class="built_in">console</span>.log(ctx.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.req.url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置状态码和响应内容</span></span><br><span class="line">  ctx.response.status = <span class="number">200</span>;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建-ctx-的引用关系"><a href="#创建-ctx-的引用关系" class="headerlink" title="创建 ctx 的引用关系"></a>创建 ctx 的引用关系</h3><p>从上面我们可以看出，<code>ctx</code> 为 <code>use</code> 方法的第一个参数，<code>request</code> 和 <code>response</code> 是 <code>ctx</code> 新增的，而通过这两个属性又都可以获取原生的 <code>req</code> 和 <code>res</code> 属性，<code>ctx</code> 本身也可以获取到原生的 <code>req</code> 和 <code>res</code>，我们可以分析出，<code>ctx</code> 是对这些属性做了一个集成，或者说特殊处理。</p><p>源码的文件目录中正好有与 <code>request</code>、<code>response</code> 名字相对应的文件，并且还有 <code>context</code> 名字的文件，我们其实可以分析出这三个文件就是用于封装 <code>ctx</code> 上下文对象使用的，而封装 <code>ctx</code> 中也会用到 <code>req</code> 和 <code>res</code>，所以核心逻辑应该在 <code>handleRequest</code> 中实现。</p><p>在使用案例中 <code>ctx</code> 是作为 <code>use</code> 方法中回调函数的参数，所以我们分析应该有一个数组统一管理调用 <code>use</code> 后传入的函数，<code>Koa</code> 应该有一个属性，值为数组，用来存储这些函数，下面是实现代码。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>首先，给实例创建了三个属性 <code>context</code>、<code>request</code> 和 <code>response</code> 分别继承了 <code>context.js</code>、<code>request.js</code> 和 <code>response.js</code> 导出的对象，之所以这么做而不是直接赋值是防止操作实例属性时 “污染” 原对象，而获取原模块导出对象的属性可以通过原型链进行查找，并不影响取值。</p><p>其次，给实例挂载了 <code>middlewares</code> 属性，值为数组，为了存储 <code>use</code> 方法调用时传入的函数，在 <code>handleRequest</code> 把创建 <code>ctx</code> 属性及引用的过程单独抽取成了 <code>createContext</code> 方法，并在 <code>handleRequest</code> 中调用，返回值为创建好的 <code>ctx</code> 对象，而在 <code>createContext</code> 中我们根据案例中的规则构建了 <code>ctx</code> 的属性相关的各种引用关系。</p><h3 id="实现-request-取值"><a href="#实现-request-取值" class="headerlink" title="实现 request 取值"></a>实现 request 取值</h3><p>上面构建的属性中，所有通过访问原生 <code>req</code> 或 <code>res</code> 的属性都能获取到，反之则是 <code>undefined</code>，这就需要我们去构建 <code>request.js</code>。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/request.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 url 和 path 添加 getter</span></span><br><span class="line"><span class="keyword">const</span> request = &#123;</span><br><span class="line">  <span class="keyword">get</span> url() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.req.url;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> path() &#123;</span><br><span class="line">    <span class="keyword">return</span> url.parse(<span class="keyword">this</span>.req.url).pathname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = request;</span><br></pre></td></tr></table></figure><p>上面我们只构造了两个属性 <code>url</code> 和 <code>path</code>，我们知道 <code>url</code> 是原生所自带的属性，我们在使用 <code>ctx.request.url</code> 获取是通过 <code>request</code> 对象设置的 <code>getter</code>，将 <code>ctx.request.req.url</code> 的值返回了。</p><p><code>path</code> 是原生 <code>req</code> 所没有的属性，但却是通过原生 <code>req</code> 的 <code>url</code> 属性和 <code>url</code> 模块共同构建出来的，所以我们同样用了给 <code>request</code> 对象设置 <code>getter</code> 的方式获取 <code>req</code> 的 <code>url</code> 属性，并使用 <code>url</code> 模块将转换对象中的 <code>pathname</code> 返回，此时就可以通过 <code>ctx.request.path</code> 来获取访问路径，至于源码中我们没有处理的 <code>req</code> 属性都是通过这样的方式建立的引用关系。</p><h3 id="实现-response-的取值和赋值"><a href="#实现-response-的取值和赋值" class="headerlink" title="实现 response 的取值和赋值"></a>实现 response 的取值和赋值</h3><p><code>Koa</code> 中 <code>response</code> 对象的真正作用是给客户端进行响应，使用时是通过访问属性获取，并通过重新赋值实现响应，但是现在 <code>response</code> 获取的属性都是 <code>undefined</code>，我们这里先不管响应给浏览器的问题，首先要让 <code>response</code> 下的某个属性有值才行，下面我们来实现 <code>response.js</code>。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/response.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 body 和 status 添加 getter 和 setter</span></span><br><span class="line"><span class="keyword">const</span> response = &#123;</span><br><span class="line">  <span class="keyword">get</span> body() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._body;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> body(val) &#123;</span><br><span class="line">    <span class="comment">// 只要给 body 赋值就代表响应成功</span></span><br><span class="line">    <span class="keyword">this</span>.status = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">this</span>._body = val;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> status() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.res.statusCode;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> status(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.res.statusCode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = response;</span><br></pre></td></tr></table></figure><p>这里选择了 <code>Koa</code> 在使用时，<code>response</code> 对象上比较重要的两个属性进行处理，因为这两个属性是服务器响应客户端所必须的，并模仿了 <code>request.js</code> 的方式给 <code>body</code> 和 <code>status</code> 设置了 <code>getter</code>，不同的是响应浏览器所做的其实是赋值操作，所以又给这两个属性添加了 <code>setter</code>，对于 <code>status</code> 来说，直接操作原生 <code>res</code> 对象的 <code>statusCode</code> 属性即可，因为同为赋值操作。</p><p>还有一点，响应是通过给 <code>body</code> 赋值实现，我们认为只要触发了 <code>body</code> 的 <code>setter</code> 就成功响应，所以在 <code>body</code> 的 <code>getter</code> 中将响应状态码设置为 <code>200</code>，至于 <code>body</code> 赋值是如何实现响应的，放在后面再说。</p><h3 id="ctx-代理-request、response-的属性"><a href="#ctx-代理-request、response-的属性" class="headerlink" title="ctx 代理 request、response 的属性"></a>ctx 代理 request、response 的属性</h3><p>上面实现了通过 <code>request</code> 和 <code>response</code> 对属性的操作，<code>Koa</code> 虽然给我们提供了多样的属性操作方式，但由于我们程序猿（媛）们都很 “懒”，几乎没有人会在开发的时候愿意多写代码，大部分情况都是通过 <code>ctx</code> 直接操作 <code>request</code> 和 <code>response</code> 上的属性，这就是我们现在的问题所在，这些属性通过 <code>ctx</code> 访问不到。</p><p>我们需要给 <code>ctx</code> 对象做一个代理，让 <code>ctx</code> 可以访问到 <code>request</code> 和 <code>response</code> 上的属性，这个场景何曾相识，不正是 <code>Vue</code> 创建实例时，将传入参数对象 <code>options</code> 的 <code>data</code> 属性代理给实例本身的场景吗，既然如此，我们也通过相似的方式实现，还记得上面引入的 <code>context</code> 模块作为实例的 <code>context</code> 属性所继承的对象，而剩下的最后一个核心文件 <code>context.js</code> 正是用来做这件事的，代码如下。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/context.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将传入对象属性代理给 ctx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineGetter</span>(<span class="params">property, key</span>) </span>&#123;</span><br><span class="line">  proto.__defineGetter__(key, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[property][key];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ctx 值时直接操作传入对象的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineSetter</span>(<span class="params">property, key</span>) </span>&#123;</span><br><span class="line">  proto.__defineSetter__(key, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[property][key] = val;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 request 的 url 和 path 代理给 ctx</span></span><br><span class="line">defineGetter(<span class="string">'request'</span>, <span class="string">'url'</span>);</span><br><span class="line">defineGetter(<span class="string">'request'</span>, <span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 response 的 body 和 status 代理给 ctx</span></span><br><span class="line">defineGetter(<span class="string">'response'</span>, <span class="string">'body'</span>);</span><br><span class="line">defineSetter(<span class="string">'response'</span>, <span class="string">'body'</span>);</span><br><span class="line">defineGetter(<span class="string">'response'</span>, <span class="string">'status'</span>);</span><br><span class="line">defineSetter(<span class="string">'response'</span>, <span class="string">'status'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = proto;</span><br></pre></td></tr></table></figure><p>在 <code>Vue</code> 中是使用 <code>Object.defineProperty</code> 来时实现的代理，而在 <code>Koa</code> 源码中借助了 <code>delegate</code> 第三方模块来实现的，并在添加代理时链式调用了 <code>delegate</code> 封装的方法，我们并没有直接使用 <code>delegate</code> 模块，而是将 <code>delegate</code> 内部的核心逻辑抽取出来在 <code>context.js</code> 中直接编写，这样方便大家理解原理，也可以清楚的知道是如何实现代理的。</p><p>我们封装了两个方法 <code>defineGetter</code> 和 <code>defineSetter</code> 分别来实现取值和设置值时，将传入的属性（第二个参数）代理给传入的对象（第一个参数），函数内是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__" target="_blank">Object.prototype.__defineGetter__</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__" target="_blank">Object.prototype.__defineSetter__</a> 实现的，点击方法名可查看官方 API。</p><h2 id="洋葱模型-——-实现中间件的串行"><a href="#洋葱模型-——-实现中间件的串行" class="headerlink" title="洋葱模型 —— 实现中间件的串行"></a>洋葱模型 —— 实现中间件的串行</h2><blockquote class="pullquote info"><p>现在已经实现了 <code>ctx</code> 上下文对象的创建，但是会发现我们封装 <code>ctx</code> 之前所写的案例 <code>use</code> 回调中的代码并不能执行，也不会报错，根本原因是 <code>use</code> 方法内传入的函数没有调用，在使用 <code>Koa</code> 的过程中会发现，我们往往使用多个 <code>use</code>，并且传入 <code>use</code> 的回调函数除了 <code>ctx</code> 还有第二个参数 <code>next</code>，而这个 <code>next</code> 也是一个函数，调用 <code>next</code> 则执行下一个 <code>use</code> 中的回调函数，否则就会 “卡住”，这种执行机制被取名为 “洋葱模型”，而这些被执行的函数被称为 “中间件”，下面我们就来分析这个 “洋葱模型” 并实现中间件的串行。</p></blockquote><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/onion-model.png" alt="洋葱模型执行过程" title>                </div>                <div class="image-caption">洋葱模型执行过程</div>            </figure><p><br></p><h3 id="洋葱模型分析"><a href="#洋葱模型分析" class="headerlink" title="洋葱模型分析"></a>洋葱模型分析</h3><p>下面来看看表述洋葱模型的一个经典案例，结果似乎让人匪夷所思，一时很难想到原因，不着急先看了再说。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>根据上面的执行特性我们不妨来分析以下，我们知道 <code>use</code> 方法执行时其实是把传入的回调函数放入了实例的 <code>middlewares</code> 数组中，而执行结果打印了 <code>1</code> 说明第一个回调函数被执行了，接着又打印了 <code>2</code> 说明第二个回调函数被执行了，根据上面的代码我们可以大胆的猜想，第一个回调函数调用的 <code>next</code> 肯定是一个函数，可能就是下一个回调函数，或者是 <code>next</code> 函数中执行了下一个回调函数，这样根据函数调用栈先进后出的原则，会在 <code>next</code> 执行完毕，即出栈后，继续执行上一个回调函数的代码。</p><h3 id="支持异步的中间件串行"><a href="#支持异步的中间件串行" class="headerlink" title="支持异步的中间件串行"></a>支持异步的中间件串行</h3><p>在实现中间件串行之前需要补充一点，中间件函数内调用 <code>next</code> 时，前面的代码出现异步，则会继续向下执行，等到异步执行结束后要执行的代码插入到同步代码中，这会导致执行顺序错乱，所以在官方推荐中告诉我们任何遇到异步的操作前都需要使用 <code>await</code> 进行等待（包括 <code>next</code>，因为下一个中间件中可能包含异步操作），这也间接的说明了传入 <code>use</code> 的回调函数只要有异步代码需要 <code>await</code>，所以应该是 <code>async</code> 函数，而了解 <code>ES7</code> 特性 <code>async/await</code> 的我们来说，一定能分析出 <code>next</code> 返回的应该是一个 Promise 实例，下面是我们在之前 <code>application.js</code> 基础上的实现。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>仔细想想我们其实在利用循环执行每一个 <code>middlewares</code> 中的函数，而且需要把下一个中间件函数的执行作为函数体的代码包装一层成为新的函数，并作为参数 <code>next</code> 传入，那么在上一个中间件函数内部调用 <code>next</code> 就相当于先执行了下一个中间件函数，而下一个中间件函数内部调用 <code>next</code>，又先执行了下一个的下一个中间件函数，依次类推。</p><p>直到执行到最后一个中间件函数，调用了 <code>next</code>，但是 <code>middlewares</code> 中已经没有下一个中间件函数了，这也是为什么我们要给下一个中间件函数外包了一层函数而不是直接将中间件函数传入的原因之一（另一个原因是解决传参问题，因为在执行时还要传入下一个中间件函数），但是防止递归 “死循环”，要配合一个终止条件，即指向 <code>middlewares</code> 索引的变量等于了 <code>middlewares</code> 的长度，最后只是相当于执行了一个只有一条判断语句的函数就 <code>return</code> 的函数，而并没有报错。</p><p>在这整个过程中如果有任意一个 <code>next</code> 没有被调用，就不会向下执行其他的中间件函数，这样就 “卡住了”，完全符合 <code>Koa</code> 中间件的执行规则，而 <code>await</code> 过后也就是下一个中间件优先执行完成，则会继续执行当前中间件 <code>next</code> 调用下面的代码，这也就是 <code>1、3、5、6、4、2</code> 的由来。</p><p>为了实现所描述的执行过程，将所有中间件串行的逻辑抽出了一个 <code>compose</code> 方法，但是我们没有使用普通的循环，而是使用递归实现的，首先在 <code>compose</code> 创建 <code>dispatch</code> 递归函数，参数为当前数组函数的索引，初始值为 <code>0</code>，函数逻辑是先取出第一个函数执行，并传入一个回调函数参数，回调函数参数中递归 <code>dispatch</code>，参数 <code>+1</code>，这样就会将整个中间件串行起来了。</p><p>但是上面的串行也只是同步串行，如果某个中间件内部需要等待异步，则调用的 <code>next</code> 函数必须返回一个 Promise 实例，有些中间件没有执行异步，则不需要 <code>async</code> 函数，也不会返回 Promise，而 <code>Koa</code> 规定只要遇到 <code>next</code> 就需要等待，则将取出每一个中间件函数执行后的结果使用 <code>Promise.resolve</code> 强行包装成一个成功态的 Promise，就对异步进行了兼容。</p><p>我们最后也希望 <code>compose</code> 返回一个 Promise 方便执行一些只有在中间件都执行后才会执行的逻辑，每次串行最后执行的都是一个只有一条判断逻辑就 <code>return</code> 了的函数（包含一个中间件也没有的情况），此时 <code>compose</code> 返回了 <code>undefined</code>，无法调用 <code>then</code> 方法，为了兼容这种情况也强行的使用相同的 “招数”，在判断条件的 <code>return</code> 关键字后面加上了 <code>Promise.resolve()</code>，直接返回了一个成功态的 Promise。</p><blockquote class="pullquote warning"><p><em><strong>注意：官方只是推荐我们在调用 <code>next</code> 的时候使用 <code>await</code> 等待，即使执行的 <code>next</code> 真的存在异步，也不是非 <code>await</code> 不可，我们完全可以使用 <code>return</code> 来代替 <code>await</code>，唯一的区别就是 <code>next</code> 调用后，下面的代码不会再执行了，类比 “洋葱模型”，形象地说就是 “下去了就上不来了”，这个完全可以根据我们的使用需要而定，如果 <code>next</code> 后面不再有任何逻辑，完全可以使用 <code>return</code> 替代。</strong></em></p></blockquote><h2 id="实现真正的响应"><a href="#实现真正的响应" class="headerlink" title="实现真正的响应"></a>实现真正的响应</h2><p>在对 <code>ctx</code> 实现属性代理后，我们通过 <code>ctx.body</code> 重新赋值其实只是改变了 <code>response.js</code> 导出对象的 <code>_body</code> 属性，而并没有实现真正的响应，看下面这个 <code>Koa</code> 的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = fs.createReadStream(<span class="string">'1.txt'</span>);</span><br><span class="line"></span><br><span class="line">  ctx.body = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'panda'</span>), <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实最后响应给客户端的值是 <code>panda</code>，正常在最后一个中间件执行后，由于异步定时器的代码没有执行完，<code>ctx.body</code> 最后的值应该是 <code>1.txt</code> 的可读流，这与客户端接收到的值相违背，通过这个猜想上的差异我们应该知道，<code>compose</code> 在串行执行中间件后为什么要返回一个 Promise 了，因为最后执行的只有判断语句的函数会等待我们例子中最后一个 <code>use</code> 传入的中间件函数执行完毕调用，也就是说在执行 <code>compose</code> 返回值的 <code>then</code> 时，<code>ctx.body</code> 的值已经是 <code>panda</code> 了。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">    <span class="comment">// 设置默认状态码（Koa 规定），必须在调用中间件之前</span></span><br><span class="line">    ctx.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取最后 body 的值</span></span><br><span class="line">      <span class="keyword">let</span> body = ctx.body;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器</span></span><br><span class="line">      <span class="keyword">if</span> (Buffer.isBuffer(body) || <span class="keyword">typeof</span> body === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 Buffer 类型的数据</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line">        res.end(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> body === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理对象类型</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) &#123;</span><br><span class="line">        <span class="comment">// 处理流类型的数据</span></span><br><span class="line">        body.pipe(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>处理 <code>response</code> 时，在 <code>body</code> 的 <code>setter</code> 中将状态码设置为了 <code>200</code>，就是说需要设置 <code>ctx.body</code> 去触发 <code>setter</code> 让响应成功，如果没有给 <code>ctx.body</code> 设置任何值，默认应该是无响应的，在官方文档也有默认状态码为 <code>404</code> 的明确说明，所以在 <code>handleRequest</code> 把状态码设置为了 <code>404</code>，但必须在 <code>compose</code> 执行之前才叫默认状态码，因为中间件中可能会操作 <code>ctx.body</code>，重新设置状态码。</p><p>在 <code>comose</code> 的 <code>then</code> 中，也就是在所有中间件执行后，我们取出 <code>ctx.body</code> 的值，即为最后生效的响应值，对该值进行了数据类型验证，如 Buffer、字符串、对象和流，并分别用不同的方式处理了响应，但本质都是调用的原生 <code>res</code> 对象的 <code>end</code> 方法。</p><h2 id="中间件错误处理"><a href="#中间件错误处理" class="headerlink" title="中间件错误处理"></a>中间件错误处理</h2><p>在上面的逻辑当中我们实现了很多 <code>Koa</code> 的核心逻辑，但是只考虑了顺利执行的情况，并没有考虑如果中间件中代码执行出现错误的问题，如下面案例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 error 监听</span></span><br><span class="line">app.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们之所以让 <code>compose</code> 方法在执行所有中间件后返回一个 Promise 还有一个更重要的意义，因为在 Promise 链式调用中，只要其中任何一个环节出现代码执行错误或抛出异常，都会直接执行出现错误的 <code>then</code> 方法中错误的回调或者最后的 <code>catch</code> 方法，对于 <code>Koa</code> 中间件的串行而言，最后一个 <code>then</code> 调用 <code>catch</code> 方法就是 <code>compose</code> 的返回值调用 <code>then</code> 后继续调用的 <code>catch</code>，<code>catch</code> 内可以捕获到任意一个中间件执行时出现的错误。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line"><span class="comment">// 继承 EventEmitter 后可以用创建的实例 app 添加 error 监听，可以通过 emit 触发监听</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    supper();</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认状态码（Koa 规定），必须在调用中间件之前</span></span><br><span class="line">    ctx.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取最后 body 的值</span></span><br><span class="line">      <span class="keyword">let</span> body = ctx.body;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器</span></span><br><span class="line">      <span class="keyword">if</span> (Buffer.isBuffer(body) || <span class="keyword">typeof</span> body === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 Buffer 类型的数据</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line">        res.end(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> body === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理对象类型</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) &#123;</span><br><span class="line">        <span class="comment">// 处理流类型的数据</span></span><br><span class="line">        body.pipe(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行 error 事件</span></span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 500 状态码</span></span><br><span class="line">      ctx.status = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回状态码对应的信息响应浏览器</span></span><br><span class="line">      res.end(httpServer.STATUS_CODES[ctx.status]);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>在使用的案例当中，使用 <code>app</code>（即 <code>Koa</code> 创建的实例）监听了一个 <code>error</code> 事件，当中间件执行错误时会触发该监听的回调，这让我们想起了 NodeJS 中一个重要的核心模块 <code>events</code>，这个模块帮我们提供了一个事件机制，通过 <code>on</code> 方法添加监听，通过 <code>emit</code> 触发监听，所以我们引入了 <code>events</code>，并让 <code>Koa</code> 类继承了 <code>events</code> 导入的 <code>EventEmitter</code> 类，此时 <code>Koa</code> 的实例就可以使用 <code>EventEmitter</code> 原型对象上的 <code>on</code> 和 <code>emit</code> 方法。</p><p>在 <code>compose</code> 执行后调用的 <code>catch</code> 中，通过实例调用了 <code>emit</code>，并传入了事件类型 <code>error</code> 和错误对象，这样就是实现了中间件的错误监听，只要中间件执行出错，就会执行案例中错误监听的回调。</p><h2 id="让引入的-Koa-直接指向-application-js"><a href="#让引入的-Koa-直接指向-application-js" class="headerlink" title="让引入的 Koa 直接指向 application.js"></a>让引入的 Koa 直接指向 application.js</h2><p>在上面我们实现了 <code>Koa</code> 大部分常用功能的核心逻辑，但还有一点美中不足，就是我们引入自己的简易版 <code>Koa</code> 时，默认会查找 <code>koa</code> 路径下的 <code>index.js</code>，想要执行我们的 <code>Koa</code> 必须要使用路径找到 <code>application.js</code>，代码如下。</p><figure class="highlight js"><figcaption><span>现在的引入方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa/application'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>希望的引入方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa'</span>);</span><br></pre></td></tr></table></figure><p>我们更希望像直接引入指定 <code>koa</code> 文件夹，就可以找到 <code>application.js</code> 文件并执行，这就需要我们在 <code>koa</code> 文件夹创建 <code>package.json</code> 文件，并在动一点小小的 “手脚” 如下。</p><figure class="highlight"><figcaption><span>文件路径：&#126koa/package.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  "main": "./application.js",</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Koa-原理图"><a href="#Koa-原理图" class="headerlink" title="Koa 原理图"></a>Koa 原理图</h2><p>在文章最后一节送给大家一张 <code>Koa</code> 执行的原理图，这张图片是准备写这篇文章时在 Google 上发现的，觉得把 <code>Koa</code> 的整个流程表达的非常清楚，所以这里拿来帮助大家理解 <code>Koa</code> 框架的原理和执行过程。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/koa-flow-chart.png" alt="Koa 原理图" title>                </div>                <div class="image-caption">Koa 原理图</div>            </figure><p><br></p><p>之所以没有在文章开篇放上这张图是因为觉得在完全没有了解过 <code>Koa</code> 的原理之前，可能有一部分小伙伴看这张图会懵，会打消学习的积极性，因为本篇的目的就是带着大家从零到有的，一步一步实现简易版 <code>Koa</code>，梳理 <code>Koa</code> 的核心逻辑，如果你已经看到了这里，是不是觉得这张图出现的不早不晚，刚刚好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>最后还是在这里做一个总结，在 <code>Koa</code> 中主要的部分有 <code>listen</code> 创建服务器、封装上下文对象 <code>ctx</code> 并代理属性、<code>use</code> 方法添加中间件、<code>compose</code> 串行执行中间、让 <code>Koa</code> 继承 <code>EventEmitter</code> 实现错误监听，而我个人觉得最重要的就是 <code>compose</code>，它是一个事件串行机制，也是实现 “洋葱模型” 的核心，如今 <code>compose</code> 已经不再只是一个方法名，而是一种编程思想，用于将多个程序串行在一起，或同步，或异步，在 <code>Koa</code> 中自不必多说，因为大家已经见识过了，<code>compose</code> 在 <code>Redux</code> 中也起着串联中间件的作用，如串联 <code>promise</code>、<code>redux-thunk</code>、<code>logger</code> 等，在 <code>Webpack</code> 源码依赖的核心模块 <code>tapable</code> 中也有所应用，在我们的学习过程中，这样优秀的编程思想是应该重点吸收的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> async/await </tag>
            
            <tag> Koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express 中间件 body-parser 原理分析</title>
      <link href="/2018/08/28/20180828022147/"/>
      <url>/2018/08/28/20180828022147/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/28/20180828022147/express-middleware.png" title="Express 中间件"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Express</code> 是基于 NodeJS 平台的 Web 框架，应用广泛，在 <code>Express</code> 社区中有着大量的开发者通过 <code>Express</code> 中间件的特性，开发了各种功能的中间件，用来处理某些响应以及给请求对象 <code>req</code>、响应对象 <code>res</code> 添加属性或方法，我们接下来就通过分析常用的 <code>body-parser</code> 中间件的原理来了解如何开发 <code>Express</code> 中间件，如果想了解更多 <code>Express</code> 内部封装原理可以看 <a href="https://www.overtaking.top/2018/08/25/20180825162129/" target="_blank">《Express 源码分析及简易封装》</a>。</p></blockquote><a id="more"></a><h2 id="body-parser-的基本使用"><a href="#body-parser-的基本使用" class="headerlink" title="body-parser 的基本使用"></a>body-parser 的基本使用</h2><p>想刨析一个中间件的原理，首先应该从使用入手，在足够了解用法的基础上去分析，现在搭建一个简易的 <code>Express</code> 服务，并使用 <code>body-parser</code> 中间件，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express body-parser</span><br></pre></td></tr></table></figure><p><strong>使用 body-parser 代码如下：</strong></p><figure class="highlight js"><figcaption><span>使用 body-parser 中间件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 body-parser 中间</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body);</span><br><span class="line">  res.send(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动上面的服务器，通过 <code>postman</code> 工具分别通过表单提交和 <code>json</code> 的格式访问 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000/login</a>，查看服务器控制后台的打印结果和 <code>postman</code> 的返回结果。</p><h2 id="body-parser-的实现"><a href="#body-parser-的实现" class="headerlink" title="body-parser 的实现"></a>body-parser 的实现</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>从上面的使用案例我们可以分析出一下几点：</p><ul><li>首先，<code>body-parser</code> 中间件的作用是给 <code>req</code> 添加属性 <code>body</code>，值为对象，以键值对的形式存储请求体中的参数；</li><li>其次，<code>body-parser</code> 只处理 <code>POST</code> 请求；</li><li>最后，<code>body-parser</code> 模块导出一个对象，上面有两个方法 <code>urlencoded</code> 和 <code>json</code>，分别处理表单提交和 <code>json</code> 格式的请求体参数。</li></ul><h3 id="分析-urlencoded、json-公共逻辑"><a href="#分析-urlencoded、json-公共逻辑" class="headerlink" title="分析 urlencoded、json 公共逻辑"></a>分析 urlencoded、json 公共逻辑</h3><p>在实现之前我们先分析一下两个方法，首先都需要先读取请求体中的内容，数据传输的类型为 Buffer，转换成字符串后会根据提交方式不同而导致请求体中的内容是查询字符串或者是 <code>json</code> 字符串的区别。</p><p>当解析失败时都需要做错误处理，当不是 <code>POST</code> 请求时都需要向下执行其他中间件，而最核心的事就是把请求体中的数据转换成对象挂在 <code>req.body</code> 上。</p><p>使用的转换数据的方法不同是唯一的区别，能区分两者的就是请求头 <code>Content-Type</code> 的值，因此我们可以把所有的公共逻辑抽取出来用一个 <code>acceptPost</code> 函数来执行。</p><h3 id="模块的创建"><a href="#模块的创建" class="headerlink" title="模块的创建"></a>模块的创建</h3><p>我们下面创建自己的 <code>body-parser</code> 模块，防止命名冲突，我们的模块命名为 <code>my-body-parser</code>，处理参数需要使用 <code>querystring</code> 和 <code>qs</code> 两个模块，其中 <code>qs</code> 是第三方模块，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qs</span><br></pre></td></tr></table></figure><p><code>qs</code> 和 <code>querystring</code> 作用基本相同，就是处理查询字符串格式的参数，但是也有一点小小的区别，<code>querystring</code> 只能处理一级，而 <code>qs</code> 可以处理多级。</p><figure class="highlight js"><figcaption><span>文件：my-body-parser.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// urlencoded 和 json 公共逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理表单提交的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlencoded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求体 json 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">json</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; urlencoded, json &#125;;</span><br></pre></td></tr></table></figure><p>在把基本模块搭建好后，我们下面就实现 <code>body-parser</code> 模块内的公共逻辑函数 <code>acceptPost</code>。</p><h3 id="acceptPost-的实现"><a href="#acceptPost-的实现" class="headerlink" title="acceptPost 的实现"></a>acceptPost 的实现</h3><p>为了兼容 <code>urlencoded</code> 方法和 <code>json</code> 方法设计了两个参数，一个是区分当前调用方法的 <code>type</code>，一个是针对 <code>urlencoded</code> 方法的 <code>options</code>。</p><figure class="highlight js"><figcaption><span>acceptPost 的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// urlencoded 方法和 json 方法的公共逻辑函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptPost</span>(<span class="params">type, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个中间件函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求头</span></span><br><span class="line">    <span class="keyword">const</span> contentType = req.headers[<span class="string">'content-type'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断如果不符合两种提交的请求头直接交给其他中间件处理</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      contentType === <span class="string">'application/x-www-form-urlencoded'</span> ||</span><br><span class="line">      contentType === <span class="string">'application/json'</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 存储数据的数组</span></span><br><span class="line">      <span class="keyword">const</span> buffers = [];</span><br><span class="line"></span><br><span class="line">      req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 接收数据并存入数组中</span></span><br><span class="line">        buffers.push(data);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 组合数据并转换成字符串</span></span><br><span class="line">        <span class="keyword">let</span> result = Buffer.concat(buffers).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数据并挂载 req.body 属性上</span></span><br><span class="line">        <span class="comment">// 如果是表单提交则使用 querystring 或 qs，否则使用 JSON.parse</span></span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">'form'</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果配置 extended 值为 true 使用 qs，否则使用 querystring</span></span><br><span class="line">          req.body = options.extended ?</span><br><span class="line">            qs.parse(result) :</span><br><span class="line">            querystring.parse(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'json'</span>) &#123;</span><br><span class="line">          req.body = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next(); <span class="comment">// 向下执行</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">      req.on(<span class="string">'err'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        next(err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="urlencoded-和-json-方法的实现"><a href="#urlencoded-和-json-方法的实现" class="headerlink" title="urlencoded 和 json 方法的实现"></a>urlencoded 和 json 方法的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理表单提交的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlencoded</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义 type 值</span></span><br><span class="line">  <span class="keyword">let</span> type = <span class="string">'form'</span>;</span><br><span class="line">  <span class="keyword">return</span> acceptPost(type, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求体 json 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">json</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义 type 值</span></span><br><span class="line">  <span class="keyword">let</span> type = <span class="string">'json'</span>;</span><br><span class="line">  <span class="keyword">return</span> acceptPost(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把所有的公共逻辑都抽取出去后发现，<code>urlencoded</code> 和 <code>json</code> 方法内部只需要定义不同的类型就可以执行自己的中间件逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>上面分析 <code>body-parse</code> 中间件的原理的目的在于理解 <code>Express</code> 中间件开发的模式，在此总结一下，<code>Express</code> 中间件返回的是一个函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，当功能无法处理某些情况时需要调用 <code>next</code>，当出现错误时调用 <code>next</code> 并传递错误，则交给 <code>Express</code> 内置的错误处理中间件，在中间件内部代码涉及异步操作时，须在异步完成的回调当中调用 <code>next</code>，这是不如 <code>Koa</code> 方便的一点，同时也是两者的区别，因为 <code>Koa</code> 中已经大量使用 <code>async/await</code>，在执行异步代码时可以等待。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Express </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express 源码分析及简易封装</title>
      <link href="/2018/08/25/20180825162129/"/>
      <url>/2018/08/25/20180825162129/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/25/20180825162129/express.png" title="Express 源码解析"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><code>Express</code> 是 NodeJS 的 Web 框架，与 <code>Koa</code> 的轻量相比，功能要更多一些，依然是当前使用最广泛的 NodeJS 框架，本篇参考 <code>Express</code> 的核心逻辑来实现一个简易版，<code>Express</code> 源码较多，逻辑复杂，看一周可能也看不完，如果你已经使用过 <code>Express</code>，又想快速的了解 <code>Express</code> 常用功能的原理，那读这篇文章是一个好的选择，也可以为读真正的源码做铺垫，本篇内容每部分代码较多，因为按照 <code>Express</code> 的封装思想很难拆分，所以建议以星号标注区域为主其他代码为辅。</p></blockquote><a id="more"></a><h2 id="搭建基本服务"><a href="#搭建基本服务" class="headerlink" title="搭建基本服务"></a>搭建基本服务</h2><p>下面我们使用 <code>Express</code> 来搭建一个最基本的服务，只有三行代码，只能访问不能响应。</p><figure class="highlight js"><figcaption><span>三行代码搭建的最基本服务</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>从上面我们可以分析出，<code>express</code> 模块给我们提供了一个函数，调用后返回了一个函数或对象给上面有 <code>listen</code> 方法给我们创建了一个 <code>http</code> 服务，我们就按照官方的设计返回一个函数 <code>app</code>。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>我们创建一个模块 <code>express.js</code>，导出了 <code>createApplication</code> 函数并返回在内部创建 <code>app</code> 函数，<code>createApplication</code> 等于我们引入 <code>Express</code> 模块时所调用的那个函数，返回值就是我们接收的 <code>app</code>，在 <code>createApplication</code> 返回的 <code>app</code> 函数上挂载了静态方法 <code>listen</code>，用于帮助我们启动 <code>http</code> 服务。</p><p><code>createApplication</code> 函数内我们使用引入的 <code>http</code> 模块创建了服务，并调用了创建服务 <code>server</code> 的 <code>listen</code> 方法，将 <code>app.listen</code> 的所有参数传递进去，这就等于做了一层封装，将真正创建服务器的过程都包在了 <code>app.listen</code> 内部，我们自己封装的 <code>Express</code> 模块只有在调用导出函数并调用 <code>app.listen</code> 时才会真正的创建服务器和启动服务器，相当于将原生的两步合二为一。</p><h2 id="路由的实现"><a href="#路由的实现" class="headerlink" title="路由的实现"></a>路由的实现</h2><p>在 <code>Express</code> 框架中有多个路由方法，方法名分别对应不同的请求方式，可以帮助我们匹配路径和请求方式，在完全匹配时执行路由内部的回调函数，以、目的是在不同路由不同请求方法的情况下让服务器做出不同的响应，路由的使用方式如下。</p><figure class="highlight js"><figcaption><span>路由的使用方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'home'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'about'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>如果启动上面的服务，通过浏览器访问定义的路由时可以匹配到 <code>app.get</code>、<code>app.post</code> 或 <code>app.all</code> 并执行回调，但其实我们可以发现这些方法的名字是与请求类型严格对应的，不仅仅这几个，下面来看看实现路由的核心逻辑（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">    <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">    <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">    <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.lenth; i++) &#123;</span><br><span class="line">      <span class="comment">// 循环取得每一层</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (reqPath === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">        (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">    res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;reqPath&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>我们的逻辑大体可以分为两个部分，路由方法的创建以及路由的匹配，首先是路由方法的创建阶段，每一个方法的内部所做的事情就是将路由的路径、请求方式和回调函数作为对象的属性，并将对象存入一个数组中统一管理，所以我们创建了 <code>app.routes</code> 数组用来存储这些路由对象。</p><p>方法名对应请求类型，请类型有很多，我们不会一一的创建每一个方法，所以选择引入专门存储请求类型名称的 <code>methods</code> 模块，其实路由方法逻辑相同，我们封装了 <code>createRouteMethod</code> 方法用来生成不同路由方法的函数体，之所以这样做是因为有个特殊的路由方法 <code>app.all</code>，导致请求类型有差别，其他的可以从 <code>methods</code> 中取，<code>app.all</code> 我们定义类型为 <code>all</code> 通过 <code>createRouteMethod</code> 函数的参数传入。</p><p>接着就是循环 <code>methods</code> 调用 <code>createRouteMethod</code> 函数创建路由方法，并单独创建 <code>app.all</code> 方法。</p><p>路由匹配阶段实在函数 <code>app</code> 内完成的，因为启动服务接收到请求时会执行 <code>createServer</code> 中的回调，即执行 <code>app</code>，先通过原生自带的 <code>req.method</code> 取出请求方式并处理成小写，通过 <code>req.path</code> 取出完整路径并分成路由名和查询字符串两个部分。</p><p>循环 <code>app.routes</code> 用取到请求的类型和路由名称匹配，两者都相等则执行对应路由对象上的回调函数，在判断条件中，请求方式兼容了我们之前定义的 <code>all</code>，为了所有的请求类型只要路由匹配都可以执行 <code>app.all</code> 的回调，请求路径兼容了 <code>*</code>，因为如果某个路由方法定义的路径为 <code>*</code>，则任意路由都可以执行这个路由对象上的回调。</p><h2 id="扩展请求对象属性"><a href="#扩展请求对象属性" class="headerlink" title="扩展请求对象属性"></a>扩展请求对象属性</h2><p>且在路由内部可以通过 <code>req</code> 访问一些原生没有的属性如 <code>req.path</code>、<code>req.query</code>、<code>req.host</code> 和 <code>req.params</code>，这说明 <code>Express</code> 在实现的过程中对 <code>req</code> 进行了处理。</p><figure class="highlight js"><figcaption><span>req 属性的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.path);</span><br><span class="line">  <span class="built_in">console</span>.log(req.query);</span><br><span class="line">  <span class="built_in">console</span>.log(req.host);</span><br><span class="line">  res.end(<span class="string">'home'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/about/:id/:name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.params);</span><br><span class="line">  res.end(<span class="string">'about'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>在上面的使用中我们写了两个路由，分别打印了原生所不具备而 <code>Express</code> 帮我们处理并新增的属性，下面我们就来在之前自己实现的 <code>express.js</code> 的基础上增加这些属性（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">    <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">    <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************** 以下为修改代码 *****************************</span></span><br><span class="line">    <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">    req.path = reqPath;</span><br><span class="line">    <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">    req.query = querystring.parse(query);</span><br><span class="line">    <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">    req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.lenth; i++) &#123;</span><br><span class="line">      <span class="comment">// 循环取得每一层</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">      <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">        <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">        <span class="keyword">const</span> result = pathname.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">        <span class="keyword">if</span> (result &amp;&amp; (method === layer.method || layer.method === <span class="string">'all'</span>)) &#123;</span><br><span class="line">          <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">          req.params = layer.paramNames.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">            memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> memo;</span><br><span class="line">          &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行对应的回调</span></span><br><span class="line">          <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          (reqPath === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">          (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">    res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;reqPath&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>上面代码有些长，我们一点一点分析，首先是 <code>req.path</code>，就是我们浏览器地址栏里查询字符串前的路径，值其实就是我们之前从 <code>req.url</code> 中解构出来的 <code>pathname</code>，我们只需要将 <code>pathname</code> 赋值给 <code>req.path</code> 即可。</p><p><code>req.query</code> 是浏览器地址栏的查询字符串传递的参数，就是我们从 <code>req.url</code> 解构出来的查询字符串，借助 <code>querystring</code> 模块将查询字符串处理成对象赋值给 <code>req.query</code> 即可。</p><p><code>req.host</code> 是访问的主机名，请求头中的 <code>host</code> 包含了主机名和端口号，我们只要截取出前半部分赋值给 <code>req.host</code> 即可。</p><p>最复杂的是 <code>req.params</code> 的实现，大概分为两个步骤，首先是在路由方法创建时需要检查定义的路由是否含有路由参数，如果有则取出参数的键存入数组 <code>paramNames</code> 中，然后创建一个匹配路由参数的正则，通过 <code>replace</code> 实现正则字符串的创建，再通过 <code>RegExp</code> 构造函数来创建正则，并挂在路由对象上，之所以使用 <code>replace</code> 是因为创建的规则内的分组要和路由参数的个数是相同的，我们将这些逻辑完善进了 <code>createRouteMethod</code> 函数中。</p><h2 id="实现响应方法-send-和-sendFile"><a href="#实现响应方法-send-和-sendFile" class="headerlink" title="实现响应方法 send 和 sendFile"></a>实现响应方法 send 和 sendFile</h2><p>之前的例子中我们都是用原生的 <code>end</code> 方法响应浏览器，我们知道 <code>end</code> 方法只能接收字符串和 Buffer 作为响应的值，非常不方便，其实在 <code>Express</code> 中封装了一个 <code>send</code> 方法挂在 <code>res</code> 对象下，可以接收数组、对象、字符串、Buffer、数字处理后响应给浏览器，在 <code>Express</code> 内部同样封装了一个 <code>sendFile</code> 方法用于读取请求的文件。</p><figure class="highlight js"><figcaption><span>send 响应</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(&#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/test.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 必须传入绝对路径</span></span><br><span class="line">  res.sendFile(path.join(__dirname, req.path));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过我们的分析，封装的 <code>send</code> 方法应该是将 <code>end</code> 不支持的类型数据转换成了字符串，在内部再次调用 <code>end</code>，而 <code>sendFile</code> 方法规定参数必须为绝对路径，内部实现应该是利用可读流读取文件内容相应给浏览器，下面是两个方法的实现（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">    <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">    <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">    req.path = reqPath;</span><br><span class="line">    <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">    req.query = querystring.parse(query);</span><br><span class="line">    <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">    req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">    <span class="comment">// 响应方法</span></span><br><span class="line">    res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 设置响应头</span></span><br><span class="line">      res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">          res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">          params = util.inspect(params);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">          <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">          params = httpServer.STATUS_CODES[params];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应</span></span><br><span class="line">      res.end(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应文件方法</span></span><br><span class="line">    res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">      fs.createReadStream(pathname).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.lenth; i++) &#123;</span><br><span class="line">      <span class="comment">// 循环取得每一层</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">      <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">        <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">        <span class="keyword">const</span> result = reqPath.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">        <span class="keyword">if</span> (result &amp;&amp; (method === layer.method || layer.method === <span class="string">'all'</span>)) &#123;</span><br><span class="line">          <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">          req.params = layer.paramNames.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">            memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> memo;</span><br><span class="line">          &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行对应的回调</span></span><br><span class="line">          <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          (reqPath === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">          (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">    res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;reqPath&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>有一点需要注意，在 Node 环境中想把任何对象类型转换成字符串应该使用 <code>util.inspect</code> 方法，而当 <code>send</code> 方法输入数字类型时，要返回对应状态码的名称，可通过 <code>_http_server</code> 模块的 <code>STATUS_CODES</code> 对象获取。</p><h2 id="内置中间件的实现"><a href="#内置中间件的实现" class="headerlink" title="内置中间件的实现"></a>内置中间件的实现</h2><p><code>Express</code> 最大的特点就是中间件机制，中间件就是用来处理请求的函数，用来完成不同场景的请求处理，一个中间件处理完请求后可以再传递给下一个中间件，具有回调函数 <code>next</code>，不执行 <code>next</code> 则会卡在一个位置，调用 <code>next</code> 则继续向下传递。</p><figure class="highlight js"><figcaption><span>use 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(&#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>在上面代码中使用 <code>use</code> 方法执行了传入的回调函数，实现公共逻辑，起到了中间件的作用，调用回调参数的 <code>next</code> 方法向下继续执行，下面来实现 <code>use</code> 方法（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取第一个回调函数</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[index++];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">// 将当前中间件函数的属性解构出来</span></span><br><span class="line">        <span class="keyword">let</span> &#123; method, pathname, handler &#125; = layer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; <span class="comment">// 如果存在错误将错误交给错误处理中间件，否则</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>, handle.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hanlder(err, req, res, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在错误则继续向下执行</span></span><br><span class="line">          <span class="comment">// 判断是中间件还是路由</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配路径判断</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              pathname === <span class="string">'/'</span> ||</span><br><span class="line">              pathname === req.path ||</span><br><span class="line">              req.path.startWidth(pathname)</span><br><span class="line">            ) &#123;</span><br><span class="line">              handler(req, res, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              next();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">              <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">              <span class="keyword">const</span> result = req.path.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                result &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                  method === layer.method ||</span><br><span class="line">                  layer.method === <span class="string">'all'</span></span><br><span class="line">                )</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">                req.params = layer.paramNames.reduce(</span><br><span class="line">                  <span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index </span>) </span>&#123;</span><br><span class="line">                    memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">return</span> memo;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行对应的回调</span></span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (req.path === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">                (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">        res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">      <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">      <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">      req.path = reqPath;</span><br><span class="line">      <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">      req.query = querystring.parse(query);</span><br><span class="line">      <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">      req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应方法</span></span><br><span class="line">      res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">            params = util.inspect(params);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">            params = httpServer.STATUS_CODES[params];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        res.end(params);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应文件方法</span></span><br><span class="line">      res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">        fs.createReadStream(pathname).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下执行</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        pathname.method !== <span class="string">'middle'</span></span><br><span class="line">      ) &#123;</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  <span class="comment">// 添加中间件方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理没有传入路径的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = pathname;</span><br><span class="line">      pathname = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成函数并执行</span></span><br><span class="line">    createRouteMethod(<span class="string">'middle'</span>)(pathname, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将初始逻辑作为中间件执行</span></span><br><span class="line">  app.use(init());</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p><code>use</code> 方法第一个参数为路径，与路由相同，不传默认为 <code>/</code>，如果不传所有的路径都会经过该中间件，如果传入指定的值，则匹配后的请求才会通过该中间件。</p><p>中间件的执行可能存在异步的情况，但之前匹配路径使用的是 <code>for</code> 循环同步匹配，我们将其修改为异步并把路由匹配的逻辑与中间件路径匹配的逻辑进行了整合，并创建了 <code>use</code> 方法，对是否传了第一个参数做了一个兼容，其他将带有请求方式、路径和回调的逻辑统一使用 <code>createRouteMethod</code> 方法创建，并传入 <code>middle</code> 类型，<code>createRouteMethod</code> 中路由参数匹配的逻辑对 <code>middle</code> 类型做了一个排除。</p><p>使用 <code>Express</code> 中间件调用 <code>next</code> 方法时，不传递参数和参数为 <code>null</code> 代表执行成功，如果传入了其他的参数，表示执行出错，会跳过所有正常的中间件和路由，直接交给错误处理中间件处理，并将 <code>next</code> 传入的参数作为错误处理中间件回调函数的第一个参数 <code>err</code>，后面三个参数分别为 <code>req</code>、<code>res</code> 和 <code>next</code>。</p><p>代码种创建了 <code>index</code> 变量，默认调用了一次 <code>next</code> 方法，每次然后取出数组 <code>app.routes</code> 中的路由对象的回调函数执行，并在内部执行 <code>handler</code>，而 <code>handler</code> 回调中又调用了 <code>next</code> 方法，就这样将整个中间件和路由的回调串联起来。</p><p>我们发现在第一次调用 <code>next</code> 之前的所有逻辑，如给 <code>req</code> 添加属性，给 <code>res</code> 添加方法，都是公共逻辑，是任何中间件和路由在匹配之前都会执行的逻辑，我们既然有了中间件方法 <code>app.user</code>，可以将这些逻辑抽取出来作为一个单独的中间件回调函数执行，所以创建了 <code>init</code> 函数，内部返回了一个函数作为回调函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，并在<code>init</code> 调用返回的函数内部调用 <code>next</code> 向下执行。</p><h2 id="内置模板引擎的实现"><a href="#内置模板引擎的实现" class="headerlink" title="内置模板引擎的实现"></a>内置模板引擎的实现</h2><p>在 <code>Express</code> 框架中内置支持了 <code>ejs</code>、<code>jade</code> 等模板，使用方法 “三部曲” 如下。</p><figure class="highlight js"><figcaption><span>模板的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、指定模板引擎，其实就是模板文件的后缀名</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、指定模板的存放根目录</span></span><br><span class="line">app.set(<span class="string">'views'</span>, path.resolve(__dirname, <span class="string">'views'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、如果要自定义模板后缀和函数的关系</span></span><br><span class="line">app.engine(<span class="string">'.html'</span>, <span class="built_in">require</span>(<span class="string">'./ejs'</span>).__express);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//使用指定的模板引擎渲染 user 模板</span></span><br><span class="line">  res.render(<span class="string">'user'</span>, &#123; <span class="attr">title</span>: <span class="string">'用户管理'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面将模板根目录设置为 <code>views</code> 文件夹，并规定了模板类型为 <code>ejs</code>，可以同时给多种模板设置，并不冲突，如果需要将其他后缀名的模板按照另一种模板的渲染引擎渲染则使用 <code>app.engine</code> 进行设置，下面看一下实现代码（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取第一个回调函数</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[index++];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">// 将当前中间件函数的属性解构出来</span></span><br><span class="line">        <span class="keyword">let</span> &#123; method, pathname, handler &#125; = layer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; <span class="comment">// 如果存在错误将错误交给错误处理中间件，否则</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>, handle.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hanlder(err, req, res, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在错误则继续向下执行</span></span><br><span class="line">          <span class="comment">// 判断是中间件还是路由</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">              <span class="comment">// 匹配路径判断</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                pathname === <span class="string">'/'</span> ||</span><br><span class="line">                pathname === req.path ||</span><br><span class="line">                req.path.startWidth(pathname)</span><br><span class="line">              ) &#123;</span><br><span class="line">                handler(req, res, next);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">              <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">              <span class="keyword">const</span> result = req.path.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                result &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                  method === layer.method ||</span><br><span class="line">                  layer.method === <span class="string">'all'</span></span><br><span class="line">                )</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">                req.params = layer.paramNames.reduce(</span><br><span class="line">                  <span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">                    memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">return</span> memo;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行对应的回调</span></span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (req.path === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">                (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">        res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">      <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">      <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">      req.path = reqPath;</span><br><span class="line">      <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">      req.query = querystring.parse(query);</span><br><span class="line">      <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">      req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应方法</span></span><br><span class="line">      res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">            params = util.inspect(params);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">            params = httpServer.STATUS_CODES[params];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        res.end(params);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应文件方法</span></span><br><span class="line">      res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">        fs.createReadStream(pathname).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">      <span class="comment">// 模板渲染方法</span></span><br><span class="line">      res.render = <span class="function"><span class="keyword">function</span>(<span class="params">filename, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将文件名和模板路径拼接</span></span><br><span class="line">        <span class="keyword">let</span> filepath = path.join(app.get(<span class="string">'views'</span>), filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展名</span></span><br><span class="line">        <span class="keyword">let</span> extname = path.extname(filename.split(path.sep).pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有扩展名，则使用默认的扩展名</span></span><br><span class="line">        <span class="keyword">if</span> (!extname) &#123;</span><br><span class="line">          extname = <span class="string">`.<span class="subst">$&#123;app.get(<span class="string">'view engine'</span>)&#125;</span>`</span></span><br><span class="line">          filepath += extname;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取模板文件并使用渲染引擎相应给浏览器</span></span><br><span class="line">        app.engines[extname](filepath, data, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>&#123;</span><br><span class="line">          res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">          res.end(html);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下执行</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">      <span class="comment">// 满足条件说明是取值方法</span></span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> app.settings[pathname];</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span> &amp;&amp; pathname.method !== <span class="string">'middle'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加中间件方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理没有传入路径的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = pathname;</span><br><span class="line">      pathname = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成函数并执行</span></span><br><span class="line">    createRouteMethod(<span class="string">'middle'</span>)(pathname, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将初始逻辑作为中间件执行</span></span><br><span class="line">  app.use(init());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  <span class="comment">// 存储设置的对象</span></span><br><span class="line">  app.setting =&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储模板渲染方法</span></span><br><span class="line">  app.engines = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加设置的方法</span></span><br><span class="line">  app.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    app.use[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加渲染引擎的方法</span></span><br><span class="line">  app.engine = <span class="function"><span class="keyword">function</span>(<span class="params">ext, renderFile</span>) </span>&#123;</span><br><span class="line">    app.engines[ext] = renderFile;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>在上面新增代码中设置了两个缓存 <code>settings</code> 和 <code>engines</code>，前者用来存储模板相关的设置，如渲染成什么类型的文件、读取模板文件的根目录，后者用来存储渲染引擎，即渲染模板的方法，这所以设置这两个缓存对象是为了实现 <code>Express</code> 多种不同模板共存的功能，可以根据需要进行设置和使用，而设置的方法分别为 <code>app.set</code> 和 <code>app.engine</code>，有设置值的方法就应该有取值的方法，但是 <code>app.get</code> 方法已经被设置为路由方法了，为了语义我们在 <code>app.get</code> 方法逻辑中进行了兼容，当参数为 <code>1</code> 个时，从 <code>settings</code> 中取值并返回，否则执行添加路由方法的逻辑。</p><p>之前都是准备工作，在使用时无论是中间件还是路由中都是靠调用 <code>res.render</code> 方法并传入模板路径和渲染数据来真正实现渲染和响应的，<code>render</code> 方法是在 <code>init</code> 函数初始化时就挂在了 <code>res</code> 上，核心逻辑是取出传入的模板文件后缀名，如果存在则使用后缀名，将文件名与默认读取模板的文件夹路径拼接传递给设置的渲染引擎的渲染方法，如果不存在后缀名则默认拼接 <code>.html</code> 当作后缀名，再与默认读取模板路径进行拼接，在渲染函数的回调中将渲染引擎渲染的模板字符串响应给浏览器。</p><h2 id="内置静态资源中间件的实现"><a href="#内置静态资源中间件的实现" class="headerlink" title="内置静态资源中间件的实现"></a>内置静态资源中间件的实现</h2><p>在 <code>Express</code> 内部可以通过路由处理静态文件，但是如果可能请求多个文件不可能一个文件对应一个路由，因此 <code>Express</code> 内部实现了静态文件中间件，使用如下。</p><figure class="highlight js"><figcaption><span>静态文件中间件的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用处理静态文件中间件</span></span><br><span class="line">app.use(express.static(path.resolve(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>从上面使用可以看出，<code>express.static</code> 是一个函数，执行的时候传入了一个参数，为默认查找文件的根路径，而添加中间件的 <code>app.use</code> 方法传入的参数正好是回调函数，这说明 <code>express.static</code> 方法需要返回一个函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，通过调用方式我们能看出 <code>static</code> 是静态方法，挂在了模块返回的函数上，实现代码如下（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取第一个回调函数</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[index++];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">// 将当前中间件函数的属性解构出来</span></span><br><span class="line">        <span class="keyword">let</span> &#123; method, pathname, handler &#125; = layer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; <span class="comment">// 如果存在错误将错误交给错误处理中间件，否则</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>, handle.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hanlder(err, req, res, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在错误则继续向下执行</span></span><br><span class="line">          <span class="comment">// 判断是中间件还是路由</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配路径判断</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              pathname === <span class="string">'/'</span> ||</span><br><span class="line">              pathname === req.path ||</span><br><span class="line">              req.path.startWidth(pathname)</span><br><span class="line">            ) &#123;</span><br><span class="line">              handler(req, res, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              next();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">              <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">              <span class="keyword">const</span> result = req.path.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                result &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                  method === layer.method ||</span><br><span class="line">                  layer.method === <span class="string">'all'</span></span><br><span class="line">                )</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">                req.params = layer.paramNames.reduce(</span><br><span class="line">                  <span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">                    memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">return</span> memo;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行对应的回调</span></span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (req.path === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">                (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">        res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">      <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">      <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">      req.path = reqPath;</span><br><span class="line">      <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">      req.query = querystring.parse(query);</span><br><span class="line">      <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">      req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应方法</span></span><br><span class="line">      res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line">            <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">            params = util.inspect(params);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">            params = httpServer.STATUS_CODES[params];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        res.end(params);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应文件方法</span></span><br><span class="line">      res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">        fs.createReadStream(pathname).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模板渲染方法</span></span><br><span class="line">      res.render = <span class="function"><span class="keyword">function</span>(<span class="params">filename, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将文件名和模板路径拼接</span></span><br><span class="line">        <span class="keyword">let</span> filepath = path.join(app.get(<span class="string">'views'</span>), filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展名</span></span><br><span class="line">        <span class="keyword">let</span> extname = path.extname(filename.split(path.sep).pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有扩展名，则使用默认的扩展名</span></span><br><span class="line">        <span class="keyword">if</span> (!extname) &#123;</span><br><span class="line">          extname = <span class="string">`.<span class="subst">$&#123;app.get(<span class="string">'view engine'</span>)&#125;</span>`</span></span><br><span class="line">          filepath += extname;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取模板文件并使用渲染引擎相应给浏览器</span></span><br><span class="line">        app.engines[extname](filepath, data, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>&#123;</span><br><span class="line">          res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">          res.end(html);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下执行</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 满足条件说明是取值方法</span></span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> app.settings[pathname];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span> &amp;&amp; pathname.method !== <span class="string">'middle'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加中间件方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理没有传入路径的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = pathname;</span><br><span class="line">      pathname = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成函数并执行</span></span><br><span class="line">    createRouteMethod(<span class="string">'middle'</span>)(pathname, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将初始逻辑作为中间件执行</span></span><br><span class="line">  app.use(init());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储设置的对象</span></span><br><span class="line">  app.setting =&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储模板渲染方法</span></span><br><span class="line">  app.engines = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加设置的方法</span></span><br><span class="line">  app.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    app.use[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加渲染引擎的方法</span></span><br><span class="line">  app.engine = <span class="function"><span class="keyword">function</span>(<span class="params">ext, renderFile</span>) </span>&#123;</span><br><span class="line">    app.engines[ext] = renderFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">createApplication.static = <span class="function"><span class="keyword">function</span>(<span class="params">staticRoot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件的完整路径</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(staticRoot, req.path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应</span></span><br><span class="line">    fs.access(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置响应头类型和响应文件内容</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">`<span class="subst">$&#123;mime.getType()&#125;</span>;charset=utf8`</span>);</span><br><span class="line">        fs.createReadStream(filename).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>这个方法的核心逻辑是获取文件的路径，检查文件的权限，如果没有权限，则调用 <code>next</code> 交给其他中间件，这里注意的是 <code>err</code> 错误对象不要传递给 <code>next</code>，因为后面的中间件还要执行，如果传递后会直接执行错误处理中间件，有权限的情况下就正常读取文件内容，给 <code>Content-Type</code> 响应头设置文件类型，并将文件的可读流通过 <code>pipe</code> 方法传递给可写流 <code>res</code>，即响应给浏览器。</p><h2 id="实现重定向"><a href="#实现重定向" class="headerlink" title="实现重定向"></a>实现重定向</h2><p>在 <code>Express</code> 中有一个功能在我们匹配到的某一个路由中调用可以直接跳转到另一个路由，即 <code>302</code> 重定向。</p><figure class="highlight js"><figcaption><span>使用重定向</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'user'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/detail'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 访问 /detail 重定向到 /user</span></span><br><span class="line">  res.redirect(<span class="string">'/user'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>看到上面的使用方式，我们根据前面的套路知道是 <code>Express</code> 在 <code>res</code> 对象上给挂载了一个 <code>redirect</code> 方法，参数为状态码（可选）和要跳转路由的路径，并且这个方法应该在 <code>init</code> 函数调用时挂在 <code>res</code> 上的，下面是实现的代码（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取第一个回调函数</span></span><br><span class="line">      <span class="keyword">let</span> layer = app.routes[index++];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">// 将当前中间件函数的属性解构出来</span></span><br><span class="line">        <span class="keyword">let</span> &#123; method, pathname, handler &#125; = layer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; <span class="comment">// 如果存在错误将错误交给错误处理中间件，否则</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>, handle.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hanlder(err, req, res, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在错误则继续向下执行</span></span><br><span class="line">          <span class="comment">// 判断是中间件还是路由</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配路径判断</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              pathname === <span class="string">'/'</span> ||</span><br><span class="line">              pathname === req.path ||</span><br><span class="line">              req.path.startWidth(pathname)</span><br><span class="line">            ) &#123;</span><br><span class="line">              handler(req, res, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              next();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">              <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">              <span class="keyword">const</span> result = req.path.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                result &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                  method === layer.method ||</span><br><span class="line">                  layer.method === <span class="string">'all'</span></span><br><span class="line">                )</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">                req.params = layer.paramNames.reduce(</span><br><span class="line">                  <span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">                    memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">return</span> memo;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行对应的回调</span></span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (req.path === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">                (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">        res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">      <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">      <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">      req.path = reqPath;</span><br><span class="line">      <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">      req.query = querystring.parse(query);</span><br><span class="line">      <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">      req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应方法</span></span><br><span class="line">      res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">            params = util.inspect(params);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">            params = httpServer.STATUS_CODES[params];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        res.end(params);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应文件方法</span></span><br><span class="line">      res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">        fs.createReadStream(pathname).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模板渲染方法</span></span><br><span class="line">      res.render = <span class="function"><span class="keyword">function</span>(<span class="params">filename, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将文件名和模板路径拼接</span></span><br><span class="line">        <span class="keyword">let</span> filepath = path.join(app.get(<span class="string">'views'</span>), filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展名</span></span><br><span class="line">        <span class="keyword">let</span> extname = path.extname(filename.split(path.sep).pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有扩展名，则使用默认的扩展名</span></span><br><span class="line">        <span class="keyword">if</span> (!extname) &#123;</span><br><span class="line">          extname = <span class="string">`.<span class="subst">$&#123;app.get(<span class="string">'view engine'</span>)&#125;</span>`</span></span><br><span class="line">          filepath += extname;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取模板文件并使用渲染引擎相应给浏览器</span></span><br><span class="line">        app.engines[extname](filepath, data, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>&#123;</span><br><span class="line">          res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">          res.end(html);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">      <span class="comment">// 重定向方法</span></span><br><span class="line">      res.redirect = <span class="function"><span class="keyword">function</span>(<span class="params">status, target</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果第一个参数是字符串类型说明没有传状态码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> status === <span class="string">'string'</span>) &#123;</span><br><span class="line">          <span class="comment">// 将第二个参数（重定向的目标路径）设置给 target</span></span><br><span class="line">          target = status;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 再把状态码设置成 302</span></span><br><span class="line">          status = <span class="number">302</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应状态码，设置重定向响应头</span></span><br><span class="line">        res.statusCode = status;</span><br><span class="line">        res.setHeader(<span class="string">'Location'</span>, target);</span><br><span class="line">        res.end();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下执行</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 满足条件说明是取值方法</span></span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> app.settings[pathname];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span> &amp;&amp; pathname.method !== <span class="string">'middle'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加中间件方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理没有传入路径的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = pathname;</span><br><span class="line">      pathname = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成函数并执行</span></span><br><span class="line">    createRouteMethod(<span class="string">'middle'</span>)(pathname, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将初始逻辑作为中间件执行</span></span><br><span class="line">  app.use(init());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储设置的对象</span></span><br><span class="line">  app.setting =&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储模板渲染方法</span></span><br><span class="line">  app.engines = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加设置的方法</span></span><br><span class="line">  app.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    app.use[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加渲染引擎的方法</span></span><br><span class="line">  app.engine = <span class="function"><span class="keyword">function</span>(<span class="params">ext, renderFile</span>) </span>&#123;</span><br><span class="line">    app.engines[ext] = renderFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createApplication.static = <span class="function"><span class="keyword">function</span>(<span class="params">staticRoot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件的完整路径</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(staticRoot, req.path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应</span></span><br><span class="line">    fs.access(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置响应头类型和响应文件内容</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">`<span class="subst">$&#123;mime.getType()&#125;</span>;charset=utf8`</span>);</span><br><span class="line">        fs.createReadStream(filename).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>其实 <code>res.redirect</code> 方法的核心逻辑就是处理参数，如果没有传状态码的时候将参数设置给 <code>target</code>，将状态码设置为 <code>302</code>，并设置重定向响应头 <code>Location</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>到此为止 <code>Express</code> 的大部分内置功能就都简易的实现了，由于 <code>Express</code> 内部的封装思想，以及代码复杂、紧密的特点，各个功能代码很难单独拆分，总结一下就是很难表述清楚，只能通过大量代码来堆砌，好在每一部分实现我都标记了 “重点”，但看的时候还是要经历 “痛苦”，这已经将 <code>Express</code> 中的逻辑 “阉割” 到了一定的程度，读 <code>Express</code> 的源码一定比读这篇文章更需要耐心，当然如果你已经读到了这里证明困难都被克服了，继续加油。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Express </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koa2 中间件原理解析 —— 看了就会写</title>
      <link href="/2018/08/20/20180820200342/"/>
      <url>/2018/08/20/20180820200342/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/20/20180820200342/koa-middleware.png" title="Koa 中间件"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><code>Koa 2.x</code> 版本是当下最流行的 NodeJS 框架，<code>Koa 2.0</code> 的源码特别精简，不像 <code>Express</code> 封装的功能那么多，所以大部分的功能都是由 <code>Koa</code> 开发团队（同 <code>Express</code> 是一家出品）和社区贡献者针对 <code>Koa</code> 对 NodeJS 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 <code>Koa</code> 的 <code>use</code> 方法使用在对应的位置，这样就可以通过在内部操作 <code>ctx</code> 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 <code>Koa</code> 中间件供自己和别人使用。</p></blockquote><a id="more"></a><h2 id="Koa-的洋葱模型介绍"><a href="#Koa-的洋葱模型介绍" class="headerlink" title="Koa 的洋葱模型介绍"></a>Koa 的洋葱模型介绍</h2><p>我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 API 的使用方式及洋葱模型分析中间件是如何工作的。</p><figure class="highlight js"><figcaption><span>洋葱模型特点</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Koa</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们知道 <code>Koa</code> 的 <code>use</code> 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 <code>next</code> 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 <code>Koa</code> 中都是建议使用 <code>async/await</code> 的，引入的中间件都是在 <code>use</code> 方法中调用，由此我们可以分析出每一个 <code>Koa</code> 的中间件都是返回一个 <code>async</code> 函数的。</p><h2 id="koa-bodyparser-中间件模拟"><a href="#koa-bodyparser-中间件模拟" class="headerlink" title="koa-bodyparser 中间件模拟"></a>koa-bodyparser 中间件模拟</h2><p>想要分析 <code>koa-bodyparser</code> 的原理首先需要知道用法和作用，<code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值，使用前需提前安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-bodyparser</span><br></pre></td></tr></table></figure><p><strong>koa-bodyparser 具体用法如下：</strong></p><figure class="highlight js"><figcaption><span>koa-bodyparser 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用中间件</span></span><br><span class="line">app.use(bodyParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">'/'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>根据用法我们可以看出 <code>koa-bodyparser</code> 中间件引入的其实是一个函数，我们把它放在了 <code>use</code> 中执行，根据 <code>Koa</code> 的特点，我们推断出 <code>koa-bodyparser</code> 的函数执行后应该给我们返回了一个 <code>async</code> 函数，下面是我们模拟实现的代码。</p><figure class="highlight js"><figcaption><span>文件：my-koa-bodyparser.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">bodyParser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 存储数据的数组</span></span><br><span class="line">      <span class="keyword">const</span> dataArr = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 接收数据</span></span><br><span class="line">      ctx.req.on(<span class="string">'data'</span>, data =&gt; dataArr.push(data));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 整合数据并使用 Promise 成功</span></span><br><span class="line">      ctx.req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取请求数据的类型 json 或表单</span></span><br><span class="line">        <span class="keyword">const</span> contentType = ctx.get(<span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据 Buffer 格式</span></span><br><span class="line">        <span class="keyword">const</span> data = Buffer.concat(dataArr).toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (contentType === <span class="string">'application/x-www-form-urlencoded'</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body</span></span><br><span class="line">          ctx.request.body = querystring.parse(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType === <span class="string">'applaction/json'</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body</span></span><br><span class="line">          ctx.request.body = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行成功的回调</span></span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续向下执行</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中由几点是需要我们注意的，即 <code>next</code> 的调用以及为什么通过流接收数据、处理数据和将数据挂在 <code>ctx.request.body</code> 要在 Promise 中进行。</p><blockquote class="pullquote info"><p><em><strong>首先是 <code>next</code> 的调用，我们知道 <code>Koa</code> 的 <code>next</code> 执行，其实就是在执行下一个中间件的函数，即下一个 <code>use</code> 中的 <code>async</code> 函数，为了保证后面的异步代码执行完毕后再继续执行当前的代码，所以我们需要使用 <code>await</code> 进行等待，其次就是数据从接收到挂在 <code>ctx.request.body</code> 都在 Promise 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 <code>ctx.request.body</code> 上，可以保证我们在下一个 <code>use</code> 的 <code>async</code> 函数中可以在 <code>ctx.request.body</code> 上拿到数据，所以我们使用 <code>await</code> 等待一个 Promise 成功后再执行 <code>next</code>。</strong></em></p></blockquote><h2 id="koa-better-body-中间件模拟"><a href="#koa-better-body-中间件模拟" class="headerlink" title="koa-better-body 中间件模拟"></a>koa-better-body 中间件模拟</h2><p><code>koa-bodyparser</code> 在处理表单提交时还是显得有一点弱，因为不支持文件上传，而 <code>koa-better-body</code> 则弥补了这个不足，但是 <code>koa-better-body</code> 为 <code>Koa 1.x</code> 版本的中间件，<code>Koa 1.x</code> 的中间件都是使用 <code>Generator</code> 函数实现的，我们需要使用 <code>koa-convert</code> 将 <code>koa-better-body</code> 转化成 <code>Koa 2.x</code> 的中间件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-better-body koa-convert path uuid</span><br></pre></td></tr></table></figure><p><strong>koa-better-body 具体用法如下：</strong></p><figure class="highlight js"><figcaption><span>koa-better-body 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> betterBody = <span class="built_in">require</span>(<span class="string">'koa-better-body'</span>);</span><br><span class="line"><span class="keyword">const</span> convert = <span class="built_in">require</span>(<span class="string">'koa-convert'</span>); <span class="comment">// 将  koa 1.0 中间转化成 koa 2.0 中间件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>); <span class="comment">// 生成随机串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 koa-better-body 中间件从 koa 1.0 转化成 koa 2.0，并使用中间件</span></span><br><span class="line">app.use(convert(betterBody(&#123;</span><br><span class="line">  uploadDir: path.resolve(__dirname, <span class="string">'upload'</span>)</span><br><span class="line">&#125;)));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">'/'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用中间件后 ctx.request.fields 属性自动加上了 post 请求的文件数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.fields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件重命名</span></span><br><span class="line">    <span class="keyword">let</span> imgPath = ctx.request.fields.avatar[<span class="number">0</span>].path;</span><br><span class="line">    <span class="keyword">let</span> newPath = path.resolve(__dirname, uuid());</span><br><span class="line">    fs.rename(imgPath, newPath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中 <code>koa-better-body</code> 的主要功能就是将表单上传的文件存入本地指定的文件夹下，并将文件流对象挂在了 <code>ctx.request.fields</code> 属性上，我们接下来就模拟 <code>koa-better-body</code> 的功能实现一版基于 <code>Koa 2.x</code> 处理文件上传的中间件。</p><figure class="highlight js"><figcaption><span>文件：my-koa-better-body.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 Buffer 扩展 split 方法预备后面使用</span></span><br><span class="line">Buffer.prototype.split = <span class="function"><span class="keyword">function</span> (<span class="params">sep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = Buffer.from(sep).length; <span class="comment">// 分隔符所占的字节数</span></span><br><span class="line">  <span class="keyword">let</span> result = []; <span class="comment">// 返回的数组</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>; <span class="comment">// 查找 Buffer 的起始位置</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>; <span class="comment">// 偏移量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找分隔符</span></span><br><span class="line">  <span class="keyword">while</span> ((offset = <span class="keyword">this</span>.indexOf(sep, start)) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 将分隔符之前的部分截取出来存入</span></span><br><span class="line">    result.push(<span class="keyword">this</span>.slice(start, offset));</span><br><span class="line">    start = offset + len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理剩下的部分</span></span><br><span class="line">  result.push(<span class="keyword">this</span>.slice(start));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> dataArr = []; <span class="comment">// 存储读取的数据</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取数据</span></span><br><span class="line">      ctx.req.on(<span class="string">'data'</span>, data =&gt; dataArr.push(data));</span><br><span class="line"></span><br><span class="line">      ctx.req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 取到请求体每段的分割线字符串</span></span><br><span class="line">        <span class="keyword">let</span> bondery = <span class="string">`--<span class="subst">$&#123;ctx.get(<span class="string">'content-Type'</span>).split(<span class="string">'='</span>)[<span class="number">1</span>]&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取不同系统的换行符</span></span><br><span class="line">        <span class="keyword">let</span> lineBreak = process.platform === <span class="string">'win32'</span> ? <span class="string">'\r\n'</span> : <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非文件类型数据的最终返回结果</span></span><br><span class="line">        <span class="keyword">let</span> fields = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分隔的 buffer 去掉没用的头和尾即开头的 '' 和末尾的 '--'</span></span><br><span class="line">        dataArr = dataArr.split(bondery).slice(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环处理 dataArr 中每一段 Buffer 的内容</span></span><br><span class="line">        dataArr.forEach(<span class="function"><span class="params">lines</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 对于普通值，信息由包含键名的行 + 两个换行 + 数据值 + 换行组成</span></span><br><span class="line">          <span class="comment">// 对于文件，信息由包含 filename 的行 + 两个换行 + 文件内容 + 换行组成</span></span><br><span class="line">          <span class="keyword">let</span> [head, tail] = lines.split(<span class="string">`<span class="subst">$&#123;lineBreak&#125;</span><span class="subst">$&#123;lineBreak&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 判断是否是文件，如果是文件则创建文件并写入，如果是普通值则存入 fields 对象中</span></span><br><span class="line">          <span class="keyword">if</span> (head.includes(<span class="string">'filename'</span>)) &#123;</span><br><span class="line">            <span class="comment">// 防止文件内容含有换行而被分割，应重新截取内容并去掉最后的换行</span></span><br><span class="line">            <span class="keyword">let</span> tail = lines.slice(</span><br><span class="line">              head.length + <span class="number">2</span> * lineBreak.length,</span><br><span class="line">              -lineBreak.length</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建可写流并指定写入的路径：</span></span><br><span class="line">            <span class="comment">// 绝对路径 + 指定文件夹 + 随机文件名，最后写入文件</span></span><br><span class="line">            fs.createWriteStream(</span><br><span class="line">              path.join(__dirname, options.uploadDir, uuid())</span><br><span class="line">            ).end(tail);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是普通值取出键名</span></span><br><span class="line">            <span class="keyword">let</span> key = head.match(<span class="regexp">/name='(\w+)'/</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 key 设置给 fields tail 去掉末尾换行后的内容</span></span><br><span class="line">            fields[key] = tail.toString(<span class="string">'utf8'</span>).slice(<span class="number">0</span>, -lineBreak.length);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将处理好的 fields 对象挂在 ctx.request.fields 上，并完成 Promise</span></span><br><span class="line">        ctx.request.fields = fields;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下执行</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的内容逻辑可以通过代码注释来理解，就是模拟 <code>koa-better-body</code> 的功能逻辑，我们主要的关心点在于中间件实现的方式，上面功能实现的异步操作依然是读取数据，为了等待数据处理结束仍然在 Promise 中执行，并使用 <code>await</code> 等待，Promise 执行成功调用 <code>next</code>。</p><h2 id="koa-views-中间件模拟"><a href="#koa-views-中间件模拟" class="headerlink" title="koa-views 中间件模拟"></a>koa-views 中间件模拟</h2><p>Node 模板是我们经常使用的工具用来在服务端帮我们渲染页面，模板的种类繁多，因此出现了 <code>koa-view</code> 中间件，帮我们来兼容这些模板，先安装依赖的模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-views ejs</span><br></pre></td></tr></table></figure><p><strong>下面是一个 ejs 的模板文件：</strong></p><figure class="highlight html"><figcaption><span>文件：index.ejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">'en'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'UTF-8'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ejs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%=</span> <span class="attr">name</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%=</span> <span class="attr">age</span> %&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">name</span>==<span class="string">'panda'</span>) &#123; %&gt;</span></span><br><span class="line">    panda</span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> &#123; %&gt;</span></span><br><span class="line">    shen</span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">arr.forEach</span>(<span class="attr">item</span> =&gt;</span> &#123; %&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=item%</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>koa-views 具体用法如下：</strong></p><figure class="highlight js"><figcaption><span>koa-views 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用中间件</span></span><br><span class="line">app.use(views(path.resolve(__dirname, <span class="string">'views'</span>), &#123;</span><br><span class="line">  extension: <span class="string">'ejs'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>可以看出我们使用了 <code>koa-views</code> 中间件后，让 <code>ctx</code> 上多了 <code>render</code> 方法帮助我们实现对模板的渲染和响应页面，就和直接使用 <code>ejs</code> 自带的 <code>render</code> 方法一样，并且从用法可以看出 <code>render</code> 方法是异步执行的，所以需要使用 <code>await</code> 进行等待，接下来我们就来模拟实现一版简单的 <code>koa-views</code> 中间件。</p><figure class="highlight js"><figcaption><span>文件：my-koa-views.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将读取文件方法转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到处中间件</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">dir, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 动态引入模板依赖模块</span></span><br><span class="line">    <span class="keyword">const</span> view = <span class="built_in">require</span>(options.extension);</span><br><span class="line"></span><br><span class="line">    ctx.render = <span class="keyword">async</span> (filename, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 异步读取文件内容</span></span><br><span class="line">      <span class="keyword">let</span> tmpl = <span class="keyword">await</span> readFile(</span><br><span class="line">        path.join(dir, <span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;options.extension&#125;</span>`</span>),</span><br><span class="line">        <span class="string">'utf8'</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将模板渲染并返回页面字符串</span></span><br><span class="line">      <span class="keyword">let</span> pageStr = view.render(tmpl, data);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置响应类型并响应页面</span></span><br><span class="line">      ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">      ctx.body = pageStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续向下执行</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂在 <code>ctx</code> 上的 <code>render</code> 方法之所以是异步执行的是因为内部读取模板文件是异步执行的，需要等待，所以 <code>render</code> 方法为 <code>async</code> 函数，在中间件内部动态引入了我们使的用模板，如 <code>ejs</code>，并在 <code>ctx.render</code> 内部使用对应的 <code>render</code> 方法获取替换数据后的页面字符串，并以 <code>html</code> 的类型响应。</p><h2 id="koa-static-中间件模拟"><a href="#koa-static-中间件模拟" class="headerlink" title="koa-static 中间件模拟"></a>koa-static 中间件模拟</h2><p>下面是 <code>koa-static</code> 中间件的用法，代码使用的依赖如下，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-static mime</span><br></pre></td></tr></table></figure><p><strong>koa-static 具体用法如下：</strong></p><figure class="highlight js"><figcaption><span>koa-static 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">static</span>(path.resolve(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'hello world'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过使用和分析，我们知道了 <code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件，如果我们直接访问文件名的时候，会查找这个文件并直接响应，如果没有这个文件路径会当作文件夹，并查找文件夹下的 <code>index.html</code>，如果存在则直接响应，如果不存在则交给其他中间件处理。</p><figure class="highlight js"><figcaption><span>文件：my-koa-static.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 stat 和 access 转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> stat = promisify(fs.stat);</span><br><span class="line"><span class="keyword">const</span> access = promisify(fs.access)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /</span></span><br><span class="line">    <span class="keyword">let</span> realPath = path.join(dir, ctx.path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 stat 对象</span></span><br><span class="line">      <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(realPath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html</span></span><br><span class="line">      <span class="keyword">if</span> (statObj.isFile()) &#123;</span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">`<span class="subst">$&#123;mime.getType()&#125;</span>;charset=utf8`</span>);</span><br><span class="line">        ctx.body = fs.createReadStream(realPath);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filename = path.join(realPath, <span class="string">'index.html'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理</span></span><br><span class="line">        <span class="keyword">await</span> access(filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存在设置文件类型并响应内容</span></span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">        ctx.body = fs.createReadStream(filename);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑中需要检测路径是否存在，由于我们导出的函数都是 <code>async</code> 函数，所以我们将 <code>stat</code> 和 <code>access</code> 转化成了 Promise，并用 <code>try...catch</code> 进行捕获，在路径不合法时调用 <code>next</code> 交给其他中间件处理。</p><h2 id="koa-router-中间件模拟"><a href="#koa-router-中间件模拟" class="headerlink" title="koa-router 中间件模拟"></a>koa-router 中间件模拟</h2><p>在 <code>Express</code> 框架中，路由是被内置在了框架内部，而 <code>Koa</code> 中没有内置，是使用 <code>koa-router</code> 中间件来实现的，使用前需要安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-router</span><br></pre></td></tr></table></figure><p><code>koa-router</code> 功能非常强大，下面我们只是简单的使用，并且根据使用的功能进行模拟。</p><figure class="highlight js"><figcaption><span>koa-router 的简单用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'Koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/panda'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'panda'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/pandashen'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'pandashen'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/shen'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'shen'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用路由中间件</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>从上面看出 <code>koa-router</code> 导出的是一个类，使用时需要创建一个实例，并且调用实例的 <code>routes</code> 方法将该方法返回的 <code>async</code> 函数进行连接，但是在匹配路由的时候，会根据路由 <code>get</code> 方法中的路径进行匹配，并串行执行内部的回调函数，当所有回调函数执行完毕之后会执行整个 <code>Koa</code> 串行的 <code>next</code>，原理同其他中间件，我下面来针对上面使用的功能简易实现。</p><figure class="highlight js"><figcaption><span>文件：my-koa-router.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制每一个路由层的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.path = path;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">  &#125;</span><br><span class="line">  match(path) &#123;</span><br><span class="line">    <span class="comment">// 地址的路由和当前配置路由相等返回 true，否则返回 false</span></span><br><span class="line">    <span class="keyword">return</span> path === <span class="keyword">this</span>.path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 存放每个路由对象的数组，&#123; path: /xxx, fn: cb &#125;</span></span><br><span class="line">    <span class="keyword">this</span>.layers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(path, cb) &#123;</span><br><span class="line">    <span class="comment">// 将路由对象存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.layers.push(<span class="keyword">new</span> Layer(path, cb));</span><br><span class="line">  &#125;</span><br><span class="line">  compose(ctx, next, handlers) &#123;</span><br><span class="line">    <span class="comment">// 将匹配的路由函数串联执行</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前 index 个数大于了存储路由对象的长度，则执行 Koa 的 next 方法</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= handlers.length) <span class="keyword">return</span> next();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 否则调用取出的路由对象的回调执行</span></span><br><span class="line">      <span class="comment">// 并传入一个函数，在传入的函数中递归 dispatch(index + 1)</span></span><br><span class="line">      <span class="comment">// 目的是为了执行下一个路由对象上的回调函数</span></span><br><span class="line">      handlers[index].cb(ctx, () =&gt; dispatch(index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次执行路由对象的回调函数</span></span><br><span class="line">    dispatch(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  routes() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) &#123;</span><br><span class="line">      <span class="comment">// 当前 next 是 Koa 自己的 next，即 Koa 其他的中间件</span></span><br><span class="line">      <span class="comment">// 筛选出路径相同的路由</span></span><br><span class="line">      <span class="keyword">let</span> handlers = <span class="keyword">this</span>.layers.filter(<span class="function"><span class="params">layer</span> =&gt;</span> layer.match(ctx.path));</span><br><span class="line">      <span class="keyword">this</span>.compose(ctx, next, handlers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们创建了一个 <code>Router</code> 类，定义了 <code>get</code> 方法，当然还有 <code>post</code> 等，我们只实现 <code>get</code> 意思一下，<code>get</code> 内为逻辑为将调用 <code>get</code> 方法的参数函数和路由字符串共同构建成对象存入了数组 <code>layers</code>，所以我们创建了专门构造路由对象的类 <code>Layer</code>，方便扩展，在路由匹配时我们可以根据 <code>ctx.path</code> 拿到路由字符串，并通过该路由过滤调数组中与路由不匹配的路由对象，调用 <code>compose</code> 方法将过滤后的数组作为参数 <code>handlers</code> 传入，串行执行路由对象上的回调函数。</p><blockquote class="pullquote warning"><p><em><strong><code>compose</code> 这个方法的实现思想非常的重要，在 <code>Koa</code> 源码中用于串联中间件，在 <code>React</code> 源码中用于串联 <code>redux</code> 的 <code>promise</code>、<code>thunk</code> 和 <code>logger</code> 等模块，我们的实现是一个简版，并没有兼容异步，主要思想是递归 <code>dispatch</code> 函数，每次取出数组中下一个路由对象的回调函数执行，直到所有匹配的路由的回调函数都执行完，执行 <code>Koa</code> 的下一个中间件 <code>next</code>，注意此处的 <code>next</code> 不同于数组中回调函数的参数 <code>next</code>，数组中路由对象回调函数的 <code>next</code> 代表下一个匹配路由的回调。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>上面我们分析和模拟了一些中间件，其实我们会理解 <code>Koa</code> 和 <code>Express</code> 相比较的优势是没有那么繁重，开发使用方便，需要的功能都可以用对应的中间件来实现，使用中间件可以给我们带来一些好处，比如能将我们处理好的数据和新方法挂载在 <code>ctx</code> 上，方便后面 <code>use</code> 传入的回调函数中使用，也可以帮我们处理一些公共逻辑，不至于在每一个 <code>use</code> 的回调中都去处理，大大减少了冗余代码，由此看来其实给 <code>Koa</code> 使用中间件的过程就是一个典型的 “装饰器” 模式，在通过上面的分析之后相信大家也了解了 <code>Koa</code> 的 “洋葱模型” 和异步特点，知道该如何开发自己的中间件了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 中间件 </tag>
            
            <tag> async/await </tag>
            
            <tag> Koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 使用 cookie 和 session</title>
      <link href="/2018/08/17/20180817153635/"/>
      <url>/2018/08/17/20180817153635/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/17/20180817153635/cookie-session.png" title="cookie-session"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>由于浏览器无状态的特性，<code>cookie</code> 技术应运而生，<code>cookie</code> 是一个会话级的存储，大小 <code>4KB</code> 左右，用于浏览器将服务器设置的信息重新带给服务器进行验证，不支持跨域，在浏览器清空缓存或超过有效期后失效，不能存放敏感信息，<code>session</code> 是专门用于存储最初设置给浏览器 <code>cookie</code> 数据的地方，我们本篇就来讨论一下 <code>cookie</code> 和 <code>session</code> 在 NodeJS 中的使用方式。</p></blockquote><a id="more"></a><h2 id="cookie-的基本使用"><a href="#cookie-的基本使用" class="headerlink" title="cookie 的基本使用"></a>cookie 的基本使用</h2><h3 id="NodeJS-原生操作-cookie"><a href="#NodeJS-原生操作-cookie" class="headerlink" title="NodeJS 原生操作 cookie"></a>NodeJS 原生操作 cookie</h3><p>下面是 <code>cookie</code> 在 Node 原生中的读取和写入方法。</p><figure class="highlight js"><figcaption><span>原生中操作 cookie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/read'</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取 cookie</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.headers.cookie);</span><br><span class="line">    res.end(req.headers.cookie);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">'/write'</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置 cookie</span></span><br><span class="line">    res.setHeader(<span class="string">'Set-Cookie'</span>, [</span><br><span class="line">      <span class="string">'name=panda; domain=panda.com; path=/write; httpOnly=true'</span>,</span><br><span class="line">      <span class="string">`age=28; Expires=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">1000</span> * <span class="number">10</span>).toGMTString()&#125;</span>`</span>,</span><br><span class="line">      <span class="string">`address=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(<span class="string">'回龙观'</span>)&#125;</span>; max-age=10`</span></span><br><span class="line">    ]);</span><br><span class="line">    res.end(<span class="string">'Write ok'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面代码创建了一个 <code>http</code> 服务器，可以通过读取 <code>cookie</code> 请求头的值来获取浏览器发来的 <code>cookie</code>，服务器可以通过给浏览器设置响应头 <code>Set-Cookie</code> 实现对浏览器 <code>cookie</code> 的设置，多个 <code>cookie</code> 参数为数组，在数组内可以规定每一条 <code>cookie</code> 的规则，中间使用一个分号和一个空格隔开。</p><ul><li><code>domain</code> 用来设置允许访问 <code>cookie</code> 的域；</li><li><code>path</code> 用来设置允许访问 <code>cookie</code> 的路径；</li><li><code>httpOnly</code> 用来设置是否允许浏览器中修改 <code>cookie</code>，如果通过浏览器修改设置过 <code>httpOnly=true</code> 的 <code>cookie</code>，则会增加一条同名 <code>cookie</code>，原来的 <code>cookie</code> 不会被修改；</li><li><code>Expires</code> 用来设置过期时间，绝对时间，值为一个 <code>GMT</code> 或 <code>UTC</code> 格式的时间；</li><li><code>max-age</code> 同样用来设置过期时间，相对时间，值为一个正整数，单位 <code>s</code>。</li></ul><blockquote class="pullquote info"><p><em><strong><code>cookie</code> 默认不支持存储中文，如果存储中文需先使用 <code>encodeURIComponent</code> 方法进行转译，将转译后的结果存入 <code>cookie</code>，在浏览器获取 <code>cookie</code> 需使用 <code>decodeURIComponent</code> 方法转回中文。</strong></em></p></blockquote><h3 id="Koa-中操作-cookie"><a href="#Koa-中操作-cookie" class="headerlink" title="Koa 中操作 cookie"></a>Koa 中操作 cookie</h3><p><code>Koa</code> 是当下流行的 NodeJS 框架，是对原生 Node 的一个轻量的封装，但是内部实现了快捷操作 <code>cookie</code> 的方法，下面是原生中对 <code>cookie</code> 的操作在 <code>Koa</code> 中的写法。</p><figure class="highlight js"><figcaption><span>Koa 中操作 cookie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务和路由</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名需要设置 key</span></span><br><span class="line">app.keys = [<span class="string">'shen'</span>];</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/read'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取 cookie</span></span><br><span class="line">  <span class="keyword">let</span> name = ctx.cookies.get(name) || <span class="string">'No name'</span>;</span><br><span class="line">  <span class="keyword">let</span> name = ctx.cookies.get(age) || <span class="string">'No age'</span>;</span><br><span class="line">  ctx.body = <span class="string">`<span class="subst">$&#123;name&#125;</span>-<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/write'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设置 cookie</span></span><br><span class="line">  ctx.cookies.set(<span class="string">'name'</span>, <span class="string">'panda'</span>, &#123; <span class="attr">domain</span>: <span class="string">'panda.com'</span> &#125;);</span><br><span class="line">  ctx.cookies.set(<span class="string">'age'</span>, <span class="number">28</span>, &#123; <span class="attr">maxAge</span>: <span class="number">10</span> * <span class="number">1000</span>, <span class="attr">signed</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>在 <code>Koa</code> 中将获取和设置 <code>cookie</code> 的方法都挂在了 <code>ctx</code> 上下文对象的 <code>cookies</code> 属性上，分别为 <code>get</code> 和 <code>set</code>。</p><p><code>cookies.get</code> 的参数为获取 <code>cookie</code> 的键名，返回值为键对应的值，<code>cookies.set</code> 的第一个参数同样为 <code>cookie</code> 的键名，第二个参数为键对应的值，第三个参数为一个对象，用来配置该条 <code>cookie</code> 的规则，如 <code>domain</code>、<code>path</code> 和过期时间等，这里 <code>maxAge</code> 值为毫秒数。</p><blockquote class="pullquote warning"><p><em><strong>注意：<code>Koa</code> 中设置的 <code>cookie</code> 默认不允许浏览器端通过 <code>document.cookie</code> 获取，但是服务器也可以被欺骗，比如使用 <code>postman</code> 发送一个带 <code>Cookie</code> 请求头的请求，服务器可以通过设置签名来预防，即添加 <code>signed</code> 选项并将值设置为 <code>true</code>。</strong></em></p></blockquote><h3 id="Koa-操作-cookie-方法的原理"><a href="#Koa-操作-cookie-方法的原理" class="headerlink" title="Koa 操作 cookie 方法的原理"></a>Koa 操作 cookie 方法的原理</h3><p><code>cookies</code> 对象都是挂在 <code>ctx</code> 上来实现的，使用过 <code>Koa</code> 都知道如果要操作 <code>ctx</code> 就会用到中间件的思想，我们这就看看这两个方法使用原生封装的过程。</p><figure class="highlight js"><figcaption><span>Koa 中 ctx.cookies 对象 get 和 set 方法的原理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取 cookie</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">get</span> = key =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> cookies = ctx.get(<span class="string">'cookie'</span>) || <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">return</span> querystring.parse(result, <span class="string">'; '</span>)[key];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 cookie，存储所有的 cookie，等于 setHeader 中的第二个参数</span></span><br><span class="line">  <span class="keyword">const</span> cookies = [];</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">set</span> = (key, val, options = &#123;&#125;) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 用于构造单条 cookie 和权限等设置的数组，默认存放这条 cookie 的键和值</span></span><br><span class="line">    <span class="keyword">let</span> single = [<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(val)&#125;</span>`</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是配置</span></span><br><span class="line">    <span class="keyword">if</span> (options.domain) &#123;</span><br><span class="line">      arr.push(<span class="string">`domain=<span class="subst">$&#123;options.domain&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.maxAge) &#123;</span><br><span class="line">      arr.push(<span class="string">`Max-Age=<span class="subst">$&#123;options.maxAge&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.path) &#123;</span><br><span class="line">      arr.push(<span class="string">`path=<span class="subst">$&#123;options.path&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.httpOnly) &#123;</span><br><span class="line">      arr.push(<span class="string">`HttpOnly=true`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将配置组合到 single 中后转为字符串存入 cookies</span></span><br><span class="line">    cookies.push(single.join(<span class="string">'; '</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置给浏览器</span></span><br><span class="line">    ctx.set(<span class="string">'Set-Cookie'</span>, cookies);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将获取和设置 cookie 的方法挂在 cookies 对象上</span></span><br><span class="line">  ctx.cookies = &#123; <span class="keyword">get</span>, <span class="keyword">set</span> &#125;;</span><br><span class="line"></span><br><span class="line">  await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>get</code> 方法内部获取 <code>cookie</code> 请求头的值并根据传入的 <code>key</code> 获取值，<code>set</code> 方法内，将传入的键值和选项拼接成符合 <code>cookie</code> 的字符串，通过 <code>Set-Cookie</code> 响应头设置给浏览器。</p><h2 id="session-的基本使用"><a href="#session-的基本使用" class="headerlink" title="session 的基本使用"></a>session 的基本使用</h2><h3 id="NodeJS-原生使用-session"><a href="#NodeJS-原生使用-session" class="headerlink" title="NodeJS 原生使用 session"></a>NodeJS 原生使用 session</h3><p>正常 <code>session</code> 是存放在数据库中的，我们这里为了方便就用一个名为 <code>session</code> 的对象来代替。</p><figure class="highlight js"><figcaption><span>原生中使用 session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>); <span class="comment">// 生成随字符串</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放 session</span></span><br><span class="line"><span class="keyword">const</span> session = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/user'</span>) &#123;</span><br><span class="line">    <span class="comment">// 取出 cookie 存储的用户 ID</span></span><br><span class="line">    <span class="keyword">let</span> userId = querystring.parse(req.headers[<span class="string">'cookie'</span>], <span class="string">'; '</span>)[<span class="string">'study'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userId) &#123;</span><br><span class="line">      <span class="keyword">if</span> (session[userId].studyCount === <span class="number">0</span>) res.end(<span class="string">'您的学习次数已用完'</span>);</span><br><span class="line">      session[userId].studyCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 生成 userId</span></span><br><span class="line">      userId = uuid();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将用户信息存入 session</span></span><br><span class="line">      session[userId] = &#123; <span class="attr">studyCount</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 cookie</span></span><br><span class="line">      req.setHeader(<span class="string">'Set-Cookie'</span>, [<span class="string">`study=<span class="subst">$&#123;userId&#125;</span>`</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应信息</span></span><br><span class="line">    res.end(<span class="string">`</span></span><br><span class="line"><span class="string">      您的用户 ID 为 <span class="subst">$&#123;userId&#125;</span>，</span></span><br><span class="line"><span class="string">      剩余学习次数为：<span class="subst">$&#123;session[userId].studyCount&#125;</span></span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面写的案例是一个网校的场景，一个新用户默认有 <code>30</code> 次学习机会，以后每次访问服务器学习次数减 <code>1</code>，如果 <code>studyCount</code> 值为 <code>0</code>，则提示学习次数用完，否则提示当前用户的 <code>ID</code> 和剩余学习次数，<code>session</code> 中存储的是每一个用户 <code>ID</code> 对应的剩余学习次数，这样就不会轻易的被修改学习剩余次数，因为服务器只认用户 <code>ID</code>，再通过 <code>ID</code> 去更改对应的剩余次数（当然忽略了别人冒充这个 <code>ID</code> 的情况，只能减，不能加），这样就不会因为篡改 <code>cookie</code> 而篡改用户存在 <code>session</code> 中的数据，除非连整个数据库都拖走。</p><h3 id="Koa-中使用-session"><a href="#Koa-中使用-session" class="headerlink" title="Koa 中使用 session"></a>Koa 中使用 session</h3><p>我们接下来使用 <code>Koa</code> 实现和上面一摸一样的场景，在 <code>Koa</code> 的社区中提供了专门操作 <code>session</code> 的中间件 <code>koa-session</code>，使用前需安装。</p><figure class="highlight js"><figcaption><span>Koa 中使用 session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> session = requier(<span class="string">'koa-session'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务和路由</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cookie 的签名</span></span><br><span class="line">app.keys = [<span class="string">'panda'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 koa-session 中间件</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  key: <span class="string">'shen'</span>,</span><br><span class="line">  maxAge: <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">&#125;, app));</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 取出 cookie 存储的用户 ID</span></span><br><span class="line">  <span class="keyword">let</span> userId = ctx.cookie(<span class="string">'study'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.session.userId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.session[userId].studyCount === <span class="number">0</span>) res.end(<span class="string">'您的学习次数已用完'</span>);</span><br><span class="line">    ctx.session[userId].studyCount--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 生成 userId</span></span><br><span class="line">    userId = uuid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将用户信息存入 session</span></span><br><span class="line">    ctx.session[userId] = &#123; <span class="attr">studyCount</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 cookie</span></span><br><span class="line">    ctx.cookies.set(<span class="string">'study'</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应信息</span></span><br><span class="line">  ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">    您的用户 ID 为 <span class="subst">$&#123;userId&#125;</span>，</span></span><br><span class="line"><span class="string">    剩余学习次数为：<span class="subst">$&#123;session[userId].studyCount&#125;</span></span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>Koa</code> 的 <code>koa-session</code> 以后，不再需要我们创建 <code>session</code> 对象进行存储，并且 <code>cookie-session</code> 中间件帮我们封装了 API 可以直接操作 <code>mongo</code> 和 <code>MySQL</code> 数据库，上面代码中与用原生相比还增加了 <code>cookie</code> 和 <code>session</code> 的签名和过期时间，比原生写起来要方便很多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>本篇内容更偏向于 <code>cookie</code> 和 <code>session</code> 在 NodeJS 中的使用，没有过多的叙述理论性的内容，<code>cookie</code> 和 <code>session</code> 是相互依存的，也就是说共同使用的，现在已经有 JWT 的方案来替代，因为相比较下有很多优点，但某些项目和特殊场景还在使用 <code>cookie</code> 和 <code>session</code>，所以还是写了这一篇，如果对 JWT 感兴趣可以看 <a href="https://www.overtaking.top/2018/08/16/20180816141146/" target="_blank">通过一个案例理解 JWT</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie/session </tag>
            
            <tag> NodeJS </tag>
            
            <tag> Koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过一个案例理解 JWT</title>
      <link href="/2018/08/16/20180816141146/"/>
      <url>/2018/08/16/20180816141146/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/16/20180816141146/jwt.png" title="JWT"><p><br></p><h2 id="JWT-简述"><a href="#JWT-简述" class="headerlink" title="JWT 简述"></a>JWT 简述</h2><blockquote class="pullquote default"><p>JWT（json web token）是为了在网络应用环境之间传递声明而基于 <code>json</code> 的开放标准，JWT 的声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便于从资源服务器获取资源。</p></blockquote><a id="more"></a><h2 id="JWT-的应用场景"><a href="#JWT-的应用场景" class="headerlink" title="JWT 的应用场景"></a>JWT 的应用场景</h2><p>JWT 一般用于用户登录上，身份认证在这种场景下，一旦用户登录完成，在接下来的每个涉及用户权限的请求中都包含 JWT，可以对用户身份、路由、服务和资源的访问权限进行验证。</p><p>举一个例子，假如一个电商网站，在用户登录以后，需要验证用户的地方其实有很多，比如购物车，订单页，个人中心等等，访问这些页面正常的逻辑是先验证用户权限和登录状态，如果验证通过，则进入访问的页面，否则重定向到登录页。</p><p>而在 JWT 之前，这样的验证我们大多都是通过 <code>cookie</code> 和 <code>session</code> 去实现的，我们接下来就来对比以下这两种方式的不同。</p><h2 id="JWT-对比-cookie-session"><a href="#JWT-对比-cookie-session" class="headerlink" title="JWT 对比 cookie/session"></a>JWT 对比 cookie/session</h2><p><strong>cookie/session 的过程：</strong></p><p>由于浏览器的请求是无状态的，<code>cookie</code> 的存在就是为了带给服务器一些状态信息，服务器在接收到请求时会对其进行验证（其实是在登录时，服务器发给浏览器的），如果验证通过则正常返回结果，如果验证不通过则重定向到登录页，而服务器是根据 <code>session</code> 中存储的结果和收到的信息进行对比决定是否验证通过，当然这里只是简述过程。</p><p><strong>cookie/session 的问题：</strong></p><p>从上面可以看出服务器种植 <code>cookie</code> 后每次请求都会带上 <code>cookie</code>，浪费带宽，而且 <code>cookie</code> 不支持跨域，不方便与其他的系统之间进行跨域访问，而服务器会用 <code>session</code> 来存储这些用户验证的信息，这样浪费了服务器的内存，当多个服务器想要共享 <code>session</code> 需要都拷贝过去。</p><p><strong>JWT 的过程：</strong></p><p>当用户发送请求，将用户信息带给服务器的时候，服务器不再像过去一样存储在 <code>session</code> 中，而是将浏览器发来的内容通过内部的密钥加上这些信息，使用 <code>sha256</code> 和 <code>RSA</code> 等加密算法生成一个 <code>token</code> 令牌和用户信息一起返回给浏览器，当涉及验证用户的所有请求只需要将这个 <code>token</code> 和用户信息发送给服务器，而服务器将用户信息和自己的密钥通过既定好的算法进行签名，然后将发来的签名和生成的签名比较，严格相等则说明用户信息没被篡改和伪造，验证通过。</p><blockquote class="pullquote info"><p>JWT 的过程中，服务器不再需要额外的内存存储用户信息，和多个服务器之间只需要共享密钥就可以让多个服务器都有验证能力，同时也解决了 <code>cookie</code> 不能跨域的问题。</p></blockquote><h2 id="JWT-的结构"><a href="#JWT-的结构" class="headerlink" title="JWT 的结构"></a>JWT 的结构</h2><p>JWT 之所以能被作为一种声明传递的标准是因为它有自己的结构，并不是随便的发个 <code>token</code> 就可以的，JWT 用于生成 <code>token</code> 的结构有三个部分，使用 <code>.</code> 隔开。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p><code>Header</code> 头部中主要包含两部分，<code>token</code> 类型和加密算法，如 <code>{typ: &#39;jwt&#39;, alg: &#39;HS256&#39;}</code>，<code>HS256</code> 就是指 <code>sha256</code> 算法，会将这个对象转成 <code>base64</code>。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p><code>Payload</code> 负载就是存放有效信息的地方，有效信息被分为标准中注册的声明、公共的声明和私有的声明。</p><h4 id="标准中注册的声明"><a href="#标准中注册的声明" class="headerlink" title="标准中注册的声明"></a>标准中注册的声明</h4><p>下面是标准中注册的声明，建议但不强制使用。</p><ul><li>iss：<code>jwt</code> 签发者；</li><li>sub：<code>jwt</code> 所面向的用户；</li><li>aud：接收 <code>jwt</code> 的一方；</li><li>exp：<code>jwt</code> 的过期时间，这个过期时间必须要大于签发时间，这是一个秒数；</li><li>nbf：定义在什么时间之前，该 <code>jwt</code> 都是不可用的；</li><li>iat：<code>jwt</code> 的签发时间。</li></ul><p>上面的标准中注册的声明中常用的有 <code>exp</code> 和 <code>nbf</code>。</p><h4 id="公共声明"><a href="#公共声明" class="headerlink" title="公共声明"></a>公共声明</h4><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密，如 <code>{&#39;id&#39;, username: &#39;panda&#39;, adress: &#39;Beijing&#39;}</code>，会将这个对象转成 <code>base64</code>。</p><h4 id="私有声明"><a href="#私有声明" class="headerlink" title="私有声明"></a>私有声明</h4><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 <code>base64</code> 是对称解密的，意味着该部分信息可以归类为明文信息。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p><code>Signature</code> 这一部分指将 <code>Header</code> 和 <code>Payload</code> 通过密钥 <code>secret</code> 和加盐算法进行加密后生成的签名，<code>secret</code>，密钥保存在服务端，不会发送给任何人，所以 JWT 的传输方式是很安全的。</p><p>最后将三部分使用 <code>.</code> 连接成字符串，就是要返回给浏览器的 <code>token</code> 浏览器一般会将这个 <code>token</code> 存储在 <code>localStorge</code> 以备其他需要验证用户的请求使用。</p><blockquote class="pullquote warning"><p>经过上面对 JWT 的叙述可能还是没有完全的理解什么是 JWT，具体怎么操作的，我们接下来实现一个小的案例，为了方便，服务端使用 <code>express</code> 框架，数据库使用 <code>mongo</code> 来存储用户信息，前端使用 <code>Vue</code> 来实现，做一个登录页登录后进入订单页验证 <code>token</code> 的功能。</p></blockquote><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><pre>jwt-apply<br>  |- jwt-client<br>  | |- src<br>  | | |- views<br>  | | | |- Login.vue<br>  | | | |- Order.vue<br>  | | |- App.vue<br>  | | |- axios.js<br>  | | |- main.js<br>  | | |- router.js<br>  | |- .gitignore<br>  | |- babel.config<br>  | |- package.json<br>  |- jwt-server<br>  | |- model<br>  | | |- user.js<br>  | |- app.js<br>  | |- config.js<br>  | |- jwt-simple.js<br>  | |- package.json</pre></p><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>在搭建服务端之前需要安装我们使用的依赖，这里我们使用 <code>yarn</code> 来安装，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add express body-parse mongoose jwt-simple</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">'db_url'</span>: <span class="string">'mongodb://localhost:27017/jwt'</span>, <span class="comment">// 操作 mongo 自动生成这个数据库</span></span><br><span class="line">  <span class="string">'secret'</span>: <span class="string">'pandashen'</span> <span class="comment">// 密钥</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面配置文件中，<code>db_url</code> 存储的是 <code>mango</code> 数据库的地址，操作数据库自动创建，<code>secret</code> 是用来生成 <code>token</code> 的密钥。</p><h3 id="创建数据库模型"><a href="#创建数据库模型" class="headerlink" title="创建数据库模型"></a>创建数据库模型</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/model/user.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作数据库的逻辑</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">let</span> &#123; db_url &#125; = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库，端口默认 27017</span></span><br><span class="line">mongoose.connect(db_url, &#123;</span><br><span class="line">  useNewUrlParser: <span class="literal">true</span> <span class="comment">// 去掉警告</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个骨架 Schema，数据会按照这个骨架格式存储</span></span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  username: <span class="built_in">String</span>,</span><br><span class="line">  password: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个模型</span></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">'User'</span>, UserSchema);</span><br></pre></td></tr></table></figure><p>我们将连接数据库、定义数据库字段和值类型以及创建数据模型的代码统一放在了 <code>model</code> 文件夹下的 <code>user.js</code> 当中，将数据模型导出方便在服务器的代码中进行查找操作。</p><h3 id="实现基本服务"><a href="#实现基本服务" class="headerlink" title="实现基本服务"></a>实现基本服务</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jwt-simple'</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'./model/user'</span>);</span><br><span class="line"><span class="keyword">let</span> &#123; secret &#125; = <span class="built_in">require</span>(<span class="string">'./config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置中间件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注册接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 登录接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 验证 token 接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口号</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面是一个基本的服务器，引入了相关的依赖，能保证启动，接下来添加处理 <code>post</code> 请求的中间件和实现 <code>cors</code> 跨域的中间件。</p><h3 id="添加中间件"><a href="#添加中间件" class="headerlink" title="添加中间件"></a>添加中间件</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置跨域中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 允许跨域的头</span></span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 允许浏览器发送的头</span></span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type,Authorization'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 允许哪些请求方法</span></span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET,POST,PUT,DELETE,OPTIONS'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前请求是 OPTIONS 直接结束，否则继续执行</span></span><br><span class="line">  req.method === <span class="string">'OPTIONS'</span> ? res.end() : next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置处理 post 请求参数的中间件</span></span><br><span class="line">app.use(bodyParser.json());</span><br></pre></td></tr></table></figure><p>之所以设置处理 <code>post</code> 请求参数中间件是因为注册和登录都需要使用 <code>post</code> 请求，之所以设置跨域中间件是因为我们项目虽小也是前后端分离的，需要用前端的 <code>8080</code> 端口访问服务器的 <code>3000</code> 端口，所以需要服务端使用 <code>cors</code> 处理跨域问题。</p><h3 id="注册接口的实现"><a href="#注册接口的实现" class="headerlink" title="注册接口的实现"></a>注册接口的实现</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册接口的实现</span></span><br><span class="line">app.post(<span class="string">'/reg'</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取 post 请求的数据</span></span><br><span class="line">  <span class="keyword">let</span> user = req.body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误验证</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据库，添加成功后返回的就是添加后的结果</span></span><br><span class="line">    user = <span class="keyword">await</span> User.create(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回注册成功的信息</span></span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code: <span class="number">0</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">          id: user._id,</span><br><span class="line">          username: user.username</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 返回注册失败的信息</span></span><br><span class="line">    res.json(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">data</span>: <span class="string">'注册失败'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面将用户注册的信息存入了 <code>mongo</code> 数据库，返回值为存入的数据，如果存入成功，则返回注册成功的信息，否则返回注册失败的信息。</p><h3 id="登录接口的实现"><a href="#登录接口的实现" class="headerlink" title="登录接口的实现"></a>登录接口的实现</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户能登录</span></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = req.body;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 查找用户是否存在</span></span><br><span class="line">    user = <span class="keyword">await</span> User.findOne(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">      <span class="comment">// 生成 token</span></span><br><span class="line">      <span class="keyword">let</span> token = jwt.encode(&#123;</span><br><span class="line">        id: user._id,</span><br><span class="line">        username: user.username,</span><br><span class="line">        exp: <span class="built_in">Date</span>.now() + <span class="number">1000</span> * <span class="number">10</span></span><br><span class="line">      &#125;, secret);</span><br><span class="line"></span><br><span class="line">      res.json(&#123;</span><br><span class="line">        code: <span class="number">0</span>,</span><br><span class="line">        data: &#123; token &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.json(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">data</span>: <span class="string">'用户不存在'</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    res.json(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">data</span>: <span class="string">'登录失败'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>登录的过程中会先拿用户的账号和密码进数据库中进行严重和查找，如果存在，则登录成功并返回 <code>token</code>，如果不存在则登录失败。</p><h3 id="token-校验接口"><a href="#token-校验接口" class="headerlink" title="token 校验接口"></a>token 校验接口</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只针对 token 校验接口的中间件</span></span><br><span class="line"><span class="keyword">const</span> auth = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取请求头 authorization</span></span><br><span class="line">  <span class="keyword">const</span> authorization = req.headers[<span class="string">'authorization'</span>];</span><br><span class="line">  <span class="comment">// 如果存在，则获取 token</span></span><br><span class="line">  <span class="keyword">if</span> (authorization) &#123;</span><br><span class="line">    <span class="keyword">const</span> token = authorization.split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 对 token 进行校验</span></span><br><span class="line">      req.user = jwt.decode(token, secret);</span><br><span class="line">      next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).send(<span class="string">'Not Allowed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.status(<span class="number">401</span>).send(<span class="string">'Not Allowed'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户可以校验是否登录过，通过请求头 authorization: Bearer token</span></span><br><span class="line">app.get(<span class="string">'/order'</span>, auth, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      user: req.user</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在校验过程中，每次浏览器都会将 <code>token</code> 通过请求头 <code>authorization</code> 带给服务器，请求头的值为 <code>Bearer token</code>，这是 JWT 规定的，服务器取出 <code>token</code> 使用 <code>decode</code> 方法进行解码，并使用 <code>try...catch</code> 进行捕获，如果解码失败则会触发 <code>try...catch</code>，说明 <code>token</code> 过期、被篡改、或被伪造，返回 <code>401</code> 响应。</p><h2 id="前端的实现"><a href="#前端的实现" class="headerlink" title="前端的实现"></a>前端的实现</h2><p>我们使用 <code>3.0</code> 版本的 <code>vue-cli</code> 脚手架生成 <code>Vue</code> 项目，并安装 <code>axios</code> 发送请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add global @vue/cli</span><br><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为生产模式</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><p>上面这个文件是 <code>vue-cli</code> 自动生成的，我们并没有做改动，但是为了方便查看我们会将主要文件的代码一一贴出来。</p><h3 id="主组件-App"><a href="#主组件-App" class="headerlink" title="主组件 App"></a>主组件 App</h3><figure class="highlight html"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'nav'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/order"</span>&gt;</span>订单<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在主组件中我们将 <code>router-link</code> 分别对应了 <code>/login</code> 和 <code>/order</code> 两个路由。</p><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/router.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./views/Login.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Order <span class="keyword">from</span> <span class="string">'./views/Order.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/order'</span>,</span><br><span class="line">      name: <span class="string">'order'</span>,</span><br><span class="line">      component: Order</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们定义了两个路由，一个对应登录页，一个对应订单页，并引入了组件 <code>Login</code> 和 <code>Order</code>，前端并没有写注册模块，可以使用 <code>postman</code> 发送注册请求生成一个账户以备后面验证使用。</p><h3 id="登录组件-Login"><a href="#登录组件-Login" class="headerlink" title="登录组件 Login"></a>登录组件 Login</h3><figure class="highlight html"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/views/Login.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">    用户名</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"user.username"</span>&gt;</span></span><br><span class="line">    密码</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"user.password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"login"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'../axios'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">      user: &#123;</span></span><br><span class="line"><span class="javascript">        username: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">        password: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    login() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 发送请求访问服务器的登录接口</span></span></span><br><span class="line"><span class="javascript">      axios.post(<span class="string">'/login'</span>, <span class="keyword">this</span>.user).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 将返回的 token 存入 localStorage，并跳转订单页</span></span></span><br><span class="line"><span class="javascript">        localStorage.setItem(<span class="string">'token'</span>, res.data.token);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$router.push(<span class="string">'/order'</span>);</span></span><br><span class="line"><span class="javascript">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 弹出错误</span></span></span><br><span class="line"><span class="undefined">        alert(err.data);</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Login</code> 组件中将两个输入框的值同步到 <code>data</code> 中，用来存放账号和密码，当点击提交按钮时，触发点击事件 <code>login</code> 发送请求，请求成功后将返回的 <code>token</code> 存入 <code>localStorage</code>，并跳转路由到订单页，请求错误时弹出错误信息。</p><h3 id="订单组件-Order"><a href="#订单组件-Order" class="headerlink" title="订单组件 Order"></a>订单组件 Order</h3><figure class="highlight html"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/views/Order.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"order"</span>&gt;</span></span><br><span class="line">    &#123;&#123;username&#125;&#125; 的订单</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'../axios'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      username: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  mounted() &#123;</span></span><br><span class="line"><span class="javascript">    axios.get(<span class="string">'/order'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.username = res.data.user.username;</span></span><br><span class="line"><span class="javascript">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">      alert(err);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Order</code> 页面显示的内容是 “XXX 的订单”，在加载 <code>Order</code> 组件被挂载时发送请求获取用户名，即访问服务器的验证 <code>token</code> 接口，因为订单页就是一个涉及到验证用户的页面，当请求成功时，将用户名同步到 <code>data</code>，否则弹出错误信息。</p><p>在 <code>Login</code> 和 <code>Order</code> 两个组件中对请求的回调内似乎写的太简单了，其实是因为 <code>axios</code> 的返回值会在服务器返回的返回值外面包了一层，存放一些 <code>http</code> 响应的相关信息，两个接口访问时请求地址也是同一个服务器，而且在服务器响应时的错误处理都是对状态吗 <code>401</code> 的处理，在涉及验证用户信息的请求中需要设置请求头 <code>Authorization</code> 发送 <code>token</code>。</p><p>这些逻辑我们似乎在组件请求相关的代码中都没有看到，是因为我们使用 <code>axios</code> 的 API 设置了 <code>baseURL</code> 请求拦截和响应拦截，细心可以发现其实引入的 <code>axios</code> 并不是直接从 <code>node_modules</code> 引入，而是引入了我们自己的导出的 <code>axios</code>。</p><h3 id="axios-配置"><a href="#axios-配置" class="headerlink" title="axios 配置"></a>axios 配置</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/axios.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认访问地址</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">'http://localhost:3000'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 报错执行 axios then 方法错误的回调，成功返回正确的数据</span></span><br><span class="line">  <span class="keyword">return</span> res.data.code !== <span class="number">0</span> ? <span class="built_in">Promise</span>.reject(res.data) : res.data;</span><br><span class="line">&#125;, res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 token 验证失败则跳回登陆页，并执行 axios then 方法错误的回调</span></span><br><span class="line">  <span class="keyword">if</span> (res.response.status === <span class="number">401</span>) &#123;</span><br><span class="line">    router.history.push(<span class="string">'/login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'Not Allowed'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截，用于将请求统一带上 token</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 localStorage 获取 token</span></span><br><span class="line">  <span class="keyword">const</span> token = localStorage.getItem(<span class="string">'token'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在则设置请求头</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios;</span><br></pre></td></tr></table></figure><p>访问服务器时会将 <code>axios</code> 中的第一个参数拼接在 <code>axios.defaults.baseURL</code> 的后面作为请求地址。</p><p><code>axios.interceptors.response.use</code> 为响应拦截，<code>axios</code> 发送请求后所有的响应都会先执行这个方法内部的逻辑，返回值为数据，作为参数传递给 <code>axios</code> 返回值的 <code>then</code> 方法。</p><p><code>axios.interceptors.request.use</code> 为请求拦截，<code>axios</code> 发送的所有请求都会先执行这个方法的逻辑，然后发送给服务器，一般用来设置请求头。</p><h2 id="jwt-simple-模块的实现原理"><a href="#jwt-simple-模块的实现原理" class="headerlink" title="jwt-simple 模块的实现原理"></a>jwt-simple 模块的实现原理</h2><p>相信通过上面的过程已经非常清楚 JWT 如何生成的，<code>token</code> 的格式是怎样的，如何跟前端交互去验证 <code>token</code>，我们在这些基础上再深入的研究一下 <code>token</code> 的整个生成过程和验证过程，我们使用的 <code>jwt-simple</code> 模块的 <code>encode</code> 方法如何生成 <code>token</code>，使用 <code>decode</code> 方法如何验证 <code>token</code>，下面就看看一看 <code>jwt-simple</code> 的实现原理。</p><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 其他方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  encode,</span><br><span class="line">  decode</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道 <code>jwt-simple</code> 我们使用的有两个方法 <code>encode</code> 和 <code>decode</code>，所以最后导出的对象上有这两个方法，使用加盐算法进行签名需要使用 <code>crypto</code>，所以我们提前引入。</p><h3 id="字符串和-Base64-互相转换"><a href="#字符串和-Base64-互相转换" class="headerlink" title="字符串和 Base64 互相转换"></a>字符串和 Base64 互相转换</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将子子符串转换成 Base64</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToBase64</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Buffer.from(str).toString(<span class="string">'base64'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Base64 转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64ToString</span>(<span class="params">base64</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Buffer.from(base64, <span class="string">'base64'</span>).toString(<span class="string">'utf8'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法的名字相信很容易看出用途和参数，所以就一起放在这了，其实本质是在两种编码之间进行转换，所以转换之前都应该先转换成 Buffer。</p><h3 id="生成签名的方法"><a href="#生成签名的方法" class="headerlink" title="生成签名的方法"></a>生成签名的方法</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSign</span>(<span class="params">str, secret</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用加盐算法进行加密</span></span><br><span class="line">  <span class="keyword">return</span> crypto.createHmac(<span class="string">'sha256'</span>, secret).update(str).digest(<span class="string">'base64'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步就是通过加盐算法使用 <code>sha256</code> 和密钥 <code>secret</code> 进行生成签名，但是为了方便我们把使用的加密算法给写死了，正常情况下是应该根据 <code>Header</code> 中 <code>alg</code> 字段的值去检索 <code>alg</code> 的值与加密算法名称对应的 <code>map</code>，去使用设置的算法生成签名。</p><h3 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params">payload, secret</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 头部</span></span><br><span class="line">  <span class="keyword">const</span> = stringToBase64(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    typ: <span class="string">'JWT'</span>,</span><br><span class="line">    alg: <span class="string">'HS256'</span></span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 负载</span></span><br><span class="line">  <span class="keyword">const</span> content = stringToBase64(<span class="built_in">JSON</span>.stringify(payload));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 签名</span></span><br><span class="line">  <span class="keyword">const</span> sign = createSign([header, content].join(<span class="string">'.'</span>), secret);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成签名</span></span><br><span class="line">  <span class="keyword">return</span> [header, content, sign].join(<span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>encode</code> 中将 <code>Header</code>、<code>Payload</code> 转换成 <code>base64</code>，通过 <code>.</code> 连接在一起，然后使用 <code>secret</code> 密钥生成签名，最后将 <code>Header</code> 和 <code>Payload</code> 的 <code>base64</code> 通过 <code>.</code> 和生成的签名连接在一起，这就形成了 “明文” + “明文” + “暗文” 三段格式的 <code>token</code>。</p><h3 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params">token, secret</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [header, content, sign] = token.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将接收到的 token 的前两部分（base64）重新签名并验证，验证不通过抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (sign !== createSign([header, content].join(<span class="string">'.'</span>), secret)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Allow'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 content 转成对象</span></span><br><span class="line">  content = <span class="built_in">JSON</span>.parse(base64ToString(content));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测过期时间，如果过去抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (content.exp &amp;&amp; content.exp &lt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Allow'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在验证方法 <code>decode</code> 中，首先将 <code>token</code> 的三段分别取出，并用前两段重新生成签名，并与第三段 <code>sign</code> 对比，相同通过验证，不同说明篡改过并抛出错误，将 <code>Payload</code> 的内容重新转换成对象，也就是将 <code>content</code> 转换成对象，取出 <code>exp</code> 字段与当前时间对比来验证是否过期，如果过期抛出错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 JWT 生成的 <code>token</code> 中，前两段明文可解，这样别人拦截后知道了我们的加密算法和规则，也知道我们传输的信息，也可以使用 <code>jwt-simple</code> 加密一段暗文拼接成 <code>token</code> 的格式给服务器去验证，为什么 JWT 还这么安全呢，这就说到了最最重点的地方，无论别人知道多少我们在传输的信息，篡改和伪造后都不能通过服务器的验证，是因为无法获取服务器的密钥 <code>secret</code>，真正能保证安全的就是 <code>secret</code>，同时证明了 <code>Header</code> 和 <code>Payload</code> 并不安全，可以被破解，所以不能存放敏感信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> cookie/session </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> JWT </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL —— 简单聊一聊数据库设计</title>
      <link href="/2018/08/14/20180814131241/"/>
      <url>/2018/08/14/20180814131241/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/14/20180814131241/mysql-table-design.png" title="MySQL 数据库设计"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>这是关于 MySQL 系列文章的第三篇，在前两篇文章 <a href="https://www.overtaking.top/2018/08/08/20180808012303/" target="_blank">《MySQL —— 数据库基础》</a> 和 <a href="https://www.overtaking.top/2018/08/09/20180809115245/" target="_blank">《MySQL —— SQL 语句总结》</a> 中，主要介绍了一些数据库的基础概念、创建表的方式以及 SQL 语句的使用，本篇在使用的基础上做一个小小的升华，来简单聊一聊数据库的设计，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。</p></blockquote><a id="more"></a><h2 id="为什么设计数据库"><a href="#为什么设计数据库" class="headerlink" title="为什么设计数据库"></a>为什么设计数据库</h2><p>说到为什么要设计数据库，就要说到数据的完整性，我们要在设计数据库时保证域的完整性和实体的完整性，同时从性能出发，我们要保证最大限度的节省存储空间，比如一张成绩表，上面没必要存储学生的姓名、年龄等信息，只需要存储成绩，如果一个数据库设计的合理，最后的结果就是方便我们对数据库的开发和扩展。</p><p>如果是一个 “糟糕” 的数据库设计会造成一系列的不良反应，比如数据冗余，存储空间浪费，内存浪费，有时甚至会造成数据插入和更新的异常，比如学生表存了学生信息，而成绩表也存了，这样在修改时没有全部修改就会出现错误。</p><h2 id="软件项目开发中数据库设计的生命周期"><a href="#软件项目开发中数据库设计的生命周期" class="headerlink" title="软件项目开发中数据库设计的生命周期"></a>软件项目开发中数据库设计的生命周期</h2><p><strong>软件项目开发中数据库设计的生命周期可大概分为以下几个阶段：</strong></p><ul><li>需求分析阶段，分析客户的业务和数据处理需求；</li><li>概要设计阶段，设计数据库 <code>E-R</code> 模型图，确认需求的正确和完整性；</li><li>详细设计阶段，应用三大范式审核数据库；</li><li>代码编写阶段，物理实现数据库，编码实现应用；</li><li>软件测试阶段；</li><li>安装部署阶段。</li></ul><p>上面数据库的设计经历了从 “现实世界” 到 “信息世界” 到 “数据库模型” 再到 “数据库” 产生的一个完整过程。</p><h2 id="设计数据库的步骤"><a href="#设计数据库的步骤" class="headerlink" title="设计数据库的步骤"></a>设计数据库的步骤</h2><p>收集信息：收集信息其实就是与相关人员进行交流、访谈、调研，充分了解用户需求，理解整个项目的完整流程，并理解数据库需要完成的任务，这部分工作大部分由需求人员完成，并根技术人员进行对接。</p><p>标识实体和实体属性：开发人员在明确需求和流程之后，标识数据库的实体，比如学生信息表，每一条实体中应该由哪些字段组成，成绩表中实体由哪些字段组成等等。</p><p>标识实体之间的关系：其实就是通过表之间的某字段对表进行关联，对表的实体之间建立对应关系，如学生表的 <code>id</code> 字段会关联成绩表的 <code>student_id</code> 字段，用来查找某个学生的成绩。</p><h2 id="数据库-E-R-图"><a href="#数据库-E-R-图" class="headerlink" title="数据库 E-R 图"></a>数据库 E-R 图</h2><h3 id="E-R-图基本概念"><a href="#E-R-图基本概念" class="headerlink" title="E-R 图基本概念"></a>E-R 图基本概念</h3><p><code>E-R</code> 图也叫做实体关系图，是指用实体、关系、属性三个基本概念概括数据的基本结构，从而描述静态数据的概念模型。</p><p><code>E-R</code> 图的实体：即数据模型中的数据对象，每一张表就是一个 <code>E-R</code> 图的实体。</p><p><code>E-R</code> 图的属性：即数据对象中所具有的属性，例如学生表的学生、姓名、年龄等，属性又分为唯一属性和非唯一属性，唯一属性如经过唯一约束和主键约束的属性，不可重复，其他的都是非唯一属性。</p><p><code>E-R</code> 图的关系：用来表示每一个数据对象与数据对象之间的联系，即每一个实体之间的联系，例如学生表和成绩表之间的联系，因为每个学生都有自己的成绩。</p><h3 id="E-R-图的关联关系"><a href="#E-R-图的关联关系" class="headerlink" title="E-R 图的关联关系"></a>E-R 图的关联关系</h3><h4 id="1-对-1-（1-1）"><a href="#1-对-1-（1-1）" class="headerlink" title="1 对 1 （1 : 1）"></a>1 对 1 （1 : 1）</h4><p><code>1</code> 对 <code>1</code> 关系是指对于实体集 <code>A</code> 和 实体集 <code>B</code>，<code>A</code> 中的每一个实体最多与 <code>B</code> 中的一个实体有关系，反之在实体集 <code>B</code> 中的每一个实体之多与实体集 <code>A</code> 中的一个实体有关系。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/onetoone.png" alt="1 对 1 关系图" title>                </div>                <div class="image-caption">1 对 1 关系图</div>            </figure><p><br></p><h4 id="1-对多（1-N）"><a href="#1-对多（1-N）" class="headerlink" title="1 对多（1 : N）"></a>1 对多（1 : N）</h4><p><code>1</code> 对多关系是指实体集 <code>A</code> 与实体集 <code>B</code> 中至少有 <em>N (N &gt; 0)</em> 个实体有关系，并且实体集 <code>B</code> 中最多与实体集 <code>A</code> 中的一个实体有关系。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/onetomany.png" alt="1 对多关系图" title>                </div>                <div class="image-caption">1 对多关系图</div>            </figure><p><br></p><h4 id="多对多（M-N）"><a href="#多对多（M-N）" class="headerlink" title="多对多（M : N）"></a>多对多（M : N）</h4><p>多对多关系是指实体集 <code>A</code> 中的每一个实体与实体集 <code>B</code> 中至少有 <em>M (M &gt; 0)</em> 个实体有关系，并且实体集 <code>B</code> 中的每一个实体与实体集 <code>A</code> 中至少有 <em>N (N &gt; 0)</em> 个实体有关系。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/manytomany.png" alt="多对多关系图" title>                </div>                <div class="image-caption">多对多关系图</div>            </figure><p><br></p><h2 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h2><h3 id="确保每列的原子性"><a href="#确保每列的原子性" class="headerlink" title="确保每列的原子性"></a>确保每列的原子性</h3><p>如果每列都是不可再分的最小单元信息，则满足第一范式，比如下图中，地址是由国家和城市组成的，显然可以继续在拆分成两个列，国家和城市，是不满足第一范式的，需要将地址列差分成国家和城市两个列。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/firstpattern.png" alt="原子性事例" title>                </div>                <div class="image-caption">原子性事例</div>            </figure><p><br></p><p>举一个简单的例子，我们平时在淘宝购物的时候需要添加地址，在填写新地址时，都是让我们选择国家、省、城市、区、街道、小区这样的方式，而不是让我们自己将这些地址写在一起，其原因就是因为淘宝的数据库设计严格遵循每列的原子性，这样的提交可以方便后端获取每一个列的信息在数据库中进行存储。</p><h3 id="每个表只能描述一件事情"><a href="#每个表只能描述一件事情" class="headerlink" title="每个表只能描述一件事情"></a>每个表只能描述一件事情</h3><p>如下图中所示，在左侧的表中，描述了学生信息和课程信息，这明显是两件事情，假设再有一张成绩表，也要描述学生信息，课程信息和成绩等多件事情，就会造成数据的重复、冗余，也可能会导致更新、插入、删除数据异常的现象。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/secondpattern.png" alt="每个表描述一件" title>                </div>                <div class="image-caption">每个表描述一件</div>            </figure><p><br></p><p>所以正确的做法是应该将左侧表差分成两张表分别为学生表和课程表，并使用学生编号与课程编号进行关联。</p><h3 id="其他列都不传递依赖于主键列"><a href="#其他列都不传递依赖于主键列" class="headerlink" title="其他列都不传递依赖于主键列"></a>其他列都不传递依赖于主键列</h3><p>其他列都不传递依赖于主键列的意思是表中各列必须都与主键直接相关，不能间接相关，从下图左表可以看出，学生编号为主键，年级 <code>ID</code> 也应该为主键，正常应该通过学生编号找到年级 <code>ID</code>，再找到年级名称，这样年级名称与学生编号之间就形成了一个传递并且依赖于主键年级 <code>ID</code>，即年级 <code>ID</code> 做为主键在中间隔了一层，这样就使年级名称与主键学生编号间接相关，如果在同一张表中，所有的字段都是应该直接依赖于主键，而不是再通过其他的主键传递。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/thirdpattern.png" alt="其他列都不传递依赖于主键列" title>                </div>                <div class="image-caption">其他列都不传递依赖于主键列</div>            </figure><p><br></p><p>如果一个表中表述了多件事情并有多个作为主键的列，与上一条的处理方式相同，应该拆成多张表，并且每张表只有一个主键列。</p><h2 id="RBAC-基于角色的访问控制"><a href="#RBAC-基于角色的访问控制" class="headerlink" title="RBAC 基于角色的访问控制"></a>RBAC 基于角色的访问控制</h2><h3 id="RBAC-的含义"><a href="#RBAC-的含义" class="headerlink" title="RBAC 的含义"></a>RBAC 的含义</h3><blockquote class="pullquote info"><p>RBAC（Role-Based Access Control）基于角色的访问控制，就是用户通过角色与权限进行关联，简单的说，一个用户拥若干个角色，每个角色拥有若干个权限，这样就构造成了 “用户 → 角色 → 权限 → 资源” 的授权模型，在这个模型中，用户与角色之间，角色与权限之间，权限与资源之间，一般都是多对多的关系，在 <code>RBAC</code> 中最重要的概念主要有四部分，就是用户（User）、角色（Role）、权限（Permission）和资源（Resource）。</p></blockquote><h3 id="RBAC-的安全原则"><a href="#RBAC-的安全原则" class="headerlink" title="RBAC 的安全原则"></a>RBAC 的安全原则</h3><ul><li>最小权限原则：最小权限原则之所以被 <code>RBAC</code> 所支持，是因为 <code>RBAC</code> 可以将其角色配置成完成任务所需要的最小的权限集；</li><li>责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一个帐目；</li><li>数据抽象原则：数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限。</li></ul><h3 id="RBAC-的-E-R-图"><a href="#RBAC-的-E-R-图" class="headerlink" title="RBAC 的 E-R 图"></a>RBAC 的 E-R 图</h3><p>之前说 <code>RBAC</code> 最重要的概念由四部分，其实体现在数据库的表中有主要三部分，因为角色和用户是重叠的，那么主要有三张表分别为用户表、权限表和资源表，其中用户表与权限表之间有一张关联表，权限表与资源表之间有一张关联表，<code>E-R</code> 图如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/RBAC.png" alt="RBAC 的 E-R 图" title>                </div>                <div class="image-caption">RBAC 的 E-R 图</div>            </figure><p><br></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="为什么需要事务？"><a href="#为什么需要事务？" class="headerlink" title="为什么需要事务？"></a>为什么需要事务？</h3><p>在生活中我们经常使用银行转账或者支付宝和微信支付，这种操作每一次至少影响两个用户的数据信息，比如一方给另一方转钱，如果成功则转钱方余额减去转出金额，而收钱方余额增加收到的金额，这应该是一个请求操作了数据表中的俩个实体，如果在两个操作数据的环节任意一个失败了，都会影响两个人数据的正确性，这种时候需要两个操作同时失败或同时成功，就是说有一个操作出现失败的情况，即使另一个成功了也需要进行回滚操作，这就是事务的由来。</p><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是作为单个逻辑工作单元执行的一系列操作，多个操作作为一个整体向系统提交，要么都执行，要么都不执行，是一个不可分割的工作逻辑单元。</p><p>转账过程就是一个整体，它需要两条 <code>UPDATE</code> 语句，如果任何一个出错，则整个转账业务取消，两个账户的余额都恢复到原来的数据（回滚），确保总余额不变。</p><p>这里再举一个例子，有一个上传文件的功能，后端接收到文件流时是需要先写入的，当写入成功后，会将上传成功的结果返回给客户端，如果文件很大，写入的时间就会长，如果在此期间突然写入失败，则会删除之前写入的内容，将整个操作回滚到写入之前，这里面主要两步操作，创建一个新文件并写入，写入成功删除旧文件，如果写入失败，两个操作将会同时失败，即不会删除旧文件，这也是一个事务的例子，只是没有转账那么明显。</p><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性 ACID"></a>事务的特性 ACID</h3><p><strong>事务具有以下特性，被简称为 ACID：</strong></p><ul><li>原子性（Atomicity）：事务是一个完整的操作，事务各个部分是不可分的，要么都执行，要么都不执行；</li><li>一致性（Consistency）：当事务完成后，数据必须处理完整的状态；</li><li>隔离性（Isolation）：并发事务彼此隔离、独立，它不应该以任何方式依赖于其它事务；</li><li>持久性（Durability）：事务完成后，它对数据库的修改被永久保持。</li></ul><h3 id="如何创建事务"><a href="#如何创建事务" class="headerlink" title="如何创建事务"></a>如何创建事务</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>创建表 <code>account</code>，<code>id</code> 列为主键列，<code>name</code> 列为姓名，<code>balance</code> 为余额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`account`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`balance`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>将表 <code>account</code> 添加两条数据，分别为 “张三” 和 “李四”，余额都为 <code>100</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`name`</span>, <span class="string">`balance`</span>) <span class="keyword">VALUES</span> (<span class="string">"张三"</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`name`</span>, <span class="string">`balance`</span>) <span class="keyword">VALUES</span> (<span class="string">"李四"</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h4 id="使用-NodeJS-实现事务"><a href="#使用-NodeJS-实现事务" class="headerlink" title="使用 NodeJS 实现事务"></a>使用 NodeJS 实现事务</h4><figure class="highlight js"><figcaption><span>一个非常简单的事务</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据库连接</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>, <span class="comment">// 主机名</span></span><br><span class="line">  port: <span class="string">'3306'</span>, <span class="comment">// 数据库服务端口号</span></span><br><span class="line">  username: <span class="string">'root'</span>, <span class="comment">// 数据库名称</span></span><br><span class="line">  pwd: <span class="string">'123456'</span>, <span class="comment">// 数据库密码</span></span><br><span class="line">  database: <span class="string">'school'</span>  <span class="comment">// 连接的数据库名称</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">connection.beginTransaction(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 回调参数为错误对象，返回结果，返回字段描述</span></span><br><span class="line">  connection.query(</span><br><span class="line">    <span class="string">'UPDATE account SET balance - 50 WHERE id = 1'</span>,</span><br><span class="line">    (err, result, fields) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        connection.rollback(); <span class="comment">// 如果失败直接回归</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connection.query(</span><br><span class="line">          <span class="string">'UPDATE account SET balance - 50 WHERE id = 1'</span>,</span><br><span class="line">          (err, result, fields) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果失败直接回归，如果两个都成功了则提交事务</span></span><br><span class="line">            err ? connection.rollback() : connection.commit();</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>到此关于 MySQL 的系列文章就告一段落了，希望前端的同学们在看了这几篇文章后对你们入门 MySQL 有一些帮助，那这几篇的文章就达到目的了，也欢迎后端的小伙伴来指出文章中的错误和不足。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL —— SQL 语句总结</title>
      <link href="/2018/08/09/20180809115245/"/>
      <url>/2018/08/09/20180809115245/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/09/20180809115245/sql.png" title="SQL 语句"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于 MySQL 系列文章的第二篇，在上一篇 <a href="https://www.overtaking.top/2018/08/08/20180808012303/" target="_blank">《MySQL —— 数据库基础》</a> 中，主要介绍了一些数据库的基础概念、创建表的方式以及使用 DDL 数据定义语言对表的操作，本篇的主要内容是在开发中使用 SQL 语句对数据库的增、删、改、查，函数、聚合函数的应用以及表连接，本篇大部分内容都贴近开发中的实际操作，不会像上一篇那么枯燥，也可当作一个小小的查询文档，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。</p></blockquote><a id="more"></a><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>还记得在上一篇的最后我们使用 DDL 创建了完整的表关系，<code>student</code>、<code>score</code> 和 <code>course</code> 三张表如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/student-score-course.png" alt="完整表关系图" title>                </div>                <div class="image-caption">完整表关系图</div>            </figure><p><br></p><p>其中 <code>score</code> 是外键表，创建外键约束关联了两张主键表 <code>scudent</code> 和 <code>cource</code>，接下来的 SQL 语句都是基于这几张表来进行的。</p><h2 id="SQL-的组成"><a href="#SQL-的组成" class="headerlink" title="SQL 的组成"></a>SQL 的组成</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>DDL（data definition language）是数据定义语言，主要命令有 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code> 等，DDL 主要用在定义或改变数据表（TABLE）的结构、数据类型、表之间的链接和约束等初始化工作上，大多数在建立表时使用，在上一篇中 DDL 操作表的部分着重做了介绍并创建数据表，也可以将存储 DDL 语句的文件存储在 <code>.sql</code> 后缀名结尾的文件当中，在 DBMS 数据管理系统中导入，直接创建数据库。</p><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>DML（data manipulation language）是数据操做语言，通过 DML 语句对数据库数据表中的实体进行增、删、改、查，数据量非常大时，我们不可能使用 DBMS 一条一条的操作数据，所以都是通过代码完成操作，DML 是在学习 MySQL 数据库中最最重要的内容，也是本篇的重点，后面会非常详细的说明。</p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL（data control language）是数据库控制语言，用来设置或更改数据库用户或角色权限的语句，包括 <code>grant</code>、<code>revoke</code> 等，<code>grant</code> 是授权命令，<code>revoke</code> 是收回权限命令。</p><h2 id="SQL-运算符"><a href="#SQL-运算符" class="headerlink" title="SQL 运算符"></a>SQL 运算符</h2><blockquote class="pullquote info"><p>SQL 元算符分为算术运算符、逻辑运算符和比较运算符，是用来完成列之间或者变量之间的比较和运算的。</p></blockquote><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th style="width:20%;text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="width:20%;text-align:center">+</td><td style="text-align:center">加运算，求两个数或表达式相加的和，如 1 + 1</td></tr><tr><td style="width:20%;text-align:center">-</td><td style="text-align:center">减运算，求两个数或表达式相减的差，如 4 - 1</td></tr><tr><td style="width:20%;text-align:center">*</td><td style="text-align:center">乘运算，求两个数或表达式相乘的积，如 2 * 2</td></tr><tr><td style="width:20%;text-align:center">\</td><td style="text-align:center">除运算，求两个数或表达式相除的商，如 6 / 4</td></tr><tr><td style="width:20%;text-align:center">%</td><td style="text-align:center">取模运算，求两个数或表达式相除的余数，如 6 % 4</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th style="width:20%;text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="width:20%;text-align:center">AND</td><td style="text-align:center">当且仅当两个布尔表达式都为 true 时，返回 true</td></tr><tr><td style="width:20%;text-align:center">OR</td><td style="text-align:center">当且仅当两个布尔表达式都为 false 时，返回 false</td></tr><tr><td style="width:20%;text-align:center">NOT</td><td style="text-align:center">布尔表达式的值取反</td></tr></tbody></table><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table><thead><tr><th style="width:20%;text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="width:20%;text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="width:20%;text-align:center">></td><td style="text-align:center">大于</td></tr><tr><td style="width:20%;text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="width:20%;text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="width:20%;text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="width:20%;text-align:center">&lt;&gt;</td><td style="text-align:center">不等于</td></tr><tr><td style="width:20%;text-align:center">!=</td><td style="text-align:center">不等于</td></tr><tr><td style="width:20%;text-align:center">&lt;=&gt;</td><td style="text-align:center">安全不等于</td></tr></tbody></table><h2 id="SQL-语句之数据增、删、改"><a href="#SQL-语句之数据增、删、改" class="headerlink" title="SQL 语句之数据增、删、改"></a>SQL 语句之数据增、删、改</h2><h3 id="插入数据行"><a href="#插入数据行" class="headerlink" title="插入数据行"></a>插入数据行</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 [(列名)] <span class="keyword">VALUES</span> (值列表)</span><br></pre></td></tr></table></figure><p>给上面的 <code>student</code> 表插入一条数据，姓名为张三，卡号为 <code>100</code>，年龄为 <code>20</code>，城市默认为北京。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`name`</span>, <span class="string">`idcard`</span>, <span class="string">`age`</span>, <span class="string">`city`</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">"张三"</span>, <span class="string">"100"</span>, <span class="number">20</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>每次插入一行数据，不能只插入一部分数据，即不能只插入了一个实体的某几列，插入的数据是否有效将严格按照实体的完整性要求来检验；</li><li>每个数据值的数据类型、精度、位数必须要与对应的列名精确匹配，严格按照域的完整性要求来检验；</li><li>不能为标识符指定值（规定），例如作为主键自增的标识列；</li><li>如果某字段设置非空约束，则该列必须插入不为 <code>null</code> 的数据；</li><li>插入数据时还要符合检查性约束的要求，如非空约束、唯一约束等；</li><li>设置了默认值的列，有缺省值时，可以使用 <code>DEFAULT</code> 关键字来代替插入的实际值。</li></ul><h3 id="更新数据行"><a href="#更新数据行" class="headerlink" title="更新数据行"></a>更新数据行</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名 = 更新值 [<span class="keyword">WHERE</span> &lt;更新条件&gt;]</span><br></pre></td></tr></table></figure><p>将 <code>student</code> 表中 <code>id</code> 为 <code>1</code> 的实体的 <code>idcard</code> 列值改为 <code>200</code>，<code>age</code> 列值改为 <code>24</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">`idcard`</span> = <span class="string">"200"</span>, <span class="string">`age`</span> = <span class="number">24</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`id`</span> = <span class="number">1</span> <span class="keyword">AND</span> <span class="string">`name`</span> = <span class="string">"张三"</span>;</span><br></pre></td></tr></table></figure><p>将 <code>student</code> 表中 <code>city</code> 列为空的实体 <code>city</code> 列的值设置为 “上海”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">`city`</span> = <span class="string">"上海"</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>更新多列时，列赋值语句之间使用逗号分隔，一定要加更新条件，否则会更新所有的行；</li><li>多个联合条件根据逻辑关系使用 <code>AND</code> 或 <code>OR</code> 连接。</li></ul><h3 id="删除数据行"><a href="#删除数据行" class="headerlink" title="删除数据行"></a>删除数据行</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> [<span class="keyword">FROM</span>] 表名 [<span class="keyword">WHERE</span> &lt;删除条件&gt;]</span><br></pre></td></tr></table></figure><p>删除 <code>student</code> 表中 <code>age</code> 列值为 <code>24</code> 或者 <code>idcard</code> 列值为 <code>200</code> 的实体。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`age`</span> = <span class="number">24</span> <span class="keyword">OR</span> <span class="string">`idcard`</span> = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>删除的是一整行的数据，所以不需要提供列名；</li><li>如果要删除主表数据，则要先删除外键连接对应的子表数据。</li></ul><h2 id="SQL-语句之数据查询"><a href="#SQL-语句之数据查询" class="headerlink" title="SQL 语句之数据查询"></a>SQL 语句之数据查询</h2><blockquote class="pullquote default"><p>在 SQL 语句的增、删、改、查中，最繁琐和复杂的就是查询语句，在实际开发中七分查询三分增、删、改的说法一点也不为过，查询语句是在业务中使用最多的语句，所以我们将查询语句与增、删、改分离出来，用这单独的一节来叙述。</p></blockquote><h3 id="查询简介"><a href="#查询简介" class="headerlink" title="查询简介"></a>查询简介</h3><p>查询就是从客户端发出查询，请求数据库服务器，并从数据库返回查询结果的过程，每次执行查询只是从数据表中提取数据，并按照表的方式呈现出来，查询产生的虚拟表并不会保存。</p><h3 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;查询条件表达式&gt;]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序的列名&gt; [<span class="keyword">ASC</span> 或 <span class="keyword">DESC</span>]]</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;起始索引&gt;, &lt;查询条数&gt;;</span><br></pre></td></tr></table></figure><p>我们继续操作之前的三张表，查询 “北京” 的学生并按 <code>id</code> 的正序排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> = <span class="string">"北京"</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>上面 SQL 语句中的 <code>*</code> 代表查询表中所有的列，如果查找某些列，列名之间用 <code>,</code> 分隔。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>在查询数据表的某个列的时候可以通过别名改变查询到虚拟表列的名称，在列的后面使用 <code>AS</code> 关键字加上别名，<code>AS</code> 可以省略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`city`</span> <span class="keyword">AS</span> <span class="string">`城市`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> = <span class="string">"北京"</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="查询空行"><a href="#查询空行" class="headerlink" title="查询空行"></a>查询空行</h3><p>假设表中的某一列值为 <code>null</code>，我们可以通过 <code>IS</code> 关键字查询这一列值为空的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`city`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="常量列"><a href="#常量列" class="headerlink" title="常量列"></a>常量列</h3><p>查询一个数据表中没有的列，我们可以在查询时将这一列增加为常量列，如 <code>city</code> 的值都是中国的，我们可以增加一个常量列值都为 “中国”，列名为 <code>country</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`city`</span>, <span class="string">"中国"</span> <span class="keyword">AS</span> <span class="string">`country`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><h3 id="查询列的不重复数据"><a href="#查询列的不重复数据" class="headerlink" title="查询列的不重复数据"></a>查询列的不重复数据</h3><p>假设查询 <code>student</code> 表中同学们来自那些城市，正常按照 <code>city</code> 列查询，有多个条数据的 <code>city</code> 列都来自同一个城市，我们可以使用 <code>DISTINCT</code> 关键字，只保留一个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="string">`city`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><h3 id="限制查询条数"><a href="#限制查询条数" class="headerlink" title="限制查询条数"></a>限制查询条数</h3><p><code>LIMIT</code> 关键字用来限制查询返回的条数，后面的值为数字，下面查询 <code>student</code> 表，只返回 <code>3</code> 条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>当 <code>LIMIT</code> 参数大于一个时，第一个参数代表起始的索引（跳过的条数），第二个参数代表返回的条数，中间用 <code>,</code> 隔开，还是查询 <code>student</code> 表，返回第 <code>4</code> 到 <code>6</code> 条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="运算符在查询中的使用"><a href="#运算符在查询中的使用" class="headerlink" title="运算符在查询中的使用"></a>运算符在查询中的使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> + <span class="number">1</span>; <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> + <span class="string">"1"</span>; <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> + <span class="string">"panda"</span>; <span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> + <span class="literal">NULL</span>; <span class="comment">-- NULL</span></span><br></pre></td></tr></table></figure><p>通过上面的例子可以看出在 SQL 语句中，使用算术运算符相加无法起到字符串拼接的作用，会将值转化为数字进行计算，字符串转为数字 <code>0</code>，数字与 <code>null</code> 相加结果为 <code>null</code>，没意义。</p><h3 id="查询语句练习案例"><a href="#查询语句练习案例" class="headerlink" title="查询语句练习案例"></a>查询语句练习案例</h3><p>首先我们将上面的三张表 <code>student</code>，<code>cource</code> 和 <code>score</code> 三张表插入数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给 student 表插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"郭靖"</span>,</span><br><span class="line">  <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"40"</span>,</span><br><span class="line">  <span class="string">"济南"</span>,</span><br><span class="line">  <span class="string">"山东省"</span>,</span><br><span class="line">  <span class="string">"1978-09-03"</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"1@qq.com"</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"2"</span>,</span><br><span class="line">  <span class="string">"黄蓉"</span>,</span><br><span class="line">  <span class="string">"2"</span>,</span><br><span class="line">  <span class="string">"36"</span>,</span><br><span class="line">  <span class="string">"济南"</span>,</span><br><span class="line">  <span class="string">"山东省"</span>,</span><br><span class="line">  <span class="string">"1982-09-03"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">"2@qq.com"</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"3"</span>,</span><br><span class="line">  <span class="string">"杨过"</span>,</span><br><span class="line">  <span class="string">"3"</span>,</span><br><span class="line">  <span class="string">"22"</span>,</span><br><span class="line">  <span class="string">"终南山"</span>,</span><br><span class="line">  <span class="string">"陕西省"</span>,</span><br><span class="line">  <span class="string">"1996-09-03"</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"3@qq.com"</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"4"</span>,</span><br><span class="line">  <span class="string">"小龙女"</span>,</span><br><span class="line">  <span class="string">"4"</span>,</span><br><span class="line">  <span class="string">"28"</span>,</span><br><span class="line">  <span class="string">"终南山"</span>,</span><br><span class="line">  <span class="string">"陕西省"</span>,</span><br><span class="line">  <span class="string">"1990-09-03"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">"4@qq.com"</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"5"</span>,</span><br><span class="line">  <span class="string">"欧阳锋"</span>,</span><br><span class="line">  <span class="string">"5"</span>, <span class="string">"70"</span>,</span><br><span class="line">  <span class="string">"白驼山"</span>,</span><br><span class="line">  <span class="string">"新疆"</span>,</span><br><span class="line">  <span class="string">"1948-09-03"</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"5@qq.com"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 cource 表插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">"1"</span>, <span class="string">"语文"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">"2"</span>, <span class="string">"数学"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">"3"</span>, <span class="string">"英语"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 score 表插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"100"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"90"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"70"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"100"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"2"</span>, <span class="string">"2"</span>, <span class="string">"40"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"80"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"3"</span>, <span class="string">"1"</span>, <span class="string">"100"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"3"</span>, <span class="string">"2"</span>, <span class="string">"60"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"3"</span>, <span class="string">"3"</span>, <span class="string">"80"</span>);</span><br></pre></td></tr></table></figure><p><strong>添加数据后的三张表如下图：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/tables.png" alt="表的具体数据" title>                </div>                <div class="image-caption">表的具体数据</div>            </figure><p><br></p><p><strong>查询山东省学生的全部信息：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`province`</span> = <span class="string">"山东"</span>;</span><br></pre></td></tr></table></figure><p><strong>查询山东省男学生的全部信息：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`province`</span> = <span class="string">"山东"</span> <span class="keyword">AND</span> <span class="string">`gender`</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>查询没填写电子邮箱学生的姓名和身份证号：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>, <span class="string">`idcard`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`email`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>把学生的成绩按升序排列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`grade`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><strong>课程编号升序排列，成绩降序排列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`course_id`</span> <span class="keyword">ASC</span>, <span class="string">`grade`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL-语句之模糊查询"><a href="#SQL-语句之模糊查询" class="headerlink" title="SQL 语句之模糊查询"></a>SQL 语句之模糊查询</h2><blockquote class="pullquote primary"><p>在上一节中我们所使用的查询叫 “完整查询” 或 “精准查询”，而本节的 “模糊查询” 是指查询条件不明确，可以尽量多的匹配满足查询条件的数据。</p></blockquote><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>“通配符” 用于代替一个或多个真正的字符，与 <code>LIKE</code> 关键字一起使用，通配符的解释、示例如下表。</p><table><thead><tr><th style="width:15%;text-align:center">通配符</th><th style="text-align:center">解释</th><th style="width:20%;text-align:center">示例</th><th style="width:25%;text-align:center">符合条件的值</th></tr></thead><tbody><tr><td style="text-align:center">_</td><td style="text-align:center">一个任意字符</td><td style="text-align:center">LIKE “a_”</td><td style="text-align:center">as、ad 等</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">任意长度的字符串</td><td style="text-align:center">LIKE “c%”</td><td style="text-align:center">code、cat 等</td></tr><tr><td style="text-align:center">[ ]</td><td style="text-align:center">括号中所指定范围内的一个字符</td><td style="text-align:center">LIKE “1[35]5”</td><td style="text-align:center">135 或 155</td></tr><tr><td style="text-align:center">[^]</td><td style="text-align:center">不再括号中所指定范围内的一个字符</td><td style="text-align:center">LIKE “1[^1-2]5”</td><td style="text-align:center">135 或 155 等</td></tr></tbody></table><p>查询 <code>student</code> 表中 <code>email</code> 列是 <code>qq</code> 邮箱的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`emai`</span> <span class="keyword">LIKE</span> <span class="string">`%qq%`</span>;</span><br></pre></td></tr></table></figure><p>查询 <code>student</code> 表中姓杨的名字为两个字的所有学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`name`</span> <span class="keyword">LIKE</span> <span class="string">"杨_"</span>;</span><br></pre></td></tr></table></figure><h3 id="BETWEEN…AND…"><a href="#BETWEEN…AND…" class="headerlink" title="BETWEEN…AND…"></a>BETWEEN…AND…</h3><p><code>BETWEEN...AND...</code> 用于查询某一列在指定范围内的记录，包括两个边界。</p><p>查询 <code>score</code> 表中成绩在 <code>80</code> 到 <code>90</code> 范围内的所有学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 精准查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`grade`</span> &gt;= <span class="number">80</span> <span class="keyword">AND</span> <span class="string">`grade`</span> &lt;= <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`grade`</span> <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><p>查询某一列中的值在列出的内容列表中。</p><p>查询 <code>student</code> 表中 <code>city</code> 列为 “北京” 或 “上海” 或 “杭州” 所有学生的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 精准查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> = <span class="string">"北京"</span> <span class="keyword">OR</span> <span class="string">`city`</span> = <span class="string">"上海"</span> <span class="keyword">OR</span> <span class="string">`city`</span> = <span class="string">"杭州"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> <span class="keyword">IN</span> (<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"杭州"</span>);</span><br></pre></td></tr></table></figure><h2 id="截断表"><a href="#截断表" class="headerlink" title="截断表"></a>截断表</h2><p>作为主键的标识列，值是会随着数据的增加，自动递增的，且具有 “断号保留” 的特性，随着表中数据的增删，标识列的值会非常混乱，我们可以通过截断表来解决该问题，截断表有两个作用如下。</p><ul><li>使表中数据的标识列的值重新从 <code>1</code> 开始计数；</li><li>清空表中数据；</li></ul><blockquote class="pullquote warning"><p><em><strong>使用截断表时，表的列和约束不会改动，使用的前提是表与表之间不能存在外键约束，表之间如果通过外键进行关联，无法清空主表中数据，即无法截断表。</strong></em></p></blockquote><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure><p><strong>截断 student 表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>截断表操作轻易不要使用，因为普通的 SQL 操作会记录日志，并且可以还原，而 <code>TRUNCATE</code> 操作不会记录日志，并且不可还原，万一删错，彻底完蛋。</strong></em></p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote class="pullquote default"><p>在 MySQL 中有很多内置的函数帮我们实现一些功能，函数大类可分为普通函数和聚合函数，我们本节主要介绍普通函数，常用的普通函数大概可分为字符函数、数字函数、日期函数和流程控制函数等，还有一些与数据库相关的辅助函数以及自定义函数，都会在本节一一介绍。</p></blockquote><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><h4 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH"></a>LENGTH</h4><p><code>LENGTH</code> 函数的作用是返回输入字符串的长度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(<span class="string">"panda"</span>); <span class="comment">-- 5</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(<span class="string">"你好啊"</span>); <span class="comment">-- 9</span></span><br></pre></td></tr></table></figure><h4 id="CONCAT-和-CONCAT-WS"><a href="#CONCAT-和-CONCAT-WS" class="headerlink" title="CONCAT 和 CONCAT_WS"></a>CONCAT 和 CONCAT_WS</h4><p><code>CONCAT</code> 函数用于将多个字符串拼接成一个字符串，<code>CONCAT_WS</code> 函数用于使用分隔符将多个字符串拼接成一个字符串，第一个参数为分隔符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">"Panda"</span>, <span class="string">"Shen"</span>); <span class="comment">-- PandaShen</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT_WS</span>(<span class="string">"-"</span>, <span class="string">"Hello"</span>, <span class="string">"Panda"</span>, <span class="string">"Shen"</span>); <span class="comment">-- Hello-Panda-Shen</span></span><br></pre></td></tr></table></figure><h4 id="UPPER-和-LOWER"><a href="#UPPER-和-LOWER" class="headerlink" title="UPPER 和 LOWER"></a>UPPER 和 LOWER</h4><p><code>UPPER</code> 函数用于将字符串转换为大写，<code>LOWER</code> 函数用于将字符串转换为小写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UPPER</span>(<span class="string">"panda"</span>); <span class="comment">-- PANDA</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LOWER</span>(<span class="string">"PANDA"</span>); <span class="comment">-- panda</span></span><br></pre></td></tr></table></figure><h4 id="SUBSTR"><a href="#SUBSTR" class="headerlink" title="SUBSTR"></a>SUBSTR</h4><p><code>SUBSTR</code> 函数用于截取字符串，第一个参数为源字符串，第二个参数为起始的索引（从 <code>1</code> 开始），第三个参数为截取的长度，不传默认截取后面全部字符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">"panda"</span>, <span class="number">3</span>); <span class="comment">-- nda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">"panda"</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">-- nd</span></span><br></pre></td></tr></table></figure><h4 id="LEFT-和-RIGHT"><a href="#LEFT-和-RIGHT" class="headerlink" title="LEFT 和 RIGHT"></a>LEFT 和 RIGHT</h4><p><code>LEFT</code> 函数和 <code>RIGHT</code> 函数分别代表在字符串取左边或右边的规定位数，第一个参数为源字符串，第二个参数为规定的位数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">"panda12345"</span>, <span class="number">5</span>); <span class="comment">-- panda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">"panda12345"</span>, <span class="number">5</span>); <span class="comment">-- 12345</span></span><br></pre></td></tr></table></figure><h4 id="INSTR"><a href="#INSTR" class="headerlink" title="INSTR"></a>INSTR</h4><p><code>INSTR</code> 函数用于查找某个字符串在一个源字符串中的起始（第一个匹配到的）索引，第一个参数为源字符串，第二个参数为查询字符串，查询不到返回 <code>0</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSTR</span>(<span class="string">"panda"</span>, <span class="string">"a"</span>); <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSTR</span>(<span class="string">"panda"</span>, <span class="string">"x"</span>); <span class="comment">-- 0</span></span><br></pre></td></tr></table></figure><h4 id="LTRIM、RTRIM-和-TRIM"><a href="#LTRIM、RTRIM-和-TRIM" class="headerlink" title="LTRIM、RTRIM 和 TRIM"></a>LTRIM、RTRIM 和 TRIM</h4><p><code>LTRIM</code> 函数用于去掉字符串左侧空格，<code>RTRIM</code> 用于去掉字符串右侧空格，<code>TRIM</code> 用于去掉字符串两侧的空格，如果 <code>TRIM</code> 的参数将两个字符串使用 <code>FROM</code> 连接，则代表去掉右侧字符串左右两侧的左侧字符串（说的有点绕，看例子）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LTRIM</span>(<span class="string">"  panda"</span>); <span class="comment">-- panda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RTRIM</span>(<span class="string">"panda  "</span>); <span class="comment">-- panda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">"  panda  "</span>); <span class="comment">-- panda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">"@"</span> <span class="keyword">FROM</span> <span class="string">"@@panda@@"</span>); <span class="comment">-- panda</span></span><br></pre></td></tr></table></figure><h4 id="LPAD-和-RPAD"><a href="#LPAD-和-RPAD" class="headerlink" title="LPAD 和 RPAD"></a>LPAD 和 RPAD</h4><p><code>LPAD</code> 函数和 <code>RPAD</code> 函数分别用于向源字符串的左、右按照规定字符串的长度填充定义的字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">"panda"</span>, <span class="number">10</span>, <span class="string">"@"</span>); <span class="comment">-- @@@@@panda</span></span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">"panda"</span>, <span class="number">10</span>, <span class="string">"@"</span>); <span class="comment">-- panda@@@@@</span></span><br></pre></td></tr></table></figure><h4 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE"></a>REPLACE</h4><p><code>REPLACE</code> 函数用于替换某字符串的部分字符，第一个参数为源字符串，第二个参数为被替换字符，第三个参数为替换字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">REPLACE</span>(<span class="string">"panda"</span>, <span class="string">"a"</span>, <span class="string">"e"</span>); <span class="comment">-- pende</span></span><br></pre></td></tr></table></figure><h4 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h4><p>查询 <code>id</code> 为 <code>3</code> 学生的邮箱域名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">`email`</span>, <span class="keyword">INSTR</span>(<span class="string">`email`</span>, <span class="string">"@"</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`id`</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- qq.com</span></span><br></pre></td></tr></table></figure><p>将 <code>student</code> 表中的邮箱地址全部由小写改成大写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">`email`</span> = <span class="keyword">UPPER</span>(<span class="string">`email`</span>);</span><br></pre></td></tr></table></figure><p>给 <code>student</code> 表新增一列 <code>level</code>，类型为 <code>varchar</code>，值为 <code>1-1</code>、<code>1-2</code>、<code>1-3</code>、<code>2-1</code>、<code>2-2</code> 等，按照 <code>level</code> 列值中 <code>-</code> 的前半段正序排列，后半段逆序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`level`</span>,</span><br><span class="line"><span class="keyword">SUBSTR</span>(<span class="string">`level`</span>, <span class="number">1</span>, <span class="keyword">INSTR</span>(<span class="string">`level`</span>, <span class="string">"-"</span>) - <span class="number">1</span>),</span><br><span class="line"><span class="keyword">SUBSTR</span>(<span class="string">`level`</span>, <span class="keyword">INSTR</span>(<span class="string">`level`</span>, <span class="string">"-"</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">SUBSTR</span>(<span class="string">`level`</span>, <span class="number">1</span>, <span class="keyword">INSTR</span>(<span class="string">`level`</span>, <span class="string">"-"</span>) - <span class="number">1</span>) <span class="keyword">ASC</span>,</span><br><span class="line"><span class="keyword">SUBSTR</span>(<span class="string">`level`</span>, <span class="keyword">INSTR</span>(<span class="string">`level`</span>, <span class="string">"-"</span>) + <span class="number">1</span>) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>将 <code>pandashen</code> 转换成 <code>Panda_Shen</code>，将两个单词拆开，并实现首字母大写，其他字符小写，然后用 <code>_</code> 拼接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CONCAT</span>(</span><br><span class="line">  <span class="keyword">CONCAT</span>(</span><br><span class="line">    <span class="keyword">UPPER</span>(<span class="keyword">SUBSTR</span>(<span class="keyword">SUBSTR</span>(<span class="string">"pandashen"</span>, <span class="number">1</span>, <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    <span class="keyword">SUBSTR</span>(<span class="keyword">SUBSTR</span>(<span class="string">"pandashen"</span>, <span class="number">1</span>, <span class="number">5</span>), <span class="number">2</span>)</span><br><span class="line">  ),</span><br><span class="line">  <span class="string">"_"</span>,</span><br><span class="line">  <span class="keyword">CONCAT</span>(</span><br><span class="line">    <span class="keyword">UPPER</span>(<span class="keyword">SUBSTR</span>(<span class="keyword">SUBSTR</span>(<span class="string">"pandashen"</span>, <span class="number">6</span>), <span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    <span class="keyword">SUBSTR</span>(<span class="keyword">SUBSTR</span>(<span class="string">"pandashen"</span>, <span class="number">6</span>), <span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Panda_Shen</span></span><br></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><h4 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h4><p><code>FORMAT</code> 函数用于将数字格式化，第一个参数为要格式化的数字，第二个参数为保留的小数位数，返回值为字符串，整数部分每三位使用 <code>,</code> 分隔。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">100000</span>, <span class="number">2</span>); <span class="comment">-- 100,000.00</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">100.31111</span>, <span class="number">3</span>); <span class="comment">-- 100.311</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">100.31111</span>, <span class="number">0</span>); <span class="comment">-- 100</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">423423234.65534453</span>, <span class="number">2</span>); <span class="comment">-- 423,423,234.66</span></span><br></pre></td></tr></table></figure><h4 id="CEIL-和-FLOOR"><a href="#CEIL-和-FLOOR" class="headerlink" title="CEIL 和 FLOOR"></a>CEIL 和 FLOOR</h4><p><code>CEIL</code> 函数为向上取整，<code>FLOOR</code> 函数为向下取整。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">2.4</span>); <span class="comment">-- 3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">2.4</span>); <span class="comment">-- 2</span></span><br></pre></td></tr></table></figure><h4 id="ROUND-和-TRUNCATE"><a href="#ROUND-和-TRUNCATE" class="headerlink" title="ROUND 和 TRUNCATE"></a>ROUND 和 TRUNCATE</h4><p><code>ROUND</code> 函数为四舍五入，<code>TRUNCATE</code> 函数为小数截断，第一个参数为截断的数字，第二个参数为保留的小数位数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">2.1</span>); <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">2.5</span>); <span class="comment">-- 3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>, <span class="number">0</span>); <span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>, <span class="number">1</span>); <span class="comment">-- 1.6</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>, <span class="number">2</span>); <span class="comment">-- 1.66</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>, <span class="number">3</span>); <span class="comment">-- 1.66</span></span><br></pre></td></tr></table></figure><h4 id="POWER"><a href="#POWER" class="headerlink" title="POWER"></a>POWER</h4><p><code>POWER</code> 函数用于幂运算，第一个参数为底数，第二个参数为指数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">POWER</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">-- 8</span></span><br></pre></td></tr></table></figure><h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p><code>MOD</code> 函数用于取余运算，第一个参数为被除数，第二个参数为除数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SElECT</span> <span class="keyword">MOD</span>(<span class="number">10</span>, <span class="number">3</span>); <span class="comment">-- 1</span></span><br></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h4 id="NOW、CURDATE-和-CURTIME"><a href="#NOW、CURDATE-和-CURTIME" class="headerlink" title="NOW、CURDATE 和 CURTIME"></a>NOW、CURDATE 和 CURTIME</h4><p><code>NOW</code> 函数用于获取当前的时间，格式为 <code>yyyy-mm-dd hh:mm:ss</code>，<code>CURDATE</code> 函数用于获取当前日期，格式为 <code>yyyy-mm-dd hh:mm:ss</code>，<code>CURTIME</code> 函数用于获取当前时间，格式为 <code>hh:mm:ss</code>，返回类型均为日期格式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>(); <span class="comment">-- 2018-08-09 19:23:18</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURDATE</span>(); <span class="comment">-- 2018-08-09</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURTIME</span>(); <span class="comment">-- 19:25:31</span></span><br></pre></td></tr></table></figure><h4 id="DATE-ADD"><a href="#DATE-ADD" class="headerlink" title="DATE_ADD"></a>DATE_ADD</h4><p><code>DATE_ADD</code> 函数用于增加时间，即将时间求和，第一个参数为 <code>yyyy-mm-dd hh:mm:ss</code> 格式的时间，第二个参数为时间间隔，<code>INTERVAL</code> 关键字代表时间间隔，后面跟上数字，单位为 <code>DAY</code>、<code>MONTH</code>、<code>YEAR</code> 等，返回类型为字符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>); <span class="comment">-- 2019-08-09 19:30:15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>); <span class="comment">-- 2018-09-09 19:30:15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>); <span class="comment">-- 2019-08-09 19:30:15</span></span><br></pre></td></tr></table></figure><h4 id="STR-TO-DATE"><a href="#STR-TO-DATE" class="headerlink" title="STR_TO_DATE"></a>STR_TO_DATE</h4><p><code>STR_TO_DATE</code> 函数可以将一个日期格式的字符串转换成日期，第一个参数为日期格式的字符串，第二个参数为日期的格式描述，如 <code>%Y-%m-%d</code>，传入的日期字符串的格式与日期格式描述必须保持一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">"2018-08-09"</span>, <span class="string">"%Y-%m-%d"</span>); <span class="comment">-- 2018-08-09</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">"2018/08/09"</span>, <span class="string">"%Y/%m/%d"</span>); <span class="comment">-- 2018-08-09</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">"2018.08.09"</span>, <span class="string">"%Y.%m.%d"</span>); <span class="comment">-- 2018-08-09</span></span><br></pre></td></tr></table></figure><p>从 <code>student</code> 表中查询一个生日（列名为 <code>birthday</code>）为 <code>1982</code> 年 <code>9</code> 月 <code>3</code> 的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`birthday`</span> = <span class="keyword">STR_TO_DATE</span>(<span class="string">'09-03 1982'</span>,<span class="string">'%m-%d %Y'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果查到了黄蓉的信息</span></span><br></pre></td></tr></table></figure><p><strong>格式描述参考下表：</strong></p><table><thead><tr><th style="width:20%;text-align:center">序号</th><th style="width:20%;text-align:center">格式符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><span style="font-weight:inherit;font-style:inherit">%Y</span></td><td style="text-align:center">4 位的年份</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">%y</td><td style="text-align:center">2 位的年份</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">%m</td><td style="text-align:center">月份（01，02）</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">%c</td><td style="text-align:center">月份（1，2）</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">%d</td><td style="text-align:center">日（01，02）</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">%H</td><td style="text-align:center">小时（24 小时制）</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">%h</td><td style="text-align:center">小时（12 小时制）</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">%i</td><td style="text-align:center">分钟（00，01）</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">%s</td><td style="text-align:center">秒（00，01）</td></tr></tbody></table><h4 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT"></a>DATE_FORMAT</h4><p><code>DATE_FORMAT</code> 函数与 <code>STR_TO_DATE</code> 作用正好相反，是将一个日期类型按照格式描述转换成日期字符串，第一个参数为日期对象，第二个参数为日期的格式描述。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">STR_TO_DATE</span>(<span class="string">"2018-08-09"</span>, <span class="string">"%Y-%m-%d"</span>), <span class="string">"%Y年%m月%d日"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2018年08月09日</span></span><br></pre></td></tr></table></figure><h4 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h4><p><code>DATEDIFF</code> 函数用于计算时间间隔，两个参数均为日期对象，得到的结果为第一个与第二个的差值，单位为 “天”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(<span class="keyword">NOW</span>(), <span class="keyword">STR_TO_DATE</span>(<span class="string">"2018-08-08"</span>, <span class="string">"%Y-%m-%d"</span>)); <span class="comment">-- 1</span></span><br></pre></td></tr></table></figure><p>通过查询 <code>student</code> 的 <code>birthday</code> 列计算每个人的年龄（周岁）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="keyword">DATEDIFF</span>(<span class="keyword">NOW</span>(), <span class="string">`birthday`</span>) / <span class="number">365</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><h4 id="返回日期中指定的部分"><a href="#返回日期中指定的部分" class="headerlink" title="返回日期中指定的部分"></a>返回日期中指定的部分</h4><p>下面方法传入参数均为日期对象，返回的时间中对应的部分均为字符串。</p><ul><li>YEAR：返回年；</li><li>MONTH：返回月；</li><li>DAY：返回日；</li><li>HOUR：返回小时；</li><li>MINUTE：返回分钟；</li><li>SECOND：返回秒；</li><li>MONTHNAME：返回月份名称（英文）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 2018</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 8</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 9</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">HOUR</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 19</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 48</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SECOND</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 53</span></span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(<span class="keyword">NOW</span>()); <span class="comment">-- August</span></span><br></pre></td></tr></table></figure><h4 id="综合练习-1"><a href="#综合练习-1" class="headerlink" title="综合练习"></a>综合练习</h4><p>查询 <code>student</code> 表中出生月份是 <code>9</code> 月的学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(<span class="string">`birthday`</span>) = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>查询 <code>student</code> 表中生日是今天的学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>()) = <span class="keyword">MONTH</span>(<span class="string">`birthday`</span>) <span class="keyword">AND</span> <span class="keyword">DAY</span>(<span class="keyword">NOW</span>()) = <span class="keyword">DAY</span>(<span class="string">`birthday`</span>);</span><br></pre></td></tr></table></figure><p>在 <code>student</code> 表中查询年龄超过 <code>18</code> 岁的男同学。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法 1：求生日与现在时间的差值转换成年与年龄比较</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATEDIFF</span>(<span class="keyword">NOW</span>(), <span class="string">`birthday`</span>) / <span class="number">365</span> &gt; <span class="number">18</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法 2：给生日加上 18 年看看是否大于今天的时间</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATE_ADD</span>(<span class="string">`birthday`</span>, <span class="built_in">INTERVAL</span> <span class="number">18</span> <span class="keyword">YEAR</span>) &lt; <span class="keyword">NOW</span>();</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法 3：获取今天时间的年份和生日的年份做差，看是否大于 18</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) - <span class="keyword">YEAR</span>(<span class="string">`birthday`</span>) &gt; <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h3 id="数据库辅助函数"><a href="#数据库辅助函数" class="headerlink" title="数据库辅助函数"></a>数据库辅助函数</h3><h4 id="CONNECTION-ID"><a href="#CONNECTION-ID" class="headerlink" title="CONNECTION_ID"></a>CONNECTION_ID</h4><p>连接每个数据库都会分配对应的连接号，我们称为连接 ID，<code>CONNECTION_ID</code> 函数可以帮我们获取连接 ID。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONNECTION_ID(); <span class="comment">-- 10</span></span><br></pre></td></tr></table></figure><h4 id="DATABASE"><a href="#DATABASE" class="headerlink" title="DATABASE"></a>DATABASE</h4><p><code>DATABASE</code> 函数用于查看当前的连接的数据库，返回数据库名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(); <span class="comment">-- school</span></span><br></pre></td></tr></table></figure><h4 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION"></a>VERSION</h4><p><code>VERSION</code> 函数用来查看当前 MySQL 数据库的版本号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>(); <span class="comment">-- 5.5.61</span></span><br></pre></td></tr></table></figure><h4 id="LAST-INSERT-ID"><a href="#LAST-INSERT-ID" class="headerlink" title="LAST_INSERT_ID"></a>LAST_INSERT_ID</h4><p><code>LAST_INSERT_ID</code> 可以获取上次向表中（任意表）插入数据时，插入数据的 <code>id</code> 号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">LAST_INSERT_ID</span>(); <span class="comment">-- 0</span></span><br></pre></td></tr></table></figure><h4 id="USER-和-PASSWORD"><a href="#USER-和-PASSWORD" class="headerlink" title="USER 和 PASSWORD"></a>USER 和 PASSWORD</h4><p><code>USER</code> 用于查询当前数据库登录的用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(); <span class="comment">-- root@</span></span><br></pre></td></tr></table></figure><p>在 MySQL 数据库中存在一张表存放着 MySQL 当前所有的用户，可以通过下面命令查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure><p>通过查询结果可以看出密码的位置存储的是密文，如果要修改密码需要将设置的密码转换成密文进行存储，<code>PASSWORD</code> 函数就是来做这件事的，修改密码命令如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">FROM</span> mysql.user</span><br><span class="line"><span class="keyword">SET</span> <span class="string">`password`</span> = <span class="keyword">PASSWORD</span>(<span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p><code>MD5</code> 可以将传入的字符串进行一个 <code>MD5</code> 散列算法的转换并输出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MD5</span>(<span class="string">"panda"</span>); <span class="comment">-- ce61649168c4550c2f7acab92354dc6e</span></span><br></pre></td></tr></table></figure><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><h4 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h4><p><code>IF</code> 函数可以根据传入的判断条件在两个结果中进行选择输出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="number">1</span> &gt; <span class="number">2</span>, <span class="string">"yes"</span>, <span class="string">"no"</span>); <span class="comment">-- no</span></span><br></pre></td></tr></table></figure><h4 id="CASE、WHEN、THEN、ELSE-和-END"><a href="#CASE、WHEN、THEN、ELSE-和-END" class="headerlink" title="CASE、WHEN、THEN、ELSE 和 END"></a>CASE、WHEN、THEN、ELSE 和 END</h4><p><code>CASE</code>、<code>WHEN</code>、<code>THEN</code>、<code>ELSE</code> 和 <code>END</code> 共同组成了一个流程控制函数，可以代替多个 <code>IF</code>，<code>CASE</code> 为条件判断起始关键字，<code>WHEN</code> 为判断条件关键字（可以有多个），<code>THEN</code> 为输出结果关键字，<code>ELSE</code> 为默认输出关键字，<code>END</code> 为流程结束关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`grade`</span>,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">`grade`</span> &gt; <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">"优"</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">`grade`</span> &gt; <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">"良"</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">`grade`</span> &gt; <span class="number">70</span> <span class="keyword">THEN</span> <span class="string">"中"</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">`grade`</span> &gt; <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">"及格"</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">"不及格"</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>自定义函数是对 MySQL 的扩展，使用方式和内置函数相同；</li><li>函数必须要有参数和返回值，函数可以接收任意类型的值和参数，返回值只能有一个；</li><li>函数体由合法的 SQL 语句组成，可以包含声明、循环和流程控制，也可以是 <code>SELECT</code> 或 <code>INSERT</code> 语句，如果函数体是复合结构（多条语句）要用 <code>BEGIN...END</code>。</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> FUNC_NAME <span class="keyword">RETURNS</span> &#123;<span class="keyword">String</span>|<span class="built_in">Integer</span>&#125;</span><br><span class="line"><span class="keyword">BODY</span></span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">VALUE</span></span><br></pre></td></tr></table></figure><p><code>CREATE FUNCTION</code> 为创建函数关键字，<code>FUNC_NAME</code> 为函数的名字，<code>RETURNS</code> 为返回类型关键字，“&#123; &#125;” 中的内容为返回值类型，如 <code>varchar</code> 等，<code>BODY</code> 代表函数体，<code>RETURN VALUE</code> 代表返回值。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>写一个自定义函数用于获取中文格式的当前时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数 ZHNOW</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> ZHNOW() <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(), <span class="string">"%Y年%m月%d日"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 ZHNOW</span></span><br><span class="line"><span class="keyword">SELECT</span> ZHNOW(); <span class="comment">-- 2018年08月10日</span></span><br></pre></td></tr></table></figure><p>实现一个自定义函数对两个数字进行相乘运算并将结果返回。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数 MYPRODUCT，参数为两个数字</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> MYPRODUCT(n <span class="built_in">INT</span>, m <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">RETURN</span> n * m;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 MYPRODUCT</span></span><br><span class="line"><span class="keyword">SELECT</span> MYPRODUCT(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">-- 10</span></span><br></pre></td></tr></table></figure><p>针对上面的 <code>course</code> 学科表，写一个自定义函数用来增加学科并返回增加数据的 <code>id</code> 值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数 ADD_COURSE，参数为添加课程的名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> ADD_COURSE(<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>)) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> (<span class="string">`name`</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">name</span>);</span><br><span class="line">RETURN LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 ADD_COURSE</span></span><br><span class="line"><span class="keyword">SELECT</span> ADD_COURSE(<span class="string">"体育"</span>); <span class="comment">-- 4</span></span><br></pre></td></tr></table></figure><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><blockquote class="pullquote info"><p>上一节中的函数都是普通函数，多用于操作表达式后返回结果，而聚合函数更多是对一组值进行计算，并返回计算后的值，一般用来统计数据，使用难度要大于普通函数。</p></blockquote><h3 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h3><p><code>SUM</code> 函数用于累加所有行的值。</p><p>还是以上面的 <code>score</code> 表为例，我们取出 <code>student_id</code> 值为 <code>1</code> 的学生全部科目的总成绩。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`student_id`</span> = <span class="number">1</span>; <span class="comment">-- 260</span></span><br></pre></td></tr></table></figure><p>其实上面的操作是分为两部分进行，首先先查出 <code>student_id</code> 为 <code>1</code> 的所有学科的成绩，在对这些成绩进行求和计算后返回。</p><h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h3><p><code>AVG</code> 函数用于计算所有行的平均值。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>3</code> 的学生全部科目成绩的平均值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`student_id`</span> = <span class="number">3</span>; <span class="comment">-- 80</span></span><br></pre></td></tr></table></figure><h3 id="MAX-和-MIN"><a href="#MAX-和-MIN" class="headerlink" title="MAX 和 MIN"></a>MAX 和 MIN</h3><p><code>MAX</code> 和 <code>MIN</code> 分别用于计算所有行的最大值和最小值。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>2</code> 的学生全部科目成绩的最大值和最小值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="string">`grade`</span>), <span class="keyword">MIN</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`student_id`</span> = <span class="number">2</span>; <span class="comment">-- 100 40</span></span><br></pre></td></tr></table></figure><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><p><code>COUNT</code> 按照某一列统计所有行的总条数，如果参照的列值为 <code>null</code> 则不统计在内。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>1</code> 的学生成绩总数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`student_id`</span> = <span class="number">1</span>; <span class="comment">-- 3</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL-语句之分组聚合"><a href="#SQL-语句之分组聚合" class="headerlink" title="SQL 语句之分组聚合"></a>SQL 语句之分组聚合</h2><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组查询就是按某一列或某几列的值进行分组，相同的值分为一组，然后可以对组内使用聚合函数分别进行统计。</p><p><strong>以 <code>score</code> 表为例，分组表示图如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/group.jpg" alt="成绩表分组数据" title>                </div>                <div class="image-caption">成绩表分组数据</div>            </figure><p><br></p><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名, 查询表达式</span><br><span class="line"><span class="keyword">FROM</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组字段&gt;</span><br></pre></td></tr></table></figure><p><code>GROUP BY</code> 关键字用于对筛选后的结果进行分组。</p><p><strong>例子：</strong></p><p>统计 <code>score</code> 表中每位同学的平均成绩（单列分组，对 <code>student_id</code> 进行分组）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`student_id`</span>, <span class="keyword">AVG</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`student_id`</span>;</span><br></pre></td></tr></table></figure><p>统计 <code>score</code> 表中每门课程的最高分（单列分组，对 <code>course_id</code> 进行分组），并按照分数从低到高排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`course_id`</span>, <span class="keyword">MAX</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`course_id`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`grade`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>统计 <code>student</code> 表中各省男女同学人数（多列分组，按照 <code>province</code> 和 <code>gender</code> 进行分组）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`province`</span>, <span class="string">`gender`</span>, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`province`</span>, <span class="string">`gender`</span>;</span><br></pre></td></tr></table></figure><p><code>COUNT</code> 中的 <code>*</code> 代表任意一列。</p><h3 id="分组筛选"><a href="#分组筛选" class="headerlink" title="分组筛选"></a>分组筛选</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名, 查询表达式</span><br><span class="line"><span class="keyword">FROM</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;条件&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组字段&gt;</span><br><span class="line"><span class="keyword">HAVING</span> 分组后的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 [<span class="keyword">ASC</span>, <span class="keyword">DESC</span>]</span><br><span class="line"><span class="keyword">LIMIT</span> 偏移量, 条数</span><br></pre></td></tr></table></figure><p><code>WHERE</code> 用于过滤掉不符合条件的记录，<code>HAVING</code> 用于过滤分组后的记录。</p><blockquote class="pullquote warning"><p><em><strong>注意：上面查询的关键字不一定每条查询语句都要有，但是如果有其中的某些关键字，一定要按照上面的顺序进行。</strong></em></p></blockquote><p><strong>例子：</strong></p><p>统计 <code>student</code> 表中学生人数多于一个的省份。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`province`</span>, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`province`</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>统计 <code>score</code> 表中不及格次数大于 <code>1</code> 的学生按逆序排列并取前 <code>3</code> 条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`student_id`</span>, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`grade`</span> &lt; <span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`student_id`</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="string">`grade`</span>) &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(<span class="string">`grade`</span>) <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL-语句之子查询"><a href="#SQL-语句之子查询" class="headerlink" title="SQL 语句之子查询"></a>SQL 语句之子查询</h2><p><strong>子查询的注意点：</strong></p><ul><li>子查询是出现在其他 SQL 语句中的 <code>SELECT</code> 语句；</li><li>子查询嵌套在查询内部，且必须写在圆括号中，外层可以是 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>SET</code> 等；</li><li>子查询可以包含多个关键字或条件；</li><li>子查询可以返回常量、一行数据、一列数据或其它子查询（返回多行数据需使用其他关键字处理）。</li></ul><h3 id="比较运算符连接子查询"><a href="#比较运算符连接子查询" class="headerlink" title="比较运算符连接子查询"></a>比较运算符连接子查询</h3><p>在查询通过 <code>WHERE</code> 进行条件筛选时，可以使用比较运算符连接子查询。</p><p>查询年龄大于平均年龄的学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) - <span class="keyword">YEAR</span>(<span class="string">`birthday`</span>) &gt; (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) - <span class="keyword">YEAR</span>(<span class="string">`birthday`</span>))</span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="IN-和-NOT-IN"><a href="#IN-和-NOT-IN" class="headerlink" title="IN 和 NOT IN"></a>IN 和 NOT IN</h3><p>当查询一张表的数据需要另一张表中的数据作为筛选条件时，可以在查询时通过 <code>IN</code> 和 <code>NOT IN</code> 关键字连接子查询。</p><p>查询 <code>student</code> 有不及格成绩的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`id`</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="string">`student_id`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line">  <span class="keyword">WHERE</span> <span class="string">`grade`</span> &lt; <span class="number">60</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果查到了黄蓉</span></span><br></pre></td></tr></table></figure><p>上面例子查到了 “黄蓉” 同学的信息，如果将 <code>IN</code> 修改为 <code>NOT IN</code> 则会查询到除 “黄蓉” 以外其他同学的信息。</p><p>查询 <code>student</code> 表中在 <code>score</code> 表中有成绩的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> student.id <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="string">`student_id`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="EXISTS-和-NOT-EXISTS"><a href="#EXISTS-和-NOT-EXISTS" class="headerlink" title="EXISTS 和 NOT EXISTS"></a>EXISTS 和 NOT EXISTS</h3><p><code>EXISTS</code> 和 <code>NOT EXISTS</code> 关键字用于连接子查询，代表 “存在” 或 “不存在” 的意思，接收的子查询返回为数据为布尔值。</p><p>拿上面查询 <code>student</code> 表在 <code>score</code> 表中有成绩学生信息的例子，使用 <code>EXISTS</code> 实现查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`student_id`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line">  <span class="keyword">WHERE</span> score.student_id = student.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><em><strong><code>IN</code>、<code>NOT IN</code> 与 <code>EXISTS</code>、<code>NOT EXISTS</code> 比较，后者的性能更高，查询速度更快，因为判断是在子查询内部，<code>EXISTS</code>、<code>NOT EXISTS</code> 只需要判断布尔值就可以了，<code>IN</code>、<code>NOT IN</code> 在子查询返回数据的基础上还要再次过滤。</strong></em></p></blockquote><h3 id="ALL、SOME-和-ANY"><a href="#ALL、SOME-和-ANY" class="headerlink" title="ALL、SOME 和 ANY"></a>ALL、SOME 和 ANY</h3><p>当子查询返回了多条数据的时候，可以使用 <code>ALL</code>、<code>SOME</code> 和 <code>ANY</code> 关键字作为比较运算符和子查询之间的连接。</p><ul><li><code>ALL</code> 关键字代表全部，即查询的数据筛选条件要去和所有子查询返回的比较并都满足；</li><li><code>SOME</code> 关键字代表某些，查询数据筛选条件只要满足子查询返回数据的某些条即可；</li><li><code>ANY</code> 关键字代表任何一个，查询数据的筛选条件只要满足子查询返回数据的任意一条即可。</li></ul><p>查询 <code>student</code> 表中年龄大于等于所有人的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`age`</span> &gt;= <span class="keyword">ALL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`age`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果查到了欧阳锋</span></span><br></pre></td></tr></table></figure><p>查询 <code>student</code> 表中年龄大于某些人的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`age`</span> &gt; <span class="keyword">SOME</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`age`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果查到除杨过以外的所有人（因为杨过年龄最小）</span></span><br></pre></td></tr></table></figure><p>查询 <code>student</code> 表中年龄大于任意一个人的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`age`</span> &gt; <span class="keyword">ANY</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`age`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回结果同 SOME 没区别</span></span><br></pre></td></tr></table></figure><h2 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h2><h3 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h3><p><strong>在 MySQL 中的表连接类型：</strong></p><ul><li><code>INNER JOIN</code>：内连接，代表取两张关联表的交集，可以用 <code>JOIN</code> 关键字代替；</li><li><code>LEFT</code>：左外连接，代表取两张表的交集后再和左侧表求并集，即包含左侧表全部数据；</li><li><code>RIGHT</code>：右外连接，代表取两张表的交际后再和右侧表求并集，即包含右侧表全部数据。</li></ul><p><strong>三种连接类型表示如下图：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/table-join.jpg" alt="表连接类型韦恩图" title>                </div>                <div class="image-caption">表连接类型韦恩图</div>            </figure><p><br></p><h3 id="连接条件-ON"><a href="#连接条件-ON" class="headerlink" title="连接条件 ON"></a>连接条件 ON</h3><p><code>ON</code> 关键字用来设定表的连接条件，也可以使用 <code>WHERE</code> 对结果进行过滤的方式来代替。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用内连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`score`</span> <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/inner-join-result.png" alt="内连接查询结果" title>                </div>                <div class="image-caption">内连接查询结果</div>            </figure><p><br></p><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用左外连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`score`</span> <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/left-join-result.png" alt="左外连接查询结果" title>                </div>                <div class="image-caption">左外连接查询结果</div>            </figure><p><br></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用右外连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="string">`score`</span> <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/right-join-result.png" alt="右外连接查询结果" title>                </div>                <div class="image-caption">右外连接查询结果</div>            </figure><p><br></p><h4 id="多表连接案例"><a href="#多表连接案例" class="headerlink" title="多表连接案例"></a>多表连接案例</h4><p>连接 <code>student</code>、<code>score</code> 和 <code>course</code> 三张表，分别查询学生姓名、学科和分数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student.name, course.name, score.grade</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`student`</span> <span class="keyword">ON</span> student.id = score.student_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`course`</span> <span class="keyword">ON</span> course.id = score.course_id;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>到此 MySQL 系列文章的第二篇就结束了，本篇的大部分都是和操作数据库的 SQl 语句相关的知识点，里面涵盖了基本的增、删、改、查以及函数、聚合函数的应用等，如果记不住的话（当然我也记不住，只是负责替大家和我自己整理）建议收藏，在使用时随时查阅，这一篇的内容对于前端而言，可以说基本够用了，如果你对数据库还有兴趣，想了解关于表的设计的相关思想，期待我的下一篇 <a href="https://www.overtaking.top/2018/08/14/20180814131241/" target="_blank">《MySQL —— 简单聊一聊数据库设计》</a> 更新吧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL —— 数据库基础</title>
      <link href="/2018/08/08/20180808012303/"/>
      <url>/2018/08/08/20180808012303/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/08/20180808012303/mysql-use.png" title="MySQL"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>MySQL 是目前使用最广泛的关系型数据库，是在软件开发中所必备的技能之一，这是关于 MySQL 的系列文章，将从 MySQL 的基本概念、基本使用、SQL 语句、函数、聚合函数、表连接以及表设计等多方面对 MySQL 进行总结，而本篇是数据库基础部分，大多都是一些概念性的内容和表的创建，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，当然这也是我的学习笔记，希望可以帮助大家。</p></blockquote><a id="more"></a><h2 id="MySQL-的基本概念"><a href="#MySQL-的基本概念" class="headerlink" title="MySQL 的基本概念"></a>MySQL 的基本概念</h2><p><strong>MySQL 的特点：</strong>开源免费、性能高、安装使用简单。</p><p><strong>MySQL 的作用：</strong></p><ul><li>存储大量数据，方便检索和访问；</li><li>保持数据信息的一致、完整；</li><li>实现数据的共享和安全；</li><li>通过组合分析产生新的有用信息。</li></ul><p><strong>实体：</strong>只要是客观存在，能够被描述出来的都是实体，每一条数据都是一个实体。</p><p><strong>DB：</strong>是数据库的意思，就是存储数据的仓库，可以存放结构化的数据。</p><p><strong>DBMS：</strong>代表数据管理系统，是一种系统软件，提供操作数据库的环境，如 <code>Navicat for MySQL</code>，可以通过数据库管理系统对数据进行增、删、改、查。</p><p><strong>SQL：</strong>结构化查询语言，专门用来和数据库进行交流的语言，几乎所有的 <code>DBMS</code> 都支持 <code>SQL</code>。</p><p><strong>数据表：</strong></p><ul><li>表是数据库中包含所有数据的数据库对象，也是其他对象的基础；</li><li>表定义是一个集合，数据在表中是按行和列的格式组织的，用来存放数据；</li><li>行被称为记录，用来存放一个实体，列称为字段用来描述实体的某一个属性。</li></ul><h2 id="MySQL-的配置和命令"><a href="#MySQL-的配置和命令" class="headerlink" title="MySQL 的配置和命令"></a>MySQL 的配置和命令</h2><h3 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h3><p>在 MySQL 的默认安装目录中 <code>my.ini</code> 文件是专门用来配置的，常用配置项如下：</p><ul><li>port：端口号；</li><li>basedir：安装目录；</li><li>datadir：数据存放目录</li><li>charcter-set-server：字符集；</li><li>default-storage-engine：存储引擎；</li><li>sql-mode：语法模式；</li><li>max-connections：最大连接数。</li></ul><h3 id="MySQL-命令"><a href="#MySQL-命令" class="headerlink" title="MySQL 命令"></a>MySQL 命令</h3><p><strong>MySQL 服务启动和停止：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net <span class="keyword">start</span> MySQL</span><br><span class="line">net <span class="keyword">stop</span> MySQL</span><br></pre></td></tr></table></figure><p><strong>连接和退出数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3306 -uroot -p123456</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><code>-h</code> 代表主机名，<code>-p</code> 代表端口号，<code>-u</code> 和 <code>-p</code> 分别代表当前 MySQL 服务的账号和密码。</p><p><strong>查看当前 MySQL 中的数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> dbs;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">database</span>;</span><br></pre></td></tr></table></figure><p><strong>切换数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> dataname;</span><br></pre></td></tr></table></figure><p><strong>查看数据库的表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">from</span> mysql;</span><br></pre></td></tr></table></figure><p><strong>查看当前所在的数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br></pre></td></tr></table></figure><p><strong>查询表结构：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc tablename;</span><br></pre></td></tr></table></figure><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>数据完整性是指，数据库种所有数据值均为正确状态，如果数据存储有不正确的的数据值，则该数据库丧失数据完整性，为了实现数据完整性，需要检验数据库表中每行每列的数据是否符合要求，在创建表时，应该保证以后输入的数据都是正确的，错误的数据不允许输入。</p><h3 id="域（列）完整性"><a href="#域（列）完整性" class="headerlink" title="域（列）完整性"></a>域（列）完整性</h3><p>域完整性是对数据表中字段属性的约束，通常指数据的有效性，它包括字段的值域、字段的类型及字段的有效规则等约束，它是由确定关系结构时所定义的字段的属性决定的，如关于年龄的字段，数据类型应为 <code>int</code>，关于普通的字符串值得类型应该为 <code>varchar</code> 等等，并在规定值类型时相应得规定值的长度，即所占的字节数。</p><p><strong>数据类型图如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/08/20180808012303/fields-type.png" alt="数据类型图" title>                </div>                <div class="image-caption">数据类型图</div>            </figure><p><br></p><p><strong>数值类型整数型：</strong></p><ul><li>tinyint：存储所占 <code>1</code> 字节，无符号可以存储 <code>0</code> ~ <code>255</code>，有符号可以存储 <code>-128</code> ~ <code>127</code>；</li><li>smallint：存储所占 <code>2</code> 字节，无符号可以存储 <code>0</code> ~ <code>65535</code>，有符号可以存储 <code>-32768</code> ~ <code>32767</code>；</li><li>mediumint：存储所占 <code>3</code> 字节，无符号可以存储 <code>0</code> ~ <code>16777215</code>，有符号可以存储 <code>-8388608</code> ~ <code>8388607</code>；</li><li>int：存储所占 <code>4</code> 字节，无符号可以存储 <code>0</code> ~ <code>4294967295</code>，有符号可以存储 <code>-2147483648</code> ~ <code>2147483647</code>；</li><li>bigint：存储所占 <code>8</code> 字节，无符号可以存储 <code>0</code> ~ <code>18446744073709551615</code>，有符号可以存储 <code>-9223372036854775808</code> ~ <code>9223372036854775807</code>。</li></ul><p>上面的整数型用来规定字段存储的数据必须为整数，从上到下需要占用的空间越来越多，能表示的数字也越来越大，定义字段时选择满足需求的数字范围即可。</p><p><strong>数值类型小数型：</strong></p><ul><li>float：单精度浮点型，存储所占 <code>4</code> 字节，数值范围为 <code>-3.4E38 ~ 3.4E38</code>，<code>7</code> 个有效位；</li><li>double：双精度浮点型，存储所占 <code>8</code> 字节，数值范围为 <code>-1.7E308~1.7E308</code>，<code>15</code> 个有效位；</li><li>decimal：定点型，存储所占 <code>16</code> 字节，<code>28</code> 个有效位，不存在精度损失，常用于银行账目计算。</li></ul><p>数值存储范围越小，精度越高，范围越大，精度越不准确，既要求精度，又固定小数点位数的数值存储，建议使用 <code>decimal</code>，优点在于可以自定义小数点位数，精度高，特殊情况，数值范围巨大，只能使用 <code>float</code> 类型，该类型一般不建议使用。</p><p><strong>字符串类型：</strong></p><ul><li>set：存储字符串对象，最多包含 <code>64</code> 个元素，并且可以取到集合中任意元素；</li><li>enum：存储字符串对象，最多包含 <code>65536</code> 个元素，只能取到集合中一个元素；</li><li>blob：用于存储二进制字符串，有子类型；</li><li>text：用于存储大文本，有子类型；</li><li>char：定长，最大 <code>255</code> 字节，存储空间未满，会在数据右侧填充空格；</li><li>varchar：不定长，最大 <code>65536</code> 字节，当长度小于 <code>4</code> 时，会自动转换成 <code>char</code>。</li></ul><p>上面类型中最常用的为 <code>varchar</code> 可以根据字段内容的自定义长度。</p><p><strong>时间类型：</strong></p><ul><li>year：<code>yyyy</code> 格式表示的年份值；</li><li>timestamp：<code>yyyymmddhhmmss</code> 格式表示的时间戳；</li><li>time：<code>hh:mm:ss</code> 格式表示的时间值；</li><li>date：<code>yyyy-mm-dd</code> 格式表示的日期值；</li><li>datetime：<code>yyyy-mm-dd hh:mm:ss</code> 格式表示的日期和时间。</li></ul><p><strong>默认值：</strong>默认值是指如果某个字段没有指定值的情况下，会为该字段指定一个预先设定的值。</p><p><strong>非空约束：</strong>我们可以指定某个字段不能不输入，必须提供一个非空的值，即不能为 <code>null</code>。</p><h3 id="实体（行）完整性"><a href="#实体（行）完整性" class="headerlink" title="实体（行）完整性"></a>实体（行）完整性</h3><p>实体完整性是对关系中的记录唯一性，也就是主键的约束，准确地说，实体完整性是指关系中的主属性值不能为 <code>null</code> 且不能有相同值，定义表中的所有行唯一的标识，一般用主键。</p><p><strong>主键：</strong>表中一列或者几列组合的值能用来唯一标识表中的每一行，这样的列或者列组合称为表的主键，主键表的数据不能重复，如果两列或者多列组合起来唯一标识表中的每一行，则该主键又称为 “组合主键”。</p><p><strong>主键的选择标准：</strong></p><ul><li>最少性：尽量选择单个键作为主键；</li><li>稳定性：由于主键是用来在两个表之间建立关联的，不能经常更新或者说一般不更新，所以最好选择无意义的列作为主键，如各种 <code>id</code> 值。</li></ul><h3 id="引用完整性"><a href="#引用完整性" class="headerlink" title="引用完整性"></a>引用完整性</h3><p>引用完整性意思是对关系型数据库中建立关联关系的数据表之间数据参照引用的约束，也就是对外键的约束，准确地说，是指关系中的外键必须是另一个关系的主键有效值，或者是 <code>null</code>，参考完整性，维护表间数据的有效性，完整性，通常通过建立外部键联系另一张关联表的主键实现。</p><p><strong>外键：</strong>用于连接两张表的字段称为外键，属于外键表，通常要关联的主键表的字段作为外键，保证了引用完整性。</p><p><strong>外键约束：</strong>外键表的外键必须引用主键表的主键，主表没有记录。</p><p><strong>如果一个表的外键引用了一个表的主键会有以下限制：</strong></p><ul><li>在外键表里不能添加主键表里没有的数据，外键表的数据与主键表的数据必须通过外键一一对应；</li><li>要想删除主键表的数据必须删除所有外键表的数据。</li></ul><p><strong>唯一约束：</strong>唯一约束是指某个字段值是唯一的，在所有的记录中不能有重复的值，如某个人的身份证号，需将外键的索引类型设置为 <code>Unique</code>。</p><p><strong>标识列：</strong>当表中没有适合做主键的列时，此时创建作为主键的无意义列称为标识列，标识列的值是自动生成的，不能输入修改，且是自增的，可以设置每次的增量，具有 “断号保留” 的特性，当某一个实体被删除时，该标识列的值是永久保存的，其他新增实体会在这个标识列的基础上继续自增。</p><h2 id="DDL-数据定义语言的使用"><a href="#DDL-数据定义语言的使用" class="headerlink" title="DDL 数据定义语言的使用"></a>DDL 数据定义语言的使用</h2><blockquote class="pullquote default"><p>我们可以通过两种方式创建表，可以使用 DDL（data defintion language）数据定义语言来创建，也可以使用 DBMS 数据管理系统来创建，使用 DBMS 还是很方便的，而且也是最常用的方式，但 DDL 创建方式我们不得不说，就是通过代码的方式来实现表的创建和操作，因为这是最原始的方式，即使图形化的操作会更方便，我们也应该了解。</p></blockquote><h3 id="SQL-规范"><a href="#SQL-规范" class="headerlink" title="SQL 规范"></a>SQL 规范</h3><p>SQL 语句的规范如下：</p><ul><li>SQL 语句不区分大小写，建议 SQL 关键字大写，表名和列表小写；</li><li>命令用分号结尾；</li><li>命令可以缩进和换行，一种类型的关键字放在一行；</li><li>可以写单行和多行注释 , <code>#</code> 和 <code>--</code> 是单行注释， <code>/*/</code> 是多行注释。</li></ul><h3 id="使用-DDL-操作表"><a href="#使用-DDL-操作表" class="headerlink" title="使用 DDL 操作表"></a>使用 DDL 操作表</h3><p>在 DBMS 中的查询编辑器可以代替命令行实现命令的编写，为了视觉效果，我们都使用 <code>Navicat for MySQL</code> 的查询编辑器，操作界面如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/08/20180808012303/navicat-mysql.png" alt="Navicat For MySQL 操作界面" title>                </div>                <div class="image-caption">Navicat For MySQL 操作界面</div>            </figure><p><br></p><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>创建表 <code>student</code>，创建一个标识列 <code>id</code> 不为空，设为主键并自增，创建 <code>name</code> 列，<code>varchar</code> 类型，<code>64</code> 位，不为空，创建 <code>age</code> 列，<code>int</code> 类型，不为空，创建 <code>city</code> 列，<code>varchar</code> 类型，<code>32</code> 位，默认值为 “北京”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span></span><br><span class="line">(</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="string">"北京"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="操作表的列"><a href="#操作表的列" class="headerlink" title="操作表的列"></a>操作表的列</h4><p>给上面的表 <code>student</code> 增加 <code>idcard</code> 列，值为空，将 <code>idcard</code> 列类型大小修改为 <code>32</code> 位，添加 <code>province</code> 列，插入到 <code>city</code> 列前面，查询表结构，删除 <code>idcard</code> 列，删除表 <code>student</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`idcard`</span> <span class="built_in">VARCHAR</span>(<span class="number">18</span>) <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="string">`idcard`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`province`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">AFTER</span> <span class="string">`age`</span>;</span><br><span class="line">DESC `student`;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="string">`idcard`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><h4 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h4><p>重新创建上面的 <code>student</code> 表，<code>city</code> 不设置默认值，不添加主键约束和标识列，再通过命令添加主键约束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span></span><br><span class="line">(</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><h4 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h4><p>将上面我们 <code>student</code> 表中的 <code>idcard</code> 列再加回来，给 <code>idcard</code> 列添加唯一约束，外键名为 <code>uq_idcard</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">`idcard`</span> <span class="built_in">VARCHAR</span>(<span class="number">18</span>) <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uq_idcard(<span class="string">`idcard`</span>);</span><br></pre></td></tr></table></figure><h4 id="添加默认约束"><a href="#添加默认约束" class="headerlink" title="添加默认约束"></a>添加默认约束</h4><p>将 <code>student</code> 表 <code>city</code> 列的默认值设置为 “北京”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="string">`city`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="string">"北京"</span>;</span><br></pre></td></tr></table></figure><h4 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h4><p>创建一个子表 <code>score</code>，添加 <code>student_id</code> 列，添加外键 <code>fk_student_id</code>，将 <code>student_id</code> 与 <code>student</code> 表的主键 <code>id</code> 相关联，此时 <code>student</code> 为主表（主键表），<code>score</code> 为子表（外键表）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`score`</span></span><br><span class="line">(</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`score`</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="string">`fk_student_id`</span></span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`student_id`</span>)</span><br><span class="line"><span class="keyword">REFERENCES</span> <span class="string">`student`</span> (<span class="string">`id`</span>);</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>注意：在项目中一般不会添加这个约束，因为在开发时会频繁操作表和修改数据，会经常报错，非常麻烦，不添加这个约束并不影响数据的检索和修改。</strong></em></p></blockquote><h4 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h4><p>删除 <code>score</code> 表与 <code>student</code> 表的外键约束，即删除外键 <code>fk_student_id</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`score`</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="string">`fk_student_id`</span>;</span><br></pre></td></tr></table></figure><h3 id="使用-DDL-创建一个完整的表关系"><a href="#使用-DDL-创建一个完整的表关系" class="headerlink" title="使用 DDL 创建一个完整的表关系"></a>使用 DDL 创建一个完整的表关系</h3><p>完整的表关系图如下：</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/08/20180808012303/student-score-course.png" alt="完整表关系图" title>                </div>                <div class="image-caption">完整表关系图</div>            </figure><p><br></p><p>DDL 命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表 student</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`idcard`</span> <span class="built_in">VARCHAR</span>(<span class="number">18</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">"北京"</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 course</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 score，并添加外键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`score`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">"0"</span>,</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">"0"</span>,</span><br><span class="line">  <span class="string">`grade`</span> <span class="built_in">FLOAT</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`student_id`</span>, <span class="string">`course_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_courseid`</span> (<span class="string">`course_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_courseid`</span></span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`course_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`course`</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_student_id`</span></span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`student_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`student`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>在实际开发当中使用 DDL 对表的编辑并不多，因为命令繁琐，在效率上，使用 DBMS 效率更高，但是 DDL 是学习 MySQL 数据库的根本之一，应该会写。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>到此 MySQL 系列文章的第一篇就结束了，里面大部分内容都是关于 MySQL 数据库的概念以及表的创建，非常枯燥，但又是初学 MySQL 所必须要懂的知识点，相信大家通过本节已经对 MySQL 有了一定的认识，那么下一篇将是重中之重，是在开发中经常使用的 DML 数据库操作语言，也就是我们平时所说的 SQL 语句，在此期待我们的下一篇 <a href="https://www.overtaking.top/2018/08/09/20180809115245/" target="_blank">《MySQL —— SQL 语句总结》</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 核心模块 tapable 解析</title>
      <link href="/2018/08/06/20180806184412/"/>
      <url>/2018/08/06/20180806184412/</url>
      
        <content type="html"><![CDATA[<img src="/2018/08/06/20180806184412/tapable.png" title="tapable"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，是对前端项目实现自动化和优化必不可少的工具，Webpack 的 <code>loader</code>（加载器）和 <code>plugin</code>（插件）是由 Webpack 开发者和社区开发者共同贡献的，而目前又没有比较系统的开发文档，想写加载器和插件必须要懂 Webpack 的原理，即看懂 Webpack 的源码，<code>tapable</code> 则是 Webpack 依赖的核心库，可以说不懂 <code>tapable</code> 就看不懂 Webpack 源码，所以本篇会对 <code>tapable</code> 提供的类进行解析和模拟。</p></blockquote><a id="more"></a><h2 id="tapable-介绍"><a href="#tapable-介绍" class="headerlink" title="tapable 介绍"></a>tapable 介绍</h2><blockquote class="pullquote success"><p>Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 <code>tapable</code>，Webpack 中最核心的，负责编译的 <code>Compiler</code> 和负责创建 <code>bundles</code> 的 <code>Compilation</code> 都是 <code>tapable</code> 构造函数的实例。</p></blockquote><p>打开 Webpack <code>4.0</code> 的源码中一定会看到下面这些以 <code>Sync</code>、<code>Async</code> 开头，以 <code>Hook</code> 结尾的方法，这些都是 <code>tapable</code> 核心库的类，为我们提供不同的事件流执行机制，我们称为 “钩子”。</p><figure class="highlight js"><figcaption><span>引入 tapable 如下</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  SyncHook,</span><br><span class="line">  SyncBailHook,</span><br><span class="line">  SyncWaterfallHook,</span><br><span class="line">  SyncLoopHook,</span><br><span class="line">  AsyncParallelHook,</span><br><span class="line">  AsyncParallelBailHook,</span><br><span class="line">  AsyncSeriesHook,</span><br><span class="line">  AsyncSeriesBailHook,</span><br><span class="line">  AsyncSeriesWaterfallHook</span><br><span class="line"> &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>上面的实现事件流机制的 “钩子” 大方向可以分为两个类别，“同步” 和 “异步”，“异步” 又分为两个类别，“并行” 和 “串行”，而 “同步” 的钩子都是串行的。</strong></em></p></blockquote><h2 id="Sync-类型的钩子"><a href="#Sync-类型的钩子" class="headerlink" title="Sync 类型的钩子"></a>Sync 类型的钩子</h2><h3 id="SyncHook"><a href="#SyncHook" class="headerlink" title="SyncHook"></a>SyncHook</h3><p><code>SyncHook</code> 为串行同步执行，不关心事件处理函数的返回值，在触发事件之后，会按照事件注册的先后顺序执行所有的事件处理函数。</p><figure class="highlight js"><figcaption><span>SyncHook 钩子的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> syncHook = <span class="keyword">new</span> SyncHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">syncHook.tap(<span class="string">'1'</span>, (name, age) =&gt; <span class="built_in">console</span>.log(<span class="string">'1'</span>, name, age));</span><br><span class="line">syncHook.tap(<span class="string">'2'</span>, (name, age) =&gt; <span class="built_in">console</span>.log(<span class="string">'2'</span>, name, age));</span><br><span class="line">syncHook.tap(<span class="string">'3'</span>, (name, age) =&gt; <span class="built_in">console</span>.log(<span class="string">'3'</span>, name, age));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，让监听函数执行</span></span><br><span class="line">syncHook.call(<span class="string">'panda'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 panda 18</span></span><br><span class="line"><span class="comment">// 2 panda 18</span></span><br><span class="line"><span class="comment">// 3 panda 18</span></span><br></pre></td></tr></table></figure><p>在 <code>tapable</code> 解构的 <code>SyncHook</code> 是一个类，注册事件需先创建实例，创建实例时支持传入一个数组，数组内存储事件触发时传入的参数，实例的 <code>tap</code> 方法用于注册事件，支持传入两个参数，第一个参数为事件名称，在 Webpack 中一般用于存储事件对应的插件名称（名字随意，只是起到注释作用）， 第二个参数为事件处理函数，函数参数为执行 <code>call</code> 方法触发事件时所传入的参数的形参。</p><figure class="highlight js"><figcaption><span>模拟 SyncHook 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">  &#125;</span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task);</span><br><span class="line">  &#125;</span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="comment">// 也可在参数不足时抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; <span class="keyword">this</span>.args.length) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'参数不足'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined</span></span><br><span class="line">    args = args.slice(<span class="number">0</span>, <span class="keyword">this</span>.args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次执行事件处理函数</span></span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function"><span class="params">task</span> =&gt;</span> task(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tasks</code> 数组用于存储事件处理函数，<code>call</code> 方法调用时传入参数超过创建 <code>SyncHook</code> 实例传入的数组长度时，多余参数可处理为 <code>undefined</code>，也可在参数不足时抛出异常，不灵活，后面的例子中就不再这样写了。</p><h3 id="SyncBailHook"><a href="#SyncBailHook" class="headerlink" title="SyncBailHook"></a>SyncBailHook</h3><p><code>SyncBailHook</code> 同样为串行同步执行，如果事件处理函数执行时有一个返回值不为空（即返回值为 <code>undefined</code>），则跳过剩下未执行的事件处理函数（如类的名字，意义在于保险）。</p><figure class="highlight js"><figcaption><span>SyncBailHook 钩子的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncBailHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> syncBailHook = <span class="keyword">new</span> SyncBailHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">syncBailHook.tap(<span class="string">'1'</span>, (name, age) =&gt; <span class="built_in">console</span>.log(<span class="string">'1'</span>, name, age));</span><br><span class="line"></span><br><span class="line">syncBailHook.tap(<span class="string">'2'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, name, age);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'2'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">syncBailHook.tap(<span class="string">'3'</span>, (name, age) =&gt; <span class="built_in">console</span>.log(<span class="string">'3'</span>, name, age));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，让监听函数执行</span></span><br><span class="line">syncBailHook.call(<span class="string">'panda'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 panda 18</span></span><br><span class="line"><span class="comment">// 2 panda 18</span></span><br></pre></td></tr></table></figure><p>通过上面的用法可以看出，<code>SyncHook</code> 和 <code>SyncBailHook</code> 在逻辑上只是 <code>call</code> 方法不同，导致事件的执行机制不同，对于后面其他的 “钩子”，也是 <code>call</code> 的区别，接下来实现 <code>SyncBailHook</code> 类。</p><figure class="highlight js"><figcaption><span>模拟 SyncBailHook 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncBailHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">  &#125;</span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task);</span><br><span class="line">  &#125;</span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="comment">// 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined</span></span><br><span class="line">    args = args.slice(<span class="number">0</span>, <span class="keyword">this</span>.args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次执行事件处理函数，如果返回值不为空，则停止向下执行</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, ret;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      ret = <span class="keyword">this</span>.tasks[i++](...args);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!ret);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码的 <code>call</code> 方法中，我们设置返回值为 <code>ret</code>，第一次执行后没有返回值则继续循环执行，如果有返回值则立即停止循环，即实现 “保险” 的功能。</p><h3 id="SyncWaterfallHook"><a href="#SyncWaterfallHook" class="headerlink" title="SyncWaterfallHook"></a>SyncWaterfallHook</h3><p><code>SyncWaterfallHook</code> 为串行同步执行，上一个事件处理函数的返回值作为参数传递给下一个事件处理函数，依次类推，正因如此，只有第一个事件处理函数的参数可以通过 <code>call</code> 传递，而 <code>call</code> 的返回值为最后一个事件处理函数的返回值。</p><figure class="highlight js"><figcaption><span>SyncWaterfallHook 钩子的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncWaterfallHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> syncWaterfallHook = <span class="keyword">new</span> SyncWaterfallHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">syncWaterfallHook.tap(<span class="string">'1'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>, name, age);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">syncWaterfallHook.tap(<span class="string">'2'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, data);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'2'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">syncWaterfallHook.tap(<span class="string">'3'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, data);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'3'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，让监听函数执行</span></span><br><span class="line"><span class="keyword">let</span> ret = syncWaterfallHook.call(<span class="string">'panda'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'call'</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 panda 18</span></span><br><span class="line"><span class="comment">// 2 1</span></span><br><span class="line"><span class="comment">// 3 2</span></span><br><span class="line"><span class="comment">// call 3</span></span><br></pre></td></tr></table></figure><p><code>SyncWaterfallHook</code> 名称中含有 “瀑布”，通过上面代码可以看出 “瀑布” 形象生动的描绘了事件处理函数执行的特点，与 <code>SyncHook</code> 和 <code>SyncBailHook</code> 的区别就在于事件处理函数返回结果的流动性，接下来看一下 <code>SyncWaterfallHook</code> 类的实现。</p><figure class="highlight js"><figcaption><span>模拟 SyncWaterfallHook 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncWaterfallHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">  &#125;</span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task);</span><br><span class="line">  &#125;</span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="comment">// 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined</span></span><br><span class="line">    args = args.slice(<span class="number">0</span>, <span class="keyword">this</span>.args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次执行事件处理函数，事件处理函数的返回值作为下一个事件处理函数的参数</span></span><br><span class="line">    <span class="keyword">const</span> [first, ...others] = <span class="keyword">this</span>.tasks;</span><br><span class="line">    <span class="keyword">return</span> others.reduce(<span class="function">(<span class="params">ret, task</span>) =&gt;</span> task(ret), first(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中 <code>call</code> 的逻辑是将存储事件处理函数的 <code>tasks</code> 拆成两部分，分别为第一个事件处理函数，和存储其余事件处理函数的数组，使用 <code>reduce</code> 进行归并，将第一个事件处理函数执行后的返回值作为归并的初始值，依次调用其余事件处理函数并传递上一次归并的返回值。</p><h3 id="SyncLoopHook"><a href="#SyncLoopHook" class="headerlink" title="SyncLoopHook"></a>SyncLoopHook</h3><p><code>SyncLoopHook</code> 为串行同步执行，事件处理函数返回 <code>true</code> 表示继续循环，即循环执行当前事件处理函数，返回 <code>undefined</code> 表示结束循环，<code>SyncLoopHook</code> 与 <code>SyncBailHook</code> 的循环不同，<code>SyncBailHook</code> 只决定是否继续向下执行后面的事件处理函数，而 <code>SyncLoopHook</code> 的循环是指循环执行每一个事件处理函数，直到返回 <code>undefined</code> 为止，才会继续向下执行其他事件处理函数，执行机制同理。</p><figure class="highlight js"><figcaption><span>SyncLoopHook 钩子的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncLoopHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> syncLoopHook = <span class="keyword">new</span> SyncLoopHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义辅助变量</span></span><br><span class="line"><span class="keyword">let</span> total1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> total2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">syncLoopHook.tap(<span class="string">'1'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>, name, age, total1);</span><br><span class="line">  <span class="keyword">return</span> total1++ <span class="xml"><span class="tag">&lt; <span class="attr">2</span> ? <span class="attr">true</span> <span class="attr">:</span> <span class="attr">undefined</span>;</span></span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">syncLoopHook.tap('2', (name, age) =&gt; &#123;</span></span><br><span class="line"><span class="xml">  console.log('2', name, age, total2);</span></span><br><span class="line"><span class="xml">  return total2++ <span class="tag">&lt; <span class="attr">2</span> ? <span class="attr">true</span> <span class="attr">:</span> <span class="attr">undefined</span>;</span></span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">syncLoopHook.tap('3', (name, age) =&gt; console.log('3', name, age));</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 触发事件，让监听函数执行</span></span><br><span class="line"><span class="xml">syncLoopHook.call('panda', 18);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 1 panda 18 0</span></span><br><span class="line"><span class="xml">// 1 panda 18 1</span></span><br><span class="line"><span class="xml">// 1 panda 18 2</span></span><br><span class="line"><span class="xml">// 2 panda 18 0</span></span><br><span class="line"><span class="xml">// 2 panda 18 1</span></span><br><span class="line"><span class="xml">// 2 panda 18 2</span></span><br><span class="line"><span class="xml">// 3 panda 18</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>通过上面的执行结果可以清楚的看到 <code>SyncLoopHook</code> 的执行机制，但有一点需要注意，返回值必须严格是 <code>true</code> 才会触发循环，多次执行当前事件处理函数，必须严格返回 <code>undefined</code>，才会结束循环，去执行后面的事件处理函数，如果事件处理函数的返回值不是 <code>true</code> 也不是 <code>undefined</code>，则会死循环。</strong></em></p></blockquote><p>在了解 <code>SyncLoopHook</code> 的执行机制以后，我们接下来看看 <code>SyncLoopHook</code> 的 <code>call</code> 方法是如何实现的。</p><figure class="highlight js"><figcaption><span>模拟 SyncLoopHook 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncLoopHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">  &#125;</span><br><span class="line">  tap(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task);</span><br><span class="line">  &#125;</span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    <span class="comment">// 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined</span></span><br><span class="line">    args = args.slice(<span class="number">0</span>, <span class="keyword">this</span>.args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次执行事件处理函数，如果返回值为 true，则继续执行当前事件处理函数</span></span><br><span class="line">    <span class="comment">// 直到返回 undefined，则继续向下执行其他事件处理函数</span></span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function"><span class="params">task</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> ret;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = <span class="keyword">this</span>.task(...args);</span><br><span class="line">      &#125; <span class="keyword">while</span> (ret === <span class="literal">true</span> || !(ret === <span class="literal">undefined</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中可以看到 <code>SyncLoopHook</code> 类 <code>call</code> 方法的实现更像是 <code>SyncHook</code> 和 <code>SyncBailHook</code> 的 <code>call</code> 方法的结合版，外层循环整个 <code>tasks</code> 事件处理函数队列，内层通过返回值进行循环，控制每一个事件处理函数的执行次数。</p><blockquote class="pullquote warning"><p><em><strong>注意：在 Sync 类型 “钩子” 下执行的插件都是顺序执行的，只能使用 <code>tab</code> 注册。</strong></em></p></blockquote><h2 id="Async-类型的钩子"><a href="#Async-类型的钩子" class="headerlink" title="Async 类型的钩子"></a>Async 类型的钩子</h2><blockquote class="pullquote info"><p><em><strong><code>Async</code> 类型可以使用 <code>tap</code>、<code>tapAsync</code> 和 <code>tapPromise</code> 注册不同类型的插件 “钩子”，分别通过 <code>call</code>、<code>callAsync</code> 和 <code>promise</code> 方法调用，我们下面会针对 <code>AsyncParallelHook</code> 和 <code>AsyncSeriesHook</code> 的 <code>async</code> 和 <code>promise</code> 两种方式分别介绍和模拟。</strong></em></p></blockquote><h3 id="AsyncParallelHook"><a href="#AsyncParallelHook" class="headerlink" title="AsyncParallelHook"></a>AsyncParallelHook</h3><p><code>AsyncParallelHook</code> 为异步并行执行，通过 <code>tapAsync</code> 注册的事件，通过 <code>callAsync</code> 触发，通过 <code>tapPromise</code> 注册的事件，通过 <code>promise</code> 触发（返回值可以调用 <code>then</code> 方法）。</p><h4 id="tapAsync-callAsync"><a href="#tapAsync-callAsync" class="headerlink" title="tapAsync/callAsync"></a>tapAsync/callAsync</h4><p><code>callAsync</code> 的最后一个参数为回调函数，在所有事件处理函数执行完毕后执行。</p><figure class="highlight js"><figcaption><span>AsyncParallelHook 钩子：tapAsync/callAsync 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncParallelHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> asyncParallelHook = <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'time'</span>);</span><br><span class="line">asyncParallelHook.tapAsync(<span class="string">'1'</span>, (name, age, done) =&gt; &#123;</span><br><span class="line">  settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    done();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelHook.tapAsync(<span class="string">'2'</span>, (name, age, done) =&gt; &#123;</span><br><span class="line">  settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    done();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelHook.tapAsync(<span class="string">'3'</span>, (name, age, done) =&gt; &#123;</span><br><span class="line">  settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    done();</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'time'</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，让监听函数执行</span></span><br><span class="line">asyncParallelHook.callAsync(<span class="string">'panda'</span>, <span class="number">18</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 panda 18 2018-08-07T10:38:32.675Z</span></span><br><span class="line"><span class="comment">// 2 panda 18 2018-08-07T10:38:33.674Z</span></span><br><span class="line"><span class="comment">// 3 panda 18 2018-08-07T10:38:34.674Z</span></span><br><span class="line"><span class="comment">// complete</span></span><br><span class="line"><span class="comment">// time: 3005.060ms</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><em><strong>异步并行是指，事件处理函数内三个定时器的异步操作最长时间为 <code>3s</code>，而三个事件处理函数执行完成总共用时接近 <code>3s</code>，所以三个事件处理函数是几乎同时执行的，不需等待。</strong></em></p></blockquote><p>所有 <code>tabAsync</code> 注册的事件处理函数最后一个参数都为一个回调函数 <code>done</code>，每个事件处理函数在异步代码执行完毕后调用 <code>done</code> 函数，则可以保证 <code>callAsync</code> 会在所有异步函数都执行完毕后执行，接下来看一看 <code>callAsync</code> 是如何实现的。</p><figure class="highlight js"><figcaption><span>模拟 AsyncParallelHook 类：tapAsync/callAsync</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncParallelHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">  &#125;</span><br><span class="line">  tabAsync(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task);</span><br><span class="line">  &#125;</span><br><span class="line">  callAsync(...args) &#123;</span><br><span class="line">    <span class="comment">// 先取出最后传入的回调函数</span></span><br><span class="line">    <span class="keyword">const</span> finalCallback = args.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined</span></span><br><span class="line">    args = args.slice(<span class="number">0</span>, <span class="keyword">this</span>.args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 i 变量和 done 函数</span></span><br><span class="line">    <span class="comment">// 每次执行检测 i 值和队列长度，决定是否执行 callAsync 的回调函数</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> done = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (++i === <span class="keyword">this</span>.tasks.length) &#123;</span><br><span class="line">        finalCallback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次执行事件处理函数</span></span><br><span class="line">    <span class="keyword">this</span>.tasks.forEach(<span class="function"><span class="params">task</span> =&gt;</span> task(...args, done));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>callAsync</code> 中，将最后一个参数（所有事件处理函数执行完毕后执行的回调）取出，并定义 <code>done</code> 函数，通过比较 <code>i</code> 和存储事件处理函数的数组 <code>tasks</code> 的 <code>length</code> 来确定回调是否执行，循环执行每一个事件处理函数并将 <code>done</code> 作为最后一个参数传入，所以每个事件处理函数内部的异步操作完成时，执行 <code>done</code> 就是为了检测是不是该执行 <code>callAsync</code> 的回调，当所有事件处理函数均执行完毕满足 <code>done</code> 函数内部 <code>i</code> 和 <code>length</code> 相等的条件时，则调用 <code>callAsync</code> 的回调。</p><h4 id="tapPromise-promise"><a href="#tapPromise-promise" class="headerlink" title="tapPromise/promise"></a>tapPromise/promise</h4><p>要使用 <code>tapPromise</code> 注册事件，对事件处理函数有一个要求，必须返回一个 Promise 实例，而 <code>promise</code> 方法也返回一个 Promise 实例，<code>callAsync</code> 的回调函数在 <code>promise</code> 方法中用 <code>then</code> 的方式代替。</p><figure class="highlight js"><figcaption><span>AsyncParallelHook 钩子：tapPromise/promise 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncParallelHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> asyncParallelHook = <span class="keyword">new</span> AsyncParallelHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'time'</span>);</span><br><span class="line">asyncParallelHook.tapPromise(<span class="string">'1'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'1'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      resolve(<span class="string">'1'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelHook.tapPromise(<span class="string">'2'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'2'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      resolve(<span class="string">'2'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelHook.tapPromise(<span class="string">'3'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'3'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      resolve(<span class="string">'3'</span>);</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(<span class="string">'time'</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，让监听函数执行</span></span><br><span class="line">asyncParallelHook.promise(<span class="string">'panda'</span>, <span class="number">18</span>).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 panda 18 2018-08-07T12:17:21.741Z</span></span><br><span class="line"><span class="comment">// 2 panda 18 2018-08-07T12:17:22.736Z</span></span><br><span class="line"><span class="comment">// 3 panda 18 2018-08-07T12:17:23.739Z</span></span><br><span class="line"><span class="comment">// time: 3006.542ms</span></span><br><span class="line"><span class="comment">// [ '1', '2', '3' ]</span></span><br></pre></td></tr></table></figure><p>上面每一个 <code>tapPromise</code> 注册事件的事件处理函数都返回一个 Promise 实例，并将返回值传入 <code>resolve</code> 方法，调用 <code>promise</code> 方法触发事件时，如果所有事件处理函数返回的 Promise 实例结果都成功，会将结果存储在数组中，并作为参数传递给 <code>promise</code> 的 <code>then</code> 方法中成功的回调，如果有一个失败就是将失败的结果返回作为参数传递给失败的回调。</p><figure class="highlight js"><figcaption><span>模拟 AsyncParallelHook 类 tapPromise/promise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncParallelHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">  &#125;</span><br><span class="line">  tapPromise(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task);</span><br><span class="line">  &#125;</span><br><span class="line">  promise(...args) &#123;</span><br><span class="line">    <span class="comment">// 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined</span></span><br><span class="line">    args = args.slice(<span class="number">0</span>, <span class="keyword">this</span>.args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有事件处理函数转换成 Promise 实例，并发执行所有的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(<span class="keyword">this</span>.tasks.map(<span class="function"><span class="params">task</span> =&gt;</span> task(...args)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实根据上面对于 <code>tapPromise</code> 和 <code>promise</code> 使用的描述就可以猜到，<code>promise</code> 方法的逻辑是通过 <code>Promise.all</code> 来实现的。</p><h3 id="AsyncSeriesHook"><a href="#AsyncSeriesHook" class="headerlink" title="AsyncSeriesHook"></a>AsyncSeriesHook</h3><p><code>AsyncSeriesHook</code> 为异步串行执行，与 <code>AsyncParallelHook</code> 相同，通过 <code>tapAsync</code> 注册的事件，通过 <code>callAsync</code> 触发，通过 <code>tapPromise</code> 注册的事件，通过 <code>promise</code> 触发，可以调用 <code>then</code> 方法。</p><h4 id="tapAsync-callAsync-1"><a href="#tapAsync-callAsync-1" class="headerlink" title="tapAsync/callAsync"></a>tapAsync/callAsync</h4><p>与 <code>AsyncParallelHook</code> 的 <code>callAsync</code> 方法类似，<code>AsyncSeriesHook</code> 的 <code>callAsync</code> 方法也是通过传入回调函数的方式，在所有事件处理函数执行完毕后执行 <code>callAsync</code> 的回调函数。</p><figure class="highlight js"><figcaption><span>AsyncSeriesHook 钩子：tapAsync/callAsync 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncSeriesHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> asyncSeriesHook = <span class="keyword">new</span> AsyncSeriesHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'time'</span>);</span><br><span class="line">asyncSeriesHook.tapAsync(<span class="string">'1'</span>, (name, age, next) =&gt; &#123;</span><br><span class="line">  settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    next();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncSeriesHook.tapAsync(<span class="string">'2'</span>, (name, age, next) =&gt; &#123;</span><br><span class="line">  settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    next();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncSeriesHook.tapAsync(<span class="string">'3'</span>, (name, age, next) =&gt; &#123;</span><br><span class="line">  settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'time'</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，让监听函数执行</span></span><br><span class="line">asyncSeriesHook.callAsync(<span class="string">'panda'</span>, <span class="number">18</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 panda 18 2018-08-07T14:40:52.896Z</span></span><br><span class="line"><span class="comment">// 2 panda 18 2018-08-07T14:40:54.901Z</span></span><br><span class="line"><span class="comment">// 3 panda 18 2018-08-07T14:40:57.901Z</span></span><br><span class="line"><span class="comment">// complete</span></span><br><span class="line"><span class="comment">// time: 6008.790ms</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><em><strong>异步串行是指，事件处理函数内三个定时器的异步执行时间分别为 <code>1s</code>、<code>2s</code> 和 <code>3s</code>，而三个事件处理函数执行完总共用时接近 <code>6s</code>，所以三个事件处理函数执行是需要排队的，必须一个一个执行，当前事件处理函数执行完才能执行下一个。</strong></em></p></blockquote><p><code>AsyncSeriesHook</code> 类的 <code>tabAsync</code> 方法注册的事件处理函数参数中的 <code>next</code> 可以与 <code>AsyncParallelHook</code> 类中 <code>tabAsync</code> 方法参数的 <code>done</code> 进行类比，同为回调函数，不同点在于 <code>AsyncSeriesHook</code> 与 <code>AsyncParallelHook</code> 的 <code>callAsync</code> 方法的 “并行” 和 “串行” 的实现方式。</p><figure class="highlight js"><figcaption><span>模拟 AsyncSeriesHook 类：tapAsync/callAsync</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSeriesHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">  &#125;</span><br><span class="line">  tabAsync(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task);</span><br><span class="line">  &#125;</span><br><span class="line">  callAsync(...args) &#123;</span><br><span class="line">    <span class="comment">// 先取出最后传入的回调函数</span></span><br><span class="line">    <span class="keyword">const</span> finalCallback = args.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined</span></span><br><span class="line">    args = args.slice(<span class="number">0</span>, <span class="keyword">this</span>.args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 i 变量和 next 函数，每次取出一个事件处理函数执行，并维护 i 的值</span></span><br><span class="line">    <span class="comment">// 直到所有事件处理函数都执行完，调用 callAsync 的回调</span></span><br><span class="line">    <span class="comment">// 如果事件处理函数中没有调用 next，则无法继续</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> task = <span class="keyword">this</span>.tasks[i++];</span><br><span class="line">      task ? task(...args, next) : finalCallback();</span><br><span class="line">    &#125;;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AsyncParallelHook</code> 是通过循环依次执行了所有的事件处理函数，<code>done</code> 方法只为了检测是否已经满足条件执行 <code>callAsync</code> 的回调，如果中间某个事件处理函数没有调用 <code>done</code>，只是不会调用 <code>callAsync</code> 的回调，但是所有的事件处理函数都执行了。</p><p>而 <code>AsyncSeriesHook</code> 的 <code>next</code> 执行机制更像 <code>Express</code> 和 <code>Koa</code> 中的中间件，在注册事件的回调中如果不调用 <code>next</code>，则在触发事件时会在没有调用 <code>next</code> 的事件处理函数的位置 “卡死”，即不会继续执行后面的事件处理函数，只有都调用 <code>next</code> 才能继续，而最后一个事件处理函数中调用 <code>next</code> 决定是否调用 <code>callAsync</code> 的回调。</p><h4 id="tapPromise-promise-1"><a href="#tapPromise-promise-1" class="headerlink" title="tapPromise/promise"></a>tapPromise/promise</h4><p>与 <code>AsyncParallelHook</code> 类似，<code>tapPromise</code> 注册事件的事件处理函数需要返回一个 Promise 实例，<code>promise</code> 方法最后也返回一个 Promise 实例。</p><figure class="highlight js"><figcaption><span>AsyncSeriesHook 钩子：tapPromise/promise 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncSeriesHook &#125; = <span class="built_in">require</span>(<span class="string">'tapable'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">let</span> asyncSeriesHook = <span class="keyword">new</span> AsyncSeriesHook([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'time'</span>);</span><br><span class="line">asyncSeriesHook.tapPromise(<span class="string">'1'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'1'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      resolve(<span class="string">'1'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncSeriesHook.tapPromise(<span class="string">'2'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'2'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      resolve(<span class="string">'2'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelHook.tapPromise(<span class="string">'3'</span>, (name, age) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    settimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'3'</span>, name, age, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      resolve(<span class="string">'3'</span>);</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(<span class="string">'time'</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件，让监听函数执行</span></span><br><span class="line">asyncSeriesHook.promise(<span class="string">'panda'</span>, <span class="number">18</span>).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 panda 18 2018-08-07T14:45:52.896Z</span></span><br><span class="line"><span class="comment">// 2 panda 18 2018-08-07T14:45:54.901Z</span></span><br><span class="line"><span class="comment">// 3 panda 18 2018-08-07T14:45:57.901Z</span></span><br><span class="line"><span class="comment">// time: 6014.291ms</span></span><br><span class="line"><span class="comment">// [ '1', '2', '3' ]</span></span><br></pre></td></tr></table></figure><p>分析上面的执行过程，所有的事件处理函数都返回了 Promise 的实例，如果想实现 “串行”，则需要让每一个返回的 Promise 实例都调用 <code>then</code>，并在 <code>then</code> 中执行下一个事件处理函数，这样就保证了只有上一个事件处理函数执行完后才会执行下一个。</p><figure class="highlight js"><figcaption><span>模拟 AsyncSeriesHook 类 tapPromise/promise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSeriesHook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">  &#125;</span><br><span class="line">  tapPromise(name, task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(task);</span><br><span class="line">  &#125;</span><br><span class="line">  promise(...args) &#123;</span><br><span class="line">    <span class="comment">// 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined</span></span><br><span class="line">    args = args.slice(<span class="number">0</span>, <span class="keyword">this</span>.args.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将每个事件处理函数执行并调用返回 Promise 实例的 then 方法</span></span><br><span class="line">    <span class="comment">// 让下一个事件处理函数在 then 方法成功的回调中执行</span></span><br><span class="line">    <span class="keyword">const</span> [first, ...others] = <span class="keyword">this</span>.tasks;</span><br><span class="line">    <span class="keyword">return</span> others.reduce(<span class="function">(<span class="params">promise, task</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> promise.then(<span class="function"><span class="params">()</span> =&gt;</span> task(...args));</span><br><span class="line">    &#125;, first(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 “串行” 是使用 <code>reduce</code> 归并来实现的，首先将存储所有事件处理函数的数组 <code>tasks</code> 解构成两部分，第一个事件处理函数和存储其他事件处理函数的数组 <code>others</code>，对 <code>others</code> 进行归并，将第一个事件处理函数执行后返回的 Promise 实例作为归并的初始值，这样在归并的过程中上一个值始终是上一个事件处理函数返回的 Promise 实例，可以直接调用 <code>then</code> 方法，并在 <code>then</code> 的回调中执行下一个事件处理函数，直到归并完成，将 <code>reduce</code> 最后返回的 Promise 实例作为 <code>promise</code> 方法的返回值，则实现 <code>promise</code> 方法执行后继续调用 <code>then</code> 来实现后续逻辑。</p><h2 id="对其他异步钩子补充"><a href="#对其他异步钩子补充" class="headerlink" title="对其他异步钩子补充"></a>对其他异步钩子补充</h2><p>在上面 <code>Async</code> 异步类型的 “钩子中”，我们只着重介绍了 “串行” 和 “并行”（<code>AsyncParallelHook</code> 和 <code>AsyncSeriesHook</code>）以及回调和 Promise 的两种注册和触发事件的方式，还有一些其他的具有一定特点的异步 “钩子” 我们并没有进行分析，因为他们的机制与同步对应的 “钩子” 非常的相似。</p><p><code>AsyncParallelBailHook</code> 和 <code>AsyncSeriesBailHook</code> 分别为异步 “并行” 和 “串行” 执行的 “钩子”，返回值不为 <code>undefined</code>，即有返回值，则立即停止向下执行其他事件处理函数，实现逻辑可结合 <code>AsyncParallelHook</code> 、<code>AsyncSeriesHook</code> 和 <code>SyncBailHook</code>。</p><p><code>AsyncSeriesWaterfallHook</code> 为异步 “串行” 执行的 “钩子”，上一个事件处理函数的返回值作为参数传递给下一个事件处理函数，实现逻辑可结合 <code>AsyncSeriesHook</code> 和 <code>SyncWaterfallHook</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 <code>tapable</code> 源码中，注册事件的方法 <code>tab</code>、<code>tapAsync</code>、<code>tapPromise</code> 和触发事件的方法 <code>call</code>、<code>callAsync</code>、<code>promise</code> 都是通过 <code>compile</code> 方法快速编译出来的，我们本文中这些方法的实现只是遵照了 <code>tapable</code> 库这些 “钩子” 的事件处理机制进行了模拟，以方便我们了解 <code>tapable</code>，为学习 Webpack 原理做了一个铺垫，在 Webpack 中，这些 “钩子” 的真正作用就是将通过配置文件读取的插件与插件、加载器与加载器之间进行连接，“并行” 或 “串行” 执行，相信在我们对 <code>tapable</code> 中这些 “钩子” 的事件机制有所了解之后，再重新学习 Webpack 的源码应该会有所头绪。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> Webpack </tag>
            
            <tag> Hooks </tag>
            
            <tag> tapable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 多进程和集群</title>
      <link href="/2018/07/27/20180727140233/"/>
      <url>/2018/07/27/20180727140233/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/27/20180727140233/multi-processing.png" title="多进程和集群"><p><br></p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><blockquote class="pullquote default"><p>“进程” 是计算机系统进行资源分配和调度的基本单位，我们可以理解为计算机每开启一个任务就会创建至少一个进程来处理，有时会创建多个，如 Chrome 浏览器的选项卡，其目的是为了防止一个进程挂掉而应用停止工作，而 “线程” 是程序执行流的最小单元，NodeJS 默认是单进程、单线程的，我们将这个进程称为主进程，也可以通过 <code>child_process</code> 模块创建子进程实现多进程，我们称这些子进程为 “工作进程”，并且归主进程管理，进程之间默认是不能通信的，且所有子进程执行任务都是异步的。</p></blockquote><a id="more"></a><h2 id="spawn-实现多进程"><a href="#spawn-实现多进程" class="headerlink" title="spawn 实现多进程"></a>spawn 实现多进程</h2><h3 id="spawn-创建子进程"><a href="#spawn-创建子进程" class="headerlink" title="spawn 创建子进程"></a>spawn 创建子进程</h3><p>在 NodeJS 中执行一个 JS 文件，如果想在这个文件中再同时（异步）执行另一个 JS 文件，可以使用 <code>child_process</code> 模块中的 <code>spawn</code> 来实现，<code>spawn</code> 可以帮助我们创建一个子进程，用法如下。</p><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process.js'</span>, <span class="string">'--port'</span>, <span class="string">'3000'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>) <span class="comment">// 指定子进程的当前工作目录</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现错误触发</span></span><br><span class="line">child.on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程退出触发</span></span><br><span class="line">child.on(<span class="string">'exit'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'exit'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程关闭触发</span></span><br><span class="line">child.on(<span class="string">'close'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'close'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// exit</span></span><br><span class="line"><span class="comment">// close</span></span><br></pre></td></tr></table></figure><p><code>spawn</code> 方法可以帮助我们创建一个子进程，这个子进程就是方法的返回值，<code>spawn</code> 接收以下几个参数：</p><ul><li>command：要运行的命令；</li><li>args：类型为数组，数组内第一项为文件名，后面项依次为执行文件的命令参数和值；</li><li>options：选项，类型为对象，用于指定子进程的当前工作目录和主进程、子进程的通信规则等，具体可查看 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options" target="_blank">官方文档</a>。</li></ul><p><code>error</code> 事件在子进程出错时触发，<code>exit</code> 事件在子进程退出时触发，<code>close</code> 事件在子进程关闭后触发，在子进程任务结束后 <code>exit</code> 一定会触发，<code>close</code> 不一定触发。</p><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印子进程执行 sub_process.js 文件的参数</span></span><br><span class="line"><span class="built_in">console</span>.log(process.argv);</span><br></pre></td></tr></table></figure><p>通过上面代码打印了子进程执行时的参数，但是我们发现主进程窗口并没有打印，我们希望的是子进程的信息可以反馈给主进程，要实现通信需要在创建子进程时在第三个参数 <code>options</code> 中配置 <code>stdio</code> 属性定义。</p><h3 id="spawn-定义输入、输出"><a href="#spawn-定义输入、输出" class="headerlink" title="spawn 定义输入、输出"></a>spawn 定义输入、输出</h3><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process.js'</span>, <span class="string">'--port'</span>, <span class="string">'3000'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>) <span class="comment">// 指定子进程的当前工作目录</span></span><br><span class="line">  <span class="comment">// stdin: [process.stdin, process.stdout, process.stderr]</span></span><br><span class="line">  stdio: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] <span class="comment">// 配置标准输入、标准输出、错误输出</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C:\Program Files\nodejs\node.exe,g:\process\test\sub_process.js,--port,3000</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用主进程的标准输出，输出 sub_process.js 文件执行的参数</span></span><br><span class="line">process.stdout.write(process.argv.toString());</span><br></pre></td></tr></table></figure><p>通过上面配置 <code>options</code> 的 <code>stdio</code> 值为数组，上面的两种写法作用相同，都表示子进程和主进程共用了主进程的标准输入、标准输出、和错误输出，实际上并没有实现主进程与子进程的通信，其中 <code>0</code> 和 <code>stdin</code> 代表标准输入，<code>1</code> 和 <code>stdout</code> 代表标准输出，<code>2</code> 和 <code>stderr</code> 代表错误输出。</p><p>上面这样的方式只要子进程执行 <code>sub_process.js</code> 就会在窗口输出，如果我们希望是否输出在主进程里面控制，即实现子进程与主进程的通信，看下面用法。</p><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process.js'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">  stdio: [<span class="string">'pipe'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.stdout.on(<span class="string">'data'</span>, data =&gt; <span class="built_in">console</span>.log(data.toString()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程执行 sub_process.js</span></span><br><span class="line">process.stdout.write(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure><p>上面将 <code>stdio</code> 内数组的值配置为 <code>pipe</code>（默认不写就是 <code>pipe</code>），则通过流的方式实现主进程和子进程的通信，通过子进程的标准输出（可写流）写入，在主进程通过子进程的标准输出通过 <code>data</code> 事件读取的流在输出到窗口（这种写法很少用），上面都只在主进程中开启了一个子进程，下面举一个开启多个进程的例子。</p><p>例子的场景是主进程开启两个子进程，先运行子进程 <code>1</code> 传递一些参数，子进程 <code>1</code> 将参数取出返还给主进程，主进程再把参数传递给子进程 <code>2</code>，通过子进程 <code>2</code> 将参数写入到文件 <code>param.txt</code> 中，这个过程不代表真实应用场景，主要目的是体会主进程和子进程的通信过程。</p><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child1 = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process_1.js'</span>, <span class="string">'--port'</span>, <span class="string">'3000'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child2 = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process_2.js'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取子进程 1 写入的内容，写入子进程 2</span></span><br><span class="line">child1.stdout.on(<span class="string">'data'</span>, data =&gt; child2.stdout.write(data.toString));</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process_1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 --port 和 3000</span></span><br><span class="line">process.argv.slice(<span class="number">2</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> process.stdout.write(item));</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process_2.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取主进程传递的参数并写入文件</span></span><br><span class="line">process.stdout.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  fs.writeFile(<span class="string">'param.txt'</span>, data, () =&gt; &#123;</span><br><span class="line">    process.exit();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有一点需要注意，在子进程 <code>2</code> 写入文件的时候，由于主进程不知道子进程 <code>2</code> 什么时候写完，所以主进程会卡住，需要子进程在写入完成后调用 <code>process.exit</code> 方法退出子进程，子进程退出并关闭后，主进程会随之关闭。</p><p>在我们给 <code>options</code> 配置 <code>stdio</code> 时，数组内其实可以对标准输入、标准输出和错误输出分开配置，默认数组内为 <code>pipe</code> 时代表三者都为 <code>pipe</code>，分别配置看下面案例。</p><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'spawn'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process.js'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">  stdio: [<span class="number">0</span>, <span class="string">'pipe'</span>, <span class="number">2</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'world'</span>);</span><br></pre></td></tr></table></figure><p>上面代码中对 <code>stderr</code> 实现了默认打印而不通信，对标准输入实现了通信，还有一种情况，如果希望子进程只是默默的执行任务，而在主进程命令窗口什么类型的输出都禁止，可以在数组中对应位置给定值 <code>ignore</code>，将上面案例修改如下。</p><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'spawn'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process.js'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">  stdio: [<span class="number">0</span>, <span class="string">'pipe'</span>, <span class="string">'ignore'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'world'</span>);</span><br></pre></td></tr></table></figure><p>这次我们发现无论标准输出和错误输出都没有生效，上面这些方式其实是不太方便的，因为输出有 <code>stdout</code> 和 <code>stderr</code>，在写法上没办法统一，可以通过下面的方式来统一。</p><h3 id="标准进程通信"><a href="#标准进程通信" class="headerlink" title="标准进程通信"></a>标准进程通信</h3><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'spawn'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process.js'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">  stdio: [<span class="number">0</span>, <span class="string">'pipe'</span>, <span class="string">'ignore'</span>, <span class="string">'ipc'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">'message'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回复消息给子进程</span></span><br><span class="line">  child.send(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 杀死子进程</span></span><br><span class="line">  <span class="comment">// process.kill(child.pid);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给主进程发送消息</span></span><br><span class="line">process.send(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收主进程回复的消息</span></span><br><span class="line">process.on(<span class="string">'message'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退出子进程</span></span><br><span class="line">  process.exit();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>这种方式被称为标准进程通信，通过给 <code>options</code> 的 <code>stdio</code> 数组配置 <code>ipc</code>，只要数组中存在 <code>ipc</code> 即可，一般放在数组开头或结尾，配置 <code>ipc</code> 后子进程通过调用自己的 <code>send</code> 方法发送消息给主进程，主进程中用子进程的 <code>message</code> 事件进行接收，也可以在主进程中接收消息的 <code>message</code> 事件的回调当中，通过子进程的 <code>send</code> 回复消息，并在子进程中用 <code>message</code> 事件进行接收，这样的编程方式比较统一，更贴近于开发者的意愿。</p><h3 id="退出和杀死子进程"><a href="#退出和杀死子进程" class="headerlink" title="退出和杀死子进程"></a>退出和杀死子进程</h3><p>上面代码中子进程在接收到主进程的消息时直接退出，也可以在子进程发送给消息给主进程时，主进程接收到消息直接杀死子进程，代码如下。</p><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'spawn'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process.js'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">  stdio: [<span class="number">0</span>, <span class="string">'pipe'</span>, <span class="string">'ignore'</span>, <span class="string">'ipc'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">'message'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 杀死子进程</span></span><br><span class="line">  process.kill(child.pid);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给主进程发送消息</span></span><br><span class="line">process.send(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><p>从上面代码我们可以看出，杀死子进程的方法为 <code>process.kill</code>，由于一个主进程可能有多个子进程，所以指定要杀死的子进程需要传入子进程的 <code>pid</code> 属性作为 <code>process.kill</code> 的参数。</p><blockquote class="pullquote warning"><p><em><strong>注意：退出子进程 <code>process.exit</code> 方法是在子进程中操作的，此时 <code>process</code> 代表子进程，杀死子进程 <code>process.kill</code> 是在主进程中操作的，此时 <code>process</code> 代表主进程。</strong></em></p></blockquote><h3 id="独立子进程"><a href="#独立子进程" class="headerlink" title="独立子进程"></a>独立子进程</h3><p>我们前面说过，<code>child_process</code> 模块创建的子进程是被主进程统一管理的，如果主进程挂了，所有的子进程也会受到影响一起挂掉，但其实使用多进程一方面为了提高处理任务的效率，另一方面也是为了当一个进程挂掉时还有其他进程可以继续工作，不至于整个应用挂掉，这样的例子非常多，比如 Chrome 浏览器的选项卡，比如 VSCode 编辑器运行时都会同时开启多个进程同时处理任务，其实在 <code>spawn</code> 创建子进程时，也可以实现子进程的独立，即子进程不再受主进程的控制和影响。</p><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'spawn'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>, [<span class="string">'sub_process.js'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">  stdio: <span class="string">'ignore'</span>,</span><br><span class="line">  detached: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与主进程断绝关系</span></span><br><span class="line">child.unref();</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fs.appendFileSync(<span class="string">'test.txt'</span>, <span class="string">'hello'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要想创建的子进程独立，需要在创建子进程时配置 <code>detached</code> 参数为 <code>true</code>，表示该子进程不受控制，还需调用子进程的 <code>unref</code> 方法与主进程断绝关系，但是仅仅这样子进程可能还是会受主进程的影响，要想子进程完全独立需要保证子进程一定不能和主进程共用标准输入、标准输出和错误输出，也就是 <code>stdio</code> 必须设置为 <code>ignore</code>，这也就代表着独立的子进程是不能和主进程进行标准进程通信，即不能设置 <code>ipc</code>。</p><h2 id="fork-实现多进程"><a href="#fork-实现多进程" class="headerlink" title="fork 实现多进程"></a>fork 实现多进程</h2><h3 id="fork-的使用"><a href="#fork-的使用" class="headerlink" title="fork 的使用"></a>fork 的使用</h3><p><code>fork</code> 也是 <code>child_process</code> 模块的一个方法，与 <code>spawn</code> 类似，是在 <code>spawn</code> 的基础上又做了一层封装，我们看一个 <code>fork</code> 使用的例子。</p><figure class="highlight js"><figcaption><span>文件：process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = fork(<span class="string">'sub_process.js'</span>, [<span class="string">'--port'</span>, <span class="string">'3000'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">  silent: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.send(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收主进程发来的消息</span></span><br><span class="line">process.on(<span class="string">'message'</span>, data =&gt; <span class="built_in">console</span>.log(data));</span><br></pre></td></tr></table></figure><p><code>fork</code> 的用法与 <code>spawn</code> 相比有所改变，第一个参数是子进程执行文件的名称，第二个参数为数组，存储执行时的参数和值，第三个参数为 <code>options</code>，其中使用 <code>slilent</code> 属性替代了 <code>spawn</code> 的 <code>stdio</code>，当 <code>silent</code> 为 <code>true</code> 时，此时主进程与子进程的所有非标准通信的操作都不会生效，包括标准输入、标准输出和错误输出，当设为 <code>false</code> 时可正常输出，返回值依然为一个子进程。</p><blockquote class="pullquote info"><p><em><strong><code>fork</code> 创建的子进程可以直接通过 <code>send</code> 方法和监听 <code>message</code> 事件与主进程进行通信。</strong></em></p></blockquote><h3 id="fork-的原理"><a href="#fork-的原理" class="headerlink" title="fork 的原理"></a>fork 的原理</h3><p>其实 <code>fork</code> 的原理非常简单，只是在子进程模块 <code>child_process</code> 上挂了一个 <code>fork</code> 方法，而在该方法内调用 <code>spawn</code> 并将 <code>spawn</code> 返回的子进程作为返回值返回，下面进行简易实现。</p><figure class="highlight js"><figcaption><span>文件：fork.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装原理</span></span><br><span class="line">childProcess.fork = <span class="function"><span class="keyword">function</span>(<span class="params">modulePath, args, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stdio = options.silent ?</span><br><span class="line">    [<span class="string">'ignore'</span>, <span class="string">'ignore'</span>, <span class="string">'ignore'</span>, <span class="string">'ipc'</span>] :</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'ipc'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> childProcess.spawn(<span class="string">'node'</span>, [modulePath, ...args], &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    stdio</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">const</span> child = fork(<span class="string">'sub_process.js'</span>, [<span class="string">'--port'</span>, <span class="string">'3000'</span>], &#123;</span><br><span class="line">  cwd: path.join(__dirname, <span class="string">'test'</span>),</span><br><span class="line">  silent: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向子进程发送消息</span></span><br><span class="line">child.send(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：&#126;test/sub_process.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收主进程发来的消息</span></span><br><span class="line">process.on(<span class="string">'message'</span>, data =&gt; <span class="built_in">console</span>.log(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p><code>spawn</code> 中的有一些 <code>fork</code> 没有传的参数（如使用 <code>node</code> 执行文件），都在内部调用 <code>spawn</code> 时传递默认值或将默认参数与 <code>fork</code> 传入的参数进行整合，着重处理了 <code>spawn</code> 没有的参数 <code>silent</code>，其实就是处理成了 <code>spawn</code> 的 <code>stdio</code> 参数两种极端的情况（默认使用 <code>ipc</code> 通信），封装 <code>fork</code> 就是让我们能更方便的创建子进程，可以更少的传参。</p><h2 id="execFile-和-exec-实现多进程"><a href="#execFile-和-exec-实现多进程" class="headerlink" title="execFile 和 exec 实现多进程"></a>execFile 和 exec 实现多进程</h2><p><code>execFile</code> 和 <code>exec</code> 是 <code>child_process</code> 模块的两个方法，<code>execFile</code> 是基于 <code>spawn</code> 封装的，而 <code>exec</code> 是基于 <code>execFile</code> 封装的，这两个方法用法大同小异，<code>execFile</code> 可以直接创建子进程进行文件操作，而 <code>exec</code> 可以直接开启子进程执行命令，常见的应用场景如 <code>http-server</code> 以及 <code>weboack-dev-server</code> 等命令行工具在启动本地服务时自动打开浏览器。</p><figure class="highlight js"><figcaption><span>execFile 和 exec</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execFile, exec &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> execFileChild = execFile(</span><br><span class="line">  <span class="string">'node'</span>,</span><br><span class="line">  [<span class="string">'--version'</span>],</span><br><span class="line">  (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">    <span class="built_in">console</span>.log(stdout);</span><br><span class="line">    <span class="built_in">console</span>.log(stderr);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> execChild = exec(</span><br><span class="line">  <span class="string">'node --version'</span>,</span><br><span class="line">  (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(stdout);</span><br><span class="line">    <span class="built_in">console</span>.log(stderr);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>exec</code> 与 <code>execFile</code> 的区别在于传参，<code>execFile</code> 第一个参数为文件的可执行路径或命令，第二个参数为命令的参数集合（数组），第三个参数为 <code>options</code>，最后一个参数为回调函数，回调函数的形参为错误、标准输出和错误输出。</p><p><code>exec</code> 在传参上将 <code>execFile</code> 的前两个参数进行了整合，也就是命令与命令参数拼接成字符串作为第一参数，后面的参数都与 <code>execFile</code> 相同。</p><h2 id="cluster-集群"><a href="#cluster-集群" class="headerlink" title="cluster 集群"></a>cluster 集群</h2><blockquote class="pullquote primary"><p>开启进程需要消耗内存，所以开启进程的数量要适合，合理运用多进程可以大大提高效率，如 Webpack 对资源进行打包，就开启了多个进程同时进行，大大提高了打包速度，集群也是多进程重要的应用之一，用多个进程同时监听同一个服务，一般开启进程的数量跟 CPU 核数相同为好，此时多个进程监听的服务会根据请求压力分流处理，也可以通过设置每个子进程处理请求的数量来实现 “负载均衡”。</p></blockquote><h3 id="使用-ipc-实现集群"><a href="#使用-ipc-实现集群" class="headerlink" title="使用 ipc 实现集群"></a>使用 ipc 实现集群</h3><p><code>ipc</code> 标准进程通信使用 <code>send</code> 方法发送消息时第二个参数支持传入一个服务，必须是 <code>http</code> 服务或者 <code>tcp</code> 服务，子进程通过 <code>message</code> 事件进行接收，回调的参数分别对应发送的参数，即第一个参数为消息，第二个参数为服务，我们就可以在子进程创建服务并对主进程的服务进行监听和操作（<code>listen</code> 除了可以监听端口号也可以监听服务），便实现了集群，代码如下。</p><figure class="highlight js"><figcaption><span>文件：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>); <span class="comment">// os 模块用于获取系统信息</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = rquire(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">res, req</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">'hello'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 CPU 个数创建子进程</span></span><br><span class="line">os.cpus().forEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fork(<span class="string">'child_server.js'</span>, &#123;</span><br><span class="line">    cwd: path.join(__dirname);</span><br><span class="line">  &#125;).send(<span class="string">'server'</span>, server);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：child_server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收来自主进程发来的服务</span></span><br><span class="line">process.on(<span class="string">'message'</span>, (data, server) =&gt; &#123;</span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">`child<span class="subst">$&#123;process.pid&#125;</span>`</span>);</span><br><span class="line">  &#125;).listen(server); <span class="comment">// 子进程共用主进程的服务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中由主进程处理的请求会返回 <code>hello</code>，由子进程处理的请求会返回 <code>child</code> 加进程的 <code>pid</code> 组成的字符串。</p><h3 id="使用-cluster-实现集群"><a href="#使用-cluster-实现集群" class="headerlink" title="使用 cluster 实现集群"></a>使用 cluster 实现集群</h3><p><code>cluster</code> 模块是 NodeJS 提供的用来实现集群的，他将 <code>child_process</code> 创建子进程的方法集成进去，实现方式要比使用 <code>ipc</code> 更简洁。</p><figure class="highlight js"><figcaption><span>文件：cluster.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前执行的进程是否为主进程，为主进程则创建子进程，否则用子进程监听服务</span></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="comment">// 创建子进程</span></span><br><span class="line">  os.cpus().forEach(<span class="function"><span class="params">()</span> =&gt;</span> cluster.fork());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 创建并监听服务</span></span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">`child<span class="subst">$&#123;process.pid&#125;</span>`</span>);</span><br><span class="line">  &#125;).listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码既会执行 <code>if</code> 又会执行 <code>else</code>，这看似很奇怪，但其实不是在同一次执行的，主进程执行时会通过 <code>cluster.fork</code> 创建子进程，当子进程被创建会将该文件再次执行，此时则会执行 <code>else</code> 中对服务的监听，还有另一种用法将主进程和子进程执行的代码拆分开，逻辑更清晰，用法如下。</p><figure class="highlight js"><figcaption><span>文件：cluster.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置子进程读取文件的路径</span></span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">  exec: path.join(__dirname, <span class="string">'cluster-server.js'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子进程</span></span><br><span class="line">os.cpus().forEach(<span class="function"><span class="params">()</span> =&gt;</span> cluster.fork());</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：cluster-server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并监听服务</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">`child<span class="subst">$&#123;process.pid&#125;</span>`</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过 <code>cluster.setupMaster</code> 设置子进程执行文件以后，就可以将主进程和子进程的逻辑拆分开，在实际的开发中这样的方式也是最常用的，耦合度低，可读性好，更符合开发的原则。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>本篇着重的介绍了 NodeJS 多进程的实现方式以及集群的使用，之所以在开头长篇大论的介绍 <code>spawn</code>，是因为其他的所有跟多进程相关的方法包括 <code>fork</code>、<code>exec</code> 等，以及模块 <code>cluster</code> 都是基于 <code>spawn</code> 的封装，如果对 <code>spawn</code> 足够了解，其他的也不在话下，希望大家通过这篇可以在 NodeJS 多进程相关的开发中起到一个 “路标” 的作用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> process </tag>
            
            <tag> Cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack —— tree-staking 解析</title>
      <link href="/2018/07/26/20180726122146/"/>
      <url>/2018/07/26/20180726122146/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/26/20180726122146/ast-tree-shaking.png" title="tree-staking"><p><br></p><h2 id="tree-shaking-简介"><a href="#tree-shaking-简介" class="headerlink" title="tree-shaking 简介"></a>tree-shaking 简介</h2><blockquote class="pullquote info"><p><code>tree-shaking</code> 是 <code>Webpack 2</code> 后续版本的优化功能，顾名思义，就是将多余的代码给 “摇晃” 掉，在开发中我们经常使用一些第三方库，而这些第三方库只使用了这个库的一部门功能或代码，未使用的代码也要被打包进来，这样出口文件会非常大，<code>tree-shaking</code> 帮我们解决了这个问题，它可以将各个模块中没有使用的方法过滤掉，只对有效代码进行打包。</p></blockquote><a id="more"></a><h2 id="AST-语法树分析"><a href="#AST-语法树分析" class="headerlink" title="AST 语法树分析"></a>AST 语法树分析</h2><p>假设我们现在使用了 ElementUI 库的两个组件，通常会使用解构赋值来引入。</p><figure class="highlight js"><figcaption><span>优化前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button, Alert &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br></pre></td></tr></table></figure><p>这样引用资源， Webpack 在打包的时候会找到 <code>element-ui</code> 并把里面所有的代码全部打包到出口文件，我们只使用了两个组件，全部打包不是我们所希望的，<code>tree-shaking</code> 是通过在 Webpack 中配置 <code>babel-plugin-import</code> 插件来实现的，它可以将解构的代码转换成下面的形式。</p><figure class="highlight js"><figcaption><span>优化后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'element-ui/lib/button'</span>;</span><br><span class="line"><span class="keyword">import</span> Alert <span class="keyword">from</span> <span class="string">'element-ui/lib/Alert'</span>;</span><br></pre></td></tr></table></figure><p>转化后会去 <code>node_modules</code> 中的 <code>element-ui</code> 模块找到 <code>Button</code> 和 <code>Alert</code> 两个组件对应的文件，并打包到出口文件中。</p><p>通过上面的转换可以看出，其实 <code>tree-shaking</code> 的实现原理是通过改变 AST 语法树的结构来实现的，如果不了解抽象语法树可以参考 <a href="https://www.overtaking.top/2018/07/25/20180725130233/" target="_blank">AST 抽象语法树</a>，我们可以通过在线转换网站 <a href="http://esprima.org/demo/parse.html" target="_blank">http://esprima.org/demo/parse.html</a> 将 JS 代码装换成 AST 语法树。</p><figure class="highlight json"><figcaption><span>优化前的 AST 语法树</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="attr">"body"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"ImportDeclaration"</span>,</span><br><span class="line">      <span class="attr">"specifiers"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"ImportSpecifier"</span>,</span><br><span class="line">          <span class="attr">"local"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Button"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"imported"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Button"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"ImportSpecifier"</span>,</span><br><span class="line">          <span class="attr">"local"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Alert"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"imported"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Alert"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"source"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Literal"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="attr">"raw"</span>: <span class="string">"\"element-ui\""</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><figcaption><span>优化后的 AST 语法树</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="attr">"body"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"ImportDeclaration"</span>,</span><br><span class="line">      <span class="attr">"specifiers"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"ImportDefaultSpecifier"</span>,</span><br><span class="line">          <span class="attr">"local"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Button"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"source"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Literal"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"element-ui/lib/button"</span>,</span><br><span class="line">        <span class="attr">"raw"</span>: <span class="string">"\"element-ui/lib/button\""</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"ImportDeclaration"</span>,</span><br><span class="line">      <span class="attr">"specifiers"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"ImportDefaultSpecifier"</span>,</span><br><span class="line">          <span class="attr">"local"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Alert"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"source"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Literal"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"element-ui/lib/Alert"</span>,</span><br><span class="line">        <span class="attr">"raw"</span>: <span class="string">"\"element-ui/lib/Alert\""</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的语法树对比，可以看出在优化前 <code>body</code> 里面只有一个对象，使用的组件信息存在 <code>specifiers</code> 里，<code>source</code> 指向了 <code>element-ui</code>，而在优化后，将两个组件分别拆成了两个对象存在 <code>body</code> 中，每个对象的的 <code>specifiers</code> 只存储一个组件，并在 <code>source</code> 里面指向了当前组件对应的路径。</p><h2 id="模拟-tree-staking"><a href="#模拟-tree-staking" class="headerlink" title="模拟 tree-staking"></a>模拟 tree-staking</h2><p>既然我们已经清楚要修改语法树的位置，下面就使用 AST 来模拟 <code>tree-shaking</code> 功能，对语法树的操作是依赖于 <code>babel-core</code> 和 <code>babel-types</code> 两个核心模块的，下面先安装依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-types</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：babel-plugin-my-import.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">const</span> types = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">`import &#123; Button, Alert &#125; from 'element-ui'`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> importPlugin = &#123;</span><br><span class="line">  visitor: &#123;</span><br><span class="line">    ImportDeclaration(path) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = path.node;</span><br><span class="line">      <span class="keyword">let</span> source = node.source.value;</span><br><span class="line">      <span class="keyword">let</span> specifiers = node.specifiers;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出</span></span><br><span class="line">      <span class="keyword">if</span> (!types.isImportDefaultSpecifier(specifiers[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="comment">// 如果不是默认导出，则需要转换</span></span><br><span class="line">        specifiers = specifiers.map(<span class="function"><span class="params">specifier</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 数组内容：当前默认导出的标识、从哪里导入</span></span><br><span class="line">          <span class="keyword">return</span> types.importDeclaration(</span><br><span class="line">            [types.importDefaultSpecifier(specifier.local)],</span><br><span class="line">            types.stringLiteral(</span><br><span class="line">              <span class="string">`<span class="subst">$&#123;source&#125;</span>/lib/<span class="subst">$&#123;specifier.local.name.toLowerCase()&#125;</span>`</span></span><br><span class="line">            )</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换树结构</span></span><br><span class="line">        path.replaceWithMultiple(specifiers);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = babel.transform(code, &#123;</span><br><span class="line">  plugins: [importPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result.code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// import Button from 'element-ui/lib/button';</span></span><br><span class="line"><span class="comment">// import Alert from 'element-ui/lib/alert';</span></span><br></pre></td></tr></table></figure><p>通过上面的代码可以发现我们使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块的核心方法对语法书进行了遍历、修改和替换，更详细的 API 可以查看 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank">https://github.com/babel/babel/tree/6.x/packages/babel-types</a>。</p><h2 id="结合-Webpack-使用插件"><a href="#结合-Webpack-使用插件" class="headerlink" title="结合 Webpack 使用插件"></a>结合 Webpack 使用插件</h2><p>前面只是验证了 <code>tree-shaking</code> 中 JS 语法的转换过程，接下来将上面的代码转换成插件配合 Webpack 使用，来彻底感受 <code>tree-shaking</code> 的工作过程。</p><figure class="highlight js"><figcaption><span>文件：&#126;node_modules/babel-plugin-my-import.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">const</span> types = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> importPlugin = &#123;</span><br><span class="line">  visitor: &#123;</span><br><span class="line">    ImportDeclaration(path) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = path.node;</span><br><span class="line">      <span class="keyword">let</span> source = node.source.value;</span><br><span class="line">      <span class="keyword">let</span> specifiers = node.specifiers;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出</span></span><br><span class="line">      <span class="keyword">if</span> (!types.isImportDefaultSpecifier(specifiers[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="comment">// 如果不是默认导出，则需要转换</span></span><br><span class="line">        specifiers = specifiers.map(<span class="function"><span class="params">specifier</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 数组内容：当前默认导出的标识、从哪里导入</span></span><br><span class="line">          <span class="keyword">return</span> types.importDeclaration(</span><br><span class="line">            [types.importDefaultSpecifier(specifier.local)],</span><br><span class="line">            types.stringLiteral(</span><br><span class="line">              <span class="string">`<span class="subst">$&#123;source&#125;</span>/lib/<span class="subst">$&#123;specifier.local.name.toLowerCase()&#125;</span>`</span></span><br><span class="line">            )</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换树解构</span></span><br><span class="line">        path.replaceWithMultiple(specifiers);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = importPlugin;</span><br></pre></td></tr></table></figure><p>上面删掉了多余的测试代码，将模块中的 <code>importPlugin</code> 插件导出，并把 <code>babel-plugin-my-import.js</code> 移入了 <code>node_modules</code> 当中。</p><p><strong>接下来安装需要的依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli babel-loader babel-presets-env</span><br><span class="line">npm install vue element-ui --save</span><br></pre></td></tr></table></figure><p>安装完依赖，写一个要编译的文件，使用 Webpack 进行打包，查看使用插件前和使用插件后出口文件的大小。</p><figure class="highlight js"><figcaption><span>文件：import.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Alert &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br></pre></td></tr></table></figure><p>下面来写一个简单的 Webpack 配置文件。</p><figure class="highlight js"><figcaption><span>文件：webpcak.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'import.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: __dirname</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [</span><br><span class="line">            <span class="string">'env'</span>,</span><br><span class="line">          ],</span><br><span class="line">          plugins: [</span><br><span class="line">            <span class="comment">// 插件：不使用插件打包注释掉该行即可</span></span><br><span class="line">            [<span class="string">'my-import'</span>, &#123; <span class="attr">libararyName</span>: <span class="string">'element-ui'</span> &#125;]</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了防止 <code>babel</code> 相关的依赖升级 <code>7.0</code> 后出现一些问题导致 Webpack 无法启动，再此贴出 <code>package.json</code> 文件，按照对应版本下载依赖保证上面 Webpack 配置生效。</p><figure class="highlight json"><figcaption><span>文件：package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"ast-lesson"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"tree-staking"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^7.1.5"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-env"</span>: <span class="string">"^1.7.0"</span>,</span><br><span class="line">    <span class="attr">"babel-types"</span>: <span class="string">"^6.26.0"</span>,</span><br><span class="line">    <span class="attr">"escodegen"</span>: <span class="string">"^1.10.0"</span>,</span><br><span class="line">    <span class="attr">"esprima"</span>: <span class="string">"^4.0.0"</span>,</span><br><span class="line">    <span class="attr">"estraverse"</span>: <span class="string">"^4.2.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.16.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.0.8"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.5.17"</span>,</span><br><span class="line">    <span class="attr">"element-ui"</span>: <span class="string">"^2.4.6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比使用插件前后的出口文件"><a href="#对比使用插件前后的出口文件" class="headerlink" title="对比使用插件前后的出口文件"></a>对比使用插件前后的出口文件</h2><p>接下来分别在使用插件和不使用插件时执行打包命令，查看出口文件 <code>bondle.js</code> 的大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>使用 <code>babel-plugin-my-import</code> 前：</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/26/20180726122146/before-babel-plugin.jpg" alt="使用 tree-staking 之前" title>                </div>                <div class="image-caption">使用 tree-staking 之前</div>            </figure><p><br></p><p>使用 <code>babel-plugin-my-import</code> 后：</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/26/20180726122146/after-babel-plugin.jpg" alt="使用 tree-staking 之后" title>                </div>                <div class="image-caption">使用 tree-staking 之后</div>            </figure><p><br></p><blockquote class="pullquote success"><p>通过对比，可以看到使用 <code>tree-shaking</code> 即我们自己实现的 <code>babel-plugin-my-import</code> 插件后，打包的出口文件大大减小，其原因是将引入第三方库没有使用的代码全都过滤掉了，只打包了有效代码。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote default"><p>上面对 Webpack 的 <code>tree-shaking</code> 进行了分析，并模拟 <code>babel-plugin-import</code> 简易的实现了一版 <code>tree-shaking</code> 的优化插件，这个过程中相信大家已经了解了 <code>tree-shaking</code> 的原理以及实现类似插件的思路，并已经具备了开发类似插件的基本条件，最后还有一点需要补充，<code>tree-shaking</code> 优化的方式是根据 ES6 语法 <code>import</code> “静态” 引入的特性实现的，如果要说 <code>tree-shaking</code> 很强大，还不如说 ES6 模块化规范 “静态” 引入的特性强大，正由于是基于 “静态” 引入，所以目前 <code>tree-shaking</code> 只支持遍历一层 <code>import</code> 关键字。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> Webpack </tag>
            
            <tag> Babel </tag>
            
            <tag> AST </tag>
            
            <tag> tree-staking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AST 抽象语法树</title>
      <link href="/2018/07/25/20180725130233/"/>
      <url>/2018/07/25/20180725130233/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/25/20180725130233/ast.png" title="AST"><p><br></p><h2 id="AST-抽象语法树简介"><a href="#AST-抽象语法树简介" class="headerlink" title="AST 抽象语法树简介"></a>AST 抽象语法树简介</h2><blockquote class="pullquote default"><p>AST（Abstract Syntax Tree）是源代码的抽象语法结构树状表现形式，Webpack、ESLint、JSX、TypeScript 的编译和模块化规则之间的转化都是通过 AST 来实现对代码的检查、分析以及编译等操作。</p></blockquote><a id="more"></a><h2 id="JavaScript-语法的-AST-语法树"><a href="#JavaScript-语法的-AST-语法树" class="headerlink" title="JavaScript 语法的 AST 语法树"></a>JavaScript 语法的 AST 语法树</h2><p>JavaScript 中想要使用 AST 进行开发，要知道抽象成语法树之后的结构是什么，里面的字段名称都代表什么含义以及遍历的规则，可以通过 <a href="http://esprima.org/demo/parse.html" target="_blank">http://esprima.org/demo/parse.html</a> 来实现 JavaScript 语法的在线转换。</p><p>通过在线编译工具，可以将 <code>function fn(a, b) {}</code> 编译为下面的结构。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="attr">"body"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"fn"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"params"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"a"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"b"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"body"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"BlockStatement"</span>,</span><br><span class="line">        <span class="attr">"body"</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"generator"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"expression"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"async"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"sourceType"</span>: <span class="string">"script"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>将 JavaScript 语法编译成抽象语法树后，需要对它进行遍历、修该并重新编译，遍历树结构的过程为 “先序深度优先”。</p></blockquote><h2 id="esprima、estraverse-和-escodegen"><a href="#esprima、estraverse-和-escodegen" class="headerlink" title="esprima、estraverse 和 escodegen"></a>esprima、estraverse 和 escodegen</h2><p><code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 模块是操作 AST 的三个重要模块，也是实现 <code>babel</code> 的核心依赖，下面是分别介绍三个模块的作用。</p><h3 id="esprima-将-JS-转换成-AST"><a href="#esprima-将-JS-转换成-AST" class="headerlink" title="esprima 将 JS 转换成 AST"></a>esprima 将 JS 转换成 AST</h3><p><strong>esprima 模块的用法如下：</strong></p><figure class="highlight js"><figcaption><span>文件：esprima-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">'function fn() &#123;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成语法树</span></span><br><span class="line"><span class="keyword">let</span> tree = esprima.parseScript(code);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Script &#123;</span></span><br><span class="line"><span class="comment">//   type: 'Program',</span></span><br><span class="line"><span class="comment">//   body:</span></span><br><span class="line"><span class="comment">//   [ FunctionDeclaration &#123;</span></span><br><span class="line"><span class="comment">//     type: 'FunctionDeclaration',</span></span><br><span class="line"><span class="comment">//     id: [Identifier],</span></span><br><span class="line"><span class="comment">//     params: [],</span></span><br><span class="line"><span class="comment">//     body: [BlockStatement],</span></span><br><span class="line"><span class="comment">//     generator: false,</span></span><br><span class="line"><span class="comment">//     expression: false,</span></span><br><span class="line"><span class="comment">//     async: false &#125; ],</span></span><br><span class="line"><span class="comment">//   sourceType: 'script' &#125;</span></span><br></pre></td></tr></table></figure><p>通过上面的案例可以看出，通过 <code>esprima</code> 模块的 <code>parseScript</code> 方法将 JS 代码块转换成语法树，代码块需要转换成字符串，也可以通过 <code>parseModule</code> 方法转换一个模块。</p><h3 id="estraverse-遍历和修改-AST"><a href="#estraverse-遍历和修改-AST" class="headerlink" title="estraverse 遍历和修改 AST"></a>estraverse 遍历和修改 AST</h3><p><strong>查看遍历过程：</strong></p><figure class="highlight js"><figcaption><span>文件：estraverse-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>);</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">'estraverse'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">'function fn() &#123;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历语法树</span></span><br><span class="line">estraverse.traverse(esprima.parseScript(code), &#123;</span><br><span class="line">  enter(node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'enter'</span>, node.type);</span><br><span class="line">  &#125;,</span><br><span class="line">  leave() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'leave'</span>, node.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// enter Program</span></span><br><span class="line"><span class="comment">// enter FunctionDeclaration</span></span><br><span class="line"><span class="comment">// enter Identifier</span></span><br><span class="line"><span class="comment">// leave Identifier</span></span><br><span class="line"><span class="comment">// enter BlockStatement</span></span><br><span class="line"><span class="comment">// leave BlockStatement</span></span><br><span class="line"><span class="comment">// leave FunctionDeclaration</span></span><br><span class="line"><span class="comment">// leave Program</span></span><br></pre></td></tr></table></figure><p>上面代码通过 <code>estraverse</code> 模块的 <code>traverse</code> 方法将 <code>esprima</code> 模块转换的 AST 进行了遍历，并打印了所有的 <code>type</code> 属性并打印，每含有一个 <code>type</code> 属性的对象被叫做一个节点，修改是获取对应的类型并修改该节点中的属性即可。</p><blockquote class="pullquote info"><p>其实深度遍历 AST 就是在遍历每一层的 <code>type</code> 属性，所以遍历会分为两个阶段，进入阶段和离开阶段，在 <code>estraverse</code> 的 <code>traverse</code> 方法中分别用参数指定的 <code>entry</code> 和 <code>leave</code> 两个函数监听，但是我们一般只使用 <code>entry</code>。</p></blockquote><h3 id="escodegen-将-AST-转换成-JS"><a href="#escodegen-将-AST-转换成-JS" class="headerlink" title="escodegen 将 AST 转换成 JS"></a>escodegen 将 AST 转换成 JS</h3><p>下面的案例是一个段 JS 代码块被转换成 AST，并将遍历、修改后的 AST 重新转换成 JS 的全过程。</p><figure class="highlight js"><figcaption><span>文件：escodegen-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>);</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">'estraverse'</span>);</span><br><span class="line"><span class="keyword">const</span> escodegen = <span class="built_in">require</span>(<span class="string">'escodegen'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">'function fn() &#123;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成语法树</span></span><br><span class="line"><span class="keyword">let</span> tree = esprima.parseScript(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历语法树</span></span><br><span class="line">estraverse.traverse(tree, &#123;</span><br><span class="line">  enter(node) &#123;</span><br><span class="line">    <span class="comment">// 修改函数名</span></span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="string">'FunctionDeclaration'</span>) &#123;</span><br><span class="line">      node.id.name = <span class="string">'ast'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译语法树</span></span><br><span class="line"><span class="keyword">let</span> result = escodegen.generate(tree);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// function ast() &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>在遍历 AST 的过程中 <code>params</code> 值为数组，没有 <code>type</code> 属性。</strong></em></p></blockquote><h2 id="实现-Babel-语法转换插件"><a href="#实现-Babel-语法转换插件" class="headerlink" title="实现 Babel 语法转换插件"></a>实现 Babel 语法转换插件</h2><p>实现语法转换插件需要借助 <code>babel-core</code> 和 <code>babel-types</code> 两个模块，其实这两个模块就是依赖 <code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 的。</p><p><strong>使用这两个模块需要安装，命令如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-types</span><br></pre></td></tr></table></figure><h3 id="plugin-transform-arrow-functions"><a href="#plugin-transform-arrow-functions" class="headerlink" title="plugin-transform-arrow-functions"></a>plugin-transform-arrow-functions</h3><blockquote class="pullquote success"><p><code>plugin-transform-arrow-functions</code> 是 Babel 家族成员之一，用于将箭头函数转换 ES5 语法的函数表达式。</p></blockquote><figure class="highlight js"><figcaption><span>文件：plugin-transform-arrow-functions.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">const</span> types = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数代码块</span></span><br><span class="line"><span class="keyword">let</span> sumCode = <span class="string">`</span></span><br><span class="line"><span class="string">const sum = (a, b) =&gt; &#123;</span></span><br><span class="line"><span class="string">  return a + b;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"><span class="keyword">let</span> minusCode = <span class="string">`const minus = (a, b) =&gt; a - b;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化 ES5 插件</span></span><br><span class="line"><span class="keyword">const</span> ArrowPlugin = &#123;</span><br><span class="line">  <span class="comment">// 访问者（访问者模式）</span></span><br><span class="line">  visitor: &#123;</span><br><span class="line">    <span class="comment">// path 是树的路径</span></span><br><span class="line">    ArrowFunctionExpression(path) &#123;</span><br><span class="line">      <span class="comment">// 获取树节点</span></span><br><span class="line">      <span class="keyword">let</span> node = path.node;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取参数和函数体</span></span><br><span class="line">      <span class="keyword">let</span> params = node.params;</span><br><span class="line">      <span class="keyword">let</span> body = node.body;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断函数体是否是代码块，不是代码块则添加 return 和 &#123;&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (!types.isBlockStatement(body)) &#123;</span><br><span class="line">        <span class="keyword">let</span> returnStatement = types.returnStatement(body);</span><br><span class="line">        body = types.blockStatement([returnStatement]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 生成一个函数表达式树结构</span></span><br><span class="line">      <span class="keyword">let</span> func = types.functionExpression(<span class="literal">null</span>, params, body, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用新的树结构替换掉旧的树结构</span></span><br><span class="line">      path.replaceWith(func);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成转换后的代码块</span></span><br><span class="line"><span class="keyword">let</span> sumResult = babel.transform(sumCode, &#123;</span><br><span class="line">  plugins: [ArrowPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> minusResult = babel.transform(minusCode, &#123;</span><br><span class="line">  plugins: [ArrowPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumResult.code);</span><br><span class="line"><span class="built_in">console</span>.log(minusResult.code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let sum = function(a, b) &#123;</span></span><br><span class="line"><span class="comment">//   return a + b;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// let minus = function(a, b) &#123;</span></span><br><span class="line"><span class="comment">//   return a - b;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><p>我们主要使用 <code>babel-core</code> 的 <code>transform</code> 方法将 AST 转化成代码块，第一个参数为转换前的代码块（字符串），第二个参数为配置项，其中 <code>plugins</code> 值为数组，存储修改 <code>babal-core</code> 转换的 AST 的插件（对象），使用 <code>transform</code> 方法将旧的 AST 处理成新的代码块后，返回值为一个对象，对象的 <code>code</code> 属性为转换后的代码块（字符串）。</p><p>内部修改通过 <code>babel-types</code> 模块提供的方法实现，API 可以到 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank">https://github.com/babel/babel/tree/6.x/packages/babel-types</a> 中查看。</p><p><code>ArrowPlugin</code> 就是传入 <code>transform</code> 方法的插件，必须含有 <code>visitor</code> 属性（固定），值同为对象，用于存储修改语法树的方法，方法名要严格按照 API，对应的方法会修改 AST 对应的节点。</p><p>在 <code>types.functionExpression</code> 方法中参数分别代表，函数名（匿名函数为 <code>null</code>）、函数参数（必填）、函数体（必填）、是否为 <code>generator</code> 函数（默认 <code>false</code>）、是否为 <code>async</code> 函数（默认 <code>false</code>），返回值为修改后的 AST，<code>path.replaceWith</code> 方法用于替换 AST，参数为新的 AST。</p><h3 id="plugin-transform-classes"><a href="#plugin-transform-classes" class="headerlink" title="plugin-transform-classes"></a>plugin-transform-classes</h3><blockquote class="pullquote info"><p><code>plugin-transform-classes</code> 也是 Babel 家族中的成员之一，用于将 ES6 的 <code>class</code> 类转换成 ES5 的构造函数。</p></blockquote><figure class="highlight js"><figcaption><span>文件：plugin-transform-classes.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">const</span> types = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">class Person &#123;</span></span><br><span class="line"><span class="string">  constructor(name) &#123;</span></span><br><span class="line"><span class="string">    this.name = name;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  getName () &#123;</span></span><br><span class="line"><span class="string">    return this.name;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将类转化 ES5 构造函数插件</span></span><br><span class="line"><span class="keyword">const</span> ClassPlugin = &#123;</span><br><span class="line">  visitor: &#123;</span><br><span class="line">    ClassDeclaration(path) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = path.node;</span><br><span class="line">      <span class="keyword">let</span> classList = node.body.body;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将取到的类名转换成标识符 &#123; type: 'Identifier', name: 'Person' &#125;</span></span><br><span class="line">      <span class="keyword">let</span> className = types.identifier(node.id.name);</span><br><span class="line">      <span class="keyword">let</span> body = types.blockStatement([]);</span><br><span class="line">      <span class="keyword">let</span> func = types.functionDeclaration(</span><br><span class="line">        className,</span><br><span class="line">        [],</span><br><span class="line">        body,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">      );</span><br><span class="line">      path.replaceWith(func);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于存储多个原型方法</span></span><br><span class="line">      <span class="keyword">let</span> es5Func = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取 class 中的代码体</span></span><br><span class="line">      classList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 函数的代码体</span></span><br><span class="line">        <span class="keyword">let</span> body = classList[index].body;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        <span class="keyword">let</span> params = item.params.length ?</span><br><span class="line">          item.params.map(<span class="function"><span class="params">val</span> =&gt;</span> val.name) :</span><br><span class="line">          [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转化参数为标识符</span></span><br><span class="line">        params = types.identifier(params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是 constructor，如果构造函数那就生成新的函数替换</span></span><br><span class="line">        <span class="keyword">if</span> (item.kind === <span class="string">'constructor'</span>) &#123;</span><br><span class="line">          <span class="comment">// 生成一个构造函数树结构</span></span><br><span class="line">          func = types.functionDeclaration(</span><br><span class="line">            className,</span><br><span class="line">            [params],</span><br><span class="line">            body,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 其他情况是原型方法</span></span><br><span class="line">          <span class="keyword">let</span> proto = types.memberExpression(</span><br><span class="line">            className,</span><br><span class="line">            types.identifier(<span class="string">'prototype'</span>)</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 左侧层层定义标识符 Person.prototype.getName</span></span><br><span class="line">          <span class="keyword">let</span> left = types.memberExpression(</span><br><span class="line">            proto,</span><br><span class="line">            types.identifier(item.key.name)</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 右侧定义匿名函数</span></span><br><span class="line">          <span class="keyword">let</span> right = types.functionExpression(</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            [params],</span><br><span class="line">            body,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将左侧和右侧进行合并并存入数组</span></span><br><span class="line">          es5Func.push(types.assignmentExpression(<span class="string">'='</span>, left, right));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果没有原型方法，直接替换</span></span><br><span class="line">      <span class="keyword">if</span> (es5Func.length === <span class="number">0</span>) &#123;</span><br><span class="line">        path.replaceWith(func);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        es5Func.push(func);</span><br><span class="line">        <span class="comment">// 替换 n 个节点</span></span><br><span class="line">        path.replaceWithMultiple(es5Func);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成转换后的代码块</span></span><br><span class="line">result = babel.transform(code, &#123;</span><br><span class="line">  plugins: [ClassPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result.code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.prototype.getName = function() &#123;</span></span><br><span class="line"><span class="comment">//     return this.name;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// function Person(name) &#123;</span></span><br><span class="line"><span class="comment">//     this.name = name;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面这个插件的实现要比 <code>plugin-transform-arrow-functions</code> 复杂一些，归根结底还是将要互相转换的 ES6 和 ES5 语法树做对比，找到他们的不同，并使用 <code>babel-types</code> 提供的 API 对语法树对应的节点属性进行修改并替换语法树，值得注意的是 <code>path.replaceWithMultiple</code> 与 <code>path.replaceWith</code> 不同，参数为一个数组，数组支持多个语法树结构，可根据具体修改语法树的场景选择使用，也可根据不同情况使用不同的替换方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>通过本节我们了解了什么是 AST 抽象语法树、抽象语法树在 JavaScript 中的体现以及在 NodeJS 中用于生成、遍历和修改 AST 抽象语法树的核心依赖，并通过使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块简易模拟了 ES6 新特性转换为 ES5 语法的过程，希望可以为后面自己实现一些编译插件提供了思路。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Webpack </tag>
            
            <tag> Babel </tag>
            
            <tag> AST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行工具 —— 手写类似 http-server 的静态服务器</title>
      <link href="/2018/07/22/20180722110147/"/>
      <url>/2018/07/22/20180722110147/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/22/20180722110147/static-server.png" title="http-server 命令行工具"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><code>npm</code> 里有个 <code>http-server</code> 的模块，是一个简单的、零配置的 HTTP 服务，它非常强大，同时非常简单，可以方便的帮助我们开启本地服务器，以及局域网共享，可以用来做测试，开发，学习时的环境配置，我们本节就模拟 <code>http-server</code> 实现一个自己的启动本地服务的命令行工具。</p></blockquote><a id="more"></a><h2 id="http-server-使用"><a href="#http-server-使用" class="headerlink" title="http-server 使用"></a>http-server 使用</h2><p><code>http-server</code> 服务器通过命令行启动，使用时需要安装，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install http-server -g</span><br></pre></td></tr></table></figure><p>启动本地服务器时在根目录下执行下面命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server [path] [option]</span><br></pre></td></tr></table></figure><p><code>path</code> 默认情况下是 <code>./public</code>，否则是 <code>./</code>，启动后可以通过 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:8080</a> 来访问服务器，<code>options</code> 为其他参数， <code>npm</code> 官方文档 <a href="https://www.npmjs.com/package/http-server" target="_blank">https://www.npmjs.com/package/http-server</a> 有详细说明。</p><p>当通过浏览器访问 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:8080</a> 以后，会将我们服务器根目录的目录结构显示在浏览器页面上，当点击文件夹时，可以继续显示内部的文件和文件夹，当点击文件时会直接通过服务器访问文件，并将文件内容显示在浏览器页面上。</p><h2 id="实现命令行工具依赖的模块"><a href="#实现命令行工具依赖的模块" class="headerlink" title="实现命令行工具依赖的模块"></a>实现命令行工具依赖的模块</h2><h3 id="chalk-模块"><a href="#chalk-模块" class="headerlink" title="chalk 模块"></a>chalk 模块</h3><p><code>chalk</code> 模块是用来控制命令行输出的文字颜色的第三方模块，使用前需要安装，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chalk</span><br></pre></td></tr></table></figure><p><code>chalk</code> 模块的用法如下，模块支持的颜色和更多的 API 可以在 <code>npm</code> 官方文档 <a href="https://www.npmjs.com/package/chalk" target="_blank">https://www.npmjs.com/package/chalk</a> 中查看。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/tests/staticchalk-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在命令行打印绿色和红色的 hello</span></span><br><span class="line"><span class="built_in">console</span>.log(chalk.green(<span class="string">'hello'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(chalk.red(<span class="string">'hello'</span>));</span><br></pre></td></tr></table></figure><p>在命令行窗口输入 <code>node chalk-test.js</code> 查看命令行打印 <code>hello</code> 的颜色。</p><h3 id="debug-模块"><a href="#debug-模块" class="headerlink" title="debug 模块"></a>debug 模块</h3><p><code>debug</code> 模块可以匹配当前环境变量 <code>DEBUG</code> 的值并输出相关信息，作用在于命令行工具可以根据不同情况输出的信息进行调试，是第三方模块，使用前需安装，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install debug</span><br></pre></td></tr></table></figure><p><code>debug</code> 的简单使用如下，如果想了解更详细的 API 可以在 <code>npm</code> 官方文档 <a href="https://www.npmjs.com/package/debug" target="_blank">https://www.npmjs.com/package/debug</a> 中查看。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/tests/debug-test1.js —— 用法 1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">debug(<span class="string">'hi panda'</span>);</span><br></pre></td></tr></table></figure><p>当我们在命令行中执行 <code>node debug-test1.js</code> 时发现命令窗口什么也没有打印，那是因为当前根目录的环境变量 <code>DEBUG</code> 的值必须和我们设置的 <code>hello</code> 相匹配才会打印相关信息。</p><p>设置环境变量，Window 可以通过 <code>set DEBUG=hello</code> 设置，Mac 可以通过 <code>export DEBUG=hello</code> 设置，设置环境变量后再次执行 <code>node debug-test.js</code>，我们会发现命令行打印出了下面内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hi panda +0ms</span><br></pre></td></tr></table></figure><p>其中 <code>hello</code> 为我们设置 <code>DEBUG</code> 环境变量的值，<code>hi panda</code> 为调试方法 <code>debug</code> 方法打印的信息，<code>+0ms</code> 为距离上次执行的间隔时间。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/tests/debug-test2.js —— 用法 2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debugA = <span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'hello:a'</span>);</span><br><span class="line"><span class="keyword">const</span> debugB = <span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'hello:b'</span>);</span><br><span class="line"></span><br><span class="line">debugA(<span class="string">'hi panda'</span>);</span><br><span class="line">debugB(<span class="string">'hello panda'</span>);</span><br></pre></td></tr></table></figure><p>上面的代码目的是可以让我们不同的 <code>debug</code> 方法可以匹配不同的环境变量，所以需要重新将环境变量的值设置为 <code>hello:*</code>，这样再次执行 <code>node debug-test2.js</code> 发现命令窗口打印了如下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello:a hi panda +0ms</span><br><span class="line">hello:b hello panda +0ms</span><br></pre></td></tr></table></figure><p>使用 <code>debug</code> 的好处就是可以在开发的时候打印一些调试用的信息，在开发完成后因为匹配不到环境变量，这些信息就会被隐藏。</p><h3 id="commander-模块"><a href="#commander-模块" class="headerlink" title="commander 模块"></a>commander 模块</h3><p><code>commander</code> 是著名的 Node 大神 <code>TJ</code> 的 “作品”，是一个开发命令行工具的解决方案，提供了用户命令行输入和参数解析的强大功能，<code>commander</code> 是第三方模块，使用时需要安装，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commander</span><br></pre></td></tr></table></figure><p>基本用法如下：</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/tests/commander-test1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commander = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 Node 进程执行时的参数</span></span><br><span class="line">commander.version(<span class="string">'1.0.0'</span>).parse(process.argv);</span><br></pre></td></tr></table></figure><p>上面文件中 <code>version</code> 方法代表当前执行文件模块的版本，<code>parse</code> 为解析参数为当前命令行进程参数的方法，<code>process.argv</code> 为参数集合（数组），第一个参数为执行的 <code>node.exe</code> 文件的绝对路径，第二个参数为当前执行文件的绝对路径，后面为通过命令行传入的参数，如 <code>--host</code>、<code>--port</code> 等。</p><p>在命令行执行 <code>node commander-test.js --help</code> 时默认会在命令行输出如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: [options]</span><br><span class="line">Options:</span><br><span class="line">    -V, --version  output the version number</span><br><span class="line">    -h, --<span class="built_in">help</span>     output usage information</span><br></pre></td></tr></table></figure><p>当然在我们的命令行工具中，参数不只 <code>--version</code> 和 <code>--help</code> 两个，我们更希望更多的参数更多的功能，并且可定制的描述信息，使用案例如下。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/tests/commander-test2.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commander = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 Node 进程执行时的参数</span></span><br><span class="line">commander</span><br><span class="line">  .version(<span class="string">'1.0.0'</span>)</span><br><span class="line">  .usage(<span class="string">'[options]'</span>)</span><br><span class="line">  .option(<span class="string">'-p, --port &lt;n&gt;'</span>, <span class="string">'server port'</span>)</span><br><span class="line">  .option(<span class="string">'-o, --host &lt;n&gt;'</span>, <span class="string">'server host'</span>)</span><br><span class="line">  .option(<span class="string">'-d, --dir &lt;n&gt;'</span>, <span class="string">'server dir'</span>)</span><br><span class="line">  .parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(commander.port); <span class="comment">// 3000</span></span><br><span class="line"><span class="built_in">console</span>.log(commander.host); <span class="comment">// localhost</span></span><br><span class="line"><span class="built_in">console</span>.log(commander.dir); <span class="comment">// public</span></span><br></pre></td></tr></table></figure><p>在执行命令 <code>node commander-test2.js --help</code> 后会在命令窗口输出如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: yourname-http-server [options]</span><br><span class="line">ptions:</span><br><span class="line">    -V, --version   output the version number</span><br><span class="line">    -p, --port &lt;n&gt;  server port</span><br><span class="line">    -o, --host &lt;n&gt;  server host</span><br><span class="line">    -d, --dir  &lt;n&gt;  server dir</span><br><span class="line">    -h, --<span class="built_in">help</span>      output usage information</span><br></pre></td></tr></table></figure><p><code>usage</code> 方法可以让我们详细的定制参数的类型和描述，<code>option</code> 方法可以让我们添加执行 <code>--help</code> 指令时打印的命令以及对应的描述信息。</p><p><strong>执行下面命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node commander-test2.js --port 3000 --host localhost --dir public</span><br></pre></td></tr></table></figure><p>执行命令后我们发现其实给我们的参数挂在了 <code>commander</code> 对象上，方便我们取值。</p><p>在我们使用别人的命令行工具时会发现在上面输出信息的时候经常会在下面输出 <code>How to use</code> 的列表，更详细的描述了每条命令的作用及用法。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/tests/commander-test3.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> commander = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须写到 parse 方法的前面</span></span><br><span class="line">commander.on(<span class="string">'--help'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'\r\n  How to use:'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --port &lt;val&gt;'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --host &lt;val&gt;'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --dir &lt;val&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 Node 进程执行时的参数</span></span><br><span class="line">commander</span><br><span class="line">  .version(<span class="string">'1.0.0'</span>)</span><br><span class="line">  .usage(<span class="string">'[options]'</span>)</span><br><span class="line">  .option(<span class="string">'-p, --port &lt;n&gt;'</span>, <span class="string">'server port'</span>)</span><br><span class="line">  .option(<span class="string">'-o, --host &lt;n&gt;'</span>, <span class="string">'server host'</span>)</span><br><span class="line">  .option(<span class="string">'-d, --dir &lt;n&gt;'</span>, <span class="string">'server dir'</span>)</span><br><span class="line">  .parse(process.argv);</span><br></pre></td></tr></table></figure><p>再次执行命令 <code>node commander-test2.js --help</code> 后会在命令窗口输出如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage: yourname-http-server [options]</span><br><span class="line">Options:</span><br><span class="line">    -V, --version  output the version number</span><br><span class="line">    -p, --port &lt;n&gt;  server port</span><br><span class="line">    -o, --host &lt;n&gt;  server host</span><br><span class="line">    -d, --dir &lt;n&gt;   server dir</span><br><span class="line">    -h, --<span class="built_in">help</span>     output usage information</span><br><span class="line">How to use:</span><br><span class="line">    yourname-http-server --port &lt;val&gt;</span><br><span class="line">    yourname-http-server --host &lt;val&gt;</span><br><span class="line">    yourname-http-server --dir &lt;val&gt;</span><br></pre></td></tr></table></figure><p>以上是 <code>commander</code> 模块的基本用法，如想了解更详细的 API 和使用案例可以到 <code>npm</code> 官方文档查看，地址如下 <a href="https://www.npmjs.com/package/commander" target="_blank">https://www.npmjs.com/package/commander</a> 。</p><h2 id="实现静态服务的功能"><a href="#实现静态服务的功能" class="headerlink" title="实现静态服务的功能"></a>实现静态服务的功能</h2><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><pre>static<br>  |- bin<br>  | |- yourname-http-server.js<br>  |- public<br>  | |- css<br>  | | |- style.css<br>  | |- index.html<br>  | |- 1.txt<br>  |- tests<br>  | |- chalk-test.js<br>  | |- commander-test1.js<br>  | |- commander-test2.js<br>  | |- commander-test3.js<br>  | |- debug-test1.js<br>  | |- debug-test2.js<br>  |- config.js<br>  |- index.html<br>  |- index.js<br>  |- package-lock.json<br>  |- package.json</pre></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在启动静态服务的时候，我们希望可以通过命令行传参的形式来定义当前启动服务的主机名端口号，以及默认检索的文件根目录，所以需要配置文件来实现灵活传参。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  dir: process.cwd()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>在上面的配置中，默认端口号为 <code>3000</code>，默认主机名为 <code>localhost</code>，我们设置默认检索文件的根目录为通过命令行启动服务器的目录，而 <code>process.cwd()</code> 的值就是我们启动命令行执行命令的目录的绝对路径。</p></blockquote><h3 id="创建服务器-Server-类"><a href="#创建服务器-Server-类" class="headerlink" title="创建服务器 Server 类"></a>创建服务器 Server 类</h3><p>因为我们的命令行工具启动本地服务可能是在系统的任意位置，或者指定启动服务访问的域，提高可配置性，并且要更方便给服务器扩展更多的方法处理不同的逻辑，所以需要创建一个 <code>Server</code> 类。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— Server 类的创建</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'mz/fs'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>);</span><br><span class="line"><span class="keyword">const</span> debug = <span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'http:a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取模板文件</span></span><br><span class="line"><span class="keyword">const</span> templateStr = fs.readFileSync(</span><br><span class="line">  path.join(__dirname, <span class="string">'index.html'</span>),</span><br><span class="line">  <span class="string">'utf8'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config; <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">this</span>.template = templateStr; <span class="comment">// 模板</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在上面代码中引入了 <code>config.js</code> 配置文件，读取了用于启动服务后展示页面 <code>index.html</code> 的内容，并都挂在了 <code>Server</code> 类的实例上，目的是方便内部的方法使用以及达到不轻易操作全局变量的目的。</p><h3 id="启动服务器的-start-方法"><a href="#启动服务器的-start-方法" class="headerlink" title="启动服务器的 start 方法"></a>启动服务器的 start 方法</h3><p>后面为了方便代码的拆分，我们将原型上的方法统一使用 <code>Server.prototype.xxx</code> 的方式来书写，实际的案例都是写在 <code>Server</code> 类里面的。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— start 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建服务</span></span><br><span class="line">  <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从配置中解构端口号和主机名</span></span><br><span class="line">  <span class="keyword">let</span> &#123; port, host &#125; = <span class="keyword">this</span>.config;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务</span></span><br><span class="line">  server.listen(port, host, () =&gt; &#123;</span><br><span class="line">    debug(<span class="string">`server start http://<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;chalk.green(port)&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>start</code> 方法中创建了服务，在启动服务时只需要创建 <code>Server</code> 的实例并调用 <code>start</code> 方法，由于服务的回调中会处理很多请求响应的逻辑，会导致 <code>start</code> 方法的臃肿，所以将服务的回调函数抽取成 <code>Server</code> 类的一个实例方法 <code>handleRequest</code>，需要注意的是 <code>handleRequest</code> 内部的 <code>this</code> 指向需要我们修正。</p><p>在启动服务时我们根据配置可以灵活的设置服务的地址，当设置 <code>host</code> 后，服务将只能通过 <code>host</code> 的值作为主机名的地址访问静态服务器，启动服务的提示我们通过匹配环境变量 <code>DEBUG</code> 的 <code>debug</code> 方法来打印，并将端口号设置成绿色。</p><h3 id="服务回调-handleRequest-方法"><a href="#服务回调-handleRequest-方法" class="headerlink" title="服务回调 handleRequest 方法"></a>服务回调 handleRequest 方法</h3><p>在实现 <code>handleRequest</code> 之前我们应该了解要实现的功能，在 <code>http-server</code> 中，如果访问的服务地址路径后面指定具体要访问的文件，并且当前启动服务根目录按照访问路径可以查找到文件，将文件内容读取后响应给客户端，如果没指定文件，应该检索当前启动服务根目录或默认设置的目录结构，并将文件的结构通过模板渲染成超链接后将页面响应给客户端，再次点击页面的上的链接，如果是文件，直接读取并响应文件内容，如果是文件夹，则继续检索内部结构通过模板渲染成页面。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— handleRequest 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.handleRequest = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取访问的路径，默认为 /</span></span><br><span class="line">  <span class="keyword">this</span>.pathname = url.parse(req.url, <span class="literal">true</span>).pathname;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将访问的路径名转换成绝对路径，取到的 dir 就是绝对路径</span></span><br><span class="line">  <span class="keyword">this</span>.realPath = path.join(<span class="keyword">this</span>.config.dir, <span class="keyword">this</span>.pathname);</span><br><span class="line"></span><br><span class="line">  debug(realPath); <span class="comment">// 打印当前访问的绝对路径，用于调试</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 statObj 对象，如果 await 同步使用 try...catch 捕获非法路径</span></span><br><span class="line">    <span class="keyword">let</span> statObj = <span class="keyword">await</span> fs.stat(<span class="keyword">this</span>.realPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (statObj.isFile()) &#123;</span><br><span class="line">      <span class="comment">// 如果是文件，直接返回文件内容</span></span><br><span class="line">      <span class="keyword">this</span>.sendFile(req, res, statObj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是文件夹则检索文件夹通过模板渲染后返回页面</span></span><br><span class="line">      <span class="keyword">this</span>.sendDirDetails(req, res, statObj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 如果路径非法，发送错误响应</span></span><br><span class="line">    <span class="keyword">this</span>.sendError(req, res, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleRequest</code> 由于内部需要使用异步操作获取 <code>statObj</code> 对象，所以我们使用了 <code>async</code> 函数，为了函数内部可以使用 <code>await</code> 避免异步回调嵌套，由于 <code>await</code> 会等待到异步执行完毕后继续向下执行，我们可以使用 <code>try...catch...</code> 捕获非法的访问路径，并做出错误响应。</p><p>如果路径合法，我们需要检测访问路径对应的是文件还是文件夹，如果是文件则执行响应内容的逻辑，是文件夹执行检索文件夹渲染内部文件列表返回页面的逻辑。</p><p>所以我们将错误处理逻辑、响应文件内容逻辑和返回文件夹详情页面的逻辑分别抽离成 <code>Server</code> 类的三个实例方法 <code>sendError</code>、<code>sendFile</code> 和 <code>sendDirDetails</code>，使得 <code>handleRequest</code> 方法逻辑清晰且不那么臃肿。</p><h3 id="错误响应-sendError-方法"><a href="#错误响应-sendError-方法" class="headerlink" title="错误响应 sendError 方法"></a>错误响应 sendError 方法</h3><p>在服务器处理不同的请求和响应时可能需要处理不同的错误，这些错误的不同就是捕获错误对象的不同，所以我们的 <code>sendError</code> 方法为了更方便的或取请求参数、处理响应以及更好的复用，将参数设置为请求对象、响应对象和错误对象。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— sendError 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.sendError = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 打印错误对象，方便调试</span></span><br><span class="line">  <span class="built_in">console</span>.log(chalk.red(err));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置错误状态码并响应 Not Found</span></span><br><span class="line">  res.statusCode = <span class="number">404</span>;</span><br><span class="line">  res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染目录-sendDirDetails-方法"><a href="#渲染目录-sendDirDetails-方法" class="headerlink" title="渲染目录 sendDirDetails 方法"></a>渲染目录 sendDirDetails 方法</h3><p>在渲染文件夹详情之前我们首先要做的就是异步读取文件目录，所以我们同样使用 <code>async</code> 函数来实现，NodeJS 中有很多渲染页面的模板，我们本次使用 <code>ejs</code>，语法简单，比较常用，<code>ejs</code> 为第三方模块，使用前需安装，更详细的用法可参照 <code>npm</code> 官方文档 <a href="https://www.npmjs.com/package/ejs" target="_blank">https://www.npmjs.com/package/ejs</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ejs</span><br></pre></td></tr></table></figure><p><code>sendDirDetails</code> 的参数为请求对象、响应对象和 <code>statObj</code>。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— sendDirDetails 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.sendDirDetails = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, statObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取当前文件夹</span></span><br><span class="line">  <span class="keyword">let</span> dirs = <span class="keyword">await</span> fs.readdir(<span class="keyword">this</span>.realPath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造模板需要的数据</span></span><br><span class="line">  dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> (&#123;</span><br><span class="line">    name: dir,</span><br><span class="line">    path: path.join(<span class="keyword">this</span>.pathname, dir)</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染模板</span></span><br><span class="line">  <span class="keyword">let</span> pageStr = ejs.render(<span class="keyword">this</span>.template, &#123; dirs &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应客户端</span></span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">  res.end(pageStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得 <code>Server</code> 类的实例属性 <code>template</code> 存储的就是我们的模板（字符串），里面写的就是 <code>ejs</code> 的语法，我们使用 <code>ejs</code> 模块渲染的 <code>render</code> 方法可以将模板中的 JS 执行，并用传给该方法的参数的值替换掉模板中的变量，返回新的字符串，我们直接将字符串响应给客户端即可。</p><blockquote class="pullquote warning"><p><em><strong>注意：在构建模板数据的时候 <code>path</code> 为超链接标签要跳转的路径，如果直接使用 <code>dir</code> 的值，多级访问还是会在根目录去查找，所以路径非法会返回 <code>Not Found</code>，我们需要在每次访问的时候都将上一次访问的路径与当前访问的文件夹或文件名进行拼接，保证路径的正确性。</strong></em></p></blockquote><h3 id="ejs-模板-index-html"><a href="#ejs-模板-index-html" class="headerlink" title="ejs 模板 index.html"></a>ejs 模板 index.html</h3><p>上面已经知道了该怎样使用 <code>ejs</code> 对模板进行渲染，也对模板构造了数据，接下来就是使用 <code>ejs</code> 的语法编写我们的模板内容。</p><figure class="highlight html"><figcaption><span>文件位置：&#126;static/index.html —— 模板</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Server<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%dirs.forEach(function(item)</span> &#123;%&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%=item.path%&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=item.name%</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><em><strong>模板中 JS 逻辑使用 <code>&lt;% %&gt;</code> 包裹，使用 <code>&lt;%= %&gt;</code> 输出变量。</strong></em></p></blockquote><h3 id="返回文件内容-sendFile-方法"><a href="#返回文件内容-sendFile-方法" class="headerlink" title="返回文件内容 sendFile 方法"></a>返回文件内容 sendFile 方法</h3><p>由于都是根据路径查找或操作文件目录并做出响应，<code>sendFile</code> 方法与 <code>sendDirDetails</code> 方法的参数相同，分别为 <code>req</code>、<code>res</code> 和 <code>statObj</code>。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— sendFile 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, statObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置和处理缓存</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.cache(req, res, statObj)) &#123;</span><br><span class="line">    res.statusCode = <span class="number">304</span>;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建可读流</span></span><br><span class="line">  <span class="keyword">let</span> rs = fs.createReadStream(<span class="keyword">this</span>.realPath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应文件类型</span></span><br><span class="line">  res.setHeader(</span><br><span class="line">    <span class="string">'Content-Type'</span>,</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;mime.getType(<span class="keyword">this</span>.realPath)&#125;</span>;charset=utf8`</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 压缩</span></span><br><span class="line">  <span class="keyword">let</span> zip = <span class="keyword">this</span>.compress(req, res, statObj);</span><br><span class="line">  <span class="keyword">if</span> (zip) <span class="keyword">return</span> rs.pipe(zip).pipe(res);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理范围请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.range(req, res, statObj)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应文件内容</span></span><br><span class="line">  rs.pipe(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面的方法通过在根目录执行 <code>node index.js</code> 启动服务后，通过我们默认配置的地址访问服务器，表面上就已经实现了 <code>http-server</code> 的功能，但是我们为了服务器的性能和功能更强大，又在这基础上实现了缓存策略、服务器压缩和处理范围请求的逻辑。</p><p><strong>如果对缓存策略、服务器压缩和范围请求不了解可以看下面三篇文章：</strong></p><ul><li><a href="https://www.overtaking.top/2018/07/20/20180720110647/" target="_blank">HTTP 缓存的那些事儿</a></li><li><a href="https://www.overtaking.top/2018/07/18/20180718181823/" target="_blank">NodeJS 服务器实现 gzip 压缩</a></li><li><a href="https://www.overtaking.top/2018/07/13/20180713130808/" target="_blank">NodeJS 使用 Range 请求实现下载功能</a></li></ul><p>我们将上面的三个功能分别抽离成了 <code>Server</code> 类的三个原型方法，<code>cache</code>、<code>compress</code> 和 <code>range</code>，并且这三个方法的参数都为 <code>req</code>、<code>res</code> 和 <code>statObj</code>。</p><h3 id="缓存策略-cache-方法"><a href="#缓存策略-cache-方法" class="headerlink" title="缓存策略 cache 方法"></a>缓存策略 cache 方法</h3><p>我们本次的缓存兼容 <code>HTTP 1.0</code> 和 <code>HTTP 1.1</code> 版本，并且同时使用强制缓存和协商缓存共同存在的策略。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— cache 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.cache = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, statObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建协商缓存标识</span></span><br><span class="line">  <span class="keyword">let</span> etag = statObj.ctime.toGMTString() + statObj.size;</span><br><span class="line">  <span class="keyword">let</span> lastModified = statObj.ctime.toGMTString();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置强制缓存</span></span><br><span class="line">  res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=30'</span>);</span><br><span class="line">  res.setHeader(<span class="string">'Expires'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">30</span> * <span class="number">1000</span>).toUTCString());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置协商缓存</span></span><br><span class="line">  res.setHeader(<span class="string">'Etag'</span>, etag);</span><br><span class="line">  res.setHeader(<span class="string">'Last-Modified'</span>, lastModified);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取协商缓存请求头</span></span><br><span class="line">  <span class="keyword">let</span> &#123;</span><br><span class="line">    <span class="string">'if-none-match'</span>: ifNodeMatch,</span><br><span class="line">    <span class="string">'if-modified-since'</span>: ifModifiedSince</span><br><span class="line">  &#125; = req.headers;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (etag !== ifNodeMatch &amp;&amp; lastModified !== ifModifiedSince) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><em><strong>我们使用的缓存策略为同时设置强制缓存和协商缓存，当强制缓存有效期内再次请求不会访问服务器，待强制缓存过期再次请求执行协商缓存策略，带标识访问服务器进行确认，确认的同时重新设置强制缓存和协商缓存的响应头信息，如果协商缓存任然生效，则直接返回 <code>304</code> 状态码，如果协商缓存失效则读取文件内容返回浏览器。</strong></em></p></blockquote><h3 id="服务器压缩-compress-方法"><a href="#服务器压缩-compress-方法" class="headerlink" title="服务器压缩 compress 方法"></a>服务器压缩 compress 方法</h3><p>为了减少文件数据在传输过程中消耗的流量和时间，我们在浏览器支持解压的情况下使用服务器压缩功能，浏览器会在请求时默认发送请求头 <code>Accept-Encoding</code> 通知我们的服务器当前支持的压缩格式，我们要做的就是按照压缩格式的优先级进行匹配，按照最高优先级的压缩格式进行压缩，将压缩后的数据返回，并通过响应头 <code>Content-Encoding</code> 通知浏览器当前的压缩格式（压缩流的本质为转化流）。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— compress 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.compress = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, statObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取浏览器支持的压缩格式</span></span><br><span class="line">  <span class="keyword">let</span> encoding = req.headers[<span class="string">'accept-encoding'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持 gzip 使用 gzip 压缩，支持 deflate 使用 deflate 压缩</span></span><br><span class="line">  <span class="keyword">if</span> (encoding &amp;&amp; encoding.match(<span class="regexp">/\bgzip\b/</span>)) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Encoding'</span>, <span class="string">'gzip'</span>);</span><br><span class="line">    <span class="keyword">return</span> zlib.createGzip();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding &amp;&amp; encoding.match(<span class="regexp">/\bdeflate\b/</span>)) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Encoding'</span>, <span class="string">'deflate'</span>);</span><br><span class="line">    <span class="keyword">return</span> zlib.createDeflate();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不支持压缩返回 false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当浏览器支持压缩时，<code>compress</code> 方法返回的为优先级最高压缩格式的压缩流，不支持返回 <code>false</code>，存在压缩流，则将数据压缩并响应浏览器，与不压缩响应不同的是，需要使用压缩流将可读流转化为可写流写入响应 <code>res</code> 中，所以可读流执行了两次 <code>pipe</code> 方法。</p><h3 id="处理范围请求-range-方法"><a href="#处理范围请求-range-方法" class="headerlink" title="处理范围请求 range 方法"></a>处理范围请求 range 方法</h3><p><code>range</code> 方法处理的场景为客户端发送请求只想获取文件的某个范围的数据，此时通过 <code>range</code> 方法读取文件范围对应的内容响应给客户端，通过响应头 <code>Accept-Ranges</code> 通知浏览器当前响应范围请求，通过响应头 <code>Content-Range</code> 通知客户端响应的范围以及文件的总字节数。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— range 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.range = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, statObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 range 请求头</span></span><br><span class="line">  <span class="keyword">let</span> range = req.headers[<span class="string">'range'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (range) &#123;</span><br><span class="line">    <span class="comment">// 获取范围请求的开始和结束位置</span></span><br><span class="line">    <span class="keyword">let</span> [, start, end] = range.match(<span class="regexp">/(\d*)-(\d*)/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求头中范围参数不传的问题</span></span><br><span class="line">    start = start ? ParseInt(start) : <span class="number">0</span>;</span><br><span class="line">    end = end ? ParseInt(end) : statObj.size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置范围请求响应</span></span><br><span class="line">    res.statusCode = <span class="number">206</span>;</span><br><span class="line">    res.setHeader(<span class="string">'Accept-Ranges'</span>, <span class="string">'bytes'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Range'</span>, <span class="string">`bytes <span class="subst">$&#123;start&#125;</span>-<span class="subst">$&#123;end&#125;</span>/<span class="subst">$&#123;statObj.size&#125;</span>`</span>);</span><br><span class="line">    fs.createReadStream(<span class="keyword">this</span>.realPath, &#123; start, end &#125;).pipe(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code> 方法默认返回值为布尔值，当不是范围请求时返回值为 <code>false</code>，则直接向下执行 <code>sendFile</code> 中的代码，正常读取文件全部内容并响应给浏览器，如果是范围请求则会处理范围请求后在直接结束后返回 <code>true</code>，会在 <code>sendFile</code> 中直接 <code>return</code>，不再向下执行。</p><h2 id="将静态服务器关联到命令行"><a href="#将静态服务器关联到命令行" class="headerlink" title="将静态服务器关联到命令行"></a>将静态服务器关联到命令行</h2><h3 id="命令行启动服务器"><a href="#命令行启动服务器" class="headerlink" title="命令行启动服务器"></a>命令行启动服务器</h3><p><code>http-server</code> 实际上是通过命令行启动、并传参的，我们需要将我们的程序与命令行关联，关联命令行只需以下几个步骤。</p><p>首先，在根目录 <code>package.json</code> 文件中加入 <code>bin</code> 字段，值为对象，对象内属性为命令名称，值为对应执行文件的路径。</p><figure class="highlight json"><figcaption><span>文件位置：&#126;static/package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"yourname-http-server"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"chalk"</span>: <span class="string">"^2.4.1"</span>,</span><br><span class="line">    <span class="attr">"commander"</span>: <span class="string">"^2.17.1"</span>,</span><br><span class="line">    <span class="attr">"debug"</span>: <span class="string">"^3.1.0"</span>,</span><br><span class="line">    <span class="attr">"ejs"</span>: <span class="string">"^2.6.1"</span>,</span><br><span class="line">    <span class="attr">"mime"</span>: <span class="string">"^2.3.1"</span>,</span><br><span class="line">    <span class="attr">"mz"</span>: <span class="string">"^2.7.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"yourname-http-server"</span>: <span class="string">"bin/yourname-http-server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，在 <code>yourname-http-server.js</code> 文件中首行加入注释 <code>#! /usr/bin/env node</code>，在命令行执行命令时，默认会以 Node 执行 <code>yourname-http-server.js</code> 文件。</p><p>最后，想要使用我们的命令启动 <code>yourname-http-server.js</code> 文件，则需要将这条命令连接到全局（与 -g 安装效果相同），在当前根目录下执行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><em><strong>当在命令行执行 <code>yourname-http-server</code> 时，Node 会默认执行 <code>yourname-http-server.js</code> 文件。</strong></em></p></blockquote><h3 id="命令行的参数传递"><a href="#命令行的参数传递" class="headerlink" title="命令行的参数传递"></a>命令行的参数传递</h3><p>我们现在知道在命令行执行命令后用 Node 启动的文件为 <code>yourname-http-server.js</code>，在启动文件时我们应该启动我们的服务器，并结合 <code>commander</code> 模块的参数解析，则需要用命令行传递的参数替换掉 <code>config.js</code> 中的默认参数。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/bin/yourname-http-server.js —— 命令行执行文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commander = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> Server = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 How to use</span></span><br><span class="line">commander.on(<span class="string">'--help'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'\r\n  How to use: \r\n'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --port &lt;val&gt;'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --host &lt;val&gt;'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --dir &lt;val&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 Node 进程执行时的参数</span></span><br><span class="line">commander</span><br><span class="line">  .version(<span class="string">'1.0.0'</span>)</span><br><span class="line">  .usage(<span class="string">'[options]'</span>)</span><br><span class="line">  .option(<span class="string">'-p, --port &lt;n&gt;'</span>, <span class="string">'server port'</span>)</span><br><span class="line">  .option(<span class="string">'-o, --host &lt;n&gt;'</span>, <span class="string">'server host'</span>)</span><br><span class="line">  .option(<span class="string">'-d, --dir &lt;n&gt;'</span>, <span class="string">'server dir'</span>)</span><br><span class="line">  .parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Server 实例传入命令行解析的参数</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> Server(commander);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure><p>我们之前把 <code>config.js</code> 的配置直接挂在了 <code>Server</code> 实例的 <code>config</code> 属性上，创建服务使用的参数也是直接从该属性上获取的，因此我们要用 <code>commander</code> 对象对应的参数覆盖实例上 <code>config</code> 的参数，所以在创建 <code>Server</code> 实例时传入了 <code>commander</code> 对象，下面稍微修改 <code>Server</code> 类的部分代码。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/index.js —— Server 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 通过解构赋值将 options 的参数覆盖 config 的参数</span></span><br><span class="line">    <span class="keyword">this</span>.config = &#123; ...config, ...options &#125;; <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">this</span>.template = templateStr; <span class="comment">// 模板</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行下面命令，并通过浏览器访问 <a href="javascript:;" target="_blank" rel="noopener">http://127.0.0.1:4000</a> 来测试服务器功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yourname-http-server --port 4000 --host 127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="在启动服务时自动打开浏览器"><a href="#在启动服务时自动打开浏览器" class="headerlink" title="在启动服务时自动打开浏览器"></a>在启动服务时自动打开浏览器</h3><p>由于 JS 是单线程的，在命令行输入命令启动服务的同时不能去做其他的事，此时要靠多进程来帮助我们打开浏览器，在 JS 中开启一个子进程来打开浏览器。</p><figure class="highlight js"><figcaption><span>文件位置：&#126;static/bin/yourname-http-server.js —— 命令行执行文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commander = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> Server = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 How to use</span></span><br><span class="line">commander.on(<span class="string">'--help'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'\r\n  How to use: \r\n'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --port &lt;val&gt;'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --host &lt;val&gt;'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'    yourname-http-server --dir &lt;val&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 Node 进程执行时的参数</span></span><br><span class="line">commander</span><br><span class="line">  .version(<span class="string">'1.0.0'</span>)</span><br><span class="line">  .usage(<span class="string">'[options]'</span>)</span><br><span class="line">  .option(<span class="string">'-p, --port &lt;n&gt;'</span>, <span class="string">'server port'</span>)</span><br><span class="line">  .option(<span class="string">'-o, --host &lt;n&gt;'</span>, <span class="string">'server host'</span>)</span><br><span class="line">  .option(<span class="string">'-d, --dir &lt;n&gt;'</span>, <span class="string">'server dir'</span>)</span><br><span class="line">  .parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Server 实例传入命令行解析的参数</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> Server(commander);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">server.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line"><span class="keyword">let</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断系统执行不同的命令打开浏览器</span></span><br><span class="line"><span class="keyword">let</span> systemOrder = process.platform === <span class="string">'win32'</span> ? <span class="string">'start'</span> : <span class="string">'open'</span>;</span><br><span class="line">exec(<span class="string">`<span class="subst">$&#123;systemOrder&#125;</span> http://<span class="subst">$&#123;commander.localhost&#125;</span>:<span class="subst">$&#123;commander.port&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// ********** 以上为新增代码 **********</span></span><br></pre></td></tr></table></figure><h3 id="发布命令行工具到-npm"><a href="#发布命令行工具到-npm" class="headerlink" title="发布命令行工具到 npm"></a>发布命令行工具到 npm</h3><p>在发布我们自己实现的 <code>npm</code> 模块之前需要先做一件事，就是解除当前模块与全局环境的 <code>link</code>，我们可以通过两种方式，第一种方式是直接到系统存储命令文件的文件夹删除模块对应命令的 <code>yourname-http-server.cmd</code> 文件，第二种方式是在模块根目录启动命令行并输入如下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unlink</span><br></pre></td></tr></table></figure><p>输入下面命令进行登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><p>登录成功后执行下面命令进行发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>发布成功后再次使用自己的模块需要通过 <code>npm</code> 下载并全局安装，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install yourname-http-server -g</span><br></pre></td></tr></table></figure><p>任意文件夹内打开命令行，并执行命令启动服务验证。</p><blockquote class="pullquote warning"><p><em><strong>在发布模块之前如果使用 <code>nrm</code> 切换过其他的源，必须切换回 <code>npm</code>，再进行登录和发布操作。</strong></em></p></blockquote><h2 id="总结xw"><a href="#总结xw" class="headerlink" title="总结xw"></a>总结xw</h2><blockquote class="pullquote success"><p>其实我们实现的静态服务器核心还在于处理请求和响应的逻辑上，只是不再手动输入 <code>node</code> 命令启动，而是借助一些第三方模块关联到了命令行并通过命令启动，开发其他类型的命令行工具也需要借助这些第三方模块，静态服务器只是其中之一，其实类似这种命令行工具在开发的角度来讲属于 “造轮子” 系列，可以独立开发命令行工具是一个成为前端架构的必备技能，希望通过本篇文章可以了解命令行工具的开发流程，在未来 “造轮子” 的道路上提供帮助。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
            <tag> 命令行 </tag>
            
            <tag> http-server </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 缓存的那些事儿</title>
      <link href="/2018/07/20/20180720110647/"/>
      <url>/2018/07/20/20180720110647/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/20/20180720110647/caching.png" title="HTTP 缓存策略"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote primary"><p>HTTP 缓存机制作为 Web 应用性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系的基础环节，也是想要成为前端架构的必备技能。</p></blockquote><a id="more"></a><h2 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h2><p>我们为什么使用缓存，是因为缓存可以给我们的 Web 项目带来以下好处，以提高性能和用户体验。</p><ul><li>加快了浏览器加载网页的速度；</li><li>减少了冗余的数据传输，节省网络流量和带宽；</li><li>减少服务器的负担，大大提高了网站的性能。</li></ul><blockquote class="pullquote info"><p>由于从本地缓存读取静态资源，加快浏览器的网页加载速度是一定的，也确实的减少了数据传输，就提高网站性能来说，可能一两个用户的访问对于减小服务器的负担没有明显效果，但如果这个网站在高并发的情况下，使用缓存对于减小服务器压力和整个网站的性能都会发生质的变化。</p></blockquote><h2 id="缓存规则简介"><a href="#缓存规则简介" class="headerlink" title="缓存规则简介"></a>缓存规则简介</h2><p>为了方便理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息（实际上静态资源是被缓存到了内存和磁盘中），在浏览器第一次请求数据时，此时缓存数据库没有对应的缓存数据，则需要请求服务器，服务器会将缓存规则和数据返回，浏览器将缓存规则和数据存储进缓存数据库。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/cache-rule.png" alt="缓存流程图" title>                </div>                <div class="image-caption">缓存流程图</div>            </figure><p><br></p><blockquote class="pullquote success"><p><em><strong>当浏览器地址栏输入地址后请求的 <code>index.html</code> 是不会被缓存的，但 <code>index.html</code> 内部请求的其他资源会遵循缓存策略，HTTP 缓存有多种规则，根据是否需要向服务器发送请求主要分为两大类，强制缓存和协商缓存。</strong></em></p></blockquote><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><h3 id="强制缓存流程"><a href="#强制缓存流程" class="headerlink" title="强制缓存流程"></a>强制缓存流程</h3><p>强制缓存是第一次访问服务器获取数据后，在有效时间内不会再请求服务器，而是直接使用缓存数据，强制缓存的流程如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/mandatory-cache.png" alt="强制缓存流程图" title>                </div>                <div class="image-caption">强制缓存流程图</div>            </figure><p><br></p><h3 id="强制缓存判断到期时间"><a href="#强制缓存判断到期时间" class="headerlink" title="强制缓存判断到期时间"></a>强制缓存判断到期时间</h3><p>那么如何判断缓存是否到期呢？其实还是根据第一次访问时服务器的响应头来实现的，在 <code>HTTP 1.0</code> 版本和 <code>HTTP 1.1</code> 版本有所不同。</p><p>在 <code>HTTP 1.0</code> 版本，服务器使用的响应头字段为 <code>Expires</code>，值为未来的绝对时间（时间戳），浏览器请求时的当前时间超过了 <code>Expires</code> 设置的时间，代表缓存失效，需要再次向服务器发送请求，否则都会直接从缓存数据库中获取数据。</p><p>在 <code>HTTP 1.1</code> 版本，服务器使用的响应头字段为 <code>Cache-Control</code>，有多个值，意义各不相同。</p><ul><li>private：客户端可以缓存；</li><li>public：客户端和代理服务器都可以缓存（对于前端而言，可以认为与 <code>private</code> 效果相同）；</li><li>max-age=xxx：缓存的内容将在 <code>xxx</code> 秒后过期（相对时间，秒为单位）；</li><li>no-cache：需要使用协商缓存（后面介绍）来验证数据是否过期；</li><li>no-store：所有内容都不会缓存，强制缓存和协商缓存都不会触发。</li></ul><p><code>Cache-Control</code> 的值中最常用的为 <code>max-age=xxx</code>，缓存本身就是为了数据传输的优化和性能而存在的，所以 <code>no-store</code> 几乎不会使用。</p><blockquote class="pullquote warning"><p><em><strong>注意：在 <code>HTTP 1.0</code> 版本中，<code>Expires</code> 字段的绝对时间是从服务器获取的，由于请求需要时间，所以浏览器的请求时间与服务器接收到请求所获取的时间是存在误差的，这也导致了缓存命中的误差，在 <code>HTTP 1.1</code> 版本中，因为 <code>Cache-Control</code> 的值 <code>max-age=xxx</code> 中的 <code>xxx</code> 是以秒为单位的相对时间，所以在浏览器接收到资源后开始倒计时，规避了 <code>HTTP 1.0</code> 中缓存命中存在误差的缺点，为了兼容低版本 HTTP 协议，正常开发中两种响应头会同时使用，<code>HTTP 1.1</code> 版本的实现优先级高于 <code>HTTP 1.0</code>。</strong></em></p></blockquote><h3 id="通过-Network-查看强制缓存"><a href="#通过-Network-查看强制缓存" class="headerlink" title="通过 Network 查看强制缓存"></a>通过 Network 查看强制缓存</h3><p>我们通过 Chrome 浏览器的开发者工具，打开 NetWork 查看强制缓存的相关信息。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/network-mandatory-response.png" alt="缓存响应头" title>                </div>                <div class="image-caption">缓存响应头</div>            </figure><p><br></p><p>上面是百度网站 Logo 图片的响应，我们可以清楚的看到，其中兼容了 <code>HTTP 1.0</code> 和 <code>HTTP 1.1</code> 版本，并使用强制缓存存储了 <code>10</code> 年。</p><p>下面看一看通过缓存取出的数据在 Network 中与其他资源的区别。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/network-mandatory-cache.png" alt="命中缓存" title>                </div>                <div class="image-caption">命中缓存</div>            </figure><p><br></p><blockquote class="pullquote info"><p>其实缓存的储存是内存和磁盘两个位置，由当前浏览器本身的策略决定，比较随机，从内存的缓存中取出的数据会显示 <code>(from memory cache)</code>，从磁盘的缓存中取出的数据会显示 <code>(from disk cache)</code>。</p></blockquote><h3 id="NodeJS-服务器实现强制缓存"><a href="#NodeJS-服务器实现强制缓存" class="headerlink" title="NodeJS 服务器实现强制缓存"></a>NodeJS 服务器实现强制缓存</h3><figure class="highlight js"><figcaption><span>强制缓存</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  pathname = pathname !== <span class="string">'/'</span> ? pathname : <span class="string">'/index.html'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取读取文件的绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> p = path.join(__dirname, pathname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看路径是否合法</span></span><br><span class="line">  fs.access(p, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 路径不合法则直接中断连接</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> res.end(<span class="string">'Not Found'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置强制缓存</span></span><br><span class="line">    res.setHeader(<span class="string">'Expires'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">30000</span>).toGMTString());</span><br><span class="line">    res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=30'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件类型并响应给浏览器</span></span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">`<span class="subst">$&#123;mime.getType(p)&#125;</span>;charset=utf8`</span>);</span><br><span class="line">    fs.createReadStream(p).pipe(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面 <code>mime</code> 模块的 <code>getType</code> 方法可以成功返回传入路径下文件对应的文件类型，如 <code>text/html</code> 和 <code>application/javascript</code> 等，是第三方模块，使用之前需要安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mime</span><br></pre></td></tr></table></figure><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><h3 id="协商缓存流程"><a href="#协商缓存流程" class="headerlink" title="协商缓存流程"></a>协商缓存流程</h3><p>协商缓存又叫对比缓存，设置协商缓存后，第一次访问服务器获取数据时，服务器会将数据和缓存标识一起返回给浏览器，客户端会将数据和标识存入缓存数据库中，下一次请求时，会先去缓存中取出缓存标识发送给服务器进行询问，当服务器数据更改时会更新标识，所以服务器拿到浏览器发来的标识进行对比，相同代表数据未更改，响应浏览器通知数据未更改，浏览器会去缓存中获取数据，如果标识不同，代表服务器更改过数据，所以会将新的数据和新的标识返回浏览器，浏览器会将新的数据和标识存入缓存中，协商缓存的流程如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/compared-cache.png" alt="协商缓存流程图" title>                </div>                <div class="image-caption">协商缓存流程图</div>            </figure><p><br></p><blockquote class="pullquote success"><p><em><strong>协商缓存和强制缓存不同的是，协商缓存每次请求都需要跟服务器通信，而且命中缓存服务器返回状态码不再是 <code>200</code>，而是 <code>304</code>。</strong></em></p></blockquote><h3 id="协商缓存判断标识"><a href="#协商缓存判断标识" class="headerlink" title="协商缓存判断标识"></a>协商缓存判断标识</h3><p>强制缓存是通过过期时间来控制是否访问服务器，而协商缓存每次都要与服务器交互对比缓存标识，同样的，对于协商缓存的实现在 <code>HTTP 1.0</code> 版本和 <code>HTTP 1.1</code> 版本也有所不同。</p><p>在 <code>HTTP 1.0</code> 版本中，服务器通过 <code>Last-Modified</code> 响应头来设置缓存标识，通常取请求数据的最后修改时间（绝对时间）作为值，而浏览器将接收到返回的数据和标识存入缓存，再次请求会自动发送 <code>If-Modified-Since</code> 请求头，值为之前返回的最后修改时间（标识），服务器取出 <code>If-Modified-Since</code> 的值与数据的上次修改时间对比，如果上次修改时间大于了 <code>If-Modified-Since</code> 的值，说明被修改过，则通过 <code>Last-Modified</code> 响应头返回新的最后修改时间和新的数据，否则未被修改，返回状态码 <code>304</code> 通知浏览器命中缓存。</p><p>在 <code>HTTP 1.1</code> 版本中，服务器通过 <code>Etag</code> 响应头来设置缓存标识（唯一标识，像一个指纹一样，生成规则由服务器来决定），浏览器接收到数据和唯一标识后存入缓存，下次请求时，通过 <code>If-None-Match</code> 请求头将唯一标识带给服务器，服务器取出唯一标识与之前的标识对比，不同，说明修改过，返回新标识和数据，相同，则返回状态码 <code>304</code> 通知浏览器命中缓存。</p><p><strong>HTTP 协商缓存策略流程图如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/cache-flow-chart.jpg" alt="缓存策略流程图" title>                </div>                <div class="image-caption">缓存策略流程图</div>            </figure><p><br></p><blockquote class="pullquote warning"><p><em><strong>注意：使用协商缓存时 <code>HTTP 1.0</code> 版本还是不太靠谱，假设一个文件增加了一个字符后又删除了，文件相当于没更改，但是最后修改时间变了，会被当作修改处理，本应该命中缓存，服务器却重新发送了数据，因此 <code>HTTP 1.1</code> 中使用的 <code>Etag</code> 唯一标识是根据文件内容或摘要生成的，保证了只要文件内容不变，则一定会命中缓存，为了兼容低版本 HTTP 协议，开发中两种响应头也会同时使用，同样 <code>HTTP 1.1</code> 版本的实现优先级高于 <code>HTTP 1.0</code>。</strong></em></p></blockquote><h3 id="通过-Network-查看协商缓存"><a href="#通过-Network-查看协商缓存" class="headerlink" title="通过 Network 查看协商缓存"></a>通过 Network 查看协商缓存</h3><p>我们同样通过 Chrome 浏览器的开发者工具，打开 NetWork 查看协商缓存的相关信息。</p><p><strong>再次请求服务器的请求头信息：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/network-mandatory-request.png" alt="再次请求服务器的请求头信息" title>                </div>                <div class="image-caption">再次请求服务器的请求头信息</div>            </figure><p><br></p><p><strong>命中协商缓存的响应头信息：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/network-mandatory-response-cache.png" alt="命中协商缓存的响应头信息" title>                </div>                <div class="image-caption">命中协商缓存的响应头信息</div>            </figure><p><br></p><p>下面看一看通过协商缓存取出的数据在 Network 中与第一次加载的区别。</p><p><strong>第一次请求：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/network-compared-before-cache.png" alt="第一次请求" title>                </div>                <div class="image-caption">第一次请求</div>            </figure><p><br></p><p><strong>缓存后请求：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/20/20180720110647/network-compared-cache.png" alt="缓存后请求" title>                </div>                <div class="image-caption">缓存后请求</div>            </figure><p><br></p><p>通过两图的对比，我们可以发现，协商缓存生效时的状态码为 <code>304</code>，并且报文大小和请求时间大大减少，原因是服务端在进行标识比对后只返回了 <code>header</code> 部分，通过状态码来通知浏览器使用缓存，不再需要将报文主体部分一起返回给浏览器。</p><h3 id="NodeJS-服务器实现协商缓存"><a href="#NodeJS-服务器实现协商缓存" class="headerlink" title="NodeJS 服务器实现协商缓存"></a>NodeJS 服务器实现协商缓存</h3><figure class="highlight js"><figcaption><span>协商缓存</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);<span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> crytpo = <span class="built_in">require</span>(<span class="string">'crytpo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  pathname = pathname !== <span class="string">'/'</span> ? pathname : <span class="string">'/index.html'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取读取文件的绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> p = path.join(__dirname, pathname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看路径是否合法</span></span><br><span class="line">  fs.stat(p, (err, statObj) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 路径不合法则直接中断连接</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> res.end(<span class="string">'Not Found'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> md5 = crypto.createHash(<span class="string">'md5'</span>); <span class="comment">// 创建加密的转换流</span></span><br><span class="line">    <span class="keyword">let</span> rs = fs.createReadStream(p); <span class="comment">// 创建可读流</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容并加密</span></span><br><span class="line">    rs.on(<span class="string">'data'</span>, data =&gt; md5.update(data));</span><br><span class="line"></span><br><span class="line">    rs.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> ctime = statObj.ctime.toGMTString(); <span class="comment">// 获取文件最后修改时间</span></span><br><span class="line">      <span class="keyword">let</span> flag = md5.digest(<span class="string">'hex'</span>); <span class="comment">// 获取加密后的唯一标识</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取协商缓存的请求头</span></span><br><span class="line">      <span class="keyword">let</span> ifModifiedSince = req.headers[<span class="string">'if-modified-since'</span>];</span><br><span class="line">      <span class="keyword">let</span> ifNoneMatch = req.headers[<span class="string">'if-none-match'</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ifModifiedSince === ctime || ifNoneMatch === flag) &#123;</span><br><span class="line">        res.statusCode = <span class="number">304</span>;</span><br><span class="line">        res.end();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置协商缓存</span></span><br><span class="line">        res.setHeader(<span class="string">'Last-Modified'</span>, ctime);</span><br><span class="line">        res.setHeader(<span class="string">'Etag'</span>, flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置文件类型并响应给浏览器</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">`<span class="subst">$&#123;mime.getType(p)&#125;</span>;charset=utf8`</span>);</span><br><span class="line">        rs.pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的代码中是通过可读流读取文件内容，并通过 <code>crypto</code> 模块进行了 <code>md5</code> 加密后的结果作为了唯一标识，这样就能保证只要文件内容不变，就会命中缓存，其中兼容了 <code>HTTP 1.0</code> 和 <code>HTTP 1.1</code> 两个版本，只要满足一个则直接返回 <code>304</code> 通知浏览器命中缓存。</p><blockquote class="pullquote warning"><p><em><strong>注意：其实读取文件内容加密这种做法并不可取，假如读取的是大文件，在读取文件内容和进行 <code>md5</code> 加密这个过程会非常消耗时间，所以在开发中要针对业务的实际情况选择可以保证服务器性能的方式生成唯一标识，比如根据文件的摘要。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>为了使缓存策略更加健壮、灵活，<code>HTTP 1.0</code> 版本 和 <code>HTTP 1.1</code> 版本的缓存策略会同时使用，甚至强制缓存和协商缓存也会同时使用，对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，超出有效时间，执行协商缓存策略，对于协商缓存，将缓存信息中的 <code>Etag</code> 和 <code>Last-Modified</code> 通过请求头 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 发送给服务器，由服务器校验同时设置新的强制缓存，校验通过并返回 <code>304</code> 状态码时，浏览器直接使用缓存，如果协商缓存也未命中，则服务器重新设置协商缓存的标识。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 加密 —— crypto 模块</title>
      <link href="/2018/07/19/20180719190551/"/>
      <url>/2018/07/19/20180719190551/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/19/20180719190551/crypto.png" title="NodeJS 加密模块 crypto"><p><br></p><h2 id="加密简介"><a href="#加密简介" class="headerlink" title="加密简介"></a>加密简介</h2><blockquote class="pullquote danger"><p>加密是以某种算法改变原有的信息数据，使得未授权用户即使获得了已加密信息，因不知解密的方法，无法得知信息真正的含义，通过这种方式提高网络数据传输的安全性，加密算法常见的有哈希算法、HMAC 算法、签名、对称性加密算法和非对称性加密算法，加密算法也分为可逆和不可逆，比如 <code>md5</code> 就是不可逆加密，只能暴力破解（撞库），我们在 NodeJS 开发中就是直接使用这些加密算法，<code>crypto</code> 模块提供了加密功能，包含对 <code>OpenSSL</code> 的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装，核心模块，使用时不需安装。</p></blockquote><a id="more"></a><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法也叫散列算法，用来把任意长度的输入变换成固定长度的输出，常见的有 <code>md5</code>、<code>sha1</code> 等，这类算法实现对原数据的转化过程是否能被称为加密备受争议，为了后面叙述方便我们姑且先叫做加密。</p><figure class="highlight js"><figcaption><span>查看哈希加密算法的种类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getHashes 方法用于查看支持的加密算法</span></span><br><span class="line"><span class="built_in">console</span>.log(crypto.getHashes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'DSA', 'DSA-SHA', 'DSA-SHA1', 'DSA-cSHA1-old',</span></span><br><span class="line"><span class="comment">//   'RSA-MD4', 'RSA-MD5', 'RSA-MDC2', 'RSA-RIPEMD160',</span></span><br><span class="line"><span class="comment">//   'RSA-SHA', 'RSA-SHA1', 'RSA-SHA1-2', 'RSA-SHA224',</span></span><br><span class="line"><span class="comment">//   'RSA-SHA256', 'RSA-SHA384', 'RSA-SHA512',</span></span><br><span class="line"><span class="comment">//   'dsaEncryption', 'dsaWithSHA', 'dsaWithSHA1', 'dss1',</span></span><br><span class="line"><span class="comment">//   'ecdsa-with-SHA1', 'md4', 'md4WithRSAEncryption',</span></span><br><span class="line"><span class="comment">//   'md5', 'md5WithRSAEncryption', 'mdc2', 'mdc2WithRSA',</span></span><br><span class="line"><span class="comment">//   'ripemd', 'ripemd160', 'ripemd160WithRSA', 'rmd160',</span></span><br><span class="line"><span class="comment">//   'sha', 'sha1', 'sha1WithRSAEncryption', 'sha224',</span></span><br><span class="line"><span class="comment">//   'sha224WithRSAEncryption', 'sha256',</span></span><br><span class="line"><span class="comment">//   'sha256WithRSAEncryption', 'sha384',</span></span><br><span class="line"><span class="comment">//   'sha384WithRSAEncryption', 'sha512',</span></span><br><span class="line"><span class="comment">//   'sha512WithRSAEncryption', 'shaWithRSAEncryption',</span></span><br><span class="line"><span class="comment">//   'ssl2-md5', 'ssl3-md5', 'ssl3-sha1', 'whirlpool' ]</span></span><br></pre></td></tr></table></figure><p><code>md5</code> 是开发中经常使用的算法之一，官方称为摘要算法，具有以下几个特点：</p><ul><li>不可逆；</li><li>不管加密的内容多长，最后输出的结果长度都是相等的；</li><li>内容不同输出的结果完全不同，内容相同输出的结果完全相同。</li></ul><p>由于相同的输入经过 <code>md5</code> 加密后返回的结果完全相同，所以破解时通过 “撞库” 进行暴力破解，当连续被 <code>md5</code> 加密 <code>3</code> 次以上时就很难被破解了，所以使用 <code>md5</code> 一般会进行多次加密。</p><figure class="highlight js"><figcaption><span>md5 加密 —— 返回 Buffer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crytpo = <span class="built_in">require</span>(<span class="string">'crytpo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> md5 = crytpo.createHash(<span class="string">'md5'</span>); <span class="comment">// 创建 md5</span></span><br><span class="line"><span class="keyword">let</span> md5Sum = md5.update(<span class="string">'hello'</span>); <span class="comment">// update 加密</span></span><br><span class="line"><span class="keyword">let</span> result = md5Sum.digest(); <span class="comment">// 获取加密后结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// &lt;Buffer 5d 41 40 2a bc 4b 2a 76 b9 71 9d 91 10 17 c5 92&gt;</span></span><br></pre></td></tr></table></figure><p><code>digest</code> 方法参数用于指定加密后的返回值的格式，不传参默认返回加密后的 Buffer，常用的参数有 <code>hex</code> 和 <code>Base64</code>，<code>hex</code> 代表十六进制，加密后长度为 <code>32</code>，<code>Base64</code> 的结果长度为 <code>24</code>，以 <code>==</code> 结尾。</p><figure class="highlight js"><figcaption><span>md5 加密 —— 返回十六进制</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> md5 = crypto.createHash(<span class="string">'md5'</span>);</span><br><span class="line"><span class="keyword">let</span> md5Sum = md5.update(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> result = md5Sum.digest(<span class="string">'hex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 5d41402abc4b2a76b9719d911017c592</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>md5 加密 —— 返回 Base64</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> md5 = crypto.createHash(<span class="string">'md5'</span>);</span><br><span class="line"><span class="keyword">let</span> md5Sum = md5.update(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> result = md5Sum.digest(<span class="string">'Base64'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// XUFAKrxLKna5cZ2REBfFkg==</span></span><br></pre></td></tr></table></figure><p><code>update</code> 方法的返回值就是 <code>this</code>，即当前实例，所以支持链式调用，较长的信息也可以多次调用 <code>update</code> 方法进行分段加密，调用 <code>digest</code> 方法同样会返回整个加密后的值。</p><figure class="highlight js"><figcaption><span>链式调用和分段加密</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = crypto</span><br><span class="line">  .createHash(<span class="string">'md5'</span>)</span><br><span class="line">  .update(<span class="string">'he'</span>)</span><br><span class="line">  .update(<span class="string">'llo'</span>)</span><br><span class="line">  .digest(<span class="string">'hex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 5d41402abc4b2a76b9719d911017c592</span></span><br></pre></td></tr></table></figure><p>由于可以使用 <code>update</code> 进行分段加密，就可以结合流来使用，其实 <code>crypto</code> 的本质是创建 <code>Transform</code> 类型的转化流，可以将可读流转化成可写流。</p><figure class="highlight js"><figcaption><span>对可读流读取的数据进行 md5 加密</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> md5 = crypto.createHash(<span class="string">'md5'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadSteam(<span class="string">'./readme.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据并加密</span></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; md5.update(data));</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = md5.digest(<span class="string">'hex'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><em><strong>使用场景 1：经常被使用在数据的校验，比如服务器与服务器之间进行通信发送的明文摘要加 <code>md5</code> 加密摘要后的暗文，接收端拿到数据以后将明文摘要按照相同的 <code>md5</code> 算法加密后与暗文摘要对比验证，目的是防止数据传输过程中被劫持并篡改。</strong></em><br><em><strong>使用场景 2：在浏览器缓存策略中，可以通过对静态资源的信息摘要使用 <code>md5</code> 加密，每次向服务器发送加密后的密钥进行比对就可以了，不至于对整个文件内容进行比较。</strong></em></p></blockquote><blockquote class="pullquote warning"><p><em><strong>缺点：由于规定使用 <code>md5</code> 的哈希算法加密，别人可以使用同样的算法对信息进行伪造，安全性不高。</strong></em></p></blockquote><h2 id="Hmac-算法"><a href="#Hmac-算法" class="headerlink" title="Hmac 算法"></a>Hmac 算法</h2><h3 id="Hmac-算法的使用"><a href="#Hmac-算法的使用" class="headerlink" title="Hmac 算法的使用"></a>Hmac 算法的使用</h3><p>Hmac 算法又称加盐算法，是将哈希算法与一个密钥结合在一起，用来阻止对签名完整性的破坏，同样具备 <code>md5</code> 加密的几个特点。</p><figure class="highlight js"><figcaption><span>使用加盐算法加密</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crytpo = <span class="built_in">require</span>(<span class="string">'crytpo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hmac = crytpo.createHmac(<span class="string">'sha1'</span>, <span class="string">'panda'</span>);</span><br><span class="line"><span class="keyword">let</span> result = hmac.update(<span class="string">'hello'</span>).digest(<span class="string">'Base64'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 7spMLxN8WJdcEtQ8Hm/LR9pUE3YsIGag9Dcai7lwioo=</span></span><br></pre></td></tr></table></figure><p><code>crytpo.createHmac</code> 第一个参数同 <code>crytpo.createHash</code>，为加密的算法，常用 <code>sha1</code> 和 <code>sha256</code>，第二个参数为密钥。</p><p><code>digest</code> 方法生成的加密结果长度要大于 <code>md5</code>，<code>hex</code> 生成的结果长度为 <code>64</code>，<code>Base64</code> 生成的结果长度为 <code>44</code>，以 <code>=</code> 结尾。</p><blockquote class="pullquote success"><p><em><strong>安全性高于 <code>md5</code>，通过密钥来加密，不知道密钥无法破解，缺点是密钥传输的过程容易被劫持，可以通过一些生成随机密钥的方式避免。</strong></em></p></blockquote><h3 id="创建密钥的方法"><a href="#创建密钥的方法" class="headerlink" title="创建密钥的方法"></a>创建密钥的方法</h3><p>可以安装 <code>openSSH</code> 客户端，并通过命令行生成存储密钥的文件，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rsa_private.key 1024</span><br></pre></td></tr></table></figure><p><code>openssl genrsa</code> 代表生成密钥，<code>-out</code> 代表输出文件，<code>rsa_private.key</code> 代表文件名，<code>1024</code> 代表输出密钥的大小。</p><figure class="highlight js"><figcaption><span>直接读取密钥文件配合加盐算法加密</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> crytpo = <span class="built_in">require</span>(<span class="string">'crytpo'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = fs.readFileSync(path.join(__dirname, <span class="string">'/rsa_private.key'</span>));</span><br><span class="line"><span class="keyword">let</span> hmac = crytpo.createHmac(<span class="string">'sha256'</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = hmac.update(<span class="string">'hello'</span>).digest(<span class="string">'Base64'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// bmi2N+6kwgwt5b+U+zSgjL/NFs+GsUnZmcieqLKBy4M=</span></span><br></pre></td></tr></table></figure><h2 id="对称性加密"><a href="#对称性加密" class="headerlink" title="对称性加密"></a>对称性加密</h2><p>对称性加密是发送数据时使用密钥和加密算法进行加密，接收数据时需要使用相同的密钥和加密算法的逆算法（解密算法）进行解密，也就是说对称性加密的过程是可逆的，<code>crytpo</code> 中使用的算法为 <code>blowfish</code>。</p><figure class="highlight js"><figcaption><span>对称性加密</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = fs.readFileSync(path.join(__dirname, <span class="string">'/rsa_private.key'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">let</span> cipher = crypto.createCipher(<span class="string">'blowfish'</span>, key);</span><br><span class="line">cipher.update(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// final 方法不能链式调用</span></span><br><span class="line"><span class="keyword">let</span> result = cipher.final(<span class="string">'hex'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 3eb9943113c7aa1e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">let</span> decipher = crypto.createDecipher(<span class="string">'blowfish'</span>, key);</span><br><span class="line">decipher.update(result, <span class="string">'hex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = decipher.final(<span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>加密使用 <code>crypto.createCipher</code> 方法，解密使用 <code>crypto.createDecipher</code> 方法，但是使用的算法和密钥必须相同，需要注意的是解密过程中 <code>update</code> 中需要在第二个参数中指定加密时的格式，如 <code>hex</code>，在 <code>final</code> 还原数据时需要指定加密字符的编码格式，如 <code>utf8</code>。</p><blockquote class="pullquote warning"><p><em><strong>注意：使用对称性加密的字符串有长度限制，不得超过 <code>7</code> 个字符，否则虽然可以加密成功，但是无法解密。</strong></em></p></blockquote><blockquote class="pullquote danger"><p><em><strong>缺点：密钥在传输过程中容易被截获，存在安全风险。</strong></em></p></blockquote><h2 id="非对称性加密"><a href="#非对称性加密" class="headerlink" title="非对称性加密"></a>非对称性加密</h2><p>非对称性加密相也是可逆的，较于对称性加密要更安全，消息传输方和接收方都会在本地创建一对密钥，公钥和私钥，互相将自己的公钥发送给对方，每次消息传递时使用对方的公钥加密，对方接收消息后使用他的的私钥解密，这样在公钥传递的过程中被截获也无法解密，因为公钥加密的消息只有配对的私钥可以解密。</p><p>接下来我们使用 <code>openSSH</code> 对之前生成的私钥 <code>rsa_private.key</code> 产生一个对应的公钥，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> rsa_private.key -pubout -out rsa_public.key</span><br></pre></td></tr></table></figure><p>上面的命令意思根据一个私钥生成对应的公钥，<code>-pubout -out</code> 代表公钥输出，<code>rsa_public.key</code> 为公钥的文件名。</p><figure class="highlight js"><figcaption><span>非对称性加密</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公钥和私钥</span></span><br><span class="line"><span class="keyword">let</span> publicKey = fs.readFileSync(path.join(__dirname, <span class="string">'/rsa_public.key'</span>));</span><br><span class="line"><span class="keyword">let</span> privateKey = fs.readFileSync(path.join(__dirname, <span class="string">'/rsa_private.key'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">let</span> secret = crytpo.publicEncrypt(publicKey, Buffer.from(<span class="string">'hello'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">let</span> result = crytpo.provateDecrypt(privateKey, secret);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>使用公钥加密的方法是 <code>crytpo.publicEncrypt</code>，第一个参数为公钥，第二个参数为加密信息（必须是 Buffer），使用私钥解密的方法是 <code>crytpo.provateDecrypt</code>，第一个参数为私钥，第二个参数为解密的信息。</p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>签名与非对称性加密非常类似，同样有公钥和私钥，不同的是使用私钥加密，对方使用公钥进行解密验证，以确保这段数据是私钥的拥有者所发出的原始数据，且在网络中的传输过程中未被修改。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/19/20180719190551/sign.png" alt="签名" title>                </div>                <div class="image-caption">签名</div>            </figure><p><br></p><p>我们还使用 <code>rsa_public.key</code> 和 <code>rsa_private.key</code> 作为公钥和私钥，<code>crypto</code> 实现签名代码如下。</p><figure class="highlight js"><figcaption><span>签名</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公钥和私钥</span></span><br><span class="line"><span class="keyword">let</span> publicKey = fs.readFileSync(</span><br><span class="line">  path.join(__dirname, <span class="string">'rsa_public.key'</span>),</span><br><span class="line">  <span class="string">'ascii'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> privateKey = fs.readFileSync(</span><br><span class="line">  path.join(__dirname, <span class="string">'rsa_private.key'</span>),</span><br><span class="line">  <span class="string">'ascii'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成签名</span></span><br><span class="line"><span class="keyword">let</span> sign = crypto.createSign(<span class="string">'RSA-SHA256'</span>);</span><br><span class="line">sign.update(<span class="string">'panda'</span>);</span><br><span class="line"><span class="keyword">let</span> signed = sign.sign(privateKey, <span class="string">'hex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证签名</span></span><br><span class="line"><span class="keyword">let</span> verify = crypto.createVerify(<span class="string">'RSA-SHA256'</span>);</span><br><span class="line">verify.update(<span class="string">'panda'</span>);</span><br><span class="line"><span class="keyword">let</span> verifyResult = verify.verify(publicKey, signed, <span class="string">'hex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(verifyResult); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>生成签名的 <code>sign</code> 方法有两个参数，第一个参数为私钥，第二个参数为生成签名的格式，最后返回的 <code>signed</code> 为生成的签名（字符串）。</p><p>验证签名的 <code>verify</code> 方法有三个参数，第一个参数为公钥，第二个参数为被验证的签名，第三个参数为生成签名时的格式，返回为布尔值，即是否通过验证。</p><blockquote class="pullquote primary"><p><em><strong>使用场景：经常用于对 cookie 签名返回浏览器，当浏览器访问同域服务器将 cookie 带过来时再进行验证，防止 cookie 被篡改和 CSRF 跨站请求伪造。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>各种项目在数据传输时根据信息的敏感度以及用途进行不同的加密算法和加密方式，在 NodeJS 中，<code>crypto</code> 的 API 完全可以实现我们的加密需求，也可以将上面的加密方案组合使用实现更复杂的加密方案。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 加密 </tag>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 服务器实现 gzip 压缩</title>
      <link href="/2018/07/18/20180718181823/"/>
      <url>/2018/07/18/20180718181823/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/18/20180718181823/gzip.png" title="NodeJS 实现 gzip 压缩"><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote class="pullquote success"><p>在浏览器向服务器请求静态资源时，服务器为了减小在网络传输过程中消耗的流量和时间，都是将静态资源经过压缩后返回给服务器的，实现压缩的算法有 <code>deflate</code> 和 <code>gzip</code> 等，最常用的是 <code>gzip</code> 压缩。</p></blockquote><a id="more"></a><h2 id="gzip-简介"><a href="#gzip-简介" class="headerlink" title="gzip 简介"></a>gzip 简介</h2><p>在浏览器和服务器之间通过 <code>gzip</code> 压缩流实现传输的过程可以用下图表示。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/18/20180718181823/how-gzip-works.png" alt="gzip 压缩工作原理" title>                </div>                <div class="image-caption">gzip 压缩工作原理</div>            </figure><p><br></p><p>当浏览器向服务器请求静态资源，服务器会将静态资源经过处理转换为压缩流，大大减小文件体积，然后将压缩流返回给浏览器，浏览器通过压缩的类型重新将压缩流解析成静态文件。</p><h2 id="zlib-模块的使用"><a href="#zlib-模块的使用" class="headerlink" title="zlib 模块的使用"></a>zlib 模块的使用</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>在 NodeJS 中通过 <code>zlib</code> 模块帮助我们实现不同类型的压缩，其实压缩的过程就是创建流的过程，创建的压缩流是 Transform 类型（转化流），读取文件的内容经过转化流创建一个新类型的文件。</p><figure class="highlight js"><figcaption><span>文件：gzip.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gzip</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理输入和输出的文件路径</span></span><br><span class="line">  <span class="keyword">let</span> sourcePath = path.join(__dirname, source);</span><br><span class="line">  <span class="keyword">let</span> gzipPath = <span class="string">`<span class="subst">$&#123;sourcePath&#125;</span>.gz`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建转化流</span></span><br><span class="line">  <span class="keyword">let</span> gzip = zlib.createGzip();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建可读流</span></span><br><span class="line">  <span class="keyword">let</span> rs = fs.createReadStream(sourcePath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建可写流</span></span><br><span class="line">  <span class="keyword">let</span> ws = fs.createWriteStream(gzipPath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现转化</span></span><br><span class="line">  rs.pipe(gzip).pipe(ws);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gzip(<span class="string">'index.html'</span>);</span><br></pre></td></tr></table></figure><p>执行上面代码查看根目路是否出现 <code>index.gz</code> 压缩包。</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>压缩的过程是可逆的，可以压缩就可以解压，无论是在浏览器还是在服务器，我们下面实现解压的方法。</p><figure class="highlight js"><figcaption><span>文件：gunzip.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gunzip</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理输入和输出的文件路径</span></span><br><span class="line">  <span class="keyword">let</span> sourcePath = path.join(__dirname, source);</span><br><span class="line">  <span class="keyword">let</span> filePath = path.join(__dirname, path.basename(source, <span class="string">'.gz'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建转化流</span></span><br><span class="line">  <span class="keyword">let</span> unzip = zlib.createGunzip();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建可读流</span></span><br><span class="line">  <span class="keyword">let</span> rs = createReadStream(sourcePath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建可写流</span></span><br><span class="line">  <span class="keyword">let</span> ws = createWriteStream(filePath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现转化</span></span><br><span class="line">  rs.pipe(unzip).pipe(ws);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gunzip(<span class="string">'index.html.gz'</span>);</span><br></pre></td></tr></table></figure><p>删除原来 <code>index.html</code>，执行解压代码，查看文件根目录是否生成 <code>index.html</code>。</p><h2 id="服务器的实现"><a href="#服务器的实现" class="headerlink" title="服务器的实现"></a>服务器的实现</h2><p>在浏览器与服务器的交互中，浏览器其实会通过请求头 <code>Accept-Encoding</code> 告诉服务器当前支持解压的压缩格式，值为 <code>gzip, deflate, br</code>，多个压缩格式用 <code>,</code> 隔开，服务器在接收到浏览器请求后，会按照请求头的格式压缩资源，将压缩后的资源返回，并通过响应头 <code>Content-Encoding</code> 告诉浏览器当前服务器压缩的格式。</p><figure class="highlight js"><figcaption><span>文件：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理 pathname，'/' 时默认读取 '/index.html'</span></span><br><span class="line">  <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  pathname = pathname !== <span class="string">'/'</span> ? pathname : <span class="string">'/index.html'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取读取文件的绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> p = path.join(__dirname, pathname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看路径是否合法</span></span><br><span class="line">  fs.access(p, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 路径不合法则直接中断连接</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> res.end(<span class="string">'Not Found'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取浏览器支持的压缩格式</span></span><br><span class="line">    <span class="keyword">let</span> encoding = req.headers[<span class="string">'accept-encoding'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可读流</span></span><br><span class="line">    <span class="keyword">let</span> rs = fs.createReadStream(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持 gzip 使用 gzip 压缩，支持 deflate 使用 deflate 压缩</span></span><br><span class="line">    <span class="keyword">if</span> (encoding &amp;&amp; encoding.match(<span class="regexp">/\bgzip\b/</span>)) &#123;</span><br><span class="line">      <span class="keyword">let</span> compress = zlib.createGzip();</span><br><span class="line">      <span class="keyword">let</span> compressType = <span class="string">'gzip'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding &amp;&amp; encoding.match(<span class="regexp">/\bdeflate\b/</span>)) &#123;</span><br><span class="line">      <span class="keyword">let</span> compress = zlib.createDeflate();</span><br><span class="line">      <span class="keyword">let</span> compressType = <span class="string">'deflate'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则直接返回可读流</span></span><br><span class="line">      <span class="keyword">return</span> rs.pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将压缩流返回并设置响应头</span></span><br><span class="line">    res.setHeader(<span class="string">'Content-Encoding'</span>, compressType);</span><br><span class="line">    rs.pipe(compress).pipe(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面服务器中如果不通过响应头通知浏览器当前资源的压缩格式，浏览器会不知道该如何解压，默认会当成文件下载，如 Chrome，所以在返回压缩流时必须通过 <code>Content-Encoding</code> 响应头通知浏览器当前的压缩格式。</p><h2 id="测试服务器压缩"><a href="#测试服务器压缩" class="headerlink" title="测试服务器压缩"></a>测试服务器压缩</h2><p>我们在文件根目录创建一个 <code>index.html</code> 文件，代码如下。</p><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>gzip<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello GZIP!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动服务器 <code>server.js</code>，然后通过浏览器访问 <a href="javascript:;" target="_blank" rel="noopener">localhost:3000</a>，查看页面能否正确返回，并查看开发者工具 Network 中的响应头 <code>Content-Encoding</code> 的值是否正确。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p>服务器压缩其实是客户端与服务器在网络传输时的一种优化手段，可以大大减小流量的消耗和响应时间，而 <code>gzip</code> 只是目前最常用的一种压缩格式，即压缩算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
            <tag> http-headers </tag>
            
            <tag> gzip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 实现多语言</title>
      <link href="/2018/07/17/20180717111807/"/>
      <url>/2018/07/17/20180717111807/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/17/20180717111807/multi-language.png" title="NodeJS 实现多语言"><p><br></p><h2 id="什么是多语言？"><a href="#什么是多语言？" class="headerlink" title="什么是多语言？"></a>什么是多语言？</h2><blockquote class="pullquote warning"><p>我们平时访问一些文档类型的网站时，经常可以看到页面右上角有一个下拉框用来选择当前页面支持的语言，并在选中后将整个网页的内容切换为选中的语言，这就是项目中的多语言，多语言可以根据浏览器请求发送的语言类型在服务器进行设置，也可以在请求服务器时返回多种语言，并根据权重和浏览器的支持情况进行选择和渲染。</p></blockquote><a id="more"></a><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>在本文中我们通过客户端向服务器发送请求告诉服务器客户端所支持的语言及权重，服务器检索语言包并根据客户端发送的语言类型和权重返回对应语言的内容。</p><p>在这个过程中客户端向服务器发送请求需要使用请求头 <code>Accept-Language</code>，值中设置语言类型和权重，语言与语言之间使用 <code>,</code> 隔开，语言与权重之间使用 <code>;</code> 隔开，权重用 <code>q</code> 表示，与值用 <code>=</code> 隔开，如果权重值为 <code>1</code> 则可省略（最大值），值的格式为 <code>zh-CN, zh;q=0.7, en;q=0.8, fr;q=0.1</code>。</p><p>服务器响应时，应通过响应头告诉浏览器返回的内容为何种语言，响应头为 <code>Content-Language</code>, 值的格式为 <code>zh-CN, en</code>，多个语言之间使用 <code>,</code> 隔开。</p><h2 id="服务器的实现"><a href="#服务器的实现" class="headerlink" title="服务器的实现"></a>服务器的实现</h2><figure class="highlight js"><figcaption><span>文件：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语言包</span></span><br><span class="line"><span class="keyword">const</span> languagesPackage = &#123;</span><br><span class="line">  <span class="string">'zh-CN'</span>: <span class="string">'你好'</span>,</span><br><span class="line">  <span class="string">'en'</span>: <span class="string">'Hello'</span>,</span><br><span class="line">  <span class="string">'fr'</span>: <span class="string">'Bonjour'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认语言为英语</span></span><br><span class="line">languagesPackage.defaultLanguage = <span class="string">'en'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取请求头中的语言和权重</span></span><br><span class="line">  <span class="keyword">let</span> languages = req.headers[<span class="string">'accept-language'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果客户端设置了语言</span></span><br><span class="line">  <span class="keyword">if</span> (languages) &#123;</span><br><span class="line">    <span class="comment">// 解析语言为 [&#123; name: 'zh-CN', q: 1 &#125;, &#123; name: 'en', q: '0.8' &#125;] 格式</span></span><br><span class="line">    <span class="keyword">let</span> lans = languages.split(<span class="string">','</span>).map(<span class="function"><span class="params">lang</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> [name, q = <span class="number">1</span>] = <span class="built_in">Object</span>.keys(</span><br><span class="line">        querystring.parse(lang.tirm(),</span><br><span class="line">        <span class="string">';q='</span></span><br><span class="line">      ));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; name, q &#125;;</span><br><span class="line">    &#125;).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.q - a.q); <span class="comment">// 并按照权重逆序排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环检测 languagesPackage 是否存在客户端的语言</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lans.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; name &#125; = lans[i];</span><br><span class="line">      <span class="keyword">let</span> content = languagesPackage[name];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果存在直接设置响应头并返回内容</span></span><br><span class="line">      <span class="keyword">if</span> (content) &#123;</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, name);</span><br><span class="line">        <span class="keyword">return</span> res.end(content);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果客户端没设置语言活语言找不到时返回服务器设置的默认语言</span></span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, languagesPackage.defaultLanguage);</span><br><span class="line">  res.end(languagesPackage[languagesPackage.defaultLanguage]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实上面服务器和客户端配合实现多语言的思路就是客户端向服务器发送 <code>Accept-Language</code> 告诉服务器需要的语言和权重，服务器解析后根据权重从大到小排序，然后循环判断语言包中是否含有客户端需要的语言，如果有，则中断循环直接设置响应头和返回对应内容，如果不存在客户端的需要的语言或者客户端没有向后台发送 <code>Accept-Language</code> 则返回服务器默认设置的语言类型和内容。</p><h2 id="验证多语言"><a href="#验证多语言" class="headerlink" title="验证多语言"></a>验证多语言</h2><p>为了方便我们使用 <code>curl</code> 模拟客户端向服务器发送请求查看返回内容是否正确，之所以使用 <code>curl</code> 是因为只发送验证的请求，方便设置 <code>Accept-Language</code> 请求头，更灵活的控制多语言的类型和权重。</p><p>启动服务器 <code>server.js</code>，打开命令行窗口，输入下面的命令执行，查看返回命令行响应体中的内容和设置的语言是否对应。</p><blockquote><p>curl -v --header “Accept-Language: zh-CN, zh;q=0.7, en;q=0.8, fr;q=0.1” <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>这样我们就实现了一个简单的多语言，其实真正的多语言在服务器是需要做繁琐的解析和性能优化的（只解析界面有的单词返回，保证响应体中的内容最小），在前端可以通过 JavaScript 的库 <code>il8n</code>（国际化语言包）来实现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
            <tag> http-headers </tag>
            
            <tag> multi-language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 服务器数据处理（表单、json 字符串和普通字符串）</title>
      <link href="/2018/07/16/20180716155948/"/>
      <url>/2018/07/16/20180716155948/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/16/20180716155948/form-submit.png" title="NodeJS 处理不同类型数据"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p>从浏览器向服务器提交数据时，常见有表单提交，JSON 字符串提交和普通字符串提交，不同情况需要附带不同的请求头信息，告诉服务器客户端可以直接解析的数据格式，如果发送的数据为 <code>json</code> 字符串，后两种类型都可以成功发送到服务器，只是加上请求头信息服务器更容易判断该以什么格式返回数据。</p></blockquote><a id="more"></a><h2 id="querystring-模块解析请求体"><a href="#querystring-模块解析请求体" class="headerlink" title="querystring 模块解析请求体"></a>querystring 模块解析请求体</h2><p>在 <code>get</code> 请求中，我们可以通过 <code>url</code> 模块的 <code>parse</code> 方法来解析，如果是带有请求体的请求类型，如 <code>post</code>、<code>put</code> 我们应该使用 <code>querystring</code> 模块的 <code>parse</code> 方法将请求体中的数据解析成对象，在这个方法中有三个参数。</p><ul><li>str：要解析的查询字符串；</li><li>sep：查询字符串中键值对之间的分隔符，默认为 <code>&amp;</code>；</li><li>eq：查询字符串中的键与值的分隔符，默认为 <code>=</code>。</li></ul><figure class="highlight js"><figcaption><span>文件：querystring-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">'name=pandashen&amp;age=27'</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">'name*pandashen!&amp;age*27'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = querystring.parse(str1);</span><br><span class="line"><span class="keyword">let</span> obj2 = querystring.parse(str2, <span class="string">'!&amp;'</span>, <span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123; name: 'pandashen', age: '27'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123; name: 'pandashen', age: '27'&#125;</span></span><br></pre></td></tr></table></figure><p><code>querystring</code> 也是很常用的模块，就在这里多说几句关于原理相关的内容，模拟 <code>querystring</code> 模块常用方法 <code>parse</code> 的代码如下。</p><figure class="highlight js"><figcaption><span>文件：my-querystring.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exports.parse = <span class="function">(<span class="params">str, sep = <span class="string">'&amp;'</span>, eq = <span class="string">'='</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 存储解析出键值的对象</span></span><br><span class="line">  <span class="keyword">const</span> query = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先将查询字符串切割成 [k=v, k=b] 的形式</span></span><br><span class="line">  <span class="keyword">const</span> fields = str.split(sep);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环将每一项切割成 k 和 v 并存入 queryObj 中</span></span><br><span class="line">  fields.forEach(<span class="function"><span class="params">field</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> [key, value] = field.split(eq);</span><br><span class="line">    query[key] = value;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 query 对象</span></span><br><span class="line">  <span class="keyword">return</span> query;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="服务器的实现"><a href="#服务器的实现" class="headerlink" title="服务器的实现"></a>服务器的实现</h2><p>向服务器发送请求的请求头为 <code>Content-Type</code>，表单提交、<code>json</code> 和字符串作为请求体时，在 <code>Content-Type</code> 中对应的值分别为 <code>application/x-www-form-urlencoded</code>、<code>application/json</code> 和 <code>text/plain</code>。</p><p>其中 <code>text/plain</code> 为 Ajax 的默认提交方式，我们在服务器中针对上面这几种类型的请求头和 <code>get</code> 请求做处理，将发来的数据再次返回客户端。</p><figure class="highlight js"><figcaption><span>文件：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取 get 请求参数</span></span><br><span class="line">  <span class="keyword">let</span> &#123; query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 获取数据类型请求头</span></span><br><span class="line">  <span class="keyword">let</span> type = req.headers[<span class="string">'content-type'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收数据</span></span><br><span class="line">  <span class="keyword">const</span> buffers = [];</span><br><span class="line">  res.on(<span class="string">'data'</span>, data =&gt; buffers.push(data));</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 合并数据并设置默认响应头和返回数据</span></span><br><span class="line">    <span class="keyword">let</span> data = Buffer.concat(buffers).toString();</span><br><span class="line">    <span class="keyword">let</span> contentType = <span class="string">'application/json'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为 get 请求，是则直接返回解析后的数据，不是则判断请求类型</span></span><br><span class="line">    <span class="keyword">if</span> (req.method.toLowerCase() === <span class="string">'get'</span>) &#123;</span><br><span class="line">      data = <span class="built_in">JSON</span>.stringify(query);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 判断请求数据类型并做相应处理</span></span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">'application/x-www-form-urlencoded'</span>) &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.stringify(querystring.parse(str));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'application/json'</span>) &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(str));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contentType = <span class="string">'text/plain'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应头并返回数据</span></span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, contentType);</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求类型为 <code>get</code>，将 URL 的查询字符串通过 <code>url</code> 模块解析后再处理成字符串返回客户端。</p><p>当请求类型为 <code>post</code>，设置默认响应头为 <code>application/json</code>，如果是表单提交，请求体中的内容为查询字符串格式，使用 <code>querystring</code> 解析后再使用 <code>JSON.stringify</code> 处理成字符串返回，如果是 <code>json</code>，则使用 <code>JSON.parse</code> 解析，并使用 <code>JSON.stringify</code> 处理成字符串返回，如果是默认值 <code>text/plain</code>，则设置响应头的值为 <code>text/plain</code> 并将读取的结果直接返回。</p><h2 id="使用客户端进行测试"><a href="#使用客户端进行测试" class="headerlink" title="使用客户端进行测试"></a>使用客户端进行测试</h2><p>在这里我们为了方便就不用浏览器访问了，因为上面的服务器代码比较简单，只处理了数据，并没有处理静态文件请求，所以我们通过 NodeJS 来实现客户端。</p><h3 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h3><figure class="highlight js"><figcaption><span>文件：get.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/?name=pandashen&amp;age=27'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 get 请求</span></span><br><span class="line">http.get(config, res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">  <span class="keyword">const</span> buffers = [];</span><br><span class="line">  res.on(<span class="string">'data'</span>, data =&gt; buffers.push(data));</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = Buffer.concat(buffers).toString();</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动服务器 <code>server.js</code>，通过命令行执行 <code>node get.js</code> 查看命令窗口中输出的结果。</p><h3 id="post-请求表单提交"><a href="#post-请求表单提交" class="headerlink" title="post 请求表单提交"></a>post 请求表单提交</h3><figure class="highlight js"><figcaption><span>文件：post-from.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  method: <span class="string">'post'</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">http.request(config, res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">  <span class="keyword">const</span> buffers = [];</span><br><span class="line">  res.on(<span class="string">'data'</span>, data =&gt; buffers.push(data));</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = Buffer.concat(buffers).toString();</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).end(<span class="string">'name=pandashen&amp;age=27'</span>);</span><br></pre></td></tr></table></figure><p>启动服务器 <code>server.js</code>，通过命令行执行 <code>node post-form.js</code> 查看命令窗口中输出的结果。</p><h3 id="post-请求-json-字符串数据"><a href="#post-请求-json-字符串数据" class="headerlink" title="post 请求 json 字符串数据"></a>post 请求 json 字符串数据</h3><figure class="highlight js"><figcaption><span>文件：post-json.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">http.request(config, res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">  <span class="keyword">const</span> buffers = [];</span><br><span class="line">  res.on(<span class="string">'data'</span>, data =&gt; buffers.push(data));</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = Buffer.concat(buffers).toString();</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).end(<span class="string">'&#123; name: pandashen, age: 27 &#125;'</span>);</span><br></pre></td></tr></table></figure><p>启动服务器 <code>server.js</code>，通过命令行执行 <code>node post-json.js</code> 查看命令窗口中输出的结果。</p><h3 id="post-请求普通字符串数据"><a href="#post-请求普通字符串数据" class="headerlink" title="post 请求普通字符串数据"></a>post 请求普通字符串数据</h3><figure class="highlight js"><figcaption><span>文件：post-string.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">http.request(config, res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">  <span class="keyword">const</span> buffers = [];</span><br><span class="line">  res.on(<span class="string">'data'</span>, data =&gt; buffers.push(data));</span><br><span class="line">  res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = Buffer.concat(buffers).toString();</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).end(<span class="string">'pandashen27'</span>);</span><br></pre></td></tr></table></figure><p>启动服务器 <code>server.js</code>，通过命令行执行 <code>node post-string.js</code> 查看命令窗口中输出的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>通过本篇的内容可以了解 HTTP 在数据传输中的类型，即请求头类型，服务端通过请求头类型可以返回客户端可以直接解析的数据，上面的几种类型只是向服务器提交数据的最常见类型，涵盖表单提交和 Ajax 等，在上传文件时还存在二进制传输等等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
            <tag> http-headers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 服务器实现资源防盗链</title>
      <link href="/2018/07/14/20180714150009/"/>
      <url>/2018/07/14/20180714150009/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/14/20180714150009/resource-security.png" title="NodeJS 资源防盗链"><p><br></p><h2 id="什么是-“盗链”？"><a href="#什么是-“盗链”？" class="headerlink" title="什么是 “盗链”？"></a>什么是 “盗链”？</h2><blockquote class="pullquote primary"><p>“盗链” 说白了就是利用别人网站的资源链接放在自己的站点，在未经允许的情况下去获取别人网站里面的图片或者视频等资源，导致资源所有者的网站的流量费用增加或收入减少，为了防止资源链接随意被人盗用的手段被称为 “防盗链”。</p></blockquote><a id="more"></a><h2 id="模拟-“盗链”-场景"><a href="#模拟-“盗链”-场景" class="headerlink" title="模拟 “盗链” 场景"></a>模拟 “盗链” 场景</h2><p>我们先来模拟一下 “盗链” 场景，在本地启动服务运行 <code>hotlinking.html</code> 文件，并在文件中盗用百度视频的图片资源，看看效果。</p><figure class="highlight html"><figcaption><span>文件：hotlinking.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>盗链<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://c.hiphotos.baidu.com/c9f1faaf51f2de66ad.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们通过 <code>http-server</code> 来启动服务器访问 <code>hotlinking.html</code>，使用 <code>http-server</code> 需全局安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server install -g</span><br></pre></td></tr></table></figure><p>在服务中打开 <code>hotlinking.html</code> 后我们发现图片并不是我们盗用链接的资源，而是变成了下面这张图片。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/14/20180714150009/embezzle.png" alt="百度盗链返回图片" title>                </div>                <div class="image-caption">百度盗链返回图片</div>            </figure><p><br></p><p>这张图用来提醒我们盗用了别人资源，是因为百度的服务器做了防盗链处理，如果所有盗用别人的资源都变成这样，盗用也就没有实际意义了，我们本篇就通过 NodeJS 来实现防盗链处理，用来保护自己站点的资源。</p><blockquote class="pullquote warning"><p><em><strong>注意：具备防盗链处理的网站的资源链接可以直接通过浏览器地址栏访问，也可以在文件域（file 协议）访问，限制的是在未经允许的情况下其他服务器的访问。</strong></em></p></blockquote><h2 id="NodeJS-服务器实现防盗链"><a href="#NodeJS-服务器实现防盗链" class="headerlink" title="NodeJS 服务器实现防盗链"></a>NodeJS 服务器实现防盗链</h2><h3 id="模拟两个域名"><a href="#模拟两个域名" class="headerlink" title="模拟两个域名"></a>模拟两个域名</h3><p><strong>在本地的 hosts 文件中加入两个域名：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   panda.com</span><br><span class="line">127.0.0.1   shen.com</span><br></pre></td></tr></table></figure><h3 id="准备图片资源"><a href="#准备图片资源" class="headerlink" title="准备图片资源"></a>准备图片资源</h3><p>在根目录创建文件夹 <code>public</code> 并存入两张图片，<code>success.png</code> 是正常请求的图片资源，<code>error.png</code> 是经过防盗链处理后返回的图片资源，两张图片如下。</p><p><strong>正常返回的图片资源 success.png：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/14/20180714150009/success.png" alt="正常返回资源" title>                </div>                <div class="image-caption">正常返回资源</div>            </figure><p><br></p><p><strong>防盗链处理后返回的图片资源 error.png：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/14/20180714150009/error.png" alt="盗链返回资源" title>                </div>                <div class="image-caption">盗链返回资源</div>            </figure><p><br></p><h3 id="页面-index-html"><a href="#页面-index-html" class="headerlink" title="页面 index.html"></a>页面 index.html</h3><p>在页面当中通过 <code>img</code> 标签分别访问 <a href="javascript">shen.com</a>、<a href="javascript">panda.com</a> 和 <a href="javascript">localhost</a> 域下的 <code>success.png</code> 文件。</p><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>盗链<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://panda.com:3000/success.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://shen.com:3000/success.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://localhost:3000/success.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务端-server-js"><a href="#服务端-server-js" class="headerlink" title="服务端 server.js"></a>服务端 server.js</h3><p><strong>在写服务端代码之前需要介绍两个重要的请求头：</strong></p><ul><li>host：资源所在的域</li><li>referer：请求来源的域</li></ul><p>其实资源防盗就是设置白名单，通过检测 <code>referer</code> 是否在白名单中，如果在则正常返回资源，不存在则返回经过防盗链处理的资源。</p><blockquote class="pullquote info"><p><em><strong>注意：referer 请求头在地址栏输入地址时发送的请求是不存在的（如请求 index.html 页面），在旧版本的 HTTP 协议中 <code>referer</code> 的写法为 <code>referered</code>，所以为了兼容旧版本协议应该做兼容处理。</strong></em></p></blockquote><figure class="highlight js"><figcaption><span>文件：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'mz/fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(responseImages); <span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">static</span> = path.resolve(__dirname, <span class="string">'public'</span>); <span class="comment">// 静态资源目录</span></span><br><span class="line"><span class="keyword">let</span> whiteList = [<span class="string">'shen.com'</span>]; <span class="comment">// 白名单</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">responseImages</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 解析 url 中的文件目录处理成绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> p = path.join(<span class="keyword">static</span>, url.parse(req.url).pathname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测文件路径是否合法，不合法直接返回 Not Found</span></span><br><span class="line">  <span class="keyword">let</span> isExist = <span class="keyword">await</span> fs.exists(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    <span class="comment">// 获取 referer</span></span><br><span class="line">    <span class="keyword">let</span> refer = req.headers[<span class="string">'referer'</span>] || req.headers[<span class="string">'referered'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在 referer 继续检测</span></span><br><span class="line">    <span class="keyword">if</span> (refer) &#123;</span><br><span class="line">      <span class="comment">// 请求资源存在 referer，做防盗链处理</span></span><br><span class="line">      <span class="keyword">let</span> referHost = url.parse(refer).hostname;</span><br><span class="line">      <span class="keyword">let</span> host = req.headers[<span class="string">'host'</span>].split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当访问源的域和资源所在的域不是同一个域，做防盗链处理</span></span><br><span class="line">      <span class="keyword">if</span> (referHost !== host) &#123;</span><br><span class="line">        <span class="keyword">let</span> isInWhiteList = whiteList.includes(refer);</span><br><span class="line">        p = isInWhiteList ? p : path.join(<span class="keyword">static</span>, <span class="string">'error.png'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次访问请求页面 index.html，不存在 referer，将静态资源返回</span></span><br><span class="line">    <span class="comment">// 第二次访问请求图片资源，如果 referer 和资源所本就是同一个域，直接将资源返回</span></span><br><span class="line">    fs.createReadStream(p).pipe(res);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实上面的服务器是 <a href="javascript:;" target="_blank" rel="noopener">shen.com</a>、<a href="javascript:;" target="_blank" rel="noopener">panda.com</a> 和 <a href="javascript:;" target="_blank" rel="noopener">localhost</a> 所共用的，只是通过不同的域名访问。</p><p>启动服务器，然后通过 <a href="javascript:;" target="_blank" rel="noopener">localhost:3000</a> 访问，此时由于与 <a href="javascript:;" target="_blank" rel="noopener">shen.com</a> 和 <a href="javascript:;" target="_blank" rel="noopener">panda.com</a> 为不同域，所以只有第三张图片返回 <code>success.png</code>。</p><p>通过 <a href="javascript:;" target="_blank" rel="noopener">shen.com:3000</a> 访问，由于存在白名单中，所以三张图片都返回 <code>success.png</code>。</p><p>通过 <a href="javascript:;" target="_blank" rel="noopener">panda.com:3000</a> 访问，由于 <a href="javascript:;" target="_blank" rel="noopener">shen.com</a> 在不同域，所以没有返回 <code>success.png</code>。</p><blockquote class="pullquote primary"><p>无论通过 <a href="javascript:;" target="_blank" rel="noopener">shen.com</a> 还是 <a href="javascript:;" target="_blank" rel="noopener">panda.com</a> 访问 <a href="javascript:;" target="_blank" rel="noopener">localhost</a> 的资源都是在同域的，所以都能获取到。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在上面我们利用本地服务实现了一个最基本的防盗链，思路就是 <code>referer</code> 与资源同域，正常返回，不同域检测白名单，在真实的开发场景可能会更细化，更复杂一些，其实整个防盗链实现的核心就是利用 HTTP 的 <code>referer</code> 和 <code>host</code> 请求头做检测，希望通过本篇的学习，大家可以对资源防盗链有所了解，并在后面开发类似功能时提供思路。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
            <tag> http-headers </tag>
            
            <tag> 资源防盗链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 使用 Range 请求实现下载功能</title>
      <link href="/2018/07/13/20180713130808/"/>
      <url>/2018/07/13/20180713130808/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/13/20180713130808/byte-range.png" title="HTTP 范围请求"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>本篇使用 NodeJS 的 HTTP 服务创建客户端，使用 Range 请求实现下载功能，并通过本篇的 Demo 扩展在业务中实现断点续传等功能的思路。</p></blockquote><a id="more"></a><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>我们通过 <code>http</code> 模块创建服务器处理 Range 请求，在服务器代码中我们为了减少回调嵌套使用 <code>async</code> 函数，所以需要将异步的操作方法转换成 Promise，以往我们使用 <code>util</code> 的 <code>promisify</code> 来一个一个转换异步方法，比较麻烦，我们这次使用第三方模块 <code>mz</code> 并直接引入转换好的替代模块。</p><p>使用 <code>mz</code> 之前需要先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mz</span><br></pre></td></tr></table></figure><p>服务端代码如下：</p><figure class="highlight js"><figcaption><span>文件：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 mz 模块转换成 Promise 的 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'mz/fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求处理函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 range 请求头，格式为 Range:bytes=0-5</span></span><br><span class="line">  <span class="keyword">let</span> range = req.headers[<span class="string">'range'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下载文件路径</span></span><br><span class="line">  <span class="keyword">let</span> p = path.resovle(__dirname, url.parse(url, <span class="literal">true</span>).pathname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存在 range 请求头将返回范围请求的数据</span></span><br><span class="line">  <span class="keyword">if</span> (range) &#123;</span><br><span class="line">    <span class="comment">// 获取范围请求的开始和结束位置</span></span><br><span class="line">    <span class="keyword">let</span> [, start, end] = range.match(<span class="regexp">/(\d*)-(\d*)/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> statObj = <span class="keyword">await</span> fs.stat(p);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件总字节数</span></span><br><span class="line">    <span class="keyword">let</span> total = statObj.size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求头中范围参数不传的问题</span></span><br><span class="line">    start = start ? ParseInt(start) : <span class="number">0</span>;</span><br><span class="line">    end = end ? ParseInt(end) : total - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应客户端</span></span><br><span class="line">    res.statusCode = <span class="number">206</span>;</span><br><span class="line">    res.setHeader(<span class="string">'Accept-Ranges'</span>, <span class="string">'bytes'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Range'</span>, <span class="string">`bytes <span class="subst">$&#123;start&#125;</span>-<span class="subst">$&#123;end&#125;</span>/<span class="subst">$&#123;total&#125;</span>`</span>);</span><br><span class="line">    fs.createReadStream(p, &#123; start, end &#125;).pipe(res);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有 range 请求头时将整个文件内容返回给客户端</span></span><br><span class="line">    fs.createReadStream(p).pipe(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(listener);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面服务端的代码中，需要兼容 Range 请求和普通请求，两种请求的区别是，如果客户端发送的是 Range 请求，会携带 <code>Range:bytes=0-5</code> 格式的请求头，我们可以通过 <code>req</code> 的 <code>headers</code> 属性获取，在获取请求头时，原本大写字母开头 NodeJS 统一处理成小写，所以获取时应小写。</p><p>如果是 Range 请求则通过可读流读取对应的内容返回客户端，如果不是，则通过可读流读取整个文件返回客户端，在响应 Range 请求的过程中需要设置响应状态为 <code>206</code>，需要设置响应头 <code>Accept-Ranges</code> 值为 <code>bytes</code>，需要设置响应头 <code>Content-Range</code> 值为 <code>byte 0-5/100</code> 的格式，<code>0</code> 为返回数据开始的索引，<code>5</code> 为结束的索引（包含），<code>100</code> 为文件的总字节数。</p><p>在通过 <code>url</code> 和 <code>path</code> 模块解析和拼接下载文件路径时，应该进行错误检测，如果文件不存在则直接返回客户端 <code>Not Found</code>。</p><p>我们可以使用 <code>curl</code> 命令来检测我们的服务端代码，在命令行工具中输入下面命令，在命令窗口查看返回值是否正确。</p><blockquote><p>curl -v --header “Range:bytes=0-5” <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000</a></p></blockquote><h2 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h2><p>在上面使用 <code>curl</code> 命令来访问我们的服务器时，只能请求固定范围的数据，而不是类似于下载功能，每次都下载一个范围的数据，但是想要多次下载并自动维护 Range 的范围需要借助我们自己实现的客户端逻辑。</p><p>为了简便，我们的下载客户端是在命令行窗口运行的，通过指令来模拟实际项目中的开始下载、暂停和恢复按钮，当在窗口中输入 <code>s</code> 指令时开始下载，输入 <code>p</code> 指令时暂停下载，输入 <code>r</code> 指令时恢复下载。</p><figure class="highlight js"><figcaption><span>文件：client.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/download.txt'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="number">0</span>; <span class="comment">// 请求初始值</span></span><br><span class="line"><span class="keyword">let</span> step = <span class="number">5</span>; <span class="comment">// 每次请求字符个数</span></span><br><span class="line"><span class="keyword">let</span> pause = <span class="literal">false</span>; <span class="comment">// 暂停状态</span></span><br><span class="line"><span class="keyword">let</span> total; <span class="comment">// 文件总长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可写流</span></span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(path.resolve(__dirname, config.path.slice(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 配置，每次范围请求 step 个字节</span></span><br><span class="line">  config.headers = &#123;</span><br><span class="line">      <span class="string">'Range'</span>: <span class="string">`bytes=<span class="subst">$&#123;start&#125;</span>-<span class="subst">$&#123;start + step - <span class="number">1</span>&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护下次 start 的值</span></span><br><span class="line">  start += step;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送请求</span></span><br><span class="line">  http.request(config, res =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取文件总长度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> total !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      total = res.headers[<span class="string">'content-ranges'</span>].match(<span class="regexp">/\/(\d*)/</span>)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取返回数据</span></span><br><span class="line">    <span class="keyword">const</span> buffers = [];</span><br><span class="line">    res.on(<span class="string">'data'</span>, data =&gt; buffers.push(data));</span><br><span class="line">    res.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// 合并数据并写入文件</span></span><br><span class="line">      <span class="keyword">let</span> buf = Buffer.concat(buffers);</span><br><span class="line">      ws.write(buf);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递归进行下一次请求</span></span><br><span class="line">      <span class="keyword">if</span> (!pause &amp;&amp; start &lt; total) &#123;</span><br><span class="line">        download();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监控输入</span></span><br><span class="line">process.stdin.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取指令</span></span><br><span class="line">  <span class="keyword">let</span> ins = data.toString().match(<span class="regexp">/(\w*)\/r/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">switch</span> (ins) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">      pause = <span class="literal">false</span>;</span><br><span class="line">      download();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">      pause = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面代码中下载的文件通过 <code>config</code> 中的 <code>path</code> 属性配置，每次调用 <code>download</code> 函数下载时都会重新计算当前范围请求的初始位置和结束位置，并设置 Range 请求头，下一次请求靠递归 <code>download</code> 来实现。</p><p>在执行时需先启动我们的服务器，在通过命令行输入 <code>node client.js</code> 来启动客户端，在命令窗口输入对应的指令进行开始下载、暂停下载和恢复下载操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>相信现在已经了解什么是范围请求，范围请求客户端和服务端需要做些什么，其实说白了就是对应的请求头和响应头的使用，需要注意的是范围请求的响应状态码为 <code>206</code>，这样的需求在一些上传、下载资源的网站也很常见，其目的就是为了让我们实现断点续传，不至于一次没有上传或下载完成的资源文件，在下一次的做同样操作时需要重新来过，可以接着上次的位置继续，范围请求在视频网站上也广泛应用，边请求边观看，不至于一次加载整个视频资源，节省流量，节省时间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
            <tag> 范围请求 </tag>
            
            <tag> http-headers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 搭建 HTTP 服务器</title>
      <link href="/2018/07/12/20180712195514/"/>
      <url>/2018/07/12/20180712195514/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/12/20180712195514/your-first-node-server.png" title="HTTP 服务器"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p>在 NodeJS 中用来创建服务的模块是 <code>http</code> 核心模块，本篇就来介绍关于使用 <code>http</code> 模块搭建 HTTP 服务器和客户端的方法，以及模块的基本 API。</p></blockquote><a id="more"></a><h2 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h2><h3 id="创建-HTTP-服务器"><a href="#创建-HTTP-服务器" class="headerlink" title="创建 HTTP 服务器"></a>创建 HTTP 服务器</h3><p>在 NodeJS 中，创建 HTTP 服务器可以与 <code>net</code> 模块创建 TCP 服务器对比，创建服务器有也两种方式。</p><p><strong>方式 1：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>方式 2：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>在 <code>createServer</code> 的回调和 <code>request</code> 事件的回调函数中有两个参数，<code>req</code>（请求）、<code>res</code>（响应），基于 <code>socket</code>，这两个对象都是 Duplex 类型的可读可写流。</p><p><code>http</code> 模块是基于 <code>net</code> 模块实现的，所以 <code>net</code> 模块原有的事件在 <code>http</code> 中依然存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// net 模块事件</span></span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'连接成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h3 id="获取请求信息"><a href="#获取请求信息" class="headerlink" title="获取请求信息"></a>获取请求信息</h3><p>在请求对象 <code>req</code> 中存在请求的方法、请求的 <code>url</code>（包含参数，即查询字符串）、当前的 HTTP 协议版本和请求头等信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.method); <span class="comment">// 获取请求方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.url); <span class="comment">// 获取请求路径（包含查询字符串）</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.httpVersion); <span class="comment">// 获取 HTTP 协议版本</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.headers); <span class="comment">// 获取请求头（对象）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取请求体的内容</span></span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    arr.push(data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Buffer.concat(arr).toString());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 <code>req</code> 对应的属性可以拿到请求行和请求首部的信息，请求体内的内容通过流操作来获取，其中 <code>url</code> 中存在多个有用的参数，我们自己处理会很麻烦，可以通过 NodeJS 的核心模块 <code>url</code> 进行解析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">let</span> str =</span><br><span class="line">  <span class="string">'http://user:pass@www.pandashen.com:8080/src/index.html?a=1&amp;b=2#hash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse 方法帮助我们解析 url 路径</span></span><br><span class="line"><span class="keyword">let</span> obj = url.parse(str, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   protocol: 'http:',</span></span><br><span class="line"><span class="comment">//   slashes: true,</span></span><br><span class="line"><span class="comment">//   auth: 'user:pas',</span></span><br><span class="line"><span class="comment">//   host: 'www.pandashen.com:8080',</span></span><br><span class="line"><span class="comment">//   port: '8080',</span></span><br><span class="line"><span class="comment">//   hostname: 'www.pandashen.com',</span></span><br><span class="line"><span class="comment">//   hash: '#hash',</span></span><br><span class="line"><span class="comment">//   search: '?a=1&amp;b=2',</span></span><br><span class="line"><span class="comment">//   query: '&#123; a: '1', b: '2' &#125;',</span></span><br><span class="line"><span class="comment">//   pathname: '/src/index.html'</span></span><br><span class="line"><span class="comment">//   path: '/src/index.html?a=1&amp;b=2',</span></span><br><span class="line"><span class="comment">//   href: `http://user:pass@www.pandashen.com:8080</span></span><br><span class="line"><span class="comment">//     /src/index.html?a=1&amp;b=2#hash`</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>在被解析路径返回的对象中有几个属性被经常使用：</strong></p><ul><li>host：主机（域名 + 端口号）；</li><li>hostname：主机名；</li><li>query：请求参数（查询字符串或参数对象）；</li><li>pathname：资源路径（根据不同的路径返回不同的资源）。</li></ul><p>我们使用 <code>url</code> 的 <code>parse</code> 方法来帮我们解析请求路径，在真实的服务器中传入的第一个参数为 <code>req.url</code>，第二个参数不传时，<code>query</code> 会被解析成 <code>a=1&amp;b=2</code> 的形式，第二个参数传入 <code>true</code>，<code>query</code> 属性的查询字符串会被解析成对象的形式。</p><p><code>url</code> 模块中，将查询字符串 <code>a=1&amp;b=2</code> 转换为对象 <code>{ a: &#39;1&#39;, b: &#39;2&#39; }</code> 的实现方式其实是使用正则替换实现的。</p><p><strong>模拟查询字符串转换对象的核心逻辑：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'a=1&amp;b=2&amp;c=3'</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">str.replace(<span class="regexp">/([^=&amp;]+)=([^=&amp;]+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  obj[<span class="built_in">arguments</span>[<span class="number">1</span>]] = <span class="built_in">arguments</span>[<span class="number">2</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: '1', b: '2', c: '3' &#125;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>在上面代码的 <code>replace</code> 方法的回调函数中参数集合的第一项为匹配到的字符串，第二项为第一个分组的值，第三项为第二个分组的值，依次类推，倒数第二项为分组匹配的索引，最后一项为原字符串。</p></blockquote><h3 id="设置响应信息"><a href="#设置响应信息" class="headerlink" title="设置响应信息"></a>设置响应信息</h3><p>我们可以通过 <code>req</code> 来获取请求信息，自然也可以通过 <code>res</code> 来设置响应信息返回给客户端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置响应头（过去的用法），不能多次调用，见到要认识</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text'</span>, <span class="attr">a</span>: <span class="string">'hello world'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置响应头（现在的用法，常用），可以多次调用，每次设置一个响应头</span></span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置状态码，不设置默认为 200</span></span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不发送 Date（日期）响应头</span></span><br><span class="line">  res.sendDate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回内容</span></span><br><span class="line">  res.write(<span class="string">'hello world'</span>); <span class="comment">// 不会关闭连接</span></span><br><span class="line">  res.end(<span class="string">'hello world'</span>); <span class="comment">// 将内容返回后关闭连接</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回给客户端的信息主要分为两部分，分别为响应头和返回给浏览器的内容，在不设置响应头的情况下，默认会设置响应头 <code>Content-Length</code> 和 <code>Date</code> ，代表当前返回给客户端的内容长度和日期。</p><p>返回给浏览器的内容可以通过 <code>res</code> 的 <code>write</code> 方法和 <code>end</code> 方法进行发送，<code>write</code> 方法不会断开连接（通常在响应后需要断开与客户端的连接），<code>end</code> 方法会断开连接，在 <code>end</code> 方法存在参数时，会在内部调用 <code>write</code> 将参数内容返回给客户端，并断开连接。</p><h2 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h2><p>在 <code>net</code> 模块中可以通过 <code>net.createConnection</code> 来创建客户端，并发送请求到服务端，在 <code>http</code> 模块同样可以创建客户端，并向 <code>http</code> 服务器发送请求。</p><figure class="highlight js"><figcaption><span>客户端：client.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求的配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建客户端</span></span><br><span class="line"><span class="keyword">const</span> client = http.request(config, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收服务端返回的数据</span></span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line"></span><br><span class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    arr.push(data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Buffer.concat(arr).toString());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">client.end();</span><br></pre></td></tr></table></figure><p>在 <code>http</code> 模块中通过 <code>request</code> 方法创建客户端，该方法第一个参数为发送请求的配置，包含请求地址、端口号、请求方法以及请求头等，第二个参数为回调函数，在请求被响应后执行，回调函数的参数为服务器的响应对象 <code>res</code>，创建的客户端通过 <code>end</code> 方法将请求发出与服务端进行通信。</p><blockquote class="pullquote info"><p>使用 NodeJS 实现的 “爬虫” 其实就可以通过 <code>http</code> 模块创建的客户端来实现，客户端帮我们向我们要抓取数据的地址发送请求，并拿到响应的数据进行解析。</p></blockquote><h2 id="同时使用-HTTP-客户端和服务器"><a href="#同时使用-HTTP-客户端和服务器" class="headerlink" title="同时使用 HTTP 客户端和服务器"></a>同时使用 HTTP 客户端和服务器</h2><p>我们使用自己创建的客户端访问自己的服务端，并体会请求响应的过程，就是用上面 <code>client.js</code> 作为客户端，启动 <code>server.js</code> 后再启动 <code>client.js</code> 查看效果。</p><figure class="highlight js"><figcaption><span>服务器：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The request came'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取客户端请求信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.method);</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回数据</span></span><br><span class="line">  res.write(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="简易爬虫"><a href="#简易爬虫" class="headerlink" title="简易爬虫"></a>简易爬虫</h2><p>我们结合 <code>http</code> 模块创建的服务端和客户端实现一个简易版的 “爬虫” 去抓取百度新闻页所有 <code>li</code> 标签内的文章标题。</p><figure class="highlight js"><figcaption><span>简易爬虫：crawl.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听请求</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> client = http.request(</span><br><span class="line">    &#123;</span><br><span class="line">      host: <span class="string">'news.baidu.com'</span>,</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      port: <span class="number">80</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 接收百度新闻返回的数据</span></span><br><span class="line">      <span class="keyword">const</span> arr = [];</span><br><span class="line"></span><br><span class="line">      r.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        arr.push(data);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      r.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        <span class="keyword">let</span> result = Buffer.concat(arr).toString();</span><br><span class="line">        <span class="keyword">let</span> matches = result.match(<span class="regexp">/&lt;li class='bold-item'&gt;([\s\S*?])&lt;\/li&gt;/gm</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置返回给浏览器的文档类型和编码格式</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应浏览器</span></span><br><span class="line">        res.end(matches.join(<span class="string">''</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  client.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面的正则匹配中 <code>([\s\S*?])</code> 代表匹配 <code>&lt;li class=&#39;bold-item&#39;&gt;</code> 到 <code>&lt;\/li&gt;</code> 之间所有内容（多个字符、非贪婪模式），<code>gm</code> 代表全局并多行匹配。</p><p>上面爬取百度新闻数据的过程中，我们自己的 Node 服务器扮演了一个 “中间层” 的角色，我们通过浏览器访问自己的服务器 <a href="javascript:;" target="_blank" rel="noopener">localhost:3000</a> 触发 <code>request</code> 事件，执行了回调，在回调中创建客户端向 <a href="javascript:;" target="_blank" rel="noopener">news.baidu.com</a> 发送了请求，并在客户端的回调中处理了响应（百度新闻页返回的数据），将处理后的内容通过我们自己 Node 服务器的 <code>res</code> 对象返回给了浏览器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote warning"><p>相信在读过本篇文章之后对搭建一个 Node 服务应该已经有了思路，为未来通过 Node 服务实现复杂的业务场景及数据的处理打下了一个基础，希望初学 Node 的小伙伴在看了这篇文章后能有所收获。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 基础</title>
      <link href="/2018/07/09/20180709185149/"/>
      <url>/2018/07/09/20180709185149/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/09/20180709185149/img.png" title="HTTP 基础"><p><br></p><h2 id="HTTP-和-TCP-的关系"><a href="#HTTP-和-TCP-的关系" class="headerlink" title="HTTP 和 TCP 的关系"></a>HTTP 和 TCP 的关系</h2><blockquote class="pullquote info"><p>HTTP 是在 TCP 传输协议上层的应用层协议，主要解决如何包装数据的问题，关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP 协议，但是如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议，Web 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上”。</p></blockquote><a id="more"></a><h2 id="HTTP-协议和-TCP-协议"><a href="#HTTP-协议和-TCP-协议" class="headerlink" title="HTTP 协议和 TCP 协议"></a>HTTP 协议和 TCP 协议</h2><h3 id="HTTP-访问到服务器的过程"><a href="#HTTP-访问到服务器的过程" class="headerlink" title="HTTP 访问到服务器的过程"></a>HTTP 访问到服务器的过程</h3><p>从在浏览器中输入一个网址直到请求到达服务器的过程中如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/09/20180709185149/imgtcp.png" alt="HTTP 协议访问服务器流程" title>                </div>                <div class="image-caption">HTTP 协议访问服务器流程</div>            </figure><p><br></p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>在 HTTP1.0 版本中，每一个请求都需要在 TCP 协议中经历 “三次握手四次挥手”，在 HTTP1.1 中有了长连接，这个问题得到了改善，可以通过创建的一次 TCP 连接，进行多次请求响应，并在结束后关闭 TCP 连接。</p><p><strong>HTTP1.0 版本：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/09/20180709185149/connection.png" alt="HTTP1.0 版本" title>                </div>                <div class="image-caption">HTTP1.0 版本</div>            </figure><p><br></p><p><strong>HTTP1.1 长连接版本：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/09/20180709185149/keepalive.png" alt="HTTP1.1 版本" title>                </div>                <div class="image-caption">HTTP1.1 版本</div>            </figure><p><br></p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>在不同的浏览器中对于访问同一个域名，都有一个最大的请求数限制，数量大小因浏览器而异，如果请求数量大于最大请求数限制，则需要排队等待其他请求结束。</p><p>管线化技术，在超出最大请求数限制，客户端继续发送请求到服务端，而不需要其他请求得到响应的时候才能进行，实现并行发送请求，<code>CDN</code> 是比较典型的解决方式，将静态资源分发到不同 <code>ip</code> 下的服务器，请求资源是通过不同的代理服务器去同时获取，可以提高页面初始化响应的速度。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/09/20180709185149/pipeline.png" alt="HTTP 管线化" title>                </div>                <div class="image-caption">HTTP 管线化</div>            </figure><p><br></p><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><blockquote class="pullquote info"><p>URI：是统一资源标识符，在某个规则下能把这个资源独一无二标示出来，类似人的身份证号；<br>URL：统一资源定位符，表示资源的地点，URL 是使用浏览器访问 Web 页面时需要输入的网页地址。</p></blockquote><p><strong>URL 的组成：</strong></p><blockquote><p><a href="javascript:;" target="_blank" rel="noopener">http://username:password@www.pandashen.com:80/2018/07/09/index.html?uid=1&amp;name=panda#ch1</a></p></blockquote><ul><li><code>http</code>：协议类型；</li><li><code>username:password</code>：登录信息（如 Github，不安全）；</li><li><code>www.pandashen.com</code>：服务器地址（与前面用 @ 连接）；</li><li><code>80</code>：服务器端口号（与前面用 : 连接）；</li><li><code>/2018/07/09/index.html</code>：带层次的文件路径；</li><li><code>uid=1&amp;name=panda</code>：查询字符串（与前面用 ? 连接）；</li><li><code>ch1</code>：片段标识符（hash 值，与前面使用 # 连接）。</li></ul><h2 id="HTTP-的组成"><a href="#HTTP-的组成" class="headerlink" title="HTTP 的组成"></a>HTTP 的组成</h2><blockquote class="pullquote primary"><p>请求的一方叫客户端，响应的一方叫服务器端，通过请求和响应达成通信，HTTP 是一种无状态的协议。</p></blockquote><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>请求报文包含请求行、请求首部和请求体三个部分。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/09/20180709185149/request.png" alt="请求报文" title>                </div>                <div class="image-caption">请求报文</div>            </figure><p><br></p><blockquote class="pullquote default"><p>请求行由三个部分组成，并写在同一行，分别为请求方法、请求路径（域名和端口号后面的部分）和协议/版本号。</p></blockquote><p><strong>请求方法：</strong></p><ul><li>GET：获取资源</li><li>POST：向服务器端发送数据，传输实体主体</li><li>PUT：传输文件</li><li>HEAD：获取报文首部</li><li>DELETE：删除文件</li><li>OPTIONS：询问支持的方法</li><li>TRACE：追踪路径</li></ul><p><strong>追踪路径方式如下图：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/09/20180709185149/trace.png" alt="TRACE 追踪路径" title>                </div>                <div class="image-caption">TRACE 追踪路径</div>            </figure><p><br></p><blockquote class="pullquote primary"><p>请求体内的内容为向服务端发送的数据，首部分为通用首部、请求首部、响应首部和实体首部四种，在后面详细说明。</p></blockquote><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>响应报文同样包含三个部分，响应行、响应首部和响应体。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/09/20180709185149/response.png" alt="响应报文" title>                </div>                <div class="image-caption">响应报文</div>            </figure><p><br></p><p>响应行由三个部分组成，并写在同一行，分别为协议/版本号、状态码和状态码原因短语。</p><blockquote class="pullquote warning"><p><em><strong>注意：在请求首部与请求体之间、在响应首部与响应体之间都应该空一个空行。</strong></em></p></blockquote><h2 id="HTTP-响应状态码"><a href="#HTTP-响应状态码" class="headerlink" title="HTTP 响应状态码"></a>HTTP 响应状态码</h2><p>状态码负责表示客户端请求的返回结果、标记服务器端是否正常、通知出现的错误。</p><h3 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h3><table><thead><tr><th style="width:20%;text-align:center;">类别</th><th style="text-align:center;">原因短语</th></tr><thead><tbody><tr><td style="width:20%;text-align:center;">1XX</td><td style="text-align:center;">Informational（信息性状态码）</td></tr><tr><td style="width:20%;text-align:center;">2XX</td><td style="text-align:center;">Success（成功状态码）</td></tr><tr><td style="width:20%;text-align:center;">3XX</td><td style="text-align:center;">Redirection（重定向）</td></tr><tr><td style="width:20%;text-align:center;">4XX</td><td style="text-align:center;">Client Error（客户端错误状态码）<br></td></tr><tr><td style="width:20%;text-align:center;">5XX</td><td style="text-align:center;">Server Error（服务器错误状态吗）</td></tr></tbody></thead></thead></table><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><h4 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h4><table><thead><tr><th style="width:10%;text-align:center;">状态码</th><th style="width:20%;text-align:center;">原因短语</th><th style="text-align:center;">原因解释</th></tr></thead><tbody><tr><td style="width:10%;text-align:center;">200</td><td style="width:20%;text-align:center;">OK</td><td style="text-align:center;">客户端发过来的数据被正常处理</td></tr><tr><td style="width:10%;text-align:center;">204</td><td style="width:20%;text-align:center;">Not Content</td><td style="text-align:center;">正常响应，没有实体</td></tr><tr><td style="width:10%;text-align:center;">206</td><td style="width:20%;text-align:center;">Partial Content</td><td style="text-align:center;">范围请求，返回部分数据，响应报文中由 Content-Range 指定实体内容</td></tr></tbody></table><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><table><thead><tr><th style="width:10%;text-align:center;">状态码</th><th style="width:20%;text-align:center;">原因短语</th><th style="text-align:center;">原因解释</th></tr></thead><tbody><tr><td style="width:10%;text-align:center;">301</td><td style="width:20%;text-align:center;">Moved Permanently</td><td style="text-align:center;">永久重定向</td></tr><tr><td style="width:10%;text-align:center;">302</td><td style="width:20%;text-align:center;">Found</td><td style="text-align:center;">临时重定向，规范要求方法名不变，但是都会改变成 GET</td></tr><tr><td style="width:10%;text-align:center;">303</td><td style="width:20%;text-align:center;">See Other</td><td style="text-align:center;">和 302 类似，但必须用 GET 方法</td></tr><tr><td style="width:10%;text-align:center;">304</td><td style="width:20%;text-align:center;">Not Modified</td><td style="text-align:center;">状态未改变，配合（If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since）</td></tr><tr><td style="width:10%;text-align:center;">307</td><td style="width:20%;text-align:center;">Temporary Redirect</td><td style="text-align:center;">临时重定向，不该改变请求方法</td></tr></tbody></table><h4 id="客户端错误"><a href="#客户端错误" class="headerlink" title="客户端错误"></a>客户端错误</h4><table><thead><tr><th style="width:10%;text-align:center;">状态码</th><th style="width:20%;text-align:center;">原因短语</th><th style="text-align:center;">原因解释</th></tr></thead><tbody><tr><td style="width:10%;text-align:center;">400</td><td style="width:20%;text-align:center;">Bad Request</td><td style="text-align:center;">请求报文语法错误</td></tr><tr><td style="width:10%;text-align:center;">401</td><td style="width:20%;text-align:center;">Unauthorized</td><td style="text-align:center;">需要认证</td></tr><tr><td style="width:10%;text-align:center;">403</td><td style="width:20%;text-align:center;">Forbidden</td><td style="text-align:center;">服务器拒绝访问对应的资源</td></tr><tr><td style="width:10%;text-align:center;">404</td><td style="width:20%;text-align:center;">Not Found</td><td style="text-align:center;">服务器上无法找到资源</td></tr></tbody></table><h4 id="服务器错误"><a href="#服务器错误" class="headerlink" title="服务器错误"></a>服务器错误</h4><table><thead><tr><th style="width:10%;text-align:center;">状态码</th><th style="width:20%;text-align:center;">原因短语</th><th style="text-align:center;">原因解释</th></tr></thead><tbody><tr><td style="width:10%;text-align:center;">500</td><td style="width:20%;text-align:center;">Internal Server Error</td><td style="text-align:center;">服务器故障</td></tr><tr><td style="width:10%;text-align:center;">503</td><td style="width:20%;text-align:center;">Service Unavailable</td><td style="text-align:center;">服务器处于超负载或正在停机维护</td></tr></tbody></table><h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><blockquote class="pullquote info"><p>HTTP 首部字段是 HTTP 报文首部的重要部分，在客户端和服务器进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。</p></blockquote><p><strong>HTTP 首部主要分为通用首部、请求首部、响应首部和实体首部四种：</strong></p><ul><li>通用首部字段：请求和响应报文两方都会使用的首部字段；</li><li>请求首部字段：从客户端向服务器发送请求报文时使用的首部字段，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息；</li><li>响应首部字段：从服务器向客户端返回响应报文时使用的首部字段；补充了响应的附加内容，也会要求客户端附加额外的内容信息；</li><li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部，补充了资源内容的更新时间等与实体有关的信息。</li></ul><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table><thead><tr><th style="width:20%;text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr><thead><tbody><tr><td style="width:20%;text-align:center;">Cache-Control</td><td style="text-align:center;">控制缓存行为</td></tr><tr><td style="width:20%;text-align:center;">Connection</td><td style="text-align:center;">链接的管理</td></tr><tr><td style="width:20%;text-align:center;">Date</td><td style="text-align:center;">报文日期</td></tr><tr><td style="width:20%;text-align:center;">Pragma</td><td style="text-align:center;">报文指令<br></td></tr><tr><td style="width:20%;text-align:center;">Trailer</td><td style="text-align:center;">报文尾部的首部</td></tr><tr><td style="width:20%;text-align:center;">Trasfer-Encoding</td><td style="text-align:center;">指定报文主体的传输编码方式</td></tr><tr><td style="width:20%;text-align:center;">Upgrade</td><td style="text-align:center;">升级为其他协议</td></tr><tr><td style="width:20%;text-align:center;">Via</td><td style="text-align:center;">代理服务器信息</td></tr><tr><td style="width:20%;text-align:center;">Warning</td><td style="text-align:center;">错误通知</td></tr></tbody></thead></thead></table><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table><thead><tr><th style="width:20%;text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr><thead><tbody><tr><td style="width:20%;text-align:center;">Accept</td><td style="text-align:center;">用户代理可处理的媒体类型</td></tr><tr><td style="width:20%;text-align:center;">Accept-Charset</td><td style="text-align:center;">优先的字符集</td></tr><tr><td style="width:20%;text-align:center;">Accept-Encoding</td><td style="text-align:center;">优先的编码</td></tr><tr><td style="width:20%;text-align:center;">Accept-Langulage</td><td style="text-align:center;">优先的语言<br></td></tr><tr><td style="width:20%;text-align:center;">Authorization</td><td style="text-align:center;">Web 认证信息</td></tr><tr><td style="width:20%;text-align:center;">Expect</td><td style="text-align:center;">期待服务器的特定行为</td></tr><tr><td style="width:20%;text-align:center;">From</td><td style="text-align:center;">用户的电子邮箱地址</td></tr><tr><td style="width:20%;text-align:center;">Host</td><td style="text-align:center;">请求资源所在的服务器</td></tr><tr><td style="width:20%;text-align:center;">If-Match</td><td style="text-align:center;">比较实体标记</td></tr><tr><td style="width:20%;text-align:center;">If-Modified-Since</td><td style="text-align:center;">比较资源的更新时间</td></tr><tr><td style="width:20%;text-align:center;">If-None-Match</td><td style="text-align:center;">比较实体标记</td></tr><tr><td style="width:20%;text-align:center;">If-Range</td><td style="text-align:center;">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td style="width:20%;text-align:center;">If-Unmodified-Since</td><td style="text-align:center;">比较资源的更新时间（ 与 If-Modified-Since相反 ）<br></td></tr><tr><td style="width:20%;text-align:center;">Max-Forwards</td><td style="text-align:center;">最大传输跳数</td></tr><tr><td style="width:20%;text-align:center;">Proxy-Authorization</td><td style="text-align:center;">代理服务器需要客户端认证</td></tr><tr><td style="width:20%;text-align:center;">Range</td><td style="text-align:center;">实体字节范围请求</td></tr><tr><td style="width:20%;text-align:center;">Referer</td><td style="text-align:center;">请求中的URI的原始获取方</td></tr><tr><td style="width:20%;text-align:center;">TE</td><td style="text-align:center;">传输编码的优先级</td></tr><tr><td style="width:20%;text-align:center;">User-Agent</td><td style="text-align:center;">HTTP 客户端程序的信息</td></tr></tbody></thead></thead></table><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table><thead><tr><th style="width:20%;text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr><thead><tbody><tr><td style="width:20%;text-align:center;">Accept-Ranges</td><td style="text-align:center;">是否接受字节范围</td></tr><tr><td style="width:20%;text-align:center;">Age</td><td style="text-align:center;">资源的创建时间</td></tr><tr><td style="width:20%;text-align:center;">ETag</td><td style="text-align:center;">资源的匹配信息</td></tr><tr><td style="width:20%;text-align:center;">Location</td><td style="text-align:center;">客户端重定向至指定的 URI<br></td></tr><tr><td style="width:20%;text-align:center;">Proxy-Authenticate</td><td style="text-align:center;">代理服务器对客户端的认证信息</td></tr><tr><td style="width:20%;text-align:center;">Retry-After</td><td style="text-align:center;">再次发送请求的时机</td></tr><tr><td style="width:20%;text-align:center;">Server</td><td style="text-align:center;">服务器的信息</td></tr><tr><td style="width:20%;text-align:center;">Vary</td><td style="text-align:center;">代理服务器缓存的管理信息</td></tr><tr><td style="width:20%;text-align:center;">www-Authenticate</td><td style="text-align:center;">服务器对客户端的认证</td></tr></tbody></thead></thead></table><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table><thead><tr><th style="width:20%;text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr><thead><tbody><tr><td style="width:20%;text-align:center;">Allow</td><td style="text-align:center;">资源可支持的 HTTP 方法</td></tr><tr><td style="width:20%;text-align:center;">Content-Encoding</td><td style="text-align:center;">实体的编码方式</td></tr><tr><td style="width:20%;text-align:center;">Content-Language</td><td style="text-align:center;">实体的自然语言</td></tr><tr><td style="width:20%;text-align:center;">Content-Length</td><td style="text-align:center;">实体的内容大小（字节为单位）<br></td></tr><tr><td style="width:20%;text-align:center;">Content-Location</td><td style="text-align:center;">替代对应资源的 URI</td></tr><tr><td style="width:20%;text-align:center;">Content-MD5</td><td style="text-align:center;">实体的报文摘要</td></tr><tr><td style="width:20%;text-align:center;">Content-Range</td><td style="text-align:center;">实体的位置范围</td></tr><tr><td style="width:20%;text-align:center;">Content-Type</td><td style="text-align:center;">实体主体的媒体类型</td></tr><tr><td style="width:20%;text-align:center;">Expires</td><td style="text-align:center;">实体过期时间</td></tr><tr><td style="width:20%;text-align:center;">Last-Modified</td><td style="text-align:center;">资源的最后修改时间</td></tr></tbody></thead></thead></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>本篇重点介绍关于 HTTP 协议的一点基础知识，关于请求、响应以及报文对应的信息及内容，也可以用作查询使用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 TCP 实现简易聊天室</title>
      <link href="/2018/07/08/20180708120357/"/>
      <url>/2018/07/08/20180708120357/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/08/20180708120357/nodejs-tcp-ip.png" title="TCP + NodeJS 简易聊天室"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>TCP 为传输层协议，在 NodeJS 中，基于 TCP 的核心模块为 <code>net</code>，<code>http</code> 和 <code>https</code> 模块都是基于 <code>net</code> 实现的，我们先简单介绍 <code>net</code> 的用法，再根据 <code>net</code> 实现一个简易的聊天室。</p></blockquote><a id="more"></a><h2 id="net-模块的基本用法"><a href="#net-模块的基本用法" class="headerlink" title="net 模块的基本用法"></a>net 模块的基本用法</h2><h3 id="使用-net-创建一个网络服务"><a href="#使用-net-创建一个网络服务" class="headerlink" title="使用 net 创建一个网络服务"></a>使用 net 创建一个网络服务</h3><p><strong>方式 1：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 TCP 服务</span></span><br><span class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>方式 2：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 TCP 服务</span></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面两种创建网络服务的方式第二种更常用，回调函数的参数都为 <code>socket</code>（套接字），在产生连接时执行，每产生一个连接就会产生一个 <code>socket</code>，我们也可以将 <code>socket</code> 理解为客户端。</p><p>如果现在使用浏览器连接这个服务可以成功接收到请求，但浏览器是 <code>http</code> 协议，不识别，所以不会有任何响应。</p><h3 id="使用-TCP-模拟-http"><a href="#使用-TCP-模拟-http" class="headerlink" title="使用 TCP 模拟 http"></a>使用 TCP 模拟 http</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 TCP 服务</span></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  socket.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取请求报文</span></span><br><span class="line">  socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给浏览器返回响应报文</span></span><br><span class="line">  socket.write(<span class="string">`</span></span><br><span class="line"><span class="string">HTTP/1.1 200 ok</span></span><br><span class="line"><span class="string">Content-Length: 5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET /favicon.ico HTTP/1.1</span></span><br><span class="line"><span class="comment">// Host: localhost:3000</span></span><br><span class="line"><span class="comment">// Connection: keep-alive</span></span><br><span class="line"><span class="comment">// Pragma: no-cache</span></span><br><span class="line"><span class="comment">// Cache-Control: no-cache</span></span><br><span class="line"><span class="comment">// ...... 后面省略</span></span><br></pre></td></tr></table></figure><p><code>soket</code> 是一个可读可写流 Duplex（双工流），所以既可以读取来自浏览器的请求信息，又可以写入响应信息，在模拟 <code>http</code> 时需遵循 <code>http</code> 协议规则，每行前面不允许有空格或制表符，响应头与响应正文之间需空一行。</p><p>此时启动服务，使用浏览器访问 <a href="javascript:;" target="_blank" rel="noopener">localhost:3000</a> 可以在控制台打印请求报文，并在浏览器中显示 <code>hello</code>。</p><blockquote class="pullquote primary"><p><code>http</code> 的头部信息可以通过命令窗口中使用 <code>curl</code> 发送请求进行查看，输入命令为 <code>curl -v http://.....</code>，默认命令行窗口是不支持 <code>curl</code> 命令的，请在 <a href="https://curl.haxx.se/download.html" target="_blank">curl 官网</a> 下载系统对应的版本，在 Windows 系统中，下载后的压缩包解压后将 <code>curl.exe</code> 和 <code>ca-bundle.crt</code> 拷贝至 <code>C:\Windows\System32</code> 或将所在文件夹添加至系统环境变量。</p></blockquote><h3 id="server、socket-的属性和方法"><a href="#server、socket-的属性和方法" class="headerlink" title="server、socket 的属性和方法"></a>server、socket 的属性和方法</h3><p>在 TCP 创建的服务 <code>server</code> 和连接中的 <code>socket</code> 本身具有一些属性、方法和事件，我们通过下面这个例子来介绍。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 TCP 服务器</span></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 客户端的 ip + 端口号</span></span><br><span class="line">  <span class="keyword">let</span> key = socket.remoteAddress + socket.remotePort;</span><br><span class="line"></span><br><span class="line">  server.getConnetions(<span class="function"><span class="keyword">function</span>(<span class="params">err, count</span>) </span>&#123;</span><br><span class="line">    socket.write(<span class="string">`当前有<span class="subst">$&#123;count&#125;</span>人，总人数为<span class="subst">$&#123;server.maxConnections&#125;</span>人。`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置编码</span></span><br><span class="line">    socket.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端</span></span><br><span class="line">    <span class="comment">// socket.end();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭服务器</span></span><br><span class="line">    <span class="comment">// server.close();</span></span><br><span class="line">    server.unref();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大连接数</span></span><br><span class="line">server.maxConnections = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务端关闭'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err.code === <span class="string">'EADDRINUSE'</span>) &#123;</span><br><span class="line">    server.listen(err.port + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>socket.remoteAddress</code> 属性，获取客户端的 IP 地址。</p><p><code>socket.remotePort</code> 属性，获取客户端的端口号。</p><p><code>socket.setEncoding</code> 方法，设置编码格式。</p><p><code>socket.write</code> 方法，向客户端写入内容，写入内容的值只能为字符串或 Buffer。</p><p><code>socket.end</code> 方法，断开对应客户端的连接，并返回信息，返回内容的值只能为字符串或 Buffer，<code>soket</code> 可以监听 <code>end</code> 事件，当关闭客户端时触发并执行回调。</p><p><code>socket.destroy</code> 方法，用于销毁当前客户端对应的 <code>socket</code> 对象。</p><p><code>server.maxConnections</code> 属性，是当前服务器允许的最大连接数，数值类型，当连接数超过设定值时，新的客户端将无法连接服务器。</p><p><code>server.getConnetions</code> 方法，获取当前的连接数，参数为回调函数，回调函数有两个参数 <code>err</code>（错误）和 <code>count</code>（当前连接数），异步执行。</p><p><code>server.close</code> 方法，关闭服务器，并没有真的关闭服务器，而是不允许新的连接，直到所有连接都断开后自动关闭服务器。</p><p><code>server.unref</code> 方法，关闭服务器的另一种形式，不阻止新的连接，当所有连接都断开时自动关闭服务器。</p><p><code>server.listen</code> 方法，监听端口号，支持传入回调，在启动服务后执行。</p><p><code>server</code> 的 <code>close</code> 事件，参数为回调函数，异步执行，当服务器关闭时触发。</p><p><code>server</code> 的 <code>error</code> 事件，参数为回调函数，回调函数的参数为 <code>err</code>（错误对象），异步执行，当启动服务器或服务器运行时出现错误触发。</p><blockquote class="pullquote success"><p>在 Webpack 中如果启动 <code>webpack-dev-server</code> 在端口号被占用时，端口号会自动 <code>+1</code>，我们可以利用 <code>err</code> 错误对象来模拟，在 <code>err</code> 事件对象上有很多属性，其中的 <code>code</code> 属性值为 <code>EADDRINUSE</code> 时代表端口号被占用，所以在判断 <code>code</code> 值后，重新调用了 <code>server.listen</code> 并传入重新计算后的端口号。</p></blockquote><p>想看一看上面代码的效果需要客户端的支持，本文中模拟客户端访问服务器有三种方式，使用一种即可。</p><h2 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h2><p>验证我们自己实现的 TCP 服务器需要客户端访问，在本文的主题简易聊天室当中也需要用户和客户端，所以介绍一下创建客户端的方式。</p><ul><li>可以使用 <code>net</code> 模块创建客户端，并启访问服务器；</li><li>Mac 中可以直接在命令窗口执行 <code>brew install telnet</code> 安装 <code>telnet</code>，安装后输入 <code>telnet localhost 3000</code> 即可以访问上面的服务器；</li><li>Windows 中 <code>telnet</code> 接收到的服务器响应会变成乱码，所以可以使用 <a href="http://www.netsarang.com/download/main.html" target="_blank">Xshell</a> 和 <a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank">PuTTY</a> 等客户端工具。</li></ul><p>使用 <code>net</code> 创建客户端代码如下：</p><figure class="highlight js"><figcaption><span>客户端：client.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建客户端</span></span><br><span class="line"><span class="keyword">const</span> client = net.createConnection(&#123; <span class="attr">port</span>: <span class="number">3000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给服务器发送消息</span></span><br><span class="line">client.write(<span class="string">'s:username:message'</span>);</span><br></pre></td></tr></table></figure><p>为了方便本文中使用 PuTTY 工具，Windows 系统在使用之前需打开 Telnet 服务端和客户端，通过控制面板 → 打开或关闭 Windows 功能 → 勾选 Telnet 服务端和客户端。</p><p>PuTTY 界面如下，在 <code>Connection type</code>（连接类型）中默认为 <code>SSH</code>，我们之所以使用 <code>Raw</code> 而不使用其他类型是因为其他的方式在连接服务器时会发送窗口信息，我们不需要这些数据。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/08/20180708120357/PuTTY.png" alt="PuTTY 界面" title>                </div>                <div class="image-caption">PuTTY 界面</div>            </figure><p><br></p><p>点击界面下面的 <code>Open</code> 按钮就可以创建一个客户端连接，客户端窗口如下，可以通过输入并回车确定的方式向服务端发送消息。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/08/20180708120357/PuTTY-window.png" alt="PuTTY 客户端窗口" title>                </div>                <div class="image-caption">PuTTY 客户端窗口</div>            </figure><p><br></p><p>目前所有的准备工作已经就绪，下面就是我们的正题，用 <code>net</code> 模块实现一个 TCP 服务，并使用 PuTTY 作为客户端，实现一个简易的聊天室。</p><h2 id="实现简易聊天室"><a href="#实现简易聊天室" class="headerlink" title="实现简易聊天室"></a>实现简易聊天室</h2><h3 id="定义聊天室规则"><a href="#定义聊天室规则" class="headerlink" title="定义聊天室规则"></a>定义聊天室规则</h3><p>聊天室主要有四个功能，都需要输入对应的命令。</p><ul><li>显示在线用户：命令为 <code>l</code>；</li><li>改名：聊天室默认用户名为匿名，重命名的命令为 <code>r:newname</code>；</li><li>私聊：私聊的参数为聊天对象的名字和消息内容，命令为 <code>s:username:message</code>；</li><li>广播：发送的消息除自己以外的所有人都能接收到，命令为 <code>b:message</code>。</li></ul><p>在存储所有的客户端时，都使用客户端的 <code>ip + port</code> 作为用户的唯一标识。</p><h3 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h3><figure class="highlight js"><figcaption><span>服务器：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理输入命令模块</span></span><br><span class="line"><span class="keyword">const</span> processInstructs = <span class="built_in">require</span>(<span class="string">'./process-instructs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net.createServer(); <span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> client = &#123;&#125;; <span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>; <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">server.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="comment">// 客户端的 ip + 端口号 作为存储客户端的唯一标识</span></span><br><span class="line">  <span class="keyword">let</span> key = socket.remoteAddress + socket.remotePort;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将客户端添加到 client 存储中</span></span><br><span class="line">  client[key] = &#123; <span class="attr">username</span>: <span class="string">'匿名'</span>, socket &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 欢迎功能</span></span><br><span class="line">  server.getConnections(<span class="function">(<span class="params">err, count</span>) =&gt;</span> &#123;</span><br><span class="line">    socket.write(<span class="string">`欢迎加入！目前有 <span class="subst">$&#123;count&#125;</span> 人。\r\n`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  socket.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听用户输入</span></span><br><span class="line">  socket.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="comment">// 由于输入消息按回车键确认，所以需处理消息中的回车</span></span><br><span class="line">    data = data.replace(<span class="regexp">/\r\n/</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输入并做出响应</span></span><br><span class="line">    processInstructs(client, key, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端主动关闭后在服务器客户端存储中清除客户端，并销毁对应的 socket</span></span><br><span class="line">  socket.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    socket.destroy();</span><br><span class="line">    <span class="keyword">delete</span> client[key];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口号</span></span><br><span class="line">server.listen(port, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`server start <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的服务搭建当中，创建了 <code>client</code> 对象，专门存储聊天室内的客户端及信息，客户端使用 <code>ip + port</code> 作为存储的唯一标识，用户名默认为 “匿名”，设置了欢迎功能，并显示当前在线人数，监听用户的输入，并处理了消息中的回车，引入 <code>process-instructs</code> 对指令进行处理，最后处理了离开的用户，目的是防止有离开后，其他的人使用了私聊或广播功能通知这个人，因为找不到对应的 <code>socket</code> 而出现错误。</p><h3 id="处理指令模块-process-instructs"><a href="#处理指令模块-process-instructs" class="headerlink" title="处理指令模块 process-instructs"></a>处理指令模块 process-instructs</h3><figure class="highlight js"><figcaption><span>文件：process-instructs.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入处理不同指令的功能函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; list, rename, private, broadcast &#125; = <span class="built_in">require</span>(<span class="string">'./instructs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">client, key, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dataArr = data.split(<span class="string">':'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对不同的指令调用不同的处理方法</span></span><br><span class="line">  <span class="keyword">switch</span> (dataArr[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">      list(client, key);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">      rename(client, key, dataArr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">      private(client, key, dataArr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">      broadcast(client, key, dataArr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      socket.write(<span class="string">'命令有误\r\n'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面对指令的处理中针对不同的指令引入了 <code>instructs</code> 模块对应的处理方法。</p><h3 id="指令处理方法模块-instructs"><a href="#指令处理方法模块-instructs" class="headerlink" title="指令处理方法模块 instructs"></a>指令处理方法模块 instructs</h3><figure class="highlight js"><figcaption><span>文件：instructs.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理 l 指令，显示在线用户</span></span><br><span class="line">exports.list = <span class="function"><span class="keyword">function</span>(<span class="params">client, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前 socket</span></span><br><span class="line">  <span class="keyword">let</span> socket = client[key].socket;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入信息</span></span><br><span class="line">  soket.write(<span class="string">'当前用户列表:\r\n'</span>);</span><br><span class="line">  <span class="built_in">Object</span>.values(client).forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">    socket.write(<span class="string">`<span class="subst">$&#123;p.username&#125;</span>\r\n`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 r 指令，用户重命名</span></span><br><span class="line">exports.rename = <span class="function"><span class="keyword">function</span>(<span class="params">client, key, dataArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newName = dataArr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新对应 socket 的新用户名并通知</span></span><br><span class="line">  client[key].username = newName;</span><br><span class="line">  client[key].socket.write(<span class="string">`新用户名是: <span class="subst">$&#123;newName&#125;</span>\r\n`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 s 指令，私聊</span></span><br><span class="line">exports.private = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(client).forEach(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (client[c].username === dataArr[<span class="number">1</span>]) &#123;</span><br><span class="line">      client[c].socket.write(<span class="string">`<span class="subst">$&#123;client[key].username&#125;</span>: <span class="subst">$&#123;dataArr[<span class="number">2</span>]&#125;</span>\r\n`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 b 指令，广播</span></span><br><span class="line">exports.broadcast = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(client).forEach(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c !== key) &#123;</span><br><span class="line">      client[c].socket.write(<span class="string">`<span class="subst">$&#123;client[key].username&#125;</span>: <span class="subst">$&#123;dataArr[<span class="number">1</span>]&#125;</span>\r\n`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显示在线用户功能的思路是将 <code>client</code> 内部所有在线用户的用户名循环写入到当前 <code>socket</code> 中，重命名功能的思路是获取输入的新用户名替换掉 <code>client</code> 中对应的 <code>username</code> 并将当前新用户名设置成功的消息返回当前 <code>socket</code>，私聊功能的思路是循环 <code>client</code> 内的所有客户端，当 <code>username</code> 和发送的用户名相同时，将消息写入这个用户名对应的 <code>socket</code>，广播功能思路是循环 <code>client</code>，将消息写入给出自己以外的所有客户端。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p>本文重点在于理解多人聊天功能的开发思路，及 NodeJS 中关于 TCP 传输对应的 <code>net</code> 模块的使用，实际上本文中聊天室的代码在用户重名的情况下并没有做任何处理，正常情况应该使用 <code>id</code> 作为唯一标识，而不是指定用户名，在 NodeJS 开发中其实很少直接使用 <code>net</code> 大多情况下使用 <code>http</code> 和 <code>https</code> 来替代，但是我们应该知道他们都是基于 <code>net</code> 封装的，了解 <code>net</code> 会在使用 <code>http</code> 和 <code>https</code> 时更得心应手。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> NodeJS </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 NodeJS 可读流实现 “行读取器”</title>
      <link href="/2018/07/06/20180706120428/"/>
      <url>/2018/07/06/20180706120428/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/06/20180706120428/line-reader.png" title="TCP + LineReader 行读取器"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote danger"><p>本文是对于 NodeJS 核心模块 <code>fs</code> 可读流 <code>createReadeStream</code> 的应用，实现 “行读取器”，功能为读取一个文档的内容，每读完一行触发一次监听的事件，并对这一行数据进行处理。</p></blockquote><a id="more"></a><h2 id="LineReader-类的创建"><a href="#LineReader-类的创建" class="headerlink" title="LineReader 类的创建"></a>LineReader 类的创建</h2><p>实现 “行读取器” 的整体思路是创建一个类的实例，然后在这个实例上监听一个事件，并开始读取文件，每次读完一行触发，我们这里将这个类命名为 <code>LineReader</code>，因为类需要监听事件，所以需要继承 <code>EventEmitter</code>。</p><figure class="highlight js"><figcaption><span>行读取器 LineReader 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行读取器的类，参数为读取文件的路径</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineReader</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  contructor(path) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.path = path; <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="keyword">this</span>._rs = fs.createReadStream(<span class="keyword">this</span>.path); <span class="comment">// 创建可读流</span></span><br><span class="line">    <span class="keyword">this</span>.current = <span class="literal">null</span>; <span class="comment">// 存储每次读到的单个字节</span></span><br><span class="line">    <span class="keyword">this</span>.arr = []; <span class="comment">// 存放文件每一行单个字节 Buffer 的数组</span></span><br><span class="line">    <span class="keyword">this</span>.system = <span class="literal">null</span>; <span class="comment">// 默认的系统（windows 或 mac）</span></span><br><span class="line">    <span class="keyword">this</span>.RETURN = <span class="number">13</span>; <span class="comment">// \r 的十六进制数</span></span><br><span class="line">    <span class="keyword">this</span>.Line = <span class="number">10</span>; <span class="comment">// \n 的十六进制数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 newListener</span></span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, readLineCallback.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>LineReader</code> 实例上定义了 <code>system</code>（当前系统）、<code>current</code>（每次读取的单个字节）、<code>RETURN</code>（<code>\r</code> 十六进制编码）和 <code>Line</code>（<code>\n</code> 十六进制编码）等属性方便后面使用。</p><p>我们希望在监听的事件触发之前，就执行读取文件一行内容的逻辑，就说明我们需要一个在监听事件时就能执行的函数，那就需要在创建实例之前先监听 <code>newListener</code> 事件，把 <code>newListener</code> 的回调来作为这个函数执行，并能顺带在参数中获取事件类型。</p><p>我们把读取文件的核心逻辑放在了 <code>newListener</code> 事件的回调函数中，将这个回调函数命名为 <code>readLineCallback</code>，为了保证执行时 <code>readLineCallback</code> 内部使用的 <code>this</code> 是 <code>LineReader</code> 的实例，使用 <code>bind</code> 进行修正。</p><h2 id="行读取器核心逻辑-readLineCall-函数"><a href="#行读取器核心逻辑-readLineCall-函数" class="headerlink" title="行读取器核心逻辑 readLineCall 函数"></a>行读取器核心逻辑 readLineCall 函数</h2><p>如果需要默认就开始读取，并且每次读取一个字节后还可以进行下一次循环读取，这种场景最符合可读流的暂停模式 <code>readable</code> 事件默认触发一次，“容器” 内读走了一个字节，就会自动 “续杯” 的特点。</p><figure class="highlight js"><figcaption><span>行读取器的核心逻辑</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLineCallback</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用暂停模式进行读取</span></span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'newLine'</span>) &#123;</span><br><span class="line">      <span class="comment">// 为了与 \r 和 \n 对比，每次只读一个字节</span></span><br><span class="line">      <span class="keyword">while</span> ((<span class="keyword">this</span>.current = <span class="keyword">this</span>._rs.read(<span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="comment">// 结果为 Buffer，所以使用索引取出对比</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.current[<span class="number">0</span>]) &#123;</span><br><span class="line">          <span class="keyword">case</span> RETURN: <span class="comment">// 针对 Windows</span></span><br><span class="line">            <span class="keyword">this</span>.system = <span class="string">'windows'</span>;</span><br><span class="line">            <span class="keyword">this</span>.disposeLine(); <span class="comment">// 处理换行逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> LINE: <span class="comment">// 针对 Mac</span></span><br><span class="line">            <span class="keyword">this</span>.system = <span class="string">'mac'</span>;</span><br><span class="line">            <span class="keyword">this</span>.disposeLine(); <span class="comment">// 处理换行逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 每读到换行的字符存入数组中</span></span><br><span class="line">            <span class="keyword">this</span>.arr.push(current);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止最后一行丢失</span></span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'end'</span>, <span class="keyword">this</span>.disposeLine.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中监听了 <code>readable</code> 事件并验证了事件类型是否为 <code>newLine</code>，然后循环读取文件内容，为了与换行的十六进制码进行对比，每次只读取一个字节，当遇到换行符时，明确当前系统并调用换行符处理函数 <code>disposeLine</code> 进行处理。</p><blockquote class="pullquote danger"><p><em><strong>注意：在最后一次的时候文件最后一行可能没有换行，所以不满足 <code>switch</code> 内语句的条件，即没使用 <code>disposeLine</code> 进行处理，所以监听可读流的 <code>end</code> 事件，并在 <code>end</code> 触发时让 <code>disposeLine</code> 作为回调函数执行，注意使用 <code>bind</code> 修正 <code>this</code> 为当前实例。</strong></em></p></blockquote><h2 id="兼容-Windows-和-Mac-的换行符处理函数"><a href="#兼容-Windows-和-Mac-的换行符处理函数" class="headerlink" title="兼容 Windows 和 Mac 的换行符处理函数"></a>兼容 Windows 和 Mac 的换行符处理函数</h2><p>在换行符处理函数中，Windows 与其他系统（Mac、Linux）系统唯一的区别就是 Window 系统的换行符为 <code>\r\n</code>，比 Mac 和 Linux 的 <code>\n</code> 多了一个字节，而在读取下一行时，这个字节是无用的，需要忽略。</p><figure class="highlight js"><figcaption><span>换行符处理函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LineReader.prototype.disposeLine = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将这一行的内容发射出来并清空数组</span></span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'newLine'</span>, Buffer.concat(<span class="keyword">this</span>.arr).toString());</span><br><span class="line">  <span class="keyword">this</span>.arr = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是 window 系统，下一个是 \n，就往下多读一个字节不存入组即可</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.system === <span class="string">'windows'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rs.read(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="验证-LineReader-行读取器"><a href="#验证-LineReader-行读取器" class="headerlink" title="验证 LineReader 行读取器"></a>验证 LineReader 行读取器</h2><p>创建一个 “行读取器” 需要创建 <code>LineReader</code> 类的实例，并传入被读取文件的路径，由于在源码中执行的是 <code>newListener</code> 的回调函数，所以只需添加 <code>newLine</code> 事件监听就可以了，然后会在 <code>readable</code> 默认触发时在内部循环读取，并把每行读到的内容重新整合后发送，实现 <code>newLine</code> 事件的连续触发，直到文件读完。</p><figure class="highlight js"><figcaption><span>使用行读取器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件 1.txt 每次内容为 1~9 9个数字，每 3 个字符为一行</span></span><br><span class="line"><span class="keyword">const</span> lineReader = <span class="keyword">new</span> LineReader(<span class="string">'1.txt'</span>);</span><br><span class="line"></span><br><span class="line">lineReader.on(<span class="string">'newLine'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`------ <span class="subst">$&#123;data&#125;</span> ------`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 123 ------</span></span><br><span class="line"><span class="comment">// ------ 456 ------</span></span><br><span class="line"><span class="comment">// ------ 789 ------</span></span><br></pre></td></tr></table></figure><p>“行读取器” <code>lineReader</code> 对读取到每一行的数据进行处理的逻辑主要在 <code>newLine</code> 事件的回调函数中，比如上面例子，在每一行的前、后添加了 <code>------</code> 并打印。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 NodeJS 中，流的应用非常广泛，“行读取器” 只是其中的一种表现，可以根据流的不同模式的不同特性实现更复杂的功能，所以流在 NodeJS 中还是非常重要的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Stream </tag>
            
            <tag> LineReader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS —— 自定义流的实现</title>
      <link href="/2018/07/05/20180705125501/"/>
      <url>/2018/07/05/20180705125501/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/05/20180705125501/custom-stream.png" title="自定义流的实现原理"><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote class="pullquote info"><p>常见的自定义流有四种，Readable（可读流）、Writable（可写流）、Duplex（双工流）和 Transform（转换流），常见的自定义流应用有 HTTP 请求、响应，<code>crypto</code> 加密，进程 <code>stdin</code> 通信等等。</p></blockquote><a id="more"></a><h2 id="stream-模块介绍"><a href="#stream-模块介绍" class="headerlink" title="stream 模块介绍"></a>stream 模块介绍</h2><blockquote class="pullquote default"><p>在 NodeJS 中要想实现自定义流，需要依赖模块 <code>stream</code>，直接引入，不需下载，所有种类的流都是继承这个模块内部提供的对应不同种类的类来实现的。</p></blockquote><h2 id="实现一个自定义可读流-Readable"><a href="#实现一个自定义可读流-Readable" class="headerlink" title="实现一个自定义可读流 Readable"></a>实现一个自定义可读流 Readable</h2><h3 id="创建自定义可读流的类-MyRead"><a href="#创建自定义可读流的类-MyRead" class="headerlink" title="创建自定义可读流的类 MyRead"></a>创建自定义可读流的类 MyRead</h3><p>实现自定义可读流需创建一个类为 <code>MyRead</code>，并继承 <code>stream</code> 中的 <code>Readable</code> 类，重写 <code>_read</code> 方法，这是所有自定义流的固定套路。</p><figure class="highlight js"><figcaption><span>创建自定义可读流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Readable &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义可读流的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRead</span> <span class="keyword">extends</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写自定义的可读流的 _read 方法</span></span><br><span class="line">  _read() &#123;</span><br><span class="line">    <span class="keyword">this</span>.index++;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.index + <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.index === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自己写的 <code>_read</code> 方法会先查找并执行，在读取时使用 <code>push</code> 方法将数据读取出来，直到 <code>push</code> 的值为 <code>null</code> 才会停止，否则会认为没有读取完成，会继续调用 <code>_read</code>。</p><h3 id="验证自定义可读流"><a href="#验证自定义可读流" class="headerlink" title="验证自定义可读流"></a>验证自定义可读流</h3><figure class="highlight js"><figcaption><span>验证自定义可读流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myRead = <span class="keyword">new</span> MyRead();</span><br><span class="line"></span><br><span class="line">myRead.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myRead.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;Buffer 31&gt;</span></span><br><span class="line"><span class="comment">// &lt;Buffer 32&gt;</span></span><br><span class="line"><span class="comment">// &lt;Buffer 33&gt;</span></span><br><span class="line"><span class="comment">// 读取完成</span></span><br></pre></td></tr></table></figure><h2 id="实现一个自定义可写流-Writable"><a href="#实现一个自定义可写流-Writable" class="headerlink" title="实现一个自定义可写流 Writable"></a>实现一个自定义可写流 Writable</h2><h3 id="创建自定义可写流的类-MyWrite"><a href="#创建自定义可写流的类-MyWrite" class="headerlink" title="创建自定义可写流的类 MyWrite"></a>创建自定义可写流的类 MyWrite</h3><p>创建一个类名为 <code>MyWrite</code>，并继承 <code>stream</code> 中的 <code>Writable</code> 类，重写 <code>_write</code> 方法。</p><figure class="highlight js"><figcaption><span>创建自定义可写流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Writable &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义可写流的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWrite</span> <span class="keyword">extends</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重写自定义的可写流的 _write 方法</span></span><br><span class="line">  _write(chunk, encoding, callback)) &#123;</span><br><span class="line">    callback(); <span class="comment">// 将缓存区写入文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入内容时默认第一次写入直接写入文件，后面的写入都写入缓存区，如果不调用 <code>callback</code> 只能默认第一次写入文件，调用 <code>callback</code> 会将缓存区清空并写入文件。</p><h3 id="验证自定义可写流"><a href="#验证自定义可写流" class="headerlink" title="验证自定义可写流"></a>验证自定义可写流</h3><figure class="highlight js"><figcaption><span>验证自定义可写流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myWrite = <span class="keyword">new</span> MyWrite();</span><br><span class="line"></span><br><span class="line">myWrite.write(<span class="string">'hello'</span>, <span class="string">'utf8'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myWrite.write(<span class="string">'world'</span>, <span class="string">'utf8'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'world ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello ok</span></span><br><span class="line"><span class="comment">// world ok</span></span><br></pre></td></tr></table></figure><h2 id="实现一个自定义双工流-Duplex"><a href="#实现一个自定义双工流-Duplex" class="headerlink" title="实现一个自定义双工流 Duplex"></a>实现一个自定义双工流 Duplex</h2><h3 id="创建自定义可双工流的类-MyDuplex"><a href="#创建自定义可双工流的类-MyDuplex" class="headerlink" title="创建自定义可双工流的类 MyDuplex"></a>创建自定义可双工流的类 MyDuplex</h3><p>双工流的可以理解为即可读又可写的流，创建一个类名为 <code>MyDuplex</code>，并继承 <code>stream</code> 中的 <code>Duplex</code> 类，由于双工流即可读又可写，需重写 <code>_read</code> 和 <code>_write</code> 方法。</p><figure class="highlight js"><figcaption><span>创建自定双工流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Duplex &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义双工流的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDuplex</span> <span class="keyword">extends</span> <span class="title">Duplex</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重写自定义的双工流的 _read 方法</span></span><br><span class="line">  _read() &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="string">'123'</span>);</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写自定义的双工流的 _write 方法</span></span><br><span class="line">  _write(chunk, encoding, callback)) &#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双工流分别具备 <code>Readable</code> 和 <code>Writable</code> 的功能，但是读和写互不影响，互不关联。</p><h3 id="验证自定义双工流"><a href="#验证自定义双工流" class="headerlink" title="验证自定义双工流"></a>验证自定义双工流</h3><figure class="highlight js"><figcaption><span>验证自定义双工流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDuplex = <span class="keyword">new</span> MyDuplex();</span><br><span class="line"></span><br><span class="line">myDuplex.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myDuplex.read(<span class="number">1</span>), <span class="string">'----'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  myDuplex.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data, <span class="string">'xxxx'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;Buffer 31&gt; ----</span></span><br><span class="line"><span class="comment">// &lt;Buffer 32&gt; xxxx</span></span><br><span class="line"><span class="comment">// &lt;Buffer 32&gt; ----</span></span><br><span class="line"><span class="comment">// &lt;Buffer 33&gt; xxxx</span></span><br></pre></td></tr></table></figure><p>如果 <code>readable</code> 和 <code>data</code> 两种读取方式都使用默认先通过 <code>data</code> 事件读取，所以一般只选择一个，不要同时使用，可读流的特点是读取数据被消耗掉后就丢失了（缓存区被清空），如果非要两个都用可以加一个定时器（绝对不要这样写）。</p><h2 id="实现一个自定义转化流-Transform"><a href="#实现一个自定义转化流-Transform" class="headerlink" title="实现一个自定义转化流 Transform"></a>实现一个自定义转化流 Transform</h2><h3 id="创建自定义可转化流的类-MyTransform"><a href="#创建自定义可转化流的类-MyTransform" class="headerlink" title="创建自定义可转化流的类 MyTransform"></a>创建自定义可转化流的类 MyTransform</h3><p>转化流的意思是即可以当作可读流，又可以当作可写流，创建一个类名为 <code>MyTransform</code>，并继承 <code>stream</code> 中的 <code>Transform</code> 类，重写 <code>_transform</code> 方法，该方法的参数和 <code>_write</code> 相同。</p><figure class="highlight js"><figcaption><span>创建自定义转化流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义转化流的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重写自定义的转化流的 _transform 方法</span></span><br><span class="line">  _transform(chunk, encoding, callback)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunck.toString.toUpperCase());</span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="string">'123'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自定义转化流的 <code>_transform</code> 方法中，读取数据的 <code>push</code> 方法和 写入数据的 <code>callback</code> 都可以使用。</p><blockquote class="pullquote info"><p><em><strong>由此可以看出，<code>Transform</code> 类型可以将可读流转化为可写流，也可以将可写流转化成可读流，他的主要目的不是像其他类型的流一样负责数据的读写，而是既作为可读流又作为可写流，实现流的转化，即实现对数据的特殊处理，如 <code>zib</code> 模块实现的压缩流，<code>cropo</code> 模块实现的加密流，本质都是转化流，将转化流作为可写流，将存储文件内容的可写流通过 <code>pipe</code> 方法写入转化流，再将转化流作为可读流通过 <code>pipe</code> 方法将处理后的数据响应给浏览器。</strong></em></p></blockquote><h3 id="验证自定义转化流"><a href="#验证自定义转化流" class="headerlink" title="验证自定义转化流"></a>验证自定义转化流</h3><figure class="highlight js"><figcaption><span>验证自定义转化流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTransForm = <span class="keyword">new</span> MyTransform();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标准输入</span></span><br><span class="line">process.stdin.pipe(myTransForm).pipe(process.stdin);</span><br></pre></td></tr></table></figure><p>打开命令行窗口执行 <code>node demo.js</code>，然后输入 <code>abc</code>，会在命令窗口输出 <code>ABC</code> 和 <code>123</code>，其实转换流先作为一个可写流被写入到标准输入中，而此时 <code>stdin</code> 的作用是读流，即读取用户的输入，读取后转换流作为一个可读流调用 <code>pipe</code>，将用户输入的信息通过标准输出写到命令行窗口，此时 <code>stdout</code> 的作用是写流。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>自定义流最常见的种类在上面都已经涵盖了，真正的在开发中用到的不多，如果需要写一个自定义流应该比上面的复杂很多，本文主要目的是认识什么是自定义流，并了解写一个自定义流的基本套路。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS —— 流的原理分析与简易实现</title>
      <link href="/2018/07/04/20180704175217/"/>
      <url>/2018/07/04/20180704175217/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/04/20180704175217/stream.png" title="流的实现原理"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>在之前的博客中已经了解了流的基本用法，这篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 <code>ReadStream</code>，流的基本用法请看这里 <a href="http://www.overtaking.top/2018/07/03/20180703231032/" target="_blank">NodeJS —— Stream 的基本使用</a>。</p></blockquote><a id="more"></a><h2 id="可读流的实现（流动模式）"><a href="#可读流的实现（流动模式）" class="headerlink" title="可读流的实现（流动模式）"></a>可读流的实现（流动模式）</h2><h3 id="ReadStream-类创建"><a href="#ReadStream-类创建" class="headerlink" title="ReadStream 类创建"></a>ReadStream 类创建</h3><p>在使用 <code>fs</code> 的 <code>createReadStream</code> 创建可读流时，返回了 <code>ReadStream</code> 对象，上面存在着一些事件和方法，其实我们在创建这个可读流的时候创建了某一个类的实例，这个实例可以调用类原型上的方法，我们这里将这个类命名为 <code>ReadStream</code>。</p><p>在类原型上的方法内部可能会创建一些事件，在 NodeJS 中，事件是依赖 <code>events</code> 模块的，即 <code>EventEmitter</code> 类，同时类的方法可能会操作文件，会用到 <code>fs</code> 模块，所以也提前引入 <code>fs</code>。</p><figure class="highlight js"><figcaption><span>创建 ReadStream 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ReadStream 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// 创建可读流参数传入的属性</span></span><br><span class="line">    <span class="keyword">this</span>.path = path; <span class="comment">// 读取文件的路径</span></span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>; <span class="comment">// 文件标识位</span></span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>; <span class="comment">// 字符编码</span></span><br><span class="line">    <span class="keyword">this</span>.fd = options.fd || <span class="literal">null</span>; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span>; <span class="comment">// 权限位</span></span><br><span class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>; <span class="comment">// 是否自动关闭</span></span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span>; <span class="comment">// 读取文件的起始位置</span></span><br><span class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span>; <span class="comment">// 读取文件的结束位置（包含）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次读取文件的字节数</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">this</span>.flowing = <span class="literal">false</span>; <span class="comment">// 控制当前是否是流动状态，默认为暂停状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储读取内容的 Buffer</span></span><br><span class="line">    <span class="keyword">this</span>.buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark);</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start; <span class="comment">// 下次读取文件的位置（变化的）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可读流要打开文件</span></span><br><span class="line">    <span class="keyword">this</span>.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果监听了 data 事件，切换为流动状态</span></span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, type =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">'data'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始读取文件</span></span><br><span class="line">        <span class="keyword">this</span>.read();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br></pre></td></tr></table></figure><p>使用 <code>fs.createReadStream</code> 时传入了两个参数，读取文件的路径和一个 <code>options</code> 选项，<code>options</code> 上有八个参数，我们在创建 <code>ReadStream</code> 类的时候将这些参数初始化到了 <code>this</code> 上。</p><p>创建可读流的时候有两种状态，流动状态和暂停状态，默认创建可读流是暂停状态，只有在触发 <code>data</code> 事件时才会变为流动状态，所以在 <code>this</code> 上挂载了 <code>flowing</code> 存储当前的状态是否为流动状态，值默认为 <code>false</code>。</p><blockquote class="pullquote warning"><p><em><strong>注意：这里说的暂停状态不是暂停模式，暂停模式是 <code>readable</code>, 是可读流的另一种模式，我们这节讨论的可读流为流动模式。</strong></em></p></blockquote><p>在读取文件时其实是操作 Buffer 进行读取的，需要有一个 Buffer 实例用来存储每次读取的数据，所以在 <code>this</code> 上挂载了一个新创建的 Buffer，长度等于 <code>highWaterMark</code>。</p><p>当从 <code>start</code> 值的位置开始读取文件，下一次读取文件的位置会发生变化，所以在 <code>this</code> 上挂载了 <code>pos</code> 属性，用于存储下次读取文件的位置。</p><p>在创建 <code>ReadStream</code> 的实例（可读流）时，应该打开文件并进行其他操作，所以在 <code>this</code> 上挂载了 <code>open</code> 方法并执行。</p><p>创建实例的同时监听了 <code>newListener</code> 事件，回调在每次使用 <code>on</code> 监听事件时触发，回调内部逻辑是为了将默认的暂停状态切换为流动状态，因为在使用时，流动状态是通过监听 <code>data</code> 事件触发的，在 <code>newListener</code> 的回调中判断事件类型为 <code>data</code> 的时候将 <code>flowing</code> 标识的值更改为 <code>true</code>，并调用读取文件的 <code>read</code> 方法。</p><blockquote class="pullquote info"><p>在使用 ES6 的类编程时，原型上的方法都是写在 <code>class</code> 内部，我们下面为了把原型上的方法拆分出来成为单独的代码块，都使用 <code>ReadStream.prototype.open = function...</code> 直接给原型添加属性的方式，但这样的方式和直接写在 <code>class</code> 内有一点区别，就是 <code>class</code> 内部的书写的原型方法都是不可遍历的，添加属性的方式创建的方法都是可遍历的，但是这点区别对我们代码的执行没有任何影响。</p></blockquote><h3 id="打开文件方法-open-的实现"><a href="#打开文件方法-open-的实现" class="headerlink" title="打开文件方法 open 的实现"></a>打开文件方法 open 的实现</h3><p>在使用可读流时，打开时默认是暂停状态，会触发 <code>open</code> 事件，如果打开文件出错会触发 <code>error</code> 事件。</p><figure class="highlight js"><figcaption><span>open 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">ReadStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, <span class="keyword">this</span>.mode, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果文件打开了出错，并配置自动关闭，则关掉文件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autoClose) &#123;</span><br><span class="line">        <span class="comment">// 关闭文件（触发 close 事件）</span></span><br><span class="line">        <span class="keyword">this</span>.destroy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不再继续执行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储文件描述符</span></span><br><span class="line">    <span class="keyword">this</span>.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功打开文件后触发 open 事件</span></span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'open'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>open</code> 方法的逻辑就是在打开文件的时候，将文件描述符存储在实例上方便后面使用，并使用 <code>EventEmitter</code> 的原型方法 <code>emit</code> 触发 <code>open</code> 事件，如果出错就使用 <code>emit</code> 触发 <code>error</code> 事件，如果配置 <code>autoClose</code> 参数为 <code>true</code>，就关闭文件并触发 <code>close</code>。</p><p>我们将关闭文件的逻辑抽取出来封装在了 <code>ReadStream</code> 类的 <code>destroy</code> 方法中，下面来实现 <code>destroy</code>。</p><h3 id="关闭文件方法-destroy-的实现"><a href="#关闭文件方法-destroy-的实现" class="headerlink" title="关闭文件方法 destroy 的实现"></a>关闭文件方法 destroy 的实现</h3><p>文件出错分为两种，第一种文件打开出错，第二种是文件不存在出错（没打开），第二种系统是没有分配文件描述符的。</p><figure class="highlight js"><figcaption><span>detroy 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">ReadStream.prototype.detroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否存在文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在则关闭文件并触发 close 事件</span></span><br><span class="line">    fs.close(fd, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不存在文件描述符直接触发 close 事件</span></span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是打开文件后出错需要关闭文件，并触发 <code>close</code> 事件，如果是没打开文件，则直接触发 <code>close</code> 事件，所以上面通过文件描述符来判断该如何处理。</p><h3 id="读取文件方法-read-的实现"><a href="#读取文件方法-read-的实现" class="headerlink" title="读取文件方法 read 的实现"></a>读取文件方法 read 的实现</h3><p>还记得在 <code>ReadStream</code> 类中，监听的 <code>newListener</code> 事件的回调中如果监听了 <code>data</code> 事件则会执行 <code>read</code> 读取文件，接下来就实现读取文件的核心逻辑。</p><figure class="highlight js"><figcaption><span>read 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">ReadStream.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 由于 open 异步执行，read 是在创建实例时同步执行</span></span><br><span class="line">  <span class="comment">// read 执行可能早于 open，此时不存在文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 read</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, () =&gt; <span class="keyword">this</span>.read());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如过设置了结束位置，读到结束为止就不能再读了</span></span><br><span class="line">  <span class="comment">// 如果最后一次读取真实读取数应该小于 highWaterMark</span></span><br><span class="line">  <span class="comment">// 所以每次读取的字节数应该和 highWaterMark 取最小值</span></span><br><span class="line">  <span class="keyword">let</span> howMuchToRead = <span class="keyword">this</span>.end ?</span><br><span class="line">    <span class="built_in">Math</span>.min(<span class="keyword">this</span>.highWaterMark, <span class="keyword">this</span>.end - <span class="keyword">this</span>.pos + <span class="number">1</span>) :</span><br><span class="line">    <span class="keyword">this</span>.highWaterMark;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.read(</span><br><span class="line">    <span class="keyword">this</span>.fd,</span><br><span class="line">    <span class="keyword">this</span>.buffer,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    howMuchToRead,</span><br><span class="line">    <span class="keyword">this</span>.pos,</span><br><span class="line">    (err, bytesRead) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果读到内容执行下面代码，读不到则触发 end 事件并关闭文件</span></span><br><span class="line">      <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 维护下次读取文件位置</span></span><br><span class="line">        <span class="keyword">this</span>.pos += bytesRead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保留有效的 Buffer</span></span><br><span class="line">        <span class="keyword">let</span> realBuf = <span class="keyword">this</span>.buffer.slice(<span class="number">0</span>, bytesRead);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据编码处理 data 回调返回的数据</span></span><br><span class="line">        realBuf = <span class="keyword">this</span>.encoding ?</span><br><span class="line">          realBuf.toString(<span class="keyword">this</span>.encoding) :</span><br><span class="line">          realBuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发 data 事件并传递数据</span></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'data'</span>, realBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归读取</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.flowing) &#123;</span><br><span class="line">          <span class="keyword">this</span>.read();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.isEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>); <span class="comment">// 触发 end 事件</span></span><br><span class="line">        <span class="keyword">this</span>.detroy(); <span class="comment">// 关闭文件</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>ReadStream</code> 的实例时，执行的 <code>open</code> 方法内部是使用 <code>fs.open</code> 打开文件的，是异步操作，而读取文件方法 <code>read</code> 是在 <code>newListener</code> 回调中同步执行的，这样很可能触发 <code>read</code> 的时候文件还没有被打开（不存在文件描述符），所以在 <code>read</code> 方法中判断了文件描述符是否存在，并在不存在时候使用 <code>once</code> 添加了 <code>open</code> 事件，回调中重新执行了 <code>read</code>。</p><p>由于在 <code>open</code> 方法中使用 <code>emit</code> 触发了 <code>open</code> 事件，所以 <code>read</code> 内用 <code>once</code> 添加的 <code>open</code> 事件的回调也会跟着执行一次，并在回调中重新调用了 <code>read</code> 方法，保证了 <code>read</code> 读取文件的逻辑在文件真正打开后才执行，为了文件打开前执行 <code>read</code> 而不执行读取文件的逻辑，用 <code>once</code> 添加 <code>open</code> 事件时别忘记 <code>return</code>。</p><p>在使用 <code>fs.read</code> 读取文件的时候有一个参数为本次读取几个字符到 Buffer 中，如果在创建可读流的时候设置了读取文件的结束位置 <code>end</code> 参数，则读到 <code>end</code> 位置就不应该再继续读取了，所以在存在 <code>end</code> 参数的时候每次都计算一下读取个数和 <code>highWaterMark</code> 取最小值，保证读取内容小于 <code>highWaterMark</code> 的时候不会多读，因为读取时是包括 <code>end</code> 值作为 Buffer 的索引这一项的，所以计算时多减去的要 <code>+1</code> 加回来，再一次读取这个读取个数计算结果变成了 <code>0</code>，也就结束了读取。</p><p>因为 <code>end</code> 参数的情况，所以在内部读取逻辑前判断了 <code>bytesRead</code> （实际读取字节数）是否大于 <code>0</code>，如果不满足条件则在实例添加是否读取结束标识 <code>isEnd</code>（后面使用），触发 <code>end</code> 事件并关闭文件，如果满足条件，也是通过 <code>bytesRead</code> 对 Buffer 进行截取，保留了有用的 Buffer，并且通过 <code>encoding</code> 编码对 Buffer 进行处理后，触发 <code>data</code> 事件，并将处理后的数据传递给 <code>data</code> 事件的回调。</p><h3 id="暂停、恢复读取-pause-和-resume"><a href="#暂停、恢复读取-pause-和-resume" class="headerlink" title="暂停、恢复读取 pause 和 resume"></a>暂停、恢复读取 pause 和 resume</h3><p><code>pause</code> 的目的就是暂停读取，其实就是阻止 <code>read</code> 方法在读取时进行递归，所以只需要更改 <code>flowing</code> 的值即可。</p><figure class="highlight js"><figcaption><span>pause 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停读取</span></span><br><span class="line">ReadStream.prototype.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.flowing = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>resume</code> 的目的是恢复读取，在更改 <code>flowing</code> 值得基础上重新执行 <code>read</code> 方法，由于在 <code>pause</code> 调用时 <code>read</code> 内部还是执行得读取文件得分支，文件并没有关闭，读取文件位置的参数也是通过实例上的当前的属性值进行计算的，所以重新执行 <code>read</code> 会继续上一次的位置读取。</p><figure class="highlight js"><figcaption><span>resume 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恢复读取</span></span><br><span class="line">ReadStream.prototype.resume = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnd) <span class="keyword">this</span>.read();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面在重新执行 <code>read</code> 之前使用 <code>isEnd</code> 标识做了判断，防止在 <code>setInterval</code> 中调用 <code>resume</code> 在读取完成后不断的触发 <code>end</code> 和 <code>close</code> 事件。</p><h2 id="验证可读流（流动模式）ReadStream"><a href="#验证可读流（流动模式）ReadStream" class="headerlink" title="验证可读流（流动模式）ReadStream"></a>验证可读流（流动模式）ReadStream</h2><p>接下来我们使用自己实现的 <code>ReadStream</code> 类来创建可读流，并按照 <code>fs.createReadStream</code> 的用法进行使用并验证。</p><figure class="highlight js"><figcaption><span>验证 ReadStream</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 1.txt 内容为 0123456789</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">5</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'open'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'open'</span>));</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  rs.pause();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'end'</span>));</span><br><span class="line">rs.on(<span class="string">'close'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'close'</span>));</span><br><span class="line">rs.on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> rs.resume(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// open</span></span><br><span class="line"><span class="comment">// 01 2018-07-04T10:44:20.384Z</span></span><br><span class="line"><span class="comment">// 23 2018-07-04T10:44:21.384Z</span></span><br><span class="line"><span class="comment">// 45 2018-07-04T10:44:22.384Z</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// close</span></span><br></pre></td></tr></table></figure><p>执行上面的代码正常的执行逻辑是先触发 <code>open</code> 事件，然后触发 <code>data</code> 事件，读取一次后暂停，每隔一秒恢复读取一次，再读取完成后触发 <code>end</code> 和 <code>close</code> 事件，通过运行代码结果和我们希望的一样。</p><h2 id="可读流的实现（暂停模式）"><a href="#可读流的实现（暂停模式）" class="headerlink" title="可读流的实现（暂停模式）"></a>可读流的实现（暂停模式）</h2><h3 id="在-fs-中的暂停模式的真正用法"><a href="#在-fs-中的暂停模式的真正用法" class="headerlink" title="在 fs 中的暂停模式的真正用法"></a>在 fs 中的暂停模式的真正用法</h3><p>在 <code>fs</code> 模块中用 <code>createReadStream</code> 创建的可读流中通过监听 <code>readable</code> 事件触发暂停模式（监听 data 事件触发流动模式），通过下面例子感受暂停模式与流动模式的不同，现在读取文件 <code>1.txt</code>，内容为 <code>0~9</code> 十个数字。</p><figure class="highlight js"><figcaption><span>暂停模式的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取的</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// read 参数为本次读取的个数</span></span><br><span class="line">  <span class="keyword">let</span> r = rs.read(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 打印读取的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">  <span class="comment">// 打印容器剩余空间</span></span><br><span class="line">  <span class="built_in">console</span>.log(rs._readableState.length);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 012</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 345</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 678</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 90</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>通俗的解释，暂停模式的 <code>readable</code> 事件默认会触发一次，监听 <code>readable</code> 事件后就像创建了一个 “容器”，容量为 <code>highWaterMark</code>，文件中的数据会自动把容器注满，调用可读流的 <code>read</code> 方法读取时，会从容器中取出数据，如果 <code>read</code> 方法读取的数据小于 <code>highWaterMark</code>，则直接暂停，不再继续读取，如果大于 <code>highWaterMark</code> ，说明 “容器” 空了，则会触发 <code>readable</code> 事件，无论读取字节数与 <code>highWaterMark</code> 关系如何，只要 “容器” 内容量剩余小于 <code>highWaterMark</code> 就会进行 “续杯”，再次向 “容器” 中填入 <code>highWaterMark</code> 个，所以有些时候真实的容量会大于 <code>highWaterMark</code>。</p><p><code>read</code> 方法读取的内容会返回 <code>null</code> 是因为容器内真实的数据数小于了读取数，如果不是最后一次读取，会在多次读取后将值一并返回，如果是最后一次读取，会把剩余不足的数据返回。</p><blockquote class="pullquote success"><p><em><strong>1、<code>readable</code> 事件的触发条件：“容器” 空了；</strong></em><br><em><strong>2、“续杯” 条件：读取后 “容器” 内剩余量小于 <code>highWaterMark</code>。</strong></em><br><em><strong>3、<code>read</code> 返回 <code>null</code>：“容器” 容器内可悲读取数据无法满足一次读取字节数。</strong></em></p></blockquote><h3 id="ReadableStream-类的实现"><a href="#ReadableStream-类的实现" class="headerlink" title="ReadableStream 类的实现"></a>ReadableStream 类的实现</h3><p>同为可读流，暂停模式与流动模式相同，都依赖 <code>fs</code> 模块和 <code>events</code> 模块的 <code>EventEmitter</code> 类，参数依然为读取文件的路径和 <code>options</code>。</p><figure class="highlight js"><figcaption><span>创建 ReadableStream 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadableStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.path = path; <span class="comment">// 读取文件的路径</span></span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>; <span class="comment">// 文件标识位</span></span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>; <span class="comment">// 字符编码</span></span><br><span class="line">    <span class="keyword">this</span>.fd = options.fd || <span class="literal">null</span>; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span>; <span class="comment">// 权限位</span></span><br><span class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>; <span class="comment">// 是否自动关闭</span></span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span>; <span class="comment">// 读取文件的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次读取文件的字节数</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">this</span>.reading = <span class="literal">false</span>; <span class="comment">// 如果正在读取，则不再读取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当缓存区的长度等于 0 的时候， 触发 readable</span></span><br><span class="line">    <span class="keyword">this</span>.emitReadable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.arr = []; <span class="comment">// 缓存区</span></span><br><span class="line">    <span class="keyword">this</span>.len = <span class="number">0</span>; <span class="comment">// 缓存区的长度</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start; <span class="comment">// 下次读取文件的位置（变化的）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可读流要打开文件</span></span><br><span class="line">    <span class="keyword">this</span>.open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, type =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">'readable'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.read(); <span class="comment">// 监听readable就开始读取</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = ReadableStream;</span><br></pre></td></tr></table></figure><p>在类的添加了 <code>newListener</code> 事件，在回调中判断是否监听了 <code>readable</code> 事件，如果监听了开始从 “容器” 中读取。</p><h3 id="打开、关闭文件-open-和-detroy"><a href="#打开、关闭文件-open-和-detroy" class="headerlink" title="打开、关闭文件 open 和 detroy"></a>打开、关闭文件 open 和 detroy</h3><p>打开和关闭文件的方法和流动模式的套路基本相似。</p><figure class="highlight js"><figcaption><span>open 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">ReadableStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, <span class="keyword">this</span>.mode, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autoClose) &#123;</span><br><span class="line">        <span class="keyword">this</span>.destroy();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fd = fd;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'open'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>detroy 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">ReadableStream.prototype.detroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd === <span class="string">'number'</span>) &#123;</span><br><span class="line">    fs.close(fd, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从-“容器”-中读取-read-方法的实现"><a href="#从-“容器”-中读取-read-方法的实现" class="headerlink" title="从 “容器” 中读取 read 方法的实现"></a>从 “容器” 中读取 read 方法的实现</h3><p><code>read</code> 方法的参数不传时就相当于从 “容器” 读取 <code>highWaterMart</code> 个字节，如果传参表示读取参数数量的字节数。</p><figure class="highlight js"><figcaption><span>read 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ReadableStream.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果读取大于了 highWaterMark，重新计算 highWaterMark，并重新读取</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="keyword">this</span>.len) &#123;</span><br><span class="line">    <span class="comment">// 计算新的 highWaterMark，方法摘自 NodeJS 源码</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = computeNewHighWaterMark(n);</span><br><span class="line">    <span class="keyword">this</span>.reading = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>._read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将要返回的数据</span></span><br><span class="line">  <span class="keyword">let</span> buffer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果读取的字节数大于 0 小于等于当前缓存 Buffer 的总长度</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n &lt;= <span class="keyword">this</span>.len) &#123;</span><br><span class="line">    <span class="comment">// 则从缓存中取出</span></span><br><span class="line">    buffer = Buffer.alloc(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> current; <span class="comment">// 存储每次从缓存区读出的第一个 Buffer</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 每次读取缓存 Buffer 的索引</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>; <span class="comment">// 是否结束整个 while 循环的标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始读取</span></span><br><span class="line">    <span class="keyword">while</span> ((current = <span class="keyword">this</span>.arr.shift()) &amp;&amp; flag) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; current.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 将缓存中取到的 Buffer 的内容读到自己定义的 Buffer 中</span></span><br><span class="line">        buffer[index++] = current[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前索引值已经等于了读取个数，结束 for 循环</span></span><br><span class="line">        <span class="keyword">if</span> (index === n) &#123;</span><br><span class="line">          flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 取出当前 Buffer 没有消耗的</span></span><br><span class="line">          <span class="keyword">let</span> residue = current.slice(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在读取后维护缓存的长度</span></span><br><span class="line">          <span class="keyword">this</span>.len -= n;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果 BUffer 真的有剩下的就给塞回到缓存中</span></span><br><span class="line">          <span class="keyword">if</span> (residue.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.arr.unshift(residue);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前 读取的 Buffer 为 0，将触发 readable 事件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.len === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.emitReadable = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前的缓存区大小小于 highWaterMark，就要读取</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark) &#123;</span><br><span class="line">    <span class="comment">// 如果不是正在读取才开始读取</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.read) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reading = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>._read(); <span class="comment">// 正真读取的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 buffer 转回创建可读流设置成的编码格式</span></span><br><span class="line">  <span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">    buffer = <span class="keyword">this</span>.encoding ? buffer.toString(<span class="keyword">this</span>.encoding) : buffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>read</code> 方法的参数大小对比缓存区中取出的 Buffer 长度有两种情况，一种是小于当前缓存区内取出 Buffer 的长度，一种是大于了真个缓存区的 <code>len</code> 的长度。</p><p>小于当前缓存区总长度通过循环取出需要的 Buffer 存储了我们要返回创建的 Buffer 中，剩余的 Buffer 会丢失，所以我们做了一个小小的处理，将剩下的 Buffer 作为第一个 Buffer 塞回到了缓存区中，在处理这个问题时与流动模式不相同，流动模式处理后直接跳出了，而暂停模式相当于从 “容器” 中读取，如果第一次读取后还有剩余还要接着从容器中继续读取。</p><p>大于 <code>len</code> 属性时，规定需要重新计算 <code>highWaterMark</code>，遵循的原则是将当前 <code>highWaterMark</code> 设定为当前读取字节个数距离最接近的 <code>2</code> 的 <code>n</code> 次方的数值，NodeJS 源码中方法名称为 <code>computeNewHighWaterMark</code>，为了提高性能是使用位运算的方式进行计算的，源码如下。</p><figure class="highlight js"><figcaption><span>重新计算 highWaterMark</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeNewHighWaterMark</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  n--;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  n++;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用该方法重新计算 <code>highWaterMark</code> 后更改正在读取状态，重新读取，由于读取逻辑的重复，所以真正读取文件的逻辑抽取成一个 <code>_read</code> 方法来实现，下面呢就来看看 <code>_read</code> 内部都做了什么。</p><h3 id="真正读取文件的-read"><a href="#真正读取文件的-read" class="headerlink" title="真正读取文件的 _read"></a>真正读取文件的 _read</h3><p>对比可读流（流动模式）的 <code>read</code> 方法，在调用 <code>_read</code> 方法读取时，是在 <code>newListener</code> 中同步执行 <code>_read</code>，所以为了保证 <code>_read</code> 的逻辑是在 <code>open</code> 方法打开文件以后执行，使用了与 <code>read</code> 相同的处理方式。</p><figure class="highlight js"><figcaption><span>_read 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ReadableStream.prototype._read = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, () =&gt; _read());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建本次读取的 Buffer</span></span><br><span class="line">  <span class="keyword">let</span> buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.read(</span><br><span class="line">    <span class="keyword">this</span>.fd,</span><br><span class="line">    buffer,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">this</span>.highWaterMark,</span><br><span class="line">    <span class="keyword">this</span>.pos,</span><br><span class="line">    (err, bytesRead) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.arr.push(buffer); <span class="comment">// 缓存</span></span><br><span class="line">        <span class="keyword">this</span>.len += bytesRead; <span class="comment">// 维护缓存区长度</span></span><br><span class="line">        <span class="keyword">this</span>.pos += bytesRead; <span class="comment">// 维护下一次读取位置</span></span><br><span class="line">        <span class="keyword">this</span>.reading = <span class="literal">false</span>; <span class="comment">// 读取完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发 readable 事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.emitReadable) &#123;</span><br><span class="line">          <span class="comment">// 触发后更改触发状态为 false</span></span><br><span class="line">          <span class="keyword">this</span>.emitReadable = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">this</span>.emit(<span class="string">'readable'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果读完触发结束事件</span></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于缓存区是一个数组，存储的每一个 Buffer 是独立存在的，所以不能挂载在实例上共用，如果挂在实例上则引用相同，一动全动，这不是我们想要的，所以每一次执行 <code>_read</code> 方法时都创建新的 Buffer 实例存入读取的数据后存储在缓存区中，如果读取完成 <code>bytesRead</code> 为 <code>0</code>，则触发 <code>end</code> 事件。</p><blockquote class="pullquote warning"><p><em><strong>注意：在 NodeJS 源码中，可读流的两种模式代码都是混合在一起的，只是使用 <code>fs.createReadStream</code> 创建一个可读流，通过监听 <code>data</code> 和 <code>readable</code> 两种不同的事件来触发两种不同的模式，而我们为了模拟，把两种模式拆开成了两个类来实现的，在测试时需要创建不同类的实例。</strong></em></p></blockquote><h2 id="验证可读流（暂停模式）ReadableStream"><a href="#验证可读流（暂停模式）ReadableStream" class="headerlink" title="验证可读流（暂停模式）ReadableStream"></a>验证可读流（暂停模式）ReadableStream</h2><p>为了统一我们依然读取真正用法中 <code>1.txt</code> 文件，内容为 0~9 十个数字。</p><figure class="highlight js"><figcaption><span>验证 ReadableStream</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> ReadableStream = <span class="built_in">require</span>(<span class="string">'./ReadableStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReadableStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> r = rs.read(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">  <span class="built_in">console</span>.log(rs.len);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在打印 “容器” 剩余容量时，我们使用在 <code>ReadableStream</code> 上构造的 <code>len</code> 属性。</p><blockquote class="pullquote info"><p>流动模式和暂停模式分别有不同的应用场景，如果只是希望读取一个文件，并最快的获得结果使用流动模式是很好的选择，如果希望了解读取文件的具体内容，并进行精细的处理，使用暂停模式更好一些。</p></blockquote><h2 id="可写流的实现"><a href="#可写流的实现" class="headerlink" title="可写流的实现"></a>可写流的实现</h2><h3 id="WriteStream-类创建"><a href="#WriteStream-类创建" class="headerlink" title="WriteStream 类创建"></a>WriteStream 类创建</h3><p>在使用 <code>fs</code> 的 <code>createWriteStream</code> 创建可写流时，返回了 <code>WriteStream</code> 对象，上面也存在事件和方法，创建可写流的时也是创建类的实例，我们将这个类命名为 <code>WriteStream</code>。事件同样依赖 <code>events</code> 模块的 <code>EventEmitter</code> 类，文件操作同样依赖 <code>fs</code> 模块，所以需提前引入。</p><figure class="highlight js"><figcaption><span>创建 WriteStream 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 WriteStream 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// 创建可写流参数传入的属性</span></span><br><span class="line">    <span class="keyword">this</span>.path = path; <span class="comment">// 写入文件的路径</span></span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'w'</span>; <span class="comment">// 文件标识位</span></span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="string">'utf8'</span>; <span class="comment">// 字符编码</span></span><br><span class="line">    <span class="keyword">this</span>.fd = options.fd || <span class="literal">null</span>; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span>; <span class="comment">// 权限位</span></span><br><span class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>; <span class="comment">// 是否自动关闭</span></span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span>; <span class="comment">// 写入文件的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比写入字节数的标识</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">this</span>.writing = <span class="literal">false</span>; <span class="comment">// 是否正在写入</span></span><br><span class="line">    <span class="keyword">this</span>.needDrain = <span class="literal">false</span>; <span class="comment">// 是否需要触发 drain 事件</span></span><br><span class="line">    <span class="keyword">this</span>.buffer = []; <span class="comment">// 缓存，正在写入就存入缓存中</span></span><br><span class="line">    <span class="keyword">this</span>.len = <span class="number">0</span>; <span class="comment">// 当前缓存的个数</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start; <span class="comment">// 下次写入文件的位置（变化的）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可写流要打开文件</span></span><br><span class="line">    <span class="keyword">this</span>.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = WriteStream;</span><br></pre></td></tr></table></figure><p>使用 <code>fs.createWriteStream</code> 创建可写流时传入了两个参数，写入的文件路径和一个 <code>options</code> 选项，<code>options</code> 上有七个参数，我们在创建 <code>ReadStream</code> 类的时候将这些参数初始化到了 <code>this</code> 上。</p><p>创建可写流后需要使用 <code>write</code> 方法进行写入，写入时第一次会真的通过内存写入到文件中，而再次写入则会将内容写到缓存中，注意这里的 “内存” 和 “缓存”，内存是写入文件是的系统内存，缓存是我们自己创建的数组，第一次写入以后要写入文件的 Buffer 都会先存入这个数组中，这个数组名为 <code>buffer</code>，挂载在实例上，实例上同时挂载了 <code>len</code> 属性用来存储当前缓存中 Buffer 总共的字节数（长度）。</p><p>我们在可读流上挂载了是否正在写入的状态 <code>writing</code> 属性，只要缓存区中存在未写入的 Buffer，<code>writing</code> 的状态就是正在写入，当写入的字节数大于了 <code>highWaterMark</code> 需要触发 <code>drain</code> 事件，所以又挂载了是否需要触发 <code>drain</code> 事件的标识 <code>needDrain</code> 属性。</p><p>当从文件的 <code>start</code> 值对应的位置开始写入，下一次写入文件的位置会发生变化，所以在 <code>this</code> 上挂载了 <code>pos</code> 属性，用于存储下次写入文件的位置。</p><blockquote class="pullquote primary"><p>在 NodeJS 流的源码中缓存是用链表实现的，通过指针来操作缓存中的 Buffer，而我们为了简化逻辑就使用数组来作为缓存，虽然性能相对链表要差。</p></blockquote><h3 id="打开、关闭文件-open-和-detroy-1"><a href="#打开、关闭文件-open-和-detroy-1" class="headerlink" title="打开、关闭文件 open 和 detroy"></a>打开、关闭文件 open 和 detroy</h3><p>在 <code>WriteStream</code> 中，写入文件之前也应该打开文件，在打开文件过程中出错时也应该触发 <code>error</code> 事件并关闭文件，打开和关闭文件的方法 <code>open</code> 和 <code>detroy</code> 与 <code>ReadStream</code> 的 <code>open</code> 和 <code>detroy</code> 方法的逻辑如出一辙，所以这里直接拿过来用了。</p><figure class="highlight js"><figcaption><span>open 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">WriteStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, <span class="keyword">this</span>.mode, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autoClose) &#123;</span><br><span class="line">        <span class="keyword">this</span>.destroy();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fd = fd;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'open'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>detroy 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">WriteStream.prototype.detroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd === <span class="string">'number'</span>) &#123;</span><br><span class="line">    fs.close(fd, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入文件方法-write-的实现"><a href="#写入文件方法-write-的实现" class="headerlink" title="写入文件方法 write 的实现"></a>写入文件方法 write 的实现</h3><p><code>write</code> 方法默认支持传入三个参数：</p><ul><li>chunk：写入文件的内容；</li><li>encoding：写入文件的编码格式；</li><li>callback：写入成功后执行的回调。</li></ul><figure class="highlight js"><figcaption><span>write 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件的方法，只要逻辑为写入前的处理</span></span><br><span class="line">WriteStream.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  chunk,</span></span></span><br><span class="line"><span class="function"><span class="params">  encoding = this.encoding,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了方便操作将要写入的数据转换成 Buffer</span></span><br><span class="line">  chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护缓存的长度</span></span><br><span class="line">  <span class="keyword">this</span>.len += chunk.lenth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护是否触发 drain 事件的标识</span></span><br><span class="line">  <span class="keyword">this</span>.needDrain = <span class="keyword">this</span>.highWaterMark &lt;= <span class="keyword">this</span>.len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果正在写入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.writing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.buffer.push(&#123;</span><br><span class="line">      chunk,</span><br><span class="line">      encoding,</span><br><span class="line">      callback</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更改标识为正在写入，再次写入的时候走缓存</span></span><br><span class="line">    <span class="keyword">this</span>.writing = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果已经写入清空缓存区的内容</span></span><br><span class="line">    <span class="keyword">this</span>._write(chunk, encoding, () =&gt; <span class="keyword">this</span>.clearBuffer());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !<span class="keyword">this</span>.needDrain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与可写流的 <code>read</code> 一样，我们在使用 <code>write</code> 方法将数据写入文件时，也是操作 Buffer，在 <code>write</code> 方法中，首先将接收到的要写入的数据转换成了 Buffer，因为是多次写入，要知道缓存中 Buffer 字节数的总长度，所以维护了 <code>len</code> 变量。</p><p>我们的 <code>WriteStream</code> 构造函数中，<code>this</code> 挂载了 <code>needDrain</code> 属性，在使用 <code>fs.createWriteStream</code> 创建的可读流时，是写入的字节长度超过 <code>highWaterMark</code> 才会触发 <code>drain</code> 事件，而 <code>needDrain</code> 与 <code>write</code> 的返回值正好相反，所以我们用 <code>needDrain</code> 取反来作为 <code>write</code> 方法的返回值。</p><p>在写入的逻辑中第一次是直接通过内存写入到文件，但是再次写入就需要将数据存入缓存，将数据写入到文件中写入状态 <code>writing</code> 默认为 <code>false</code>，通过缓存再写入证明应该正在写入中，所以在第一次写入后应更改 <code>writing</code> 的状态为 <code>true</code>，写入缓存其实就是把转换的 Buffer、编码以及写入成功后要执行的回调挂在一个对象上存入缓存的数组 <code>buffer</code> 中。</p><p>我们把真正写入文件的逻辑抽取成一个单独的方法 <code>_write</code>，并传入 <code>chunk</code>（要写入的内容，已经处理成 Buffer）、<code>encoding</code>（字符编码）、回调函数，在回调函数中执行了原型方法 <code>clearBuffer</code>，接下来就来实现 <code>_write</code> 和 <code>clearBuffer</code>。</p><blockquote class="pullquote warning"><p><strong><em>注意：方法使用 `</em>` 开头代表私有方法，轻易不要在外部调用或修改，这是一个开发者之间约定俗成的不成文规定。_</strong></p></blockquote><h3 id="真正的文件操作-write"><a href="#真正的文件操作-write" class="headerlink" title="真正的文件操作 _write"></a>真正的文件操作 _write</h3><p>对比可读流（流动模式）的 <code>read</code> 方法，在调用 <code>_write</code> 方法写入时，是在创建可写流之后的同步代码中执行的，与可读流在 <code>newListener</code> 中同步执行 <code>read</code> 的情况类似，所以为了保证 <code>_write</code> 的逻辑是在 <code>open</code> 方法打开文件以后执行，使用了与 <code>read</code> 相同的处理方式。</p><figure class="highlight js"><figcaption><span>_write 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的写入文件操作的方法</span></span><br><span class="line">WriteStream.prototype._write = <span class="function"><span class="keyword">function</span>(<span class="params">chunk, encoding, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 由于 open 异步执行，write 是在创建实例时同步执行</span></span><br><span class="line">  <span class="comment">// write 执行可能早于 open，此时不存在文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 write</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.once(</span><br><span class="line">      <span class="string">'open'</span>,</span><br><span class="line">      () =&gt; <span class="keyword">this</span>._write(chunk, encoding, callback)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.write(</span><br><span class="line">    <span class="keyword">this</span>.fd,</span><br><span class="line">    chunk,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    chunk.length,</span><br><span class="line">    <span class="keyword">this</span>.pos,</span><br><span class="line">    (err, bytesWritten) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 维护下次写入的位置和缓存区 Buffer 的总字节数</span></span><br><span class="line">      <span class="keyword">this</span>.pos += bytesWritten;</span><br><span class="line">      <span class="keyword">this</span>.len -= bytesWritten;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在打开文件并写入的时候需要维护两个变量，下次写入的位置 <code>pos</code> 和当前缓存区内 Buffer 所占总字节数 <code>len</code>，本次写入了多少个字节，下次写入需要在写入位置的基础上加多少个字节，而 <code>len</code> 恰恰相反，本次写入了多少个字节，缓存区中的总长度应该对应的减少多少个字节。</p><p>在维护两个变量的值以后调用 <code>callback</code>，其实 <code>callback</code> 内执行的是 <code>clearBuffer</code> 方法，就如方法名，译为 “清空缓存”，其实就是一次一次的将数据写入文件并从缓存中移除，很明显需要递归调用 <code>_write</code> 方法，我们将这个递归的逻辑统一放在 <code>clearBuffer</code> 方法中实现。</p><h3 id="清空缓存操作-clearBuffer"><a href="#清空缓存操作-clearBuffer" class="headerlink" title="清空缓存操作 clearBuffer"></a>清空缓存操作 clearBuffer</h3><figure class="highlight js"><figcaption><span>clearBuffer 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空缓存方法</span></span><br><span class="line">WriteStream.prototype.clearBuffer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先写入的在数组前面，从前面取出缓存中的 Buffer</span></span><br><span class="line">  <span class="keyword">let</span> buf = <span class="keyword">this</span>.buffer.shift();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在 buf，证明缓存还有 Buffer 需要写入</span></span><br><span class="line">  <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">    <span class="comment">// 递归 _write 按照编码将数据写入文件</span></span><br><span class="line">    <span class="keyword">this</span>._write(buf.chunk, buf.encoding, () =&gt; <span class="keyword">this</span>.clearBuffer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有 buf，说明缓存内的内容已经完全写入文件并清空，需要触发 drain 事件</span></span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'drain'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改正在写入状态</span></span><br><span class="line">    <span class="keyword">this</span>.writing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改是否需要触发 drain 事件状态</span></span><br><span class="line">    <span class="keyword">this</span>.needDrain = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clearBuffer</code> 方法中获取了缓存区数组的最前面的 Buffer（最前面的是先写入缓存的，也应该先取出来写入文件），存在这个 Buffer 时，递归 <code>_write</code> 方法按照编码将数据写入文件，如果不存在说明缓存区已经清空了，代表内容完全写入文件中，所以触发 <code>drain</code> 事件，最后更改了 <code>writing</code> 和 <code>needDrain</code> 的状态。</p><p>更正 <code>writing</code> 是为了 <code>WriteStream</code> 创建的可读流在下次调用 <code>write</code> 方法时默认第一次真正写入文件，而更正 <code>needDrain</code> 的状态是在缓存区要清空的最后一个 Buffer 的长度小于了 <code>highWaterMark</code> 时，保证 <code>write</code> 方法的返回值是正确的。</p><blockquote class="pullquote info"><p>第一次是真正写入，其他的都写入缓存，再一个一个的将缓存中存储的 Buffer 写入并从缓存清空，之所以这样设计是为了把写入的内容排成一个队列，假如有 <code>3</code> 个人同时操作一个文件写入内容，只有第一个人是真的写入，其他的人都写在缓存中，再按照写入缓存的顺序依次写入文件，避免冲突和写入顺序出错。</p></blockquote><h2 id="验证可写流-WriteStream"><a href="#验证可写流-WriteStream" class="headerlink" title="验证可写流 WriteStream"></a>验证可写流 WriteStream</h2><p>接下来我们使用自己实现的 WriteStream 类来创建可写流，并按照 <code>fs.createWriteStream</code> 的用法进行使用并验证。</p><figure class="highlight js"><figcaption><span>验证 WriteStream</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 1.txt 文件中写入 012345</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteStream = <span class="built_in">require</span>(<span class="string">'./WriteStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可写流</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= <span class="number">6</span> &amp;&amp; flag) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    flag = ws.write(i + <span class="string">''</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'写入成功'</span>);</span><br><span class="line">  write();</span><br><span class="line">&#125;);</span><br><span class="line">write();</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// 写入成功</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// 写入成功</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>fs.createWriteStream</code> 和 <code>WriteStream</code> 类分别执行上面的代码，对比结果，看看是否相同。</p><h2 id="可读流和可写流的桥梁-pipe"><a href="#可读流和可写流的桥梁-pipe" class="headerlink" title="可读流和可写流的桥梁 pipe"></a>可读流和可写流的桥梁 pipe</h2><p>可写流和可读流一般是通过 <code>pipe</code> 配合来使用的，<code>pipe</code> 方法是可读流 <code>ReadStream</code> 的原型方法，参数为一个可写流。</p><figure class="highlight js"><figcaption><span>pipe 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接可读流和可写流的方法 pipe</span></span><br><span class="line">ReadStream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 开始读取</span></span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果超出可写流的 highWaterMark，暂停读取</span></span><br><span class="line">    <span class="keyword">let</span> flag = dest.write(data);</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">this</span>.pause();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dest.on(<span class="string">'drain'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当可写流清空内存时恢复读取</span></span><br><span class="line">    <span class="keyword">this</span>.resume();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在读取完毕后关闭文件</span></span><br><span class="line">    <span class="keyword">this</span>.destroy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pipe</code> 方法其实就是通过可读流的 <code>data</code> 事件触发流动状态，并用可写流接收读出的数据进行写入，当写入数据超出 <code>highWaterMark</code>，则暂停可读流的读取，直到可写流的缓存被清空并把内容写进文件后，恢复可读流的读取，当读取结束后关闭文件。</p><p>下面我们实现一个将 <code>1.txt</code> 的内容拷贝 <code>2.txt</code> 中的例子。</p><figure class="highlight js"><figcaption><span>验证 pipe</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe 的使用</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入自己的 ReadStream 类和 WriteStream 类</span></span><br><span class="line"><span class="keyword">const</span> ReadStream = rquire(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteStream = rquire(<span class="string">'./WriteStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流和可写流</span></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 pipe 实现文件内容复制</span></span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 NodeJS 源码中，可读流和可写流的内容要比本篇内容多很多，本篇是将源码精简，抽出核心逻辑并针对流的使用方式进行实现，主要目的是帮助理解流的原理和使用，争取做到 “知其然知其所以然”，了解了一些底层再对流使用时，也能游刃有余。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Stream </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS —— Stream 的基本使用</title>
      <link href="/2018/07/03/20180703231032/"/>
      <url>/2018/07/03/20180703231032/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/03/20180703231032/stream-use.jpg" title="流的基本使用"><p><br></p><h2 id="流的介绍"><a href="#流的介绍" class="headerlink" title="流的介绍"></a>流的介绍</h2><blockquote class="pullquote info"><p>在 NodeJS 中，我们对文件的操作需要依赖核心模块 <code>fs</code>，<code>fs</code> 中有很基本 API 可以帮助我们读写占用内存较小的文件，如果是大文件或内存不确定也可以通过 <code>open</code>、<code>read</code>、<code>write</code>、<code>close</code> 等方法对文件进行操作，但是这样操作文件每一个步骤都要关心，非常繁琐，<code>fs</code> 中提供了可读流和可写流，让我们通过流来操作文件，方便我们对文件的读取和写入。</p></blockquote><a id="more"></a><h2 id="可读流"><a href="#可读流" class="headerlink" title="可读流"></a>可读流</h2><h3 id="createReadStream-创建可读流"><a href="#createReadStream-创建可读流" class="headerlink" title="createReadStream 创建可读流"></a>createReadStream 创建可读流</h3><p><code>createReadStream</code> 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 <code>options</code> 选项，其中有八个参数：</p><ul><li>flags：标识位，默认为 <code>r</code>；</li><li>encoding：字符编码，默认为 <code>null</code>；</li><li>fd：文件描述符，默认为 <code>null</code>；</li><li>mode：权限位，默认为 <code>0o666</code>；</li><li>autoClose：是否自动关闭文件，默认为 <code>true</code>；</li><li>start：读取文件的起始位置；</li><li>end：读取文件的（包含）结束位置；</li><li>highWaterMark：最大读取文件的字节数，默认 <code>64 * 1024</code>。</li></ul><p><code>createReadStream</code> 的返回值为 <code>fs.ReadStream</code> 对象，读取文件的数据在不指定 <code>encoding</code> 时，默认为 Buffer。</p><figure class="highlight js"><figcaption><span>创建可读流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流，读取 1.txt 文件</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.creatReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">3</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在创建可读流后默认是不会读取文件内容的，读取文件时，可读流有两种状态，暂停状态和流动状态。</p><blockquote class="pullquote warning"><p><em><strong>注意：本篇的可写流为流动模式，流动模式中有暂停状态和流动状态，而不是暂停模式，暂停模式是另一种可读流 <code>readable</code>。</strong></em></p></blockquote><h3 id="流动状态"><a href="#流动状态" class="headerlink" title="流动状态"></a>流动状态</h3><p>流动状态的意思是，一旦开始读取文件，会按照 <code>highWaterMark</code> 的值一次一次读取，直到读完为止，就像一个打开的水龙头，水不断的流出，直到流干，需要通过监听 <code>data</code> 事件触发。</p><p>假如现在 <code>1.txt</code> 文件中的内容为 <code>0~9</code> 十个数字，我们现在创建可读流并用流动状态读取。</p><figure class="highlight js"><figcaption><span>流动状态</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">3</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听读取结束</span></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读完了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;Buffer 30 31&gt;</span></span><br><span class="line"><span class="comment">// &lt;Buffer 32 33&gt;</span></span><br><span class="line"><span class="comment">// 读完了</span></span><br></pre></td></tr></table></figure><p>在上面代码中，返回的 <code>rs</code> 对象监听了两个事件：</p><ul><li>data：每次读取 <code>highWaterMark</code> 个字节，触发一次 <code>data</code> 事件，直到读取完成，回调的参数为每次读取的 Buffer；</li><li>end：当读取完成时触发并执行回调函数。</li></ul><p>我们希望最后读到的结果是完整的，所以我们需要把每一次读到的结果在 <code>data</code> 事件触发时进行拼接，以前我们可能使用下面这种方式。</p><figure class="highlight js"><figcaption><span>错误拼接数据的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">3</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  str += data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0123</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p>在上面代码中如果读取的文件内容是中文，每次读取的 <code>highWaterMark</code> 为两个字节，不能组成一个完整的汉字，在每次读取时进行 <code>+=</code> 操作会默认调用 <code>toString</code> 方法，这样会导致最后读取的结果是乱码。</p></blockquote><p>在以后通过流操作文件时，大部分情况下都是在操作 Buffer，所以应该用下面这种方式来获取最后读取到的结果。</p><figure class="highlight js"><figcaption><span>正确拼接数据的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">3</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每次读取回来的 Buffer</span></span><br><span class="line"><span class="keyword">const</span> bufArr = [];</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  bufArr.push(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(Buffer.concat(bufArr).toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0123</span></span><br></pre></td></tr></table></figure><h3 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h3><p>在流动状态中，一旦开始读取文件，会不断的触发 <code>data</code> 事件，直到读完，暂停状态是我们每读取一次就直接暂停，不再继续读取，即不再触发 <code>data</code> 事件，除非我们主动控制继续读取，就像水龙头打开放水一次后马上关上水龙头，下次使用时再打开。</p><p>类似于开关水龙头的动作，也就是暂停和恢复读取的动作，在可读流返回的 <code>rs</code> 对象上有两个对应的方法，<code>pause</code> 和 <code>resume</code>。</p><p>在下面的场景中我们把创建可读流的结尾位置更改成 <code>9</code>，在每次读两个字节并暂停一秒后恢复读取，直到读完 <code>0~9</code> 十个数字。</p><figure class="highlight js"><figcaption><span>暂停状态</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">9</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bufArr = [];</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  bufArr.push(data);</span><br><span class="line">  rs.pause(); <span class="comment">// 暂停读取</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'暂停'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    rs.resume(); <span class="comment">// 恢复读取</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(Buffer.concat(bufArr).toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:52.436Z</span></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:53.439Z</span></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:54.440Z</span></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:55.442Z</span></span><br><span class="line"><span class="comment">// 暂停 2018-07-03T23:52:56.443Z</span></span><br><span class="line"><span class="comment">// 0123456789</span></span><br></pre></td></tr></table></figure><h3 id="错误监听"><a href="#错误监听" class="headerlink" title="错误监听"></a>错误监听</h3><p>在通过可读流读取文件时都是异步读取，在异步读取中如果遇到错误也可以通过异步监听到，可读流返回值 <code>rs</code> 对象可以通过 <code>error</code> 事件来监听错误，在读取文件出错时触发回调函数，回调函数参数为 <code>err</code>，即错误对象。</p><figure class="highlight js"><figcaption><span>错误监听</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一个不存在的文件</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'xxx.js'</span>, &#123;</span><br><span class="line">  highWarterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bufArr = [];</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  bufArr.push(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'err'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(Buffer.concat(bufArr).toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; Error: ENOENT: no such file or directory, open '......xxx.js' ......&#125;</span></span><br></pre></td></tr></table></figure><h3 id="打开和关闭文件的监听"><a href="#打开和关闭文件的监听" class="headerlink" title="打开和关闭文件的监听"></a>打开和关闭文件的监听</h3><p>流的适用性非常广，不只是文件读写，也可以用在 <code>http</code> 中数据的请求和响应上，但是在针对文件读取返回的 <code>rs</code> 上有两个专有的事件用来监听文件的打开与关闭。</p><p><code>open</code> 事件用来监听文件的打开，回调函数在打开文件后执行，<code>close</code> 事件用来监听文件的关闭，如果创建的可读流的 <code>autoClose</code> 为 <code>true</code>，在自动关闭文件时触发，回调函数在关闭文件后执行。</p><figure class="highlight js"><figcaption><span>打开和关闭可读流的监听</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">3</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'open'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'open'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'close'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// open</span></span><br></pre></td></tr></table></figure><p>在上面代码我们看出只要创建了可读流就会打开文件触发 <code>open</code> 事件，因为默认为暂停状态，没有对文件进行读取，所以不会关闭文件，即不会触发 <code>close</code> 事件。</p><figure class="highlight js"><figcaption><span>暂停状态</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">3</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'open'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'open'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'close'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// open</span></span><br><span class="line"><span class="comment">// &lt;Buffer 30 31&gt;</span></span><br><span class="line"><span class="comment">// &lt;Buffer 32 33&gt;</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// close</span></span><br></pre></td></tr></table></figure><p>从上面例子执行的打印结果可以看出只有开始读取文件并读完后，才会关闭文件并触发 <code>close</code> 事件，<code>end</code> 事件的触发要早于 <code>close</code>。</p><h2 id="可写流"><a href="#可写流" class="headerlink" title="可写流"></a>可写流</h2><h3 id="createWriteStream-创建可写流"><a href="#createWriteStream-创建可写流" class="headerlink" title="createWriteStream 创建可写流"></a>createWriteStream 创建可写流</h3><p><code>createWriteStream</code> 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 <code>options</code> 选项，其中有七个参数：</p><ul><li>flags：标识位，默认为 <code>w</code>；</li><li>encoding：字符编码，默认为 <code>utf8</code>；</li><li>fd：文件描述符，默认为 <code>null</code>；</li><li>mode：权限位，默认为 <code>0o666</code>；</li><li>autoClose：是否自动关闭文件，默认为 <code>true</code>；</li><li>start：写入文件的起始位置；</li><li>highWaterMark：一个对比写入字节数的标识，默认 <code>16 * 1024</code>。</li></ul><p><code>createWriteStream</code> 返回值为 <code>fs.WriteStream</code> 对象，第一次写入时会真的写入文件中，继续写入，会写入到缓存中。</p><figure class="highlight js"><figcaption><span>创建可写流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可写流，写入 2.txt 文件</span></span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="可写流的-write-方法"><a href="#可写流的-write-方法" class="headerlink" title="可写流的 write 方法"></a>可写流的 write 方法</h3><p>在可写流中将内容写入文件需要使用 <code>ws</code> 的 <code>write</code> 方法，参数为写入的内容，返回值是一个布尔值，代表 <code>highWaterMark</code> 的值是否足够当前的写入，如果足够，返回 <code>true</code>，否则返回 <code>false</code>，换种说法就是写入内容的长度是否超出了 <code>highWaterMark</code>，超出返回 <code>false</code>。</p><figure class="highlight js"><figcaption><span>write 方法写入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteSteam(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag1 = ws.write(<span class="string">'1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag2 = ws.write(<span class="string">'2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag3 = ws.write(<span class="string">'3'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>写入不存在的文件时会自动创建文件，如果 <code>start</code> 的值不是 <code>0</code>，在写入不存在的文件时默认找不到写入的位置。</p></blockquote><h3 id="可写流的-drain-事件"><a href="#可写流的-drain-事件" class="headerlink" title="可写流的 drain 事件"></a>可写流的 drain 事件</h3><p><code>drain</code> 意为 “吸干”，当前写入的内容已经大于等于了 <code>highWaterMark</code>，会触发 <code>drain</code> 事件，当内容全部从缓存写入文件后，会执行回调函数。</p><figure class="highlight js"><figcaption><span>drain 事件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag1 = ws.write(<span class="string">'1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag2 = ws.write(<span class="string">'2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag3 = ws.write(<span class="string">'3'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'drain'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'吸干'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="可写流的-end-方法"><a href="#可写流的-end-方法" class="headerlink" title="可写流的 end 方法"></a>可写流的 end 方法</h3><p><code>end</code> 方法传入的参数为最后写入的内容，<code>end</code> 会将缓存未写入的内容清空写入文件，并关闭文件。</p><figure class="highlight js"><figcaption><span>end 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag1 = ws.write(<span class="string">'1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag2 = ws.write(<span class="string">'2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag3 = ws.write(<span class="string">'3'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(flag3);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'drain'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'吸干'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ws.end(<span class="string">'写完了'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在调用 <code>end</code> 方法后，即使再次写入的值超出了 <code>highWaterMark</code> 也不会再触发 <code>drain</code> 事件了，此时打开 <code>2.txt</code> 后发现文件中的内容为 ‘123写完了’。</p><figure class="highlight js"><figcaption><span>常见报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ws.write(<span class="string">'1'</span>);</span><br><span class="line">ws.end(<span class="string">'写完了'</span>);</span><br><span class="line">ws.write(<span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error [ERR_STREAM_WRITE_AFTER_END]: write after end...</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>在调用 <code>end</code> 方法后，不可以再调用 <code>write</code> 方法写入，否则会报一个很常见的错误 <code>write after end</code>，文件原有内容会被清空，而且不会被写入新内容。</p></blockquote><h2 id="可写流与可读流混合使用"><a href="#可写流与可读流混合使用" class="headerlink" title="可写流与可读流混合使用"></a>可写流与可读流混合使用</h2><p>可写流和可读流一般配合来使用，读来的内容如果超出了可写流的 <code>highWaterMark</code>，则调用可读流的 <code>pause</code> 暂停读取，等待内存中的内容写入文件，未写入的内容小于 <code>highWaterMark</code> 时，调用可写流的 <code>resume</code> 恢复读取，创建可写流返回值的 <code>rs</code> 上的 <code>pipe</code> 方法是专门用来连接可读流和可写流的，可以将一个文件读来的内容通过流写到另一个文件中。</p><figure class="highlight js"><figcaption><span>pipe 方法使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流和可写流</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 1.txt 的内容通过流写入 2.txt 中</span></span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure><p>通过上面的这种类似于管道的方式，将一个流从一个文件输送到了另一个文件中，而且会根据读流和写流的 <code>highWaterMark</code> 自由的控制写入的 “节奏”，不用担心内存的消耗。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>这篇是关于读流和写流的基本用法，在平时的开发当中，大多数的 API 都用不到，只有最后的 <code>pipe</code> 用的最多，无论是在文件的读写还是请求的响应，其他的 API 虽然用的少，但是作为一个合格的程序员一定要有所了解。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 树结构遍历 —— 深度优先和广度优先</title>
      <link href="/2018/07/02/20180702122923/"/>
      <url>/2018/07/02/20180702122923/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/02/20180702122923/traversal-tree.png" title="树结构遍历"><p><br></p><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><blockquote class="pullquote info"><p>树（Tree）是 <code>n</code> 个结点的有限集，<code>n</code> 为 <code>0</code> 时，称为空树，在任意一棵非空树中有且仅有一个特定的被称为根（Root）的结点，当 <code>n</code> 大于 <code>1</code> 时，其余结点可分为 <code>m</code> 个互不相交的有限集 <code>T1</code>、<code>T2</code>、<code>......</code>、<code>Tm</code>，其中每一个集合本身又是一棵树，并且称为 <code>SubTree</code>，即根的子树。</p></blockquote><p>需要强调的是，<code>n&gt;0</code> 时根结点是唯一的，不可能存在多个根结点，<code>m&gt;0</code> 时，子树的个数没有限制，但它们一定是互不相交的。</p><p>从根开始定义起，根为第一层，根的孩子为第二层，若某结点在第 <code>l</code> 层，则其子树就在第 <code>l+1</code> 层，其双亲在同一层的结点互为 “堂兄弟”，树中结点的最大层级数称为树的深度（Depth）或高度。</p><a id="more"></a><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/02/20180702122923/tree-detials.jpg" alt="树结构的组成" title>                </div>                <div class="image-caption">树结构的组成</div>            </figure><p><br></p><p>在对树结构进行遍历时，按顺序可分为先序、中序和后续，按遍历的方式可分为深度优先和广度优先，我们这篇文章就通过使用先序深度优先和先序广度优先来实现 NodeJS 中递归删除目录结构，体会对树结构的遍历，文章中会大量用到 NodeJS 核心模块 <code>fs</code> 的方法，可以通过 <a href="https://www.overtaking.top/2018/06/30/20180630172601/" target="_blank">NodeJS 文件操作 —— fs 基本使用</a> 来了解文中用到的 <code>fs</code> 模块的方法及用法。</p><h2 id="先序深度优先实现递归删除文件目录"><a href="#先序深度优先实现递归删除文件目录" class="headerlink" title="先序深度优先实现递归删除文件目录"></a>先序深度优先实现递归删除文件目录</h2><blockquote class="pullquote default"><p>深度优先的意思就是在遍历当前文件目录的时候，如果子文件夹内还有内容，就继续遍历子文件夹，直到遍历到最深层不再有文件夹，则删除其中的文件，再删除这个文件夹，然后继续遍历它的 “兄弟”，直到内层文件目录都被删除，再删除上一级，最后根文件夹为空，删除根文件夹。</p></blockquote><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/02/20180702122923/depth-first-traversal.png" alt="先序深度优先" title>                </div>                <div class="image-caption">先序深度优先</div>            </figure><p><br></p><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><p>我们要实现的函数参数为要删除的根文件夹的路径，执行函数后会删除这个根文件夹。</p><figure class="highlight js"><figcaption><span>深度优先 —— 同步</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序深度优先同步删除文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rmDirDepSync</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取根文件夹的 Stats 对象</span></span><br><span class="line">  <span class="keyword">let</span> statObj = fs.statSync(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查该文件夹的是否是文件夹</span></span><br><span class="line">  <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">    <span class="comment">// 查看文件夹内部</span></span><br><span class="line">    <span class="keyword">let</span> dirs = fs.readdirSync(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将内部的文件和文件夹拼接成正确的路径</span></span><br><span class="line">    dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> path.jion(p, dir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环递归处理 dirs 内的每一个文件或文件夹</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dirs.length; i++) &#123;</span><br><span class="line">      rmDirDepSync(dirs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待都处理完后删除该文件夹</span></span><br><span class="line">    fs.rmdirSync(p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 若是文件则直接删除</span></span><br><span class="line">    fs.unlinkSync(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">rmDirDepSync(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>上面代码在调用 <code>rmDirDepSync</code> 时传入 <code>a</code>，先判断 <code>a</code> 是否是文件夹，不是则直接删除文件，是则查看文件目录，使用 <code>map</code> 将根文件路径拼接到每一个成员的名称前，并返回合法的路径集合，循环这个集合并对每一项进行递归，重复执行操作，最终实现删除根文件夹内所有的文件和文件夹，并删除根文件夹。</p><h3 id="异步回调的实现"><a href="#异步回调的实现" class="headerlink" title="异步回调的实现"></a>异步回调的实现</h3><p>同步的实现会阻塞代码的执行，每次执行一个文件操作，必须在执行完毕之后才能执行下一行代码，相对于同步，异步的方式性能会更好一些，我们下面使用异步回调的方式来实现递归删除文件目录的函数。</p><p>函数有两个参数，第一个参数同样为根文件夹的路径，第二个参数为一个回调函数，在文件目录被全部删除后执行。</p><figure class="highlight js"><figcaption><span>深度优先 —— 异步回调</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序深度优先异步（回调函数）删除文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rmDirDepCb</span>(<span class="params">p, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取传入路径的 Stats 对象</span></span><br><span class="line">  fs.stat(p, (err, statObj) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断路径下是否为文件夹</span></span><br><span class="line">    <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">      <span class="comment">// 是文件夹则查看内部成员</span></span><br><span class="line">      fs.readdir(p, (err, dirs) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 将文件夹成员拼接成合法路径的集合</span></span><br><span class="line">        dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> path.join(p, dir));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next 方法用来检查集合内每一个路径</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 如果所有成员检查并删除完成则删除上一级目录</span></span><br><span class="line">          <span class="keyword">if</span> (index === dirs.length) <span class="keyword">return</span> fs.rmdir(p, callback);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 对路径下每一个文件或文件夹执行递归，回调为递归 next 检查路径集合中的下一项</span></span><br><span class="line">          rmDirDepCb(dirs[index], () =&gt; next(index + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        next(<span class="number">0</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 是文件则直接删除</span></span><br><span class="line">      fs.unlink(p, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">rmDirDepCb(<span class="string">'a'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'删除完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除完成</span></span><br></pre></td></tr></table></figure><p>上面方法也遵循深度优先，与同步相比较主要思路是相同的，异步回调的实现更为抽象，并不是通过循环去处理的文件夹下的每个成员的路径，而是通过调用 <code>next</code> 函数和在成功删除文件时递归执行 <code>next</code> 函数并维护 <code>index</code> 变量实现的。</p><h3 id="异步-Promise-的实现"><a href="#异步-Promise-的实现" class="headerlink" title="异步 Promise 的实现"></a>异步 Promise 的实现</h3><p>在异步回调函数的实现方式中，回调嵌套层级非常多，这在对代码的可读性和维护性上都造成困扰，在 ES6 规范中，Promise 的出现就是用来解决 “回调地狱” 的问题，所以我们也使用 Promise 来实现。</p><p>函数的参数为要删除的根文件夹的路径，这次之所以不需要传 <code>callback</code> 参数是因为 <code>callback</code> 中的逻辑可以在调用函数之后链式调用 <code>then</code> 方法来执行。</p><figure class="highlight js"><figcaption><span>深度优先 —— 异步 Promise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序深度优先异步（Promise）删除文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rmDirDepPromise</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取传入路径的 Stats 对象</span></span><br><span class="line">    fs.stat(p, (err, statObj) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 判断路径下是否为文件夹</span></span><br><span class="line">      <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">// 是文件夹则查看内部成员</span></span><br><span class="line">        fs.readdir(p, (err, dirs) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 将文件夹成员拼接成合法路径的集合</span></span><br><span class="line">          dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> path.join(p, dir));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将所有的路径都转换成 Promise</span></span><br><span class="line">          dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> rmDirDepPromise(dir));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 数组中路径下所有的 Promise 都执行了 resolve 时，删除上级目录</span></span><br><span class="line">          <span class="built_in">Promise</span>.all(dirs).then(<span class="function"><span class="params">()</span> =&gt;</span> fs.rmdir(p, resolve));</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是文件则直接删除</span></span><br><span class="line">        fs.unlink(p, resolve);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">rmDirDepPromise(<span class="string">'a'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'删除完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除完成</span></span><br></pre></td></tr></table></figure><p>与异步回调函数的方式不同的是在调用 <code>rmDirDepPromise</code> 时直接返回了一个 Promise 实例，而在删除文件成功或在删除文件夹成功时直接调用了 <code>resolve</code>，在一个子文件夹下直接将这些成员通过递归 <code>rmDirDepPromise</code> 都转换为 Promise 实例，则可以用 <code>Promise.all</code> 来监听这些成员删除的状态，如果都成功再调用 <code>Promise.all</code> 的 <code>then</code> 直接删除上一级目录。</p><h3 id="异步-async-await-的实现"><a href="#异步-async-await-的实现" class="headerlink" title="异步 async/await 的实现"></a>异步 async/await 的实现</h3><p>Promise 版本相对于异步回调版本从代码的可读性上有所提升，但是实现逻辑还是比较抽象，没有同步代码的可读性好，如果想要 “鱼” 和 “熊掌” 兼得，既要性能又要可读性，可以使用 ES7 标准中的 <code>async/await</code> 来实现。</p><p>由于 <code>async</code> 函数的返回值为一个 Promise 实例，所以参数只需要传被删除的根文件夹的路径即可。</p><figure class="highlight js"><figcaption><span>深度优先 —— 异步 async/await</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将用到 fs 模块的异步方法转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> stat = promisify(fs.stat);</span><br><span class="line"><span class="keyword">const</span> readdir = promisify(fs.readdir);</span><br><span class="line"><span class="keyword">const</span> rmdir = promisify(fs.rmdir);</span><br><span class="line"><span class="keyword">const</span> unlink = promisify(fs.unlink);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序深度优先异步（async/await）删除文件夹</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rmDirDepAsync</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取传入路径的 Stats 对象</span></span><br><span class="line">  <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断路径下是否为文件夹</span></span><br><span class="line">  <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">    <span class="comment">// 是文件夹则查看内部成员</span></span><br><span class="line">    <span class="keyword">let</span> dirs = <span class="keyword">await</span> readdir(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件夹成员拼接成合法路径的集合</span></span><br><span class="line">    dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> path.join(p, dir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环集合递归 rmDirDepAsync 处理所有的成员</span></span><br><span class="line">    dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> rmDirDepAsync(dir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当所有的成员都成功</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(dirs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除该文件夹</span></span><br><span class="line">    <span class="keyword">await</span> rmdir(p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 是文件则直接删除</span></span><br><span class="line">    <span class="keyword">await</span> unlink(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">rmDirDepAsync(<span class="string">'a'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'删除完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除完成</span></span><br></pre></td></tr></table></figure><p>在递归 <code>rmDirDepAsync</code> 时，所有子文件夹内部的成员必须都删除成功，才删除这个子文件夹，在使用 <code>unlink</code> 删除文件时，必须等待文件删除结束才能让 Promise 执行完成，所以也需要 <code>await</code>，所有递归之前的异步 Promise 都需要在递归内部的异步 Promise 执行完成后才能执行完成，所以涉及到异步的操作都使用了 <code>await</code> 进行等待。</p><h2 id="先序广度优先实现递归删除文件目录"><a href="#先序广度优先实现递归删除文件目录" class="headerlink" title="先序广度优先实现递归删除文件目录"></a>先序广度优先实现递归删除文件目录</h2><blockquote class="pullquote success"><p>广度优先的意思是遍历文件夹目录的时候，先遍历根文件夹，将内部的成员路径一个一个的存入数组中，再继续遍历下一层，再将下一层的路径都存入数组中，直到遍历到最后一层，此时数组中的路径顺序为第一层的路径，第二层的路径，直到最后一层的路径，由于要删除的文件夹必须为空，所以删除时，倒序遍历这个数组取出路径进行文件目录的删除。</p></blockquote><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/07/02/20180702122923/breadth-first-traversal.png" alt="先序广度优先" title>                </div>                <div class="image-caption">先序广度优先</div>            </figure><p><br></p><p>在广度优先的实现方式中同样按照同步、异步回调、和 异步 <code>async/await</code> 这几种方式分别来实现，因为在拼接存储路径数组的时候没有异步操作，所以单纯使用 Promise 没有太大的意义。</p><h3 id="同步的实现-1"><a href="#同步的实现-1" class="headerlink" title="同步的实现"></a>同步的实现</h3><p>参数为根文件夹的路径，内部的 <code>fs</code> 方法同样都使用同步方法。</p><figure class="highlight js"><figcaption><span>广度优先 —— 同步</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序广度优先同步删除文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rmDirBreSync</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pathArr = [p]; <span class="comment">// 创建存储路径的数组，默认存入根路径</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 用于存储取出数组成员的索引</span></span><br><span class="line">  <span class="keyword">let</span> current; <span class="comment">// 用于存储取出的成员，即路径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果数组中能找到当前指定索引的项，则执行循环体，并将该项存入 current</span></span><br><span class="line">  <span class="keyword">while</span> ((current = arr[index++])) &#123;</span><br><span class="line">    <span class="comment">// 获取当前从数组中取出的路径的 Stats 对象</span></span><br><span class="line">    <span class="keyword">let</span> statObj = fs.statSync(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是文件夹，则读取内容</span></span><br><span class="line">    <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">      <span class="keyword">let</span> dirs = fs.readdir(current);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将获取到的成员路径处理为合法路径</span></span><br><span class="line">      dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> path.join(current, dir));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将原数组的成员路径和处理后的成员路径重新解构在 pathArr 中</span></span><br><span class="line">      pathArr = [...pathArr, ...dirs];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逆序循环 pathArr</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = pathArr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> pathItem = pathArr[i]; <span class="comment">// 当前循环项</span></span><br><span class="line">    <span class="keyword">let</span> statObj = fs.statSync(pathItem); <span class="comment">// 获取 Stats 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是文件夹则删除文件夹，是文件则删除文件</span></span><br><span class="line">    <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">      fs.rmdirSync(pathItem);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fs.unlinkSync(pathItem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">rmDirBreSync(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>通过 <code>while</code> 循环广度遍历，将所有的路径按层级顺序存入 <code>pathArr</code> 数组中，在通过 <code>for</code> 反向遍历数组，对遍历到的路径进行判断并调用对应的删除方法，<code>pathArr</code> 后面的项存储的都是最后一层的路径，从后向前路径的层级逐渐减小，所以反向遍历不会导致删除非空文件夹的操作。</p><h3 id="异步回调的实现-1"><a href="#异步回调的实现-1" class="headerlink" title="异步回调的实现"></a>异步回调的实现</h3><p>函数有两个参数，第一个参数为根文件夹的路径，第二个为 <code>callback</code>，在删除结束后执行。</p><figure class="highlight js"><figcaption><span>广度优先 —— 异步回调</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序广度优先异步（回调函数）删除文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rmDirBreCb</span>(<span class="params">p, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pathArr = [p]; <span class="comment">// 创建存储路径的数组，默认存入根路径</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经都处理完，则调用删除的函数</span></span><br><span class="line">    <span class="keyword">if</span> (index === pathArr.length) <span class="keyword">return</span> remove();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出数组中的文件路径</span></span><br><span class="line">    <span class="keyword">let</span> current = arr[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取取出路径的 Stats 对象</span></span><br><span class="line">    fs.stat(currrent, (err, statObj) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 判断是否是文件夹</span></span><br><span class="line">      <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">// 是文件夹读取内部成员</span></span><br><span class="line">        fs.readdir(current, (err, dirs) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 将数组中成员名称修改为合法路径</span></span><br><span class="line">          dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> path.join(current, dir));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将原数组的成员路径和处理后的成员路径重新解构在 pathArr 中</span></span><br><span class="line">          pathArr = [...pathArr, ...dirs];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 递归取出数组的下一项进行检测</span></span><br><span class="line">          next(index + <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是文件则直接递归获取数组的下一项进行检测</span></span><br><span class="line">        next(index + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  next(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果全部删除完成，执行回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> callback();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取数组的最后一项</span></span><br><span class="line">      <span class="keyword">let</span> current = pathArr[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取该路径的 Stats 对象</span></span><br><span class="line">      fs.stat(current, (err, statObj) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 不管是文件还是文件夹都直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">          fs.rmdir(current, () =&gt; next(index - <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          fs.unlink(current, () =&gt; next(index - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    next(arr.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">rmDirBreCb(<span class="string">'a'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'删除完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除完成</span></span><br></pre></td></tr></table></figure><p>在调用 <code>rmDirBreCb</code> 时主要执行两个步骤，第一个步骤是构造存储路径的数组，第二个步骤是逆序删除数组中对应的文件或文件夹，为了保证性能，两个过程都是通过递归 <code>next</code> 函数并维护存储索引的变量来实现的，而非循环。</p><p>在构造数组的过程中如果构造数组完成后，调用的删除函数 <code>remove</code>，在 <code>remove</code> 中在删除完成后，调用的 <code>callback</code>，实现思路是相同的，都是在递归时设置判断条件，如果构造数组或删除结束以后不继续递归，而是直接执行对应的函数并跳出。</p><h3 id="异步-async-await-的实现-1"><a href="#异步-async-await-的实现-1" class="headerlink" title="异步 async/await 的实现"></a>异步 async/await 的实现</h3><p>参数为删除根文件夹的路径，因为 <code>async</code> 最后返回的是 Promise 实例，所以不需要 <code>callback</code>，删除后的逻辑可以通过调用返回 Promise 实例的 <code>then</code> 来实现。</p><figure class="highlight js"><figcaption><span>广度优先 —— 异步 async/await</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将用到 fs 模块的异步方法转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> stat = promisify(fs.stat);</span><br><span class="line"><span class="keyword">const</span> readdir = promisify(fs.readdir);</span><br><span class="line"><span class="keyword">const</span> rmdir = promisify(fs.rmdir);</span><br><span class="line"><span class="keyword">const</span> unlink = promisify(fs.unlink);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序广度优先异步（async/await）删除文件夹</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rmDirBreAsync</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pathArr = [p]; <span class="comment">// 创建存储路径的数组，默认存入根路径</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 去数组中取出路径的索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在该项则继续循环</span></span><br><span class="line">  <span class="keyword">while</span> (index !== pathArr.length) &#123;</span><br><span class="line">    <span class="comment">// 取出当前的路径</span></span><br><span class="line">    <span class="keyword">let</span> current = pathArr[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Stats 对象</span></span><br><span class="line">    <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是文件夹</span></span><br><span class="line">    <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">      <span class="comment">// 查看文件夹成员</span></span><br><span class="line">      <span class="keyword">let</span> dirs = <span class="keyword">await</span> readdir(current);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径集合更改为合法路径集合</span></span><br><span class="line">      dirs = dirs.map(<span class="function"><span class="params">dir</span> =&gt;</span> path.join(current, dir));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 合并存储路径的数组</span></span><br><span class="line">      pathArr = [...pathArr, ...dirs];</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> current; <span class="comment">// 删除的路径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环取出路径</span></span><br><span class="line">  <span class="keyword">while</span> ((current = pathArr.pop())) &#123;</span><br><span class="line">    <span class="comment">// 获取 Stats 对象</span></span><br><span class="line">    <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不管是文件还是文件夹都直接删除</span></span><br><span class="line">    <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">      <span class="keyword">await</span> rmdir(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> unlink(current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">rmDirBreAsync(<span class="string">'a'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'删除完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除完成</span></span><br></pre></td></tr></table></figure><p>上面的写法都是使用同步的写法，但对文件的操作都是异步的，并使用 <code>await</code> 进行等待，在创建路径集合的数组和倒序删除的过程都是通过 <code>while</code> 循环实现的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>深度优先和广度优先的两种遍历方式应该是考虑具体场景选择最适合的方式使用，上面这么多实现递归删除文件目录的方法中，重点在于体会深度遍历和广度遍历的不同，其实在类似于递归删除文件目录的这种功能使用深度优先更适合一些。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> ES6 </tag>
            
            <tag> 异步 </tag>
            
            <tag> Promise </tag>
            
            <tag> ES7 </tag>
            
            <tag> async/await </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 文件操作 —— fs 基本使用</title>
      <link href="/2018/06/30/20180630172601/"/>
      <url>/2018/06/30/20180630172601/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/30/20180630172601/fs.jpg" title="fs 文件操作"><p><br></p><h2 id="fs-概述"><a href="#fs-概述" class="headerlink" title="fs 概述"></a>fs 概述</h2><blockquote class="pullquote info"><p>在 NodeJS 中，所有与文件操作都是通过 <code>fs</code> 核心模块来实现的，包括文件目录的创建、删除、查询以及文件的读取和写入，在 <code>fs</code> 模块中，所有的方法都分为同步和异步两种实现，具有 <code>sync</code> 后缀的方法为同步方法，不具有 <code>sync</code> 后缀的方法为异步方法，在了解文件操作的方法之前有一些关于系统和文件的前置知识，如文件的权限位 <code>mode</code>、标识位 <code>flag</code>、文件描述符 <code>fd</code> 等，所以在了解 <code>fs</code> 方法的之前会先将这几个概念明确。</p></blockquote><a id="more"></a><h2 id="权限位-mode"><a href="#权限位-mode" class="headerlink" title="权限位 mode"></a>权限位 mode</h2><p>因为 <code>fs</code> 模块需要对文件进行操作，会涉及到操作权限的问题，所以需要先清楚文件权限是什么，都有哪些权限。</p><p>文件权限表：</p><table><thead><tr><th style="text-align:center;">权限分配</th><th style="text-align:center;" colspan="3">文件所有者</th><th style="text-align:center;" colspan="3">文件所属组</th><th style="text-align:center;" colspan="3">其他用户</th></tr></thead><tbody><tr><td style="text-align:center;">权限项</td><td style="text-align:center;">读</td><td style="text-align:center;">写</td><td style="text-align:center;">执行</td><td style="text-align:center;">读</td><td style="text-align:center;">写</td><td style="text-align:center;">执行</td><td style="text-align:center;">读</td><td style="text-align:center;">写</td><td style="text-align:center;">执行</td></tr><tr><td style="text-align:center;">字符表示<br></td><td style="text-align:center;">r</td><td style="text-align:center;">w</td><td style="text-align:center;">x</td><td style="text-align:center;">r</td><td style="text-align:center;">w</td><td style="text-align:center;">x</td><td style="text-align:center;">r</td><td style="text-align:center;">w</td><td style="text-align:center;">x</td></tr><tr><td style="text-align:center;">数字表示</td><td style="text-align:center;">4</td><td style="text-align:center;">2</td><td style="text-align:center;">1</td><td style="text-align:center;">4</td><td style="text-align:center;">2</td><td style="text-align:center;">1</td><td style="text-align:center;">4</td><td style="text-align:center;">2</td><td style="text-align:center;">1</td></tr></tbody></table><p>在上面表格中，我们可以看出系统中针对三种类型进行权限分配，即文件所有者（自己）、文件所属组（家人）和其他用户（陌生人），文件操作权限又分为三种，读、写和执行，数字表示为八进制数，具备权限的八进制数分别为 <code>4</code> 、<code>2</code>、<code>1</code>，不具备权限为 <code>0</code>。</p><p>为了更容易理解，我们可以随便在一个目录中打开 <code>Git</code>，使用 Linux 命令 <code>ls -al</code> 来查目录中文件和文件夹的权限位，如果对 <code>Git</code> 和 <code>Linux</code> 命令不熟悉，可以看 <a href="https://www.overtaking.top/2017/12/14/20171214024101/" target="_blank">Git 命令总结，从零到熟悉</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core</span><br><span class="line">-rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md</span><br></pre></td></tr></table></figure><p>在上面的目录信息当中，很容易看出用户名、创建时间和文件名等信息，但最重要的是开头第一项（十位的字符）。</p><p>第一位代表是文件还是文件夹，<code>d</code> 开头代表文件夹，<code>-</code> 开头的代表文件，而后面九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），<code>-</code> 代表没有当前位对应的权限。</p><blockquote class="pullquote warning"><p>权限参数 <code>mode</code> 主要针对 Linux 和 Unix 操作系统，Window 的权限默认是可读、可写、不可执行，所以权限位数字表示为 <code>0o666</code>，转换十进制表示为 <code>438</code>。</p></blockquote><table><thead><tr><th style="text-align:center;">r</th><th style="text-align:center;">w</th><th style="text-align:center;">—</th><th style="text-align:center;">r</th><th style="text-align:center;">—</th><th style="text-align:center;">—</th><th style="text-align:center;">r</th><th style="text-align:center;">—</th><th style="text-align:center;">—</th></tr></thead><tbody><tr><td style="text-align:center;">4</td><td style="text-align:center;">2</td><td style="text-align:center;">0</td><td style="text-align:center;">4</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">4</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;" colspan="3">6</td><td style="text-align:center;" colspan="3">4</td><td style="text-align:center;" colspan="3">4</td></tr></tbody></table><h2 id="标识位-flag"><a href="#标识位-flag" class="headerlink" title="标识位 flag"></a>标识位 flag</h2><p>NodeJS 中，标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，在下面用一张表来表示文件操作的标识位和其对应的含义。</p><table><thead><tr><th style="width:20%;text-align:center;">符号</th><th style="text-align:center;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">r</td><td style="text-align:center;">读取文件，如果文件不存在则抛出异常。</td></tr><tr><td style="text-align:center;">r+</td><td style="text-align:center;">读取并写入文件，如果文件不存在则抛出异常。</td></tr><tr><td style="text-align:center;">rs</td><td style="text-align:center;">读取并写入文件，指示操作系统绕开本地文件系统缓存。</td></tr><tr><td style="text-align:center;">w</td><td style="text-align:center;">写入文件，文件不存在会被创建，存在则清空后写入。</td></tr><tr><td style="text-align:center;">wx</td><td style="text-align:center;">写入文件，排它方式打开。</td></tr><tr><td style="text-align:center;">w+</td><td style="text-align:center;">读取并写入文件，文件不存在则创建文件，存在则清空后写入。</td></tr><tr><td style="text-align:center;">wx+</td><td style="text-align:center;">和 <code>w+</code> 类似，排他方式打开。</td></tr><tr><td style="text-align:center;">a</td><td style="text-align:center;">追加写入，文件不存在则创建文件。</td></tr><tr><td style="text-align:center;">ax</td><td style="text-align:center;">与 <code>a</code> 类似，排他方式打开。</td></tr><tr><td style="text-align:center;">a+</td><td style="text-align:center;">读取并追加写入，不存在则创建。</td></tr><tr><td style="text-align:center;">ax+</td><td style="text-align:center;">与 <code>a+</code> 类似，排他方式打开。</td></tr></tbody></table><p>上面表格就是这些标识位的具体字符和含义，但是 <code>flag</code> 是不经常使用的，不容易被记住，所以在下面总结了一个加速记忆的方法。</p><ul><li>r：读取</li><li>w：写入</li><li>s：同步</li><li>+：增加相反操作</li><li>x：排他方式</li></ul><p><code>r+</code> 和 <code>w+</code> 的区别，当文件不存在时，<code>r+</code> 不会创建文件，而会抛出异常，但 <code>w+</code> 会创建文件；如果文件存在，<code>r+</code> 不会自动清空文件，但 <code>w+</code> 会自动把已有文件的内容清空。</p><h2 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h2><blockquote class="pullquote success"><p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件，Window 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。</p></blockquote><p>在 NodeJS 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 <code>3</code> 开始，因为前面有 <code>0</code>、<code>1</code>、<code>2</code> 三个比较特殊的描述符，分别代表 <code>process.stdin</code>（标准输入）、<code>process.stdout</code>（标准输出）和 <code>process.stderr</code>（错误输出）。</p><h2 id="文件操作的基本方法"><a href="#文件操作的基本方法" class="headerlink" title="文件操作的基本方法"></a>文件操作的基本方法</h2><blockquote class="pullquote primary"><p>文件操作中的基本方法都是对文件进行整体操作，即整个文件数据直接放在内存中操作，如读取、写入、拷贝和追加，由于计算机的内存容量有限，对文件操作需要考虑性能，所以这些方法只针对操作占用内存较小的文件。</p></blockquote><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><h4 id="同步读取方法-readFileSync"><a href="#同步读取方法-readFileSync" class="headerlink" title="同步读取方法 readFileSync"></a>同步读取方法 readFileSync</h4><p><code>readFileSync</code> 有两个参数：</p><ul><li>第一个参数为读取文件的路径或文件描述符；</li><li>第二个参数为 <code>options</code>，默认值为 <code>null</code>，其中有 <code>encoding</code>（编码，默认为 <code>null</code>）和 <code>flag</code>（标识位，默认为 <code>r</code>），也可直接传入 <code>encoding</code>；</li><li>返回值为文件的内容，如果没有 <code>encoding</code>，返回的文件内容为 Buffer，如果有按照传入的编码解析。</li></ul><p>若现在有一个文件名为 <code>1.txt</code>，内容为 “Hello”，现在使用 <code>readFileSync</code> 读取。</p><figure class="highlight js"><figcaption><span>同步读取 readFileSync</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = fs.readFileSync(<span class="string">'1.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.readFileSync(<span class="string">'1.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 48 65 6c 6c 6f&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><h4 id="异步读取方法-readFile"><a href="#异步读取方法-readFile" class="headerlink" title="异步读取方法 readFile"></a>异步读取方法 readFile</h4><p>异步读取方法 <code>readFile</code> 与 <code>readFileSync</code> 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 <code>err</code>（错误）和 <code>data</code>（数据），该方法没有返回值，回调函数在读取文件成功后执行。</p><p>依然读取 <code>1.txt</code> 文件：</p><figure class="highlight js"><figcaption><span>异步读取 readFile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'1.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// null</span></span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// Hello</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><h4 id="同步写入方法-writeFileSync"><a href="#同步写入方法-writeFileSync" class="headerlink" title="同步写入方法 writeFileSync"></a>同步写入方法 writeFileSync</h4><p><code>writeFileSync</code> 有三个参数：</p><ul><li>第一个参数为写入文件的路径或文件描述符；</li><li>第二个参数为写入的数据，类型为 String 或 Buffer；</li><li>第三个参数为 <code>options</code>，默认值为 <code>null</code>，其中有 <code>encoding</code>（编码，默认为 <code>utf8</code>）、 <code>flag</code>（标识位，默认为 <code>w</code>）和 <code>mode</code>（权限位，默认为 <code>0o666</code>），也可直接传入 <code>encoding</code>。</li></ul><p>若现在有一个文件名为 <code>2.txt</code>，内容为 “12345”，现在使用 <code>writeFileSync</code> 写入。</p><figure class="highlight js"><figcaption><span>同步写入 writeFileSync</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(<span class="string">'2.txt'</span>, <span class="string">'Hello world'</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.readFileSync(<span class="string">'2.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><h4 id="异步写入方法-writeFile"><a href="#异步写入方法-writeFile" class="headerlink" title="异步写入方法 writeFile"></a>异步写入方法 writeFile</h4><p>异步写入方法 <code>writeFile</code> 与 <code>writeFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件写入数据成功后执行。</p><figure class="highlight js"><figcaption><span>异步写入 writeFile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">'2.txt'</span>, <span class="string">'Hello world'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    fs.readFile(<span class="string">'2.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件追加写入"><a href="#文件追加写入" class="headerlink" title="文件追加写入"></a>文件追加写入</h3><h4 id="同步追加写入方法-appendFileSync"><a href="#同步追加写入方法-appendFileSync" class="headerlink" title="同步追加写入方法 appendFileSync"></a>同步追加写入方法 appendFileSync</h4><p><code>appendFileSync</code> 有三个参数：</p><ul><li>第一个参数为写入文件的路径或文件描述符；</li><li>第二个参数为写入的数据，类型为 String 或 Buffer；</li><li>第三个参数为 <code>options</code>，默认值为 <code>null</code>，其中有 <code>encoding</code>（编码，默认为 <code>utf8</code>）、 <code>flag</code>（标识位，默认为 <code>a</code>）和 <code>mode</code>（权限位，默认为 <code>0o666</code>），也可直接传入 <code>encoding</code>。</li></ul><p>若现在有一个文件名为 <code>3.txt</code>，内容为 “Hello”，现在使用 <code>appendFileSync</code> 追加写入 “ world”。</p><figure class="highlight js"><figcaption><span>同步追加 appendFileSync</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.appendFileSync(<span class="string">'3.txt'</span>, <span class="string">' world'</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.readFileSync(<span class="string">'3.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><h4 id="异步追加写入方法-appendFile"><a href="#异步追加写入方法-appendFile" class="headerlink" title="异步追加写入方法 appendFile"></a>异步追加写入方法 appendFile</h4><p>异步追加写入方法 <code>appendFile</code> 与 <code>appendFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件追加写入数据成功后执行。</p><figure class="highlight js"><figcaption><span>异步追加 appendFile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.appendFile(<span class="string">'3.txt'</span>, <span class="string">' world'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    fs.readFile(<span class="string">'3.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件拷贝写入"><a href="#文件拷贝写入" class="headerlink" title="文件拷贝写入"></a>文件拷贝写入</h3><h4 id="同步拷贝写入方法-copyFileSync"><a href="#同步拷贝写入方法-copyFileSync" class="headerlink" title="同步拷贝写入方法 copyFileSync"></a>同步拷贝写入方法 copyFileSync</h4><p>同步拷贝写入方法 <code>copyFileSync</code> 有两个参数，第一个参数为被拷贝的源文件路径，第二个参数为拷贝到的目标文件路径，如果目标文件不存在，则会创建并拷贝。</p><p>现在将上面 <code>3.txt</code> 的内容拷贝到 <code>4.txt</code> 中：</p><figure class="highlight js"><figcaption><span>同步拷贝 copyFileSync</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.copyFileSync(<span class="string">'3.txt'</span>, <span class="string">'4.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.readFileSync(<span class="string">'4.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><h4 id="异步拷贝写入方法-copyFile"><a href="#异步拷贝写入方法-copyFile" class="headerlink" title="异步拷贝写入方法 copyFile"></a>异步拷贝写入方法 copyFile</h4><p>异步拷贝写入方法 <code>copyFile</code> 和 <code>copyFileSync</code> 前两个参数相同，最后一个参数为回调函数，在拷贝完成后执行。</p><figure class="highlight js"><figcaption><span>异步拷贝 copyFile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.copyFile(<span class="string">'3.txt'</span>, <span class="string">'4.txt'</span>, () =&gt; &#123;</span><br><span class="line">  fs.readFile(<span class="string">'4.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="模拟同步、异步拷贝写入文件"><a href="#模拟同步、异步拷贝写入文件" class="headerlink" title="模拟同步、异步拷贝写入文件"></a>模拟同步、异步拷贝写入文件</h4><p>使用 <code>readFileSync</code> 和 <code>writeFileSync</code> 可以模拟同步拷贝写入文件，使用 <code>readFile</code> 和 <code>writeFile</code> 可以模拟异步写入拷贝文件，代码如下：</p><figure class="highlight js"><figcaption><span>模拟同步拷贝</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = fs.readFileSync(src);</span><br><span class="line">  fs.writeFileSync(dest, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝</span></span><br><span class="line">copy(<span class="string">'3.txt'</span>, <span class="string">'4.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = fs.readFileSync(<span class="string">'4.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>模拟异步拷贝</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dest, cb</span>) </span>&#123;</span><br><span class="line">  fs.readFile(src, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 没错误就正常写入</span></span><br><span class="line">    <span class="keyword">if</span> (!err) fs.writeFile(dest, data, cb);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝</span></span><br><span class="line">copy(<span class="string">'3.txt'</span>, <span class="string">'4.txt'</span>, () =&gt; &#123;</span><br><span class="line">  fs.readFile(<span class="string">'4.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="文件操作的高级方法"><a href="#文件操作的高级方法" class="headerlink" title="文件操作的高级方法"></a>文件操作的高级方法</h2><h3 id="打开文件-open"><a href="#打开文件-open" class="headerlink" title="打开文件 open"></a>打开文件 open</h3><p><code>open</code> 方法有四个参数：</p><ul><li>path：文件的路径；</li><li>flag：标识位；</li><li>mode：权限位，默认 <code>0o666</code>；</li><li>callback：回调函数，有两个参数 <code>err</code>（错误）和 <code>fd</code>（文件描述符），打开文件后执行。</li></ul><figure class="highlight js"><figcaption><span>异步打开文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.open(<span class="string">'4.txt'</span>, <span class="string">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fd);</span><br><span class="line">  fs.open(<span class="string">'5.txt'</span>, <span class="string">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fd);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="关闭文件-close"><a href="#关闭文件-close" class="headerlink" title="关闭文件 close"></a>关闭文件 close</h3><p><code>close</code> 方法有两个参数，第一个参数为关闭文件的文件描述符 <code>fd</code>，第二参数为回调函数，回调函数有一个参数 <code>err</code>（错误），关闭文件后执行。</p><figure class="highlight js"><figcaption><span>异步关闭文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.open(<span class="string">'4.txt'</span>, <span class="string">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">  fs.close(fd, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'关闭成功'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭成功</span></span><br></pre></td></tr></table></figure><h3 id="读取文件-read"><a href="#读取文件-read" class="headerlink" title="读取文件 read"></a>读取文件 read</h3><blockquote class="pullquote danger"><p><code>read</code> 方法与 <code>readFile</code> 不同，一般针对于文件太大，无法一次性读取全部内容到缓存中或文件大小未知的情况，都是多次读取到 Buffer 中。<br>想了解 Buffer 可以看 <a href="https://www.overtaking.top/2018/06/29/20180629115313/" target="_blank">NodeJS —— Buffer 解读</a>。</p></blockquote><p><code>read</code> 方法中有六个参数：</p><ul><li>fd：文件描述符，需要先使用 <code>open</code> 打开；</li><li>buffer：要将内容读取到的 Buffer；</li><li>offset：整数，向 Buffer 写入的初始位置；</li><li>length：整数，读取文件的长度；</li><li>position：整数，读取文件初始位置；</li><li>callback：回调函数，有三个参数 <code>err</code>（错误），<code>bytesRead</code>（实际读取的字节数），<code>buffer</code>（被写入的缓存区对象），读取执行完成后执行。</li></ul><p>下面读取一个 <code>6.txt</code> 文件，内容为 “你好”。</p><figure class="highlight js"><figcaption><span>异步读取文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fs.open(<span class="string">'6.txt'</span>, <span class="string">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.read(fd, buf, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, (err, bytesRead, buffer) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bytesRead);</span><br><span class="line">    <span class="built_in">console</span>.log(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续读取</span></span><br><span class="line">    fs.read(fd, buf, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, (err, bytesRead, buffer) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(bytesRead);</span><br><span class="line">      <span class="built_in">console</span>.log(buffer);</span><br><span class="line">      <span class="built_in">console</span>.log(buffer.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// &lt;Buffer e4 bd a0 00 00 00&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// &lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br><span class="line"><span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><h3 id="同步磁盘缓存-fsync"><a href="#同步磁盘缓存-fsync" class="headerlink" title="同步磁盘缓存 fsync"></a>同步磁盘缓存 fsync</h3><p><code>fsync</code> 方法有两个参数，第一个参数为文件描述符 <code>fd</code>，第二个参数为回调函数，回调函数中有一个参数 <code>err</code>（错误），在同步磁盘缓存后执行。</p><blockquote class="pullquote warning"><p>在使用 <code>write</code> 方法向文件写入数据时，由于不是一次性写入，所以最后一次写入在关闭文件之前应先同步磁盘缓存，<code>fsync</code> 方法将在后面配合 <code>write</code> 一起使用。</p></blockquote><h3 id="写入文件-write"><a href="#写入文件-write" class="headerlink" title="写入文件 write"></a>写入文件 write</h3><blockquote class="pullquote success"><p><code>write</code> 方法与 <code>writeFile</code> 不同，是将 Buffer 中的数据写入文件，Buffer 的作用是一个数据中转站，可能数据的源占用内存太大或内存不确定，无法一次性放入内存中写入，所以分段写入，多与 <code>read</code> 方法配合。</p></blockquote><p><code>write</code> 方法中有六个参数：</p><ul><li>fd：文件描述符，需要先使用 <code>open</code> 打开；</li><li>buffer：存储将要写入文件数据的 Buffer；</li><li>offset：整数，从 Buffer 读取数据的初始位置；</li><li>length：整数，读取 Buffer 数据的字节数；</li><li>position：整数，写入文件初始位置；</li><li>callback：回调函数，有三个参数 <code>err</code>（错误），<code>bytesWritten</code>（实际写入的字节数），<code>buffer</code>（被读取的缓存区对象），写入完成后执行。</li></ul><p>下面将一个 Buffer 中间的两个字写入文件 <code>6.txt</code>，原内容为 “你好”。</p><figure class="highlight js"><figcaption><span>选择范围写入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'你还好吗'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fs.open(<span class="string">'6.txt'</span>, <span class="string">'r+'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取 buf 向文件写入数据</span></span><br><span class="line">  fs.write(fd, buf, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, (err, bytesWritten, buffer) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 同步磁盘缓存</span></span><br><span class="line">    fs.fsync(fd, err =&gt; &#123;</span><br><span class="line">      <span class="comment">// 关闭文件</span></span><br><span class="line">      fs.close(fd, err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'关闭文件'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里为了看是否写入成功简单粗暴的使用 readFile 方法</span></span><br><span class="line">fs.readFile(<span class="string">'6.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你还好</span></span><br></pre></td></tr></table></figure><p>上面代码将 “你还好吗” 中间的 “还好” 从 Buffer 中读取出来写入到 <code>6.txt</code> 的 “你” 字之后，但是最后的 “好” 并没有被保留，说明先清空了文件中 “你” 字之后的内容再写入。</p><h3 id="针对大文件实现-copy"><a href="#针对大文件实现-copy" class="headerlink" title="针对大文件实现 copy"></a>针对大文件实现 copy</h3><p>之前我们使用 <code>readFile</code> 和 <code>writeFile</code> 实现了一个 <code>copy</code> 函数，那个 <code>copy</code> 函数是将被拷贝文件的数据一次性读取到内存，一次性写入到目标文件中，针对小文件。</p><p>如果是一个大文件一次性写入不现实，所以需要多次读取多次写入，接下来使用上面的这些方法针对大文件和文件大小未知的情况实现一个 <code>copy</code> 函数。</p><figure class="highlight js"><figcaption><span>大文件拷贝</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dest, size = <span class="number">16</span> * <span class="number">1024</span>, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 打开源文件</span></span><br><span class="line">  fs.open(src, <span class="string">'r'</span>, (err, readFd) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 打开目标文件</span></span><br><span class="line">    fs.open(dest, <span class="string">'w'</span>, (err, writeFd) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> buf = Buffer.alloc(size);</span><br><span class="line">      <span class="keyword">let</span> readed = <span class="number">0</span>; <span class="comment">// 下次读取文件的位置</span></span><br><span class="line">      <span class="keyword">let</span> writed = <span class="number">0</span>; <span class="comment">// 下次写入文件的位置</span></span><br><span class="line"></span><br><span class="line">      (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        fs.read(readFd, buf, <span class="number">0</span>, size, readed, (err, bytesRead) =&gt; &#123;</span><br><span class="line">          readed += bytesRead;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果都不到内容关闭文件</span></span><br><span class="line">          <span class="keyword">if</span> (!bytesRead) fs.close(readFd, err =&gt; <span class="built_in">console</span>.log(<span class="string">'关闭源文件'</span>));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 写入</span></span><br><span class="line">          fs.write(writeFd, buf, <span class="number">0</span>, bytesRead, writed, (err, bytesWritten) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果没有内容了同步缓存，并关闭文件后执行回调</span></span><br><span class="line">            <span class="keyword">if</span> (!bytesWritten) &#123;</span><br><span class="line">              fs.fsync(writeFd, err =&gt; &#123;</span><br><span class="line">                fs.close(writeFd, err =&gt; <span class="keyword">return</span> !err &amp;&amp; callback());</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            writed += bytesWritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续读取、写入</span></span><br><span class="line">            next();</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的 <code>copy</code> 方法中，我们手动维护的下次读取位置和下次写入位置，如果参数 <code>readed</code> 和 <code>writed</code> 的位置传入 <code>null</code>，NodeJS 会自动帮我们维护这两个值。</p><p>现在有一个文件 <code>6.txt</code> 内容为 “你好”，一个空文件 <code>7.txt</code>，我们将 <code>6.txt</code> 的内容写入 <code>7.txt</code> 中。</p><figure class="highlight js"><figcaption><span>验证大文件拷贝</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// buffer 的长度</span></span><br><span class="line"><span class="keyword">const</span> BUFFER_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝文件内容并写入</span></span><br><span class="line">copy(<span class="string">'6.txt'</span>, <span class="string">'7.txt'</span>, BUFFER_SIZE, () =&gt; &#123;</span><br><span class="line">  fs.readFile(<span class="string">'7.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 拷贝完读取 7.txt 的内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 你好</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p>在 NodeJS 中进行文件操作，多次读取和写入时，一般一次读取数据大小为 <code>64k</code>，写入数据大小为 <code>16k</code>。</p></blockquote><h2 id="文件目录操作方法"><a href="#文件目录操作方法" class="headerlink" title="文件目录操作方法"></a>文件目录操作方法</h2><blockquote class="pullquote info"><p>下面的这些操作文件目录的方法有一个共同点，就是传入的第一个参数都为文件的路径，如：<code>a/b/c/d</code>，也分为同步和异步两种实现。</p></blockquote><h3 id="查看文件目录操作权限"><a href="#查看文件目录操作权限" class="headerlink" title="查看文件目录操作权限"></a>查看文件目录操作权限</h3><h4 id="同步查看操作权限方法-accessSync"><a href="#同步查看操作权限方法-accessSync" class="headerlink" title="同步查看操作权限方法 accessSync"></a>同步查看操作权限方法 accessSync</h4><p><code>accessSync</code> 方法传入一个目录的路径，检查传入路径下的目录是否可读可写，当有操作权限的时候没有返回值，没有权限或路径非法时抛出一个 <code>Error</code> 对象，所以使用时多用 <code>try...catch...</code> 进行异常捕获。</p><figure class="highlight js"><figcaption><span>同步查看操作权限</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fs.accessSync(<span class="string">'a/b/c'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'可读可写'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'不可访问'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步查看操作权限方法-access"><a href="#异步查看操作权限方法-access" class="headerlink" title="异步查看操作权限方法 access"></a>异步查看操作权限方法 access</h4><p><code>access</code> 方法与第一个参数为一个目录的路径，最后一个参数为一个回调函数，回调函数有一个参数为 <code>err</code>（错误），在权限检测后触发，如果有权限 <code>err</code> 为 <code>null</code>，没有权限或路径非法 <code>err</code> 是一个 <code>Error</code> 对象。</p><figure class="highlight js"><figcaption><span>异步查看操作权限</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.access(<span class="string">'a/b/c'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'不可访问'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'可读可写'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="获取文件目录的-Stats-对象"><a href="#获取文件目录的-Stats-对象" class="headerlink" title="获取文件目录的 Stats 对象"></a>获取文件目录的 Stats 对象</h3><p>文件目录的 <code>Stats</code> 对象存储着关于这个文件或文件夹的一些重要信息，如创建时间、最后一次访问的时间、最后一次修改的时间、文章所占字节和判断文件类型的多个方法等等。</p><h4 id="同步获取-Stats-对象方法-statSync"><a href="#同步获取-Stats-对象方法-statSync" class="headerlink" title="同步获取 Stats 对象方法 statSync"></a>同步获取 Stats 对象方法 statSync</h4><p><code>statSync</code> 方法参数为一个目录的路径，返回值为当前目录路径的 <code>Stats</code> 对象，现在通过 <code>Stats</code> 对象获取 <code>a</code> 目录下的 <code>b</code> 目录下的 <code>c.txt</code> 文件的字节大小，文件内容为 “你好”。</p><figure class="highlight js"><figcaption><span>同步获取 Stats 对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> statObj = fs.statSync(<span class="string">'a/b/c.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(statObj.size); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="异步获取-Stats-对象方法-stat"><a href="#异步获取-Stats-对象方法-stat" class="headerlink" title="异步获取 Stats 对象方法 stat"></a>异步获取 Stats 对象方法 stat</h4><p><code>stat</code> 方法的第一个参数为目录的路径，最后一个参数为回调函数，回调函数有两个参数 <code>err</code>（错误）和 <code>Stats</code> 对象，在读取 <code>Stats</code> 后执行，同样实现上面的读取文件字节数的例子。</p><figure class="highlight js"><figcaption><span>异步获取 Stats 对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.stat(<span class="string">'a/b/c.txt'</span>, (err, statObj) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(statObj.size); <span class="comment">// 6</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建文件目录"><a href="#创建文件目录" class="headerlink" title="创建文件目录"></a>创建文件目录</h3><h4 id="同步创建目录方法-mkdirSync"><a href="#同步创建目录方法-mkdirSync" class="headerlink" title="同步创建目录方法 mkdirSync"></a>同步创建目录方法 mkdirSync</h4><p><code>mkdirSync</code> 方法参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常。</p><figure class="highlight js"><figcaption><span>同步创建文件目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设已经有了 a 文件夹和 a 下的 b 文件夹</span></span><br><span class="line">fs.mkdirSync(<span class="string">'a/b/c'</span>);</span><br></pre></td></tr></table></figure><h4 id="异步创建目录方法-mkdir"><a href="#异步创建目录方法-mkdir" class="headerlink" title="异步创建目录方法 mkdir"></a>异步创建目录方法 mkdir</h4><p><code>mkdir</code> 方法的第一个参数为目录的路径，最后一个参数为回调函数，回调函数有一个参数 <code>err</code>（错误），在执行创建操作后执行，同样需要路径前部分的文件夹都存在。</p><figure class="highlight js"><figcaption><span>异步创建文件目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设已经有了 a 文件夹和 a 下的 b 文件夹</span></span><br><span class="line">fs.mkdir(<span class="string">'a/b/c'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) <span class="built_in">console</span>.log(<span class="string">'创建成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建成功</span></span><br></pre></td></tr></table></figure><h3 id="读取文件目录"><a href="#读取文件目录" class="headerlink" title="读取文件目录"></a>读取文件目录</h3><h4 id="同步读取目录方法-readdirSync"><a href="#同步读取目录方法-readdirSync" class="headerlink" title="同步读取目录方法 readdirSync"></a>同步读取目录方法 readdirSync</h4><p><code>readdirSync</code> 方法有两个参数：</p><ul><li>第一个参数为目录的路径，传入的路径前部分的目录必须存在，否则会报错；</li><li>第二个参数为 <code>options</code>，其中有 <code>encoding</code>（编码，默认值为 <code>utf8</code>），也可直接传入 <code>encoding</code>；</li><li>返回值为一个存储文件目录中成员名称的数组。</li></ul><p>假设现在已经存在了 <code>a</code> 目录和 <code>a</code> 下的 <code>b</code> 目录，<code>b</code> 目录中有 <code>c</code> 目录和 <code>index.js</code> 文件，下面读取文件目录结构。</p><figure class="highlight js"><figcaption><span>同步读取目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = fs.readdirSync(<span class="string">'a/b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// [ 'c', 'index.js' ]</span></span><br></pre></td></tr></table></figure><h4 id="异步读取目录方法-readdir"><a href="#异步读取目录方法-readdir" class="headerlink" title="异步读取目录方法 readdir"></a>异步读取目录方法 readdir</h4><p><code>readdir</code> 方法的前两个参数与 <code>readdirSync</code> 相同，第三个参数为一个回调函数，回调函数有两个参数 <code>err</code>（错误）和 <code>data</code>（存储文件目录中成员名称的数组），在读取文件目录后执行。</p><p>上面案例异步的写法：</p><figure class="highlight js"><figcaption><span>异步读取目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readdir(<span class="string">'a/b'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 'c', 'index.js' ]</span></span><br></pre></td></tr></table></figure><h3 id="删除文件目录"><a href="#删除文件目录" class="headerlink" title="删除文件目录"></a>删除文件目录</h3><p>无论同步还是异步，删除文件目录时必须保证文件目录的路径存在，且被删除的文件目录为空，即不存在任何文件夹和文件。</p><h4 id="同步删除目录方法-rmdirSync"><a href="#同步删除目录方法-rmdirSync" class="headerlink" title="同步删除目录方法 rmdirSync"></a>同步删除目录方法 rmdirSync</h4><p><code>rmdirSync</code> 的参数为要删除目录的路径，现在存在 <code>a</code> 目录和 <code>a</code> 目录下的 <code>b</code> 目录，删除 <code>b</code> 目录。</p><figure class="highlight js"><figcaption><span>同步删除目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.rmdirSync(<span class="string">'a/b'</span>);</span><br></pre></td></tr></table></figure><h4 id="异步删除目录方法-rmdir"><a href="#异步删除目录方法-rmdir" class="headerlink" title="异步删除目录方法 rmdir"></a>异步删除目录方法 rmdir</h4><p><code>rmdir</code> 方法的第一个参数与 <code>rmdirSync</code> 相同，最后一个参数为回调函数，函数中存在一个参数 <code>err</code>（错误），在删除目录操作后执行。</p><figure class="highlight js"><figcaption><span>异步删除目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.rmdir(<span class="string">'a/b'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) <span class="built_in">console</span>.log(<span class="string">'删除成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除成功</span></span><br></pre></td></tr></table></figure><h3 id="删除文件操作"><a href="#删除文件操作" class="headerlink" title="删除文件操作"></a>删除文件操作</h3><h4 id="同步删除文件方法-unlinkSync"><a href="#同步删除文件方法-unlinkSync" class="headerlink" title="同步删除文件方法 unlinkSync"></a>同步删除文件方法 unlinkSync</h4><p><code>unlinkSync</code> 的参数为要删除文件的路径，现在存在 <code>a</code> 目录和 <code>a</code> 目录下的 <code>index.js</code> 文件，删除 <code>index.js</code> 文件。</p><figure class="highlight js"><figcaption><span>同步删除文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.unlinkSync(<span class="string">'a/inde.js'</span>);</span><br></pre></td></tr></table></figure><h4 id="异步删除文件方法-unlink"><a href="#异步删除文件方法-unlink" class="headerlink" title="异步删除文件方法 unlink"></a>异步删除文件方法 unlink</h4><p><code>unlink</code> 方法的第一个参数与 <code>unlinkSync</code> 相同，最后一个参数为回调函数，函数中存在一个参数 <code>err</code>（错误），在删除文件操作后执行。</p><figure class="highlight js"><figcaption><span>异步删除文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.unlink(<span class="string">'a/index.js'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) <span class="built_in">console</span>.log(<span class="string">'删除成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除成功</span></span><br></pre></td></tr></table></figure><h2 id="实现递归创建目录"><a href="#实现递归创建目录" class="headerlink" title="实现递归创建目录"></a>实现递归创建目录</h2><blockquote class="pullquote success"><p>我们创建一个函数，参数为一个路径，按照路径一级一级的创建文件夹目录。</p></blockquote><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>递归删除文件目录 —— 同步</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建文件目录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mkPathSync</span>(<span class="params">dirPath</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// path.sep 文件路径分隔符（mac 与 window 不同）</span></span><br><span class="line">  <span class="comment">// 转变成数组，如 ['a', 'b', 'c']</span></span><br><span class="line">  <span class="keyword">let</span> parts = dirPath.split(path.sep);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= parts.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 重新拼接成 a a/b a/b/c</span></span><br><span class="line">    <span class="keyword">let</span> current = parts.slice(<span class="number">0</span>, i).join(path.sep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accessSync 路径不存在则抛出错误在 catch 中创建文件夹</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fs.accessSync(current);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      fs.mkdirSync(current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件目录</span></span><br><span class="line">mkPathSync(path.join(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>));</span><br></pre></td></tr></table></figure><p>同步代码就是利用 <code>accessSync</code> 方法检查文件路径是否存在，利用 <code>try...catch...</code> 进行错误捕获，如果路径不存在，则会报错，会进入 <code>catch</code> 完成文件夹的创建。</p><h3 id="异步回调的实现"><a href="#异步回调的实现" class="headerlink" title="异步回调的实现"></a>异步回调的实现</h3><figure class="highlight js"><figcaption><span>递归删除文件目录 —— 异步回调</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mkPathAsync</span>(<span class="params">dirPath, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 转变成数组，如 ['a', 'b', 'c']</span></span><br><span class="line">  <span class="keyword">let</span> parts = dirPath.split(path.sep);</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建文件夹方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 重新拼接成 a a/b a/b/c</span></span><br><span class="line">    <span class="keyword">let</span> current = parts.slice(<span class="number">0</span>, index).join(path.sep);</span><br><span class="line">    index++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径检查成功说明已经有该文件目录，则继续创建下一级</span></span><br><span class="line">    <span class="comment">// 失败则创建目录，成功后递归 next 创建下一级</span></span><br><span class="line">    fs.access(current, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        fs.mkdir(current, next);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件目录</span></span><br><span class="line">mkPathAsync(path.join(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>), () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'创建文件目录完成'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件目录完成</span></span><br></pre></td></tr></table></figure><p>上面方法中没有通过循环实现每次目录的拼接，而是通过递归内部函数 <code>next</code> 的方式并维护 <code>index</code> 变量来实现的，在使用 <code>access</code> 的时候成功说明文件目录已经存在，就继续递归创建下一级，如果存在 <code>err</code> 说明不存在，则创建文件夹。</p><h3 id="异步-async-await-的实现"><a href="#异步-async-await-的实现" class="headerlink" title="异步 async/await 的实现"></a>异步 async/await 的实现</h3><p>上面两种方式，同步阻塞代码，性能不好，异步回调函数嵌套性能好，但是维护性差，我们想要具备性能好，代码可读性又好可以使用现在 NodeJS 中正流行的 <code>async/await</code> 的方式进行异步编程，想了解 <code>async/await</code> 可以看 <a href="https://www.overtaking.top/2018/06/15/20180615212040/" target="_blank">异步发展流程 —— 异步编程的终极大招 async/await</a> 这篇文章。</p><p>使用 <code>async</code> 函数中 <code>await</code> 等待的异步操作必须转换成 Promise，以前我们都使用 <code>util</code> 模块下的 <code>promisify</code> 方法进行转换，其实 <code>promisify</code> 方法的原理很简单，我们在实现递归创建文件目录之前先实现 <code>promisify</code> 方法。</p><figure class="highlight js"><figcaption><span>promisify 原理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个异步方法转换成 Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="literal">null</span>, ...args, (err, data) =&gt; &#123;</span><br><span class="line">        err ? reject(err) : resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>promisify</code> 方法就是利用闭包来实现的，调用时传入一个需要转换成 Promise 的函数 <code>fn</code>，返回一个闭包函数，在闭包函数中返回一个 Promise 实例，并同步执行了 <code>fn</code>，通过 <code>call</code> 将闭包函数中的参数和回调函数作为参数传入了 <code>fn</code> 中，该回调在存在错误的时候调用了 Promise 实例的 <code>reject</code>，否则调用 <code>resolve</code>；</p><figure class="highlight js"><figcaption><span>递归删除文件目录 —— 异步 async/await</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 fs 中用到的方法转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> access = promisify(fs.access);</span><br><span class="line"><span class="keyword">const</span> mkdir = promisify(fs.mkdir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// async/await 实现递归创建文件目录</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mkPath</span>(<span class="params">dirPath</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 转变成数组，如 ['a', 'b', 'c']</span></span><br><span class="line">  <span class="keyword">let</span> parts = dirPath.split(path.sep);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= parts.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 重新拼接成 a a/b a/b/c</span></span><br><span class="line">    <span class="keyword">let</span> current = parts.slice(<span class="number">0</span>, i).join(path.sep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accessSync 路径不存在则抛出错误在 catch 中创建文件夹</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> access(current);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">await</span> mkdir(current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件目录</span></span><br><span class="line">mkPath(path.(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'创建文件目录完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件目录完成</span></span><br></pre></td></tr></table></figure><p>使用 <code>async/await</code> 的写法，代码更像同步的实现方式，却是异步执行，所以同时兼顾了性能和代码的可读性，优势显而易见，在使用 NodeJS 框架 <code>Koa 2.x</code> 版本时大量使用这种方式进行异步编程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 <code>fs</code> 所有模块都有同步异步两种实现，同步方法的特点就是阻塞代码，导致性能差，异步代码的特点就是回调函数嵌套多，在使用 <code>fs</code> 应尽量使用异步方式编程来保证性能，如果觉得回调函数嵌套不好维护，可以使用 Promise 和 <code>async/await</code> 的方式解决。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS —— Buffer 解读</title>
      <link href="/2018/06/29/20180629115313/"/>
      <url>/2018/06/29/20180629115313/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/29/20180629115313/buffer.png" title="Buffer"><p><br></p><h2 id="Buffer-概述"><a href="#Buffer-概述" class="headerlink" title="Buffer 概述"></a>Buffer 概述</h2><blockquote class="pullquote warning"><p>在 ES6 引入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank">TypedArray</a> 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 NodeJS API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。<br>Buffer 属于 Global 对象，使用时不需引入，且 Buffer 的大小在创建时确定，无法调整。</p></blockquote><a id="more"></a><h2 id="创建-Buffer"><a href="#创建-Buffer" class="headerlink" title="创建 Buffer"></a>创建 Buffer</h2><p>在 NodeJS <code>v6.0.0</code> 版本之前，Buffer 实例是通过 Buffer 构造函数创建的，即使用 <code>new</code> 关键字创建，它根据提供的参数返回不同的 Buffer，但在之后的版本中这种声明方式就被废弃了，替代 <code>new</code> 的创建方式主要有以下几种。</p><h3 id="Buffer-alloc-和-Buffer-allocUnsafe"><a href="#Buffer-alloc-和-Buffer-allocUnsafe" class="headerlink" title="Buffer.alloc 和 Buffer.allocUnsafe"></a>Buffer.alloc 和 Buffer.allocUnsafe</h3><p>用 <code>Buffer.alloc</code> 和 <code>Buffer.allocUnsafe</code> 创建 Buffer 的传参方式相同，参数为创建 Buffer 的长度，数值类型。</p><figure class="highlight js"><figcaption><span>Buffer.alloc 和 Buffer.allocUnsafe 创建 Buffer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer.alloc 创建 Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf1 = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffer.allocUnsafe 创建 Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf2 = Buffer.allocUnsafe(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf1); <span class="comment">// &lt;Buffer 00 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf2); <span class="comment">// &lt;Buffer 00 e7 8f a0 00 00&gt;</span></span><br></pre></td></tr></table></figure><p>通过代码可以看出，用 <code>Buffer.alloc</code> 和 <code>Buffer.allocUnsafe</code> 创建 Buffer 是有区别的，<code>Buffer.alloc</code> 创建的 Buffer 是被初始化过的，即 Buffer 的每一项都用 <code>00</code> 填充，而 <code>Buffer.allocUnsafe</code> 创建的 Buffer 并没有经过初始化，在内存中只要有闲置的 Buffer 就直接 “抓过来” 使用。</p><p><code>Buffer.allocUnsafe</code> 创建 Buffer 使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感数据，有明显性能优势的同时又是不安全的，所以使用需格外 “小心”。</p><h3 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from"></a>Buffer.from</h3><p>Buffer.from 支持三种传参方式：</p><ul><li>第一个参数为字符串，第二个参数为字符编码，如 <code>ASCII</code>、<code>UTF-8</code>、<code>Base64</code> 等等。</li><li>传入一个数组，数组的每一项会以十六进制存储为 Buffer 的每一项。</li><li>传入一个 Buffer，会将 Buffer 的每一项作为新返回 Buffer 的每一项。</li></ul><p><strong>传入字符串和字符编码：</strong></p><figure class="highlight js"><figcaption><span>传入字符串和字符编码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'hello'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 68 65 6c 6c 6f&gt;</span></span><br></pre></td></tr></table></figure><p><strong>传入数组：</strong></p><figure class="highlight js"><figcaption><span>数组成员为十进制数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 01 02 03&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>数组成员为十六进制数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from([<span class="number">0xe4</span>, <span class="number">0xbd</span>, <span class="number">0xa0</span>, <span class="number">0xe5</span>, <span class="number">0xa5</span>, <span class="number">0xbd</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'utf8'</span>)); <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>在 NodeJS 中不支持 <code>GB2312</code> 编码，默认支持 <code>UTF-8</code>，在 <code>GB2312</code> 中，一个汉字占两个字节，而在 <code>UTF-8</code> 中，一个汉字占三个字节，所以上面 “你好” 的 Buffer 为 <code>6</code> 个十六进制数组成。</p></blockquote><figure class="highlight js"><figcaption><span>数组成员为字符串类型的数字</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 01 02 03&gt;</span></span><br></pre></td></tr></table></figure><p>传入的数组成员可以是任何进制的数值，当成员为字符串的时候，如果值是数字会被自动识别成数值类型，如果值不是数字或成员为是其他非数值类型的数据，该成员会被初始化为 <code>00</code>。</p><p>创建的 Buffer 可以通过 <code>toString</code> 方法直接指定编码进行转换，默认编码为 <code>UTF-8</code>。</p><p><strong>传入 Buffer：</strong></p><figure class="highlight js"><figcaption><span>传入一个 Buffer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf1 = Buffer.from(<span class="string">'hello'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf2 = Buffer.from(buf1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf1); <span class="comment">// &lt;Buffer 68 65 6c 6c 6f&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf2); <span class="comment">// &lt;Buffer 68 65 6c 6c 6f&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf1 === buf2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(buf1[<span class="number">0</span>] === buf2[<span class="number">0</span>]); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>当传入的参数为一个 Buffer 的时候，会创建一个新的 Buffer 并复制上面的每一个成员。</p><blockquote class="pullquote warning"><p>Buffer 为引用类型，一个 Buffer 复制了另一个 Buffer 的成员，当其中一个 Buffer 复制的成员有更改，另一个 Buffer 对应的成员会跟着改变，因为指向同一个引用，类似于 “二维数组”。</p></blockquote><figure class="highlight js"><figcaption><span>Buffer 类比二维数组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.slice();</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, [5]]</span></span><br></pre></td></tr></table></figure><h2 id="Buffer-的常用方法"><a href="#Buffer-的常用方法" class="headerlink" title="Buffer 的常用方法"></a>Buffer 的常用方法</h2><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>Buffer 的 <code>fill</code> 方法可以向一个 Buffer 中填充数据，支持传入三个参数：</p><ul><li>value：将要填充的数据；</li><li>start：填充数据的开始位置，不指定默认为 <code>0</code>；</li><li>end：填充数据的结束位置，不指定默认为 Buffer 的长度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">buf.fill(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 01 01 01&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">buf.fill(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 00 00 01 01 00 00&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码可以看出填充数据是 “包前不包后的”，<code>fill</code> 的第一个参数也支持是多个字节，从被填充 Buffer 的起始位置开始，一直到结束，会循环填充这些字节，剩余的位置不够填充这几个字节，会填到哪算哪，有可能不完整，如果 <code>fill</code> 指定的结束位置大于了 Buffer 的长度，会抛出 <code>RangeError</code> 的异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">buf.fill(<span class="string">'abc'</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 00 61 62 63 61 00&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">buf.fill(<span class="string">'abc'</span>, <span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');</span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>Buffer 的 <code>slice</code> 方法与数组的 <code>slice</code> 方法用法完全相同，相信数组的 <code>slice</code> 已经足够熟悉了，这里就不多赘述了，Buffer 中截取出来的都是 Buffer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'hello'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = buf.slice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> b = buf.slice(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> b = buf.slice(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.toString()); <span class="comment">// he</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toString()); <span class="comment">// llo</span></span><br><span class="line"><span class="built_in">console</span>.log(c.toString()); <span class="comment">// o</span></span><br></pre></td></tr></table></figure><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>Buffer 的 <code>indexOf</code> 用法与数组和字符串的 <code>indexOf</code> 类似，第一个参数为查找的项，第二个参数为查找的起始位置，不同的是，对于 Buffer 而言，查找的可能是一个字符串，代表多个字节，查找的字节在 Buffer 中必须有连续相同的字节，返回连续的字节中第一个字节的索引，没查找到返回 <code>-1</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'你*好*吗'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e4 bd a0 2a e5 a5 bd 2a e5 90 97&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.indexOf(<span class="string">'*'</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.indexOf(<span class="string">'*'</span>, <span class="number">4</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>Buffer 的 copy 方法用于将一个 Buffer 的字节复制到另一个 Buffer 中去，有四个参数：</p><ul><li>target：目标 Buffer</li><li>targetStart：目标 Buffer 的起始位置</li><li>sourceStart：源 Buffer 的起始位置</li><li>sourceEnd：源 Buffer 的结束位置</li></ul><figure class="highlight js"><figcaption><span>容器 Buffer 长度充足</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> targetBuf = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> sourceBuf = Buffer.from(<span class="string">'你好'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 “你好” 复制到 targetBuf 中</span></span><br><span class="line">sourceBuf.copy(targetBuf, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(targetBuf.toString()); <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>容器 Buffer 长度不足</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> targetBuf = Buffer.alloc(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> sourceBuf = Buffer.from(<span class="string">'你好'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">sourceBuf.copy(targetBuf, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(targetBuf.toString()); <span class="comment">// 你</span></span><br></pre></td></tr></table></figure><p>上面第二个案例中虽然要把整个源 Buffer 都复制进目标 Buffer 中，但是由于目标 Buffer 的长度只有 <code>3</code>，所以最终只能复制进去一个 “你” 字。</p><blockquote class="pullquote warning"><p>Buffer 与数组不同，不能通过操作 <code>length</code> 和索引改变 Buffer 的长度，Buffer 一旦被创建，长度将保持不变。</p></blockquote><figure class="highlight js"><figcaption><span>数组对比 Buffer —— 操作 length</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4, empty]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">3</span>);</span><br><span class="line">buf[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 00 00 00&gt;</span></span><br><span class="line"></span><br><span class="line">buf.length = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 00 00 00&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>通过上面代码可以看出数组可以通过 <code>length</code> 和索引对数组的长度进行改变，但是 Buffer 中类似的操作都是不生效的。</p><p><code>copy</code> 方法的 Polyfill：</p><figure class="highlight js"><figcaption><span>模拟 copy 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Buffer.prototype.myCopy = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  sourceStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  sourceEnd</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sourceEnd - sourceStart; i++) &#123;</span><br><span class="line">    target[targetStart + i] = <span class="keyword">this</span>[sourceStart + i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Buffer-concat"><a href="#Buffer-concat" class="headerlink" title="Buffer.concat"></a>Buffer.concat</h3><p>与数组类似，Buffer 也存在用于拼接多个 Buffer 的方法 <code>concat</code>，不同的是 Buffer 中的 <code>concat</code> 不是实例方法，而是静态方法，通过 <code>Buffer.concat</code> 调用，且传入的参数不同。</p><p><code>Buffer.concat</code> 有两个参数，返回值是一个新的 Buffer：</p><ul><li>第一个参数为一个数组，数组中的每一个成员都是一个 Buffer；</li><li>第二个参数代表新 Buffer 的长度，默认值为数组中每个 Buffer 长度的总和。</li></ul><p><code>Buffer.concat</code> 会将数组中的 Buffer 进行拼接，存入新 Buffer 并返回，如果传入第二个参数规定了返回 Buffer 的长度，那么返回值存储拼接后前规定长度个字节。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf1 = Buffer.from(<span class="string">'你'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">let</span> buf2 = Buffer.from(<span class="string">'好'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = Buffer.concat([buf1, buf2]);</span><br><span class="line"><span class="keyword">let</span> result2 = Buffer.concat([buf1, buf2], <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// &lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(result1.toString()); <span class="comment">// 你好</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result2); <span class="comment">// &lt;Buffer e4 bd a0&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(result2.toString()); <span class="comment">// 你</span></span><br></pre></td></tr></table></figure><p><code>Buffer.concat</code> 方法的 Polyfill：</p><figure class="highlight js"><figcaption><span>模拟 Buffer.concat</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Buffer.myConcat = <span class="function"><span class="keyword">function</span>(<span class="params">bufferList, len</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新 Buffer 的长度</span></span><br><span class="line">  len = len || bufferList.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next.length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newBuf = Buffer.alloc(len); <span class="comment">// 创建新 Buffer</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 下次开始的索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环存储 Buffer 的数组进行复制</span></span><br><span class="line">  bufferList.forEach(<span class="function"><span class="params">buf</span> =&gt;</span> &#123;</span><br><span class="line">    buf.myCopy(newBuf, index, <span class="number">0</span>, buf.length);</span><br><span class="line">    index += buf.length;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newBuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Buffer-isBuffer"><a href="#Buffer-isBuffer" class="headerlink" title="Buffer.isBuffer"></a>Buffer.isBuffer</h3><p><code>Buffer.isBuffer</code> 是用来判断一个对象是否是一个 Buffer，返回布尔值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.isBuffer(obj)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.isBuffer(buf)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="封装一个-split"><a href="#封装一个-split" class="headerlink" title="封装一个 split"></a>封装一个 split</h2><p>字符串中的 <code>split</code> 是经常使用的方法，可以用分隔符将字符串切成几部分存储在数组中，Buffer 本身没有 <code>split</code> 方法，但是也会有类似的使用场景，所以我们在 Buffer 中自己封装一个 <code>split</code>。</p><p>Buffer 的 <code>split</code> 方法参数为一个分隔符，这个分隔符可能是一个或多个字节的内容，返回值为一个数组，分隔开的部分作为独立的 Buffer 存储在返回的数组中。</p><figure class="highlight js"><figcaption><span>封装 Buffer 的 split 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Buffer.prototype.split = <span class="function"><span class="keyword">function</span>(<span class="params">sep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = Buffer.from(sep).length; <span class="comment">// 分隔符所占的字节数</span></span><br><span class="line">  <span class="keyword">let</span> result = []; <span class="comment">// 返回的数组</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>; <span class="comment">// 查找 Buffer 的起始位置</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>; <span class="comment">// 偏移量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找分隔符</span></span><br><span class="line">  <span class="keyword">while</span> ((offset = <span class="keyword">this</span>.indexOf(sep, start)) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 将分隔符之前的部分截取出来存入</span></span><br><span class="line">    result.push(<span class="keyword">this</span>.slice(start, offset));</span><br><span class="line">    start = offset + len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理剩下的部分</span></span><br><span class="line">  result.push(<span class="keyword">this</span>.slice(start));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证 <code>split</code> 方法：</p><figure class="highlight js"><figcaption><span>验证 split</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'哈登爱篮球爱夜店'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">let</span> bufs = buf.split(<span class="string">'爱'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bufs);</span><br><span class="line"><span class="comment">// [ &lt;Buffer e5 93 88 e7 99 bb&gt;,</span></span><br><span class="line"><span class="comment">//   &lt;Buffer e7 af ae e7 90 83&gt;,</span></span><br><span class="line"><span class="comment">//   &lt;Buffer e5 a4 9c e5 ba 97&gt; ]</span></span><br><span class="line"></span><br><span class="line">newBufs = bufs.map(<span class="function"><span class="params">buf</span> =&gt;</span> buf.toString());</span><br><span class="line"><span class="built_in">console</span>.log(newBufs); <span class="comment">// [ '哈登', '篮球', '夜店' ]</span></span><br></pre></td></tr></table></figure><h2 id="Buffer-的编码转换"><a href="#Buffer-的编码转换" class="headerlink" title="Buffer 的编码转换"></a>Buffer 的编码转换</h2><p>我们知道 NodeJS 中的默认编码为 <code>UTF-8</code>，且不支持 <code>GB2312</code> 编码，假如现在有一个编码格式为 <code>GB2312</code> 的 <code>txt</code> 文件，内容为 “你好”，现在我们使用 NodeJS 去读取它，由于在 <code>UTF-8</code> 与 <code>GB2312</code> 编码中汉字所占字节数不同，所以读出的内容无法解析，即为乱码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'你好'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">let</span> result = fs.readFileSync(path.resolve(__dirname, <span class="string">'a.txt'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString()); <span class="comment">// 你好</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &lt;Buffer c4 e3 ba c3&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(result.toString()); <span class="comment">// ���</span></span><br></pre></td></tr></table></figure><p>如果一定要在 NodeJS 中来正确解析这样的内容，这样的问题还是有办法解决的，我们需要借助 <code>iconv-lite</code> 模块，这个模块可以将一个 Buffer 按照指定的编码格式进行编码或解码。</p><p>由于 <code>iconv-lite</code> 是第三方提供的模块，在使用前需要安装，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install iconv-lite</span><br></pre></td></tr></table></figure><p>如果想正确的读出其他编码格式文件的内容，上面代码应该更改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> iconvLite = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = fs.readFileSync(path.resolve(__dirname, <span class="string">'a.txt'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iconvLite.decode(result, <span class="string">'gb2312'</span>)); <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><h2 id="去掉-BOM-头"><a href="#去掉-BOM-头" class="headerlink" title="去掉 BOM 头"></a>去掉 BOM 头</h2><p>上面读取 <code>GB2312</code> 编码的 <code>txt</code> 文件也可以通过打开文件重新保存为 <code>UTF-8</code> 或用编辑器直接将编码手动修改为 <code>UTF-8</code>，此时读取的文件不需要进行编码转换，但是会产生新的问题。</p><figure class="highlight js"><figcaption><span>产生 BOM 头</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'你好'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">let</span> result = fs.readFileSync(path.resolve(__dirname, <span class="string">'a.txt'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &lt;Buffer ef bb bf e4 bd a0 e5 a5 bd&gt;</span></span><br></pre></td></tr></table></figure><p>在手动修改 <code>txt</code> 文件编码后执行上面代码，发现读取的 Buffer 与正常情况相比前面多出了三个字节，只要存在文件编码的修改就会在这个文件的前面产生多余的字节，叫做 <code>BOM</code> 头。</p><blockquote class="pullquote info"><p><code>BOM</code> 头是用来判断文本文件是哪一种 <code>Unicode</code> 编码的标记，其本身是一个 <code>Unicode</code> 字符，位于文本文件头部。</p></blockquote><p>虽然 <code>BOM</code> 头起到了标记文件编码的作用，但是它并不属于文件的内容部分，因此会产生一些问题，如文件编码发生变化后无法正确读取文件的内容，或者多个文件在合并的过程中，中间会夹杂着这些多余内容，所以在 NodeJS 文件操作的源码中，Buffer 编码转换的模块 <code>iconv-lite</code> 中，以及 Webpack 对项目文件进行打包编译时都进行了去掉 <code>BOM</code> 头的操作。</p><p>为了让上面的代码可以正确的读取并解析编码被手动修改过的文件内容，我们这里也需要进行去掉 <code>BOM</code> 头的操作。</p><figure class="highlight js"><figcaption><span>去掉 BOM 头的方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BOMStrip</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Buffer.isBuffer(result)) &#123;</span><br><span class="line">    <span class="comment">// 如果读取的内容为 Buffer</span></span><br><span class="line">    <span class="keyword">if</span> (result[<span class="number">0</span>] === <span class="number">0xef</span> &amp;&amp; result[<span class="number">1</span>] === <span class="number">0xbb</span> &amp;&amp; result[<span class="number">2</span>] === <span class="number">0xbf</span>) &#123;</span><br><span class="line">      <span class="comment">// 若前三个字节是否和 BOM 头的前三字节相同，去掉 BOM 头</span></span><br><span class="line">      <span class="keyword">return</span> Buffer.slice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是 Buffer</span></span><br><span class="line">    <span class="keyword">if</span> (result.charCodeAt(<span class="number">0</span>) === <span class="number">0xfeff</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断第一项是否和 BOM 头的十六进制相同，去掉 BOM 头</span></span><br><span class="line">      <span class="keyword">return</span> result.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用去掉 <code>BOM</code> 头的方法并验证上面读文件的案例：</p><figure class="highlight js"><figcaption><span>验证去 BOM 头的方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方式读文件</span></span><br><span class="line"><span class="keyword">let</span> result1 = fs.readFileSync(path.resolve(__dirname, <span class="string">'a.txt'</span>));</span><br><span class="line"><span class="keyword">let</span> result2 = fs.readFileSync(path.resolve(__dirname, <span class="string">'a.txt'</span>), <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(BOMStrip(result1).toString()); <span class="comment">// 你好</span></span><br><span class="line"><span class="built_in">console</span>.log(BOMStrip(result2)); <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><h2 id="缓存-Buffer"><a href="#缓存-Buffer" class="headerlink" title="缓存 Buffer"></a>缓存 Buffer</h2><figure class="highlight js"><figcaption><span>产生乱码问题</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'你好'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = buf.slice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> b = buf.slice(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.toString()); <span class="comment">// �</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toString()); <span class="comment">// �好</span></span><br></pre></td></tr></table></figure><p><code>UTF-8</code> 编码，一个汉字三个字节，使用 <code>slice</code> 方法对一个表达汉字的 Buffer 进行截取，如果截取长度不是 <code>3</code> 的整数倍，此时无法正确解析，会显示乱码，类似这种情况可以使用模块 <code>string_decoder</code> 对不能组成汉字的 Buffer 进行缓存，<code>string_decoder</code> 是核心模块，不需要安装。</p><figure class="highlight js"><figcaption><span>缓存 Buffer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> &#123; StringDecoder &#125; = <span class="built_in">require</span>(<span class="string">'string_decoder'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'你好'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = buf.slice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> b = buf.slice(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 StringDecoder 实例</span></span><br><span class="line"><span class="keyword">let</span> sd = <span class="keyword">new</span> StringDecoder();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sd.write(a));</span><br><span class="line"><span class="built_in">console</span>.log(sd.write(b)); <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><p>上面代码中使用了 <code>string_decoder</code> 后，截取的 Buffer 不能组成一个汉字的时候不打印，进行缓存，等到可以正确解析时取出缓存，重新拼接后打印。</p>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> Buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventEmitter 源码分析与简易实现</title>
      <link href="/2018/06/28/20180628204755/"/>
      <url>/2018/06/28/20180628204755/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/28/20180628204755/event-emitter.png" title="EventEmitter"><p><br></p><h2 id="EventEmitter-简介"><a href="#EventEmitter-简介" class="headerlink" title="EventEmitter 简介"></a>EventEmitter 简介</h2><blockquote class="pullquote danger"><p>EventEmitter 是 NodeJS 的核心模块 <code>events</code> 中的类，用于对 NodeJS 中的事件进行统一管理，用 <code>events</code> 特定的 API 对事件进行添加、触发和移除等等，核心方法的模式类似于发布订阅。</p></blockquote><a id="more"></a><h2 id="实现-EventEmitter"><a href="#实现-EventEmitter" class="headerlink" title="实现 EventEmitter"></a>实现 EventEmitter</h2><h3 id="EventEmitter-构造函数的实现"><a href="#EventEmitter-构造函数的实现" class="headerlink" title="EventEmitter 构造函数的实现"></a>EventEmitter 构造函数的实现</h3><figure class="highlight js"><figcaption><span>文件：events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 其他方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出自定义模块</span></span><br><span class="line"><span class="built_in">module</span>.export = EventEmitter;</span><br></pre></td></tr></table></figure><p>在构造函数 EventEmitter 上有一个属性 <code>_events</code>，类型为对象，用于存储和统一管理所有类型的事件，在创建构造函数的时候导出了 EventEmitter，后面实现其他方法的代码将放在构造函数与导出中间。</p><h3 id="事件最大监听个数"><a href="#事件最大监听个数" class="headerlink" title="事件最大监听个数"></a>事件最大监听个数</h3><p>在 EventEmitter 中监听的每一类事件都有最大监听个数，超过了这个数值，事件虽然可以正常执行，但是会发出警告信息，其目的是为了防止内存泄露。</p><figure class="highlight js"><figcaption><span>默认事件最大监听个数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.defaultMaxListeners = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这个同类型事件最大个数默认是 <code>10</code>，EventEmitter 当然也有方法设置和获取这个值，下面是设置和获取同类型事件最大监听个数的方法实现。</p><figure class="highlight js"><figcaption><span>操作最大事件监听个数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置同类型事件监听最大个数</span></span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取同类型事件监听最大个数</span></span><br><span class="line">EventEmitter.prototype.getMaxListeners = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._count || EventEmitter.defaultMaxListeners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设置这个值的时候其实就是给 EventEmitter 实例添加了一个 <code>_count</code> 的属性用来存储设置的新值来作为这个类型事件的最大监听个数，在获取的时候就是获取 <code>_count</code>，如果没有设置过就获取默认值。</p><h3 id="添加事件监听"><a href="#添加事件监听" class="headerlink" title="添加事件监听"></a>添加事件监听</h3><p>在给 EventEmitter 的实例添加事件监听时，在 <code>_event</code> 对象中会以事件的类型作为属性名，值为一个数组，每次添加这个类型事件的时候，会将要执行的函数存入这个数组中进行统一管理。</p><p>添加事件监听的方法有 <code>on</code>、<code>once</code>、<code>addListener</code>、<code>prependListener</code> 和 <code>prependOnceListener</code>：</p><ul><li><code>on</code> 等同于 <code>addListener</code> 将函数正常添加到 <code>_event</code> 对应事件类型的数组中；</li><li><code>once</code> 将函数添加到 <code>_event</code> 对应事件类型的数组中，但是只能执行一次；</li><li><code>prependListener</code> 将函数添加到 <code>_event</code> 对应事件类型的数组中的前面；</li><li><code>prependOnceListener</code> 将函数添加到 <code>_event</code> 对应事件类型的数组中的前面，但只能执行一次。</li></ul><blockquote class="pullquote warning"><p>在 EventEmitter 中正常添加事件有四点需要注意：<br>1、如果其他的类使用 <code>util</code> 模块的 <code>inherits</code> 方法继承 EventEmitter 时是无法继承实例属性的，在调用操作 <code>_events</code> 的方法中因为无法获取到 <code>_events</code> 导致报错，为了兼容这种继承的情况，在获取不到 <code>_events</code> 时应添加一个 <code>_events</code> 到继承 EventEmitter 的类的实例上；<br>2、如果添加事件的类型为 <code>newListener</code>，传入要执行的函数会有一个参数 <code>type</code> ，是事件的类型，之后再添加事件的时候，就会执行 <code>newListener</code> 的函数，对添加的事件的事件类型进行处理；<br>3、<code>on</code> 方法表面上有两个参数，实际上有第三个参数，为布尔值，代表是否从 <code>_events</code> 对应事件类型的数组前面追加函数成员；<br>4、在添加事件的时候需要判断是否超出这个类型事件的最大监听个数，如果超出要打印警告信息。</p></blockquote><p><strong>on 方法和 addListener 方法的实现：</strong></p><figure class="highlight js"><figcaption><span>on 和 addListener 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听</span></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  type,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  flag</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容继承不存在 _events 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events) <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 type 不是 newListener 就去执行 newListener 的回调</span></span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">'newListener'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没添加过 newListener 事件就忽略此处的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">this</span>._events[<span class="string">'newListener'</span>] &amp;&amp;</span><br><span class="line">      <span class="keyword">this</span>._events[<span class="string">'newListener'</span>].length</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[<span class="string">'newListener'</span>].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(type));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是第一次添加 callback 存入数组中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._events[type]) &#123;</span><br><span class="line">    <span class="comment">// 是否从数组前面添加 callback</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[type].unshift(callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[type].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次添加，在 _events 中创建数组并添加 callback 到数组中</span></span><br><span class="line">    <span class="keyword">this</span>._events[type] = [callback];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件最大监听个数</span></span><br><span class="line">  <span class="keyword">let</span> maxListeners = <span class="keyword">this</span>.getMaxListeners();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 type 类型的事件是否超出最大监听个数，超出打印警告信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._events[type].length - <span class="number">1</span> === maxListeners) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`MaxListenersExceededWarning:</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;maxListeners + <span class="number">1</span>&#125;</span> <span class="subst">$&#123;type&#125;</span> listeners added`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出 <code>on</code> 方法的第三个参数其实是服务于 <code>prependListener</code> 方法的，其他添加事件的方法都是基于 <code>on</code> 来实现的，只是在调用 <code>on</code> 的外层做了不同的处理，而我们平时调这些添加事件监听的方法时都只传入 <code>type</code> 和 <code>callback</code>。</p><p><strong>prependListener 方法的实现：</strong></p><figure class="highlight js"><figcaption><span>prependListener 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听，从数组的前面追加</span></span><br><span class="line">EventEmitter.prototype.prependListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第三个参数为 true 表示从 _events 对应事件类型的数组前面添加 callback</span></span><br><span class="line">  <span class="keyword">this</span>.on(type, callback, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>once 方法的实现：</strong></p><figure class="highlight js"><figcaption><span>once 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听，只能执行一次</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span>(<span class="params">type, callback, flag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrap =&gt; (...args) &#123;</span><br><span class="line">    callback(...args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 callback 后立即从数组中移除 callback</span></span><br><span class="line">    <span class="keyword">this</span>.removeListener(type, wrap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储 callback，确保单独使用 removeListener 删除传入的 callback 时可以被删除掉</span></span><br><span class="line">  wrap.realCallback = callback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 on 添加事件监听</span></span><br><span class="line">  <span class="keyword">this</span>.on(type, wrap, flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想让事件只执行一次，需要在执行 <code>callback</code> 之后就立即在数组中移除这个函数，由于是同步执行，直接操作 <code>callback</code> 是很难实现的，添加事件其实就是添加 <code>callback</code> 到 <code>_events</code> 对应类型的数组中，我们在使用 <code>once</code> 的时候将 <code>callback</code> 包一层函数名为 <code>wrap</code>，将这个外层函数存入数组，<code>wrap</code> 的内部逻辑就是真正 <code>callback</code> 的调用和移除 <code>wrap</code>，这里涉及到事件监听的移除方法 <code>removeListener</code> 在后面来详细说明。</p><p><code>once</code> 的第三个参数是为了 <code>prependOnceListener</code> 服务的，<code>prependOnceListener</code> 与 <code>prependListener</code> 实现方式类似，不同的是 <code>prependOnceListener</code> 是基于 <code>once</code> 实现的。</p><p><strong>prependOnceListener 方法的实现：</strong></p><figure class="highlight js"><figcaption><span>prependOnceListener 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听，从数组的前面追加，只执行一次</span></span><br><span class="line">EventEmitter.prototype.prependOnceListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第三个参数为 true 表示从 _events 对应事件类型的数组前面添加 callback</span></span><br><span class="line">  <span class="keyword">this</span>.once(type, callback, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除事件监听"><a href="#移除事件监听" class="headerlink" title="移除事件监听"></a>移除事件监听</h3><p>移除事件监听有两个方法，分别是 <code>removeListener</code> 和 <code>removeAllListeners</code>，前者的作用是移除某个类型数组中的某个回调函数，后者的作用是移除某个类型数组的所有成员，如果类型参数为空，则清空整个 <code>_events</code>。</p><p><strong>removeListener 方法的实现：</strong></p><figure class="highlight js"><figcaption><span>removeListener 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除事件执行程序</span></span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._events[type]) &#123;</span><br><span class="line">    <span class="comment">// 过滤掉当前传入的要移除的 callback</span></span><br><span class="line">    <span class="keyword">this</span>._events[type] = <span class="keyword">this</span>._events[type].filter(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn !== callback &amp;&amp; fn !== callback.realCallback;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>once</code> 中在真正的 <code>callback</code> 包了一层 <code>wrap</code>, 只有在触发事件时才能执行 <code>wrap</code> 并执行 <code>removeListener</code> 删掉函数，如果在事件触发之前使用 <code>removeListener</code> 删除，传入的是真正的回调 <code>callback</code>，无法删除，所以在 <code>once</code> 方法中对真正的 <code>callback</code> 进行了存储，在 <code>removeListener</code> 中调用 <code>filter</code> 时的返回条件的逻辑中做了处理。</p><p><strong>removeAllListeners 方法的实现：</strong></p><figure class="highlight js"><figcaption><span>removeAllListeners 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除全部事件执行程序</span></span><br><span class="line">EventEmitter.prototype.removeAllListeners = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存在 type 清空 _events 对应的数组，否则直接清空 _events</span></span><br><span class="line">  <span class="keyword">if</span> (type) &#123;</span><br><span class="line">    <span class="keyword">this</span>._events[type] = [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发事件监听"><a href="#触发事件监听" class="headerlink" title="触发事件监听"></a>触发事件监听</h3><p>执行事件就比较简单了，取出 <code>_events</code> 中对应类型的数组进行循环，执行内部的每一个函数，第一个参数为 <code>type</code>，后面参数会作为数组中函数执行传入的参数。</p><figure class="highlight js"><figcaption><span>emit 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._events[type]) &#123;</span><br><span class="line">    <span class="comment">// 循环执行函数，并将 this 指回 EventEmitter 实例</span></span><br><span class="line">    <span class="keyword">this</span>._events[type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn.call(<span class="keyword">this</span>, ...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取事件类型名称集合"><a href="#获取事件类型名称集合" class="headerlink" title="获取事件类型名称集合"></a>获取事件类型名称集合</h3><figure class="highlight js"><figcaption><span>eventNames 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取监听的所有事件类型</span></span><br><span class="line">EventEmitter.prototype.eventNames = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>._events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按事件类型获取执行程序的集合"><a href="#按事件类型获取执行程序的集合" class="headerlink" title="按事件类型获取执行程序的集合"></a>按事件类型获取执行程序的集合</h3><figure class="highlight js"><figcaption><span>listeners 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取事件类型对应的数组</span></span><br><span class="line">EventEmitter.prototype.listeners = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._events[type];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EventEmitter-的基本使用"><a href="#EventEmitter-的基本使用" class="headerlink" title="EventEmitter 的基本使用"></a>EventEmitter 的基本使用</h2><p>EventEmitter 的核心逻辑已经实现，由于上面大多数方法需要组合使用，所以在没有一一验证，下面让我们通过一些案例来了解 EventEmitter 的用法。</p><p>我们在这里引入自己自定义的 <code>events</code> 模块，并使用 <code>util</code> 模块的 <code>inherits</code> 继承 EventEmitter，下面是前置代码，后面将不在重复。</p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'./events'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 Girl 继承 EventEmitter</span></span><br><span class="line">util.inherits(Girl, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Girl 的实例</span></span><br><span class="line"><span class="keyword">const</span> girl = <span class="keyword">new</span> Girl();</span><br></pre></td></tr></table></figure><p><strong>案例 1：设置和获取同类型事件的最大监听个数</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取事件最大监听个数</span></span><br><span class="line"><span class="built_in">console</span>.log(girl.getMaxListeners()); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置事件最大监听个数</span></span><br><span class="line">girl.setMaxListeners(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(girl.getMaxListeners()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>案例 2：使用 on 添加事件并执行</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>));</span><br><span class="line"></span><br><span class="line">girl.emit(<span class="string">'失恋'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哭了</span></span><br><span class="line"><span class="comment">// 喝酒</span></span><br></pre></td></tr></table></figure><p><strong>案例 3：使用 prependListener 添加事件并执行</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.prependListener(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>));</span><br><span class="line"></span><br><span class="line">girl.emit(<span class="string">'失恋'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 喝酒</span></span><br><span class="line"><span class="comment">// 哭了</span></span><br></pre></td></tr></table></figure><p><strong>案例 4：添加 newListener 类型的事件</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">girl.on(<span class="string">'newListener'</span>, (type) =&gt; <span class="built_in">console</span>.log(type));</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.on(<span class="string">'和好'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'开心'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失恋</span></span><br><span class="line"><span class="comment">// 和好</span></span><br></pre></td></tr></table></figure><p><strong>案例 5：添加同类型事件超出最大个数并执行事件</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置事件最大监听个数</span></span><br><span class="line">girl.setMaxListeners(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>));</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'吸烟'</span>));</span><br><span class="line"></span><br><span class="line">girl.emit(<span class="string">'失恋'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxListenersExceededWarning: 3 失恋 listeners added</span></span><br><span class="line"><span class="comment">// 哭了</span></span><br><span class="line"><span class="comment">// 喝酒</span></span><br><span class="line"><span class="comment">// 吸烟</span></span><br></pre></td></tr></table></figure><p><strong>案例 6：对比 on 和 once</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.once(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>));</span><br><span class="line"></span><br><span class="line">girl.emit(<span class="string">'失恋'</span>);</span><br><span class="line">girl.emit(<span class="string">'失恋'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哭了</span></span><br><span class="line"><span class="comment">// 喝酒</span></span><br><span class="line"><span class="comment">// 哭了</span></span><br></pre></td></tr></table></figure><p><strong>案例 7：移除 on 和 once 添加的事件监听</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cry = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'哭了'</span>);</span><br><span class="line"><span class="keyword">const</span> drink = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>);</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'失恋'</span>, cry);</span><br><span class="line">girl.once(<span class="string">'失恋'</span>, drink);</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'吸烟'</span>));</span><br><span class="line"></span><br><span class="line">girl.removeListener(<span class="string">'失恋'</span>, cry);</span><br><span class="line">girl.removeListener(<span class="string">'失恋'</span>, drink);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吸烟</span></span><br></pre></td></tr></table></figure><p><strong>案例 8：使用 prependOnceListener 添加事件监听</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.prependOnceListener(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>));</span><br><span class="line"></span><br><span class="line">girl.emit(<span class="string">'失恋'</span>);</span><br><span class="line">girl.emit(<span class="string">'失恋'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 喝酒</span></span><br><span class="line"><span class="comment">// 哭了</span></span><br><span class="line"><span class="comment">// 哭了</span></span><br></pre></td></tr></table></figure><p><strong>案例 9：获取某个事件类型执行程序的集合</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cry = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'哭了'</span>);</span><br><span class="line"><span class="keyword">const</span> drink = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>);</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'失恋'</span>, cry);</span><br><span class="line">girl.once(<span class="string">'失恋'</span>, drink);</span><br><span class="line">girl.once(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'吸烟'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(girl.listeners(<span class="string">'失恋'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ [Function: cry], [Function: drink], [Function] ]</span></span><br></pre></td></tr></table></figure><p><strong>案例 10：获取所有事件类型名称</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.on(<span class="string">'和好'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'开心'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(girl.eventNames());</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ '失恋', '和好' ]</span></span><br></pre></td></tr></table></figure><p><strong>案例 11：使用 removeAllListeners 按类型移除事件监听</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>));</span><br><span class="line">girl.on(<span class="string">'和好'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'开心'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 “失恋” 类型事件监听</span></span><br><span class="line">girl.removeAllListeners(<span class="string">'失恋'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(girl.listeners(<span class="string">'失恋'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure><p><strong>案例 12：使用 removeAllListeners 移除全部事件监听</strong></p><figure class="highlight js"><figcaption><span>文件：events-demo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'哭了'</span>));</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'喝酒'</span>));</span><br><span class="line">girl.on(<span class="string">'和好'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'开心'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除全部事件监听</span></span><br><span class="line">girl.removeAllListeners();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(girl._events);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="EventEmitter-总结"><a href="#EventEmitter-总结" class="headerlink" title="EventEmitter 总结"></a>EventEmitter 总结</h2><blockquote class="pullquote success"><p><code>events</code> 模块在 NodeJS 中的使用率非常高，很多其他模块的事件执行机制都是通过继承该模块的 <code>EventEmitter</code> 类来实现的，比如 <code>ReadStream</code>（可读流）、<code>WriteStream</code>（可写流）、<code>net</code>（tcp）和 <code>http</code> 等等，我们也可以通过上面案例的方式创建自己的类去继承 <code>EventEmitter</code> 来实现事件的管理。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> EventEmitter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonJS 模块化简易实现</title>
      <link href="/2018/06/26/20180626142825/"/>
      <url>/2018/06/26/20180626142825/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/26/20180626142825/commonjs.png" title="Commonjs"><p><br></p><h2 id="CommonJS-概述"><a href="#CommonJS-概述" class="headerlink" title="CommonJS 概述"></a>CommonJS 概述</h2><blockquote class="pullquote warning"><p>CommonJS 是一种模块化的标准，而 NodeJS 是这种标准的实现，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p></blockquote><a id="more"></a><h2 id="NodeJS-模块化的简易实现"><a href="#NodeJS-模块化的简易实现" class="headerlink" title="NodeJS 模块化的简易实现"></a>NodeJS 模块化的简易实现</h2><p>在实现模块加载之前，我们需要清除模块的加载过程：</p><ul><li>假设 <code>A</code> 文件夹下有一个 <code>a.js</code>，我们要解析出一个绝对路径来；</li><li>我们写的路径可能没有后缀名 <code>.js</code>、<code>.json</code>；</li><li>得到一个真实的加载路径（模块会被缓存）先去缓存中看一下这个文件是否存在，如果存在返回缓存 没有则创建一个模块；</li><li>得到对应文件的内容，加一个闭包，把内容塞进去，之后执行即可。</li></ul><h3 id="提前加载需要用到的模块"><a href="#提前加载需要用到的模块" class="headerlink" title="提前加载需要用到的模块"></a>提前加载需要用到的模块</h3><p>因为我们只是实现 CommonJS 的模块加载方法，并不会去实现整个 Node，在这里我们需要依赖一些 Node 的模块，所以我们就 “不要脸” 的使用 Node 自带的 <code>require</code> 方法把模块加载进来。</p><figure class="highlight js"><figcaption><span>依赖模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作文件的模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理路径的模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机，帮我们创建一个黑箱执行代码，防止变量污染</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br></pre></td></tr></table></figure><h3 id="创建-Module-构造函数"><a href="#创建-Module-构造函数" class="headerlink" title="创建 Module 构造函数"></a>创建 Module 构造函数</h3><p>其实 CommonJS 中引入的每一个模块我们都需要通过 <code>Module</code> 构造函数创建一个实例。</p><figure class="highlight js"><figcaption><span>创建 Module 构造函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param &#123;String&#125; p</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = p; <span class="comment">// 当前文件的表示（绝对路径）</span></span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;; <span class="comment">// 每个模块都有一个 exports 属性，用来存储模块的内容</span></span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>; <span class="comment">// 标记是否被加载过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义静态属性存储我们需要使用的一些值"><a href="#定义静态属性存储我们需要使用的一些值" class="headerlink" title="定义静态属性存储我们需要使用的一些值"></a>定义静态属性存储我们需要使用的一些值</h3><figure class="highlight js"><figcaption><span>Module 静态变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数后面需要使用的闭包的字符串</span></span><br><span class="line">Module.wrapper = [</span><br><span class="line">  <span class="string">'(function(exports, require, module, __dirname, __filename) &#123;'</span>,</span><br><span class="line">  <span class="string">'\n&#125;)'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据绝对路径进行缓存的模块的对象</span></span><br><span class="line">Module._cacheModule = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理不同文件后缀名的方法</span></span><br><span class="line">Module._extensions = &#123;</span><br><span class="line">  <span class="string">'.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="string">'.json'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建引入模块的-req-方法"><a href="#创建引入模块的-req-方法" class="headerlink" title="创建引入模块的 req 方法"></a>创建引入模块的 req 方法</h3><p>为了防止和 Node 自带的 <code>require</code> 方法重名，我们将模拟的方法重命名为 <code>req</code>。</p><figure class="highlight js"><figcaption><span>引入模块方法 req</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param &#123;String&#125; moduleId</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 req 传入的参数处理成绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> p = Module._resolveFileName(moduleId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成一个新的模块</span></span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，我们先把传入的参数通过 <code>Module._resolveFileName</code> 处理成了一个绝对路径，并创建模块实例把绝对路径作为参数传入，我们现在实现一下 <code>Module._resolveFileName</code> 方法。</p><h3 id="返回文件绝对路径-Module-resolveFileName-方法的实现"><a href="#返回文件绝对路径-Module-resolveFileName-方法的实现" class="headerlink" title="返回文件绝对路径 Module._resolveFileName 方法的实现"></a>返回文件绝对路径 Module._resolveFileName 方法的实现</h3><p>这个方法的功能就是将 <code>req</code> 方法的参数根据是否有后缀名两种方式处理成带后缀名的文件绝对路径，如果 <code>req</code> 的参数没有后缀名，会去按照 <code>Module._extensions</code> 的键的后缀名顺序进行查找文件，直到找到后缀名对应文件的绝对路径，优先 <code>.js</code>，然后是 <code>.json</code>，这里我们只实现这两种文件类型的处理。</p><figure class="highlight js"><figcaption><span>处理绝对路径 _resolveFileName 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param &#123;String&#125; moduleId</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Module._resolveFileName = <span class="function"><span class="keyword">function</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将参数拼接成绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> p = path.resolve(moduleId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否含有后缀名</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/\.\w+$/</span>.test(p)) &#123;</span><br><span class="line">    <span class="comment">// 创建规范规定查找文件后缀名顺序的数组 .js .json</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Object</span>.keys(Module._extensions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 将绝对路径与后缀名进行拼接</span></span><br><span class="line">      <span class="keyword">let</span> file = p + arr[i];</span><br><span class="line">      <span class="comment">// 查找不到文件时捕获异常</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 并通过 fs 模块同步查找文件的方法对改路径进行查找</span></span><br><span class="line">        <span class="comment">// 文件未找到会直接进入 catch 语句</span></span><br><span class="line">        fs.accessSync(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到文件将该文件绝对路径返回</span></span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 当后缀名循环完毕都没有找到对应文件时，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= arr.length) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not found module'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有后缀名直接返回该绝对路径</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="加载模块的-load-方法"><a href="#加载模块的-load-方法" class="headerlink" title="加载模块的 load 方法"></a>加载模块的 load 方法</h3><figure class="highlight js"><figcaption><span>完善 req 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param &#123;String&#125; moduleId</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 req 传入的参数处理成绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> p = Module._resolveFileName(moduleId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成一个新的模块</span></span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 下面为新增代码 **********</span></span><br><span class="line">  <span class="comment">// 加载模块</span></span><br><span class="line">  <span class="keyword">let</span> content = <span class="built_in">module</span>.load(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将加载后返回的内容赋值给模块实例的 exports 属性上</span></span><br><span class="line">  <span class="built_in">module</span>.exports = content;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后返回 模块实例的 exports 属性，即加载模块的内容</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  <span class="comment">// ********** 上面为新增代码 **********</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码实现了一个实例方法 <code>load</code>，传入文件的绝对路径，为模块加载文件的内容，在加载后将值存入模块实例的 <code>exports</code> 属性上最后返回，其实 <code>req</code> 函数返回的就是模块加载回来的内容。</p><figure class="highlight js"><figcaption><span>load 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块加载的方法</span></span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">filepath</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断加载的文件是什么后缀名</span></span><br><span class="line">  <span class="keyword">let</span> ext = path.extname(filepath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据不同的后缀名处理文件内容，参数是当前实例</span></span><br><span class="line">  <span class="keyword">let</span> content = Moudule._extensions[ext](<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将处理后的结果返回</span></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现加载-js-文件和-json-文件的方法"><a href="#实现加载-js-文件和-json-文件的方法" class="headerlink" title="实现加载 .js 文件和 .json 文件的方法"></a>实现加载 .js 文件和 .json 文件的方法</h3><p>还记得前面准备的静态属性中有 <code>Module._extensions</code> 就是用来存储这两个方法的，下面我们来完善这两个方法。</p><figure class="highlight js"><figcaption><span>处理后缀名方法的 _extensions 对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">  <span class="string">'.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 js 文件，返回文件的内容</span></span><br><span class="line">    <span class="keyword">let</span> script = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 js 文件的内容增加一个闭包环境</span></span><br><span class="line">    <span class="keyword">let</span> fn = Module.wrap(script);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建虚拟机，将我们创建的 js 函数执行，将 this 指向模块实例的 exports 属性</span></span><br><span class="line">    vm.runInThisContext(fn).call(</span><br><span class="line">      <span class="built_in">module</span>.exports,</span><br><span class="line">      <span class="built_in">module</span>.exports,</span><br><span class="line">      req,</span><br><span class="line">      <span class="built_in">module</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回模块实例上的 exports 属性（即模块的内容）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'.json'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// .json 文件的处理相对简单，将读出的字符串转换成对象即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们这里使用了 <code>Module.wrap</code> 方法，代码如下，其实帮助我们加了一个闭包环境（即套了一层函数并传入了我们需要的参数），里面所有的变量都是私有的。</p><figure class="highlight js"><figcaption><span>创建闭包 wrap 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Module.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Module.wrapper[<span class="number">0</span>] + content + Module.wrapper[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Module.wrapper</code> 的两个值其实就是我们需要在外层包了一个函数的前半段和后半段。</p><blockquote class="pullquote warning"><p><strong>这里我们要划重点了，非常重要：</strong><br>1、我们在虚拟机中执行构建的闭包函数时利用执行上/下文 <code>call</code> 将 <code>this</code> 指向了模块实例的 <code>exports</code> 属性上，所以这也是为什么我们用 Node 启动一个 <code>js</code> 文件，打印 <code>this</code> 时，不是全局对象 <code>global</code>，而是一个空对象，这个空对象就是我们的 <code>module.exports</code>，即当前模块实例的 <code>exports</code> 属性。<br>2、还是第一条的函数执行，我们传入的第一个参数是改变 <code>this</code> 指向，那第二个参数是 <code>module.exports</code>，所以在每个模块导出的时候，使用 <code>module.exports = xxx</code>，其实直接替换了模块实例的值，即直接把模块的内容存放在了模块实例的 <code>exports</code> 属性上，而 <code>req</code> 最后返回的就是我们模块导出的内容。<br>3、第三个参数之所以传入 <code>req</code> 是因为我们还可能在一个模块中导入其他模块，而 <code>req</code> 会返回其他模块的导出在当前模块使用，这样整个 CommonJS 的规则就这样建立起来了。</p></blockquote><h3 id="对加载过的模块进行缓存"><a href="#对加载过的模块进行缓存" class="headerlink" title="对加载过的模块进行缓存"></a>对加载过的模块进行缓存</h3><p>我们现在的程序是有问题的，当重复加载了一个已经加载过得模块，当执行 <code>req</code> 方法的时候会发现，又创建了一个新的模块实例，这是不合理的，所以我们下面来实现一下缓存机制。</p><p>还记得之前的一个静态属性 <code>Module._cacheModule</code>，它的值是一个空对象，我们会把所有加载过的模块的实例存储到这个对象上。</p><figure class="highlight js"><figcaption><span>完善 req 方法（处理缓存）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param &#123;String&#125; moduleId</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 req 传入的参数处理成绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> p = Module._resolveFileName(moduleId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 下面为新增代码 **********</span></span><br><span class="line">  <span class="comment">// 判断是否已经加载过</span></span><br><span class="line">  <span class="keyword">if</span> (Module._cacheModule[p]) &#123;</span><br><span class="line">    <span class="comment">// 模块存在，如果有直接把 exports 对象返回即可</span></span><br><span class="line">    <span class="keyword">return</span> Module._cacheModule[p].exprots;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 上面为新增代码 **********</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成一个新的模块</span></span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载模块</span></span><br><span class="line">  <span class="keyword">let</span> content = <span class="built_in">module</span>.load(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 下面为新增代码 **********</span></span><br><span class="line">  <span class="comment">// 存储时是拿模块的绝对路径作为键与模块内容相对应的</span></span><br><span class="line">  Module._cacheModule[p] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否缓存表示改为 true</span></span><br><span class="line">  <span class="built_in">module</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// ********** 上面为新增代码 **********</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将加载后返回的内容赋值给模块实例的 exports 属性上</span></span><br><span class="line">  <span class="built_in">module</span>.exports = content;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后返回 模块实例的 exports 属性，即加载模块的内容</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="试用-req-加载模块"><a href="#试用-req-加载模块" class="headerlink" title="试用 req 加载模块"></a>试用 req 加载模块</h3><p>在同级目录下新建一个文件 <code>a.js</code>，使用 <code>module.exports</code> 随便导出一些内容，在我们实现模块加载的最下方尝试引入并打印内容。</p><figure class="highlight js"><figcaption><span>导出自定义模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'Hello world'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>检测 req 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = req(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><h2 id="CommonJS-模块查找规范"><a href="#CommonJS-模块查找规范" class="headerlink" title="CommonJS 模块查找规范"></a>CommonJS 模块查找规范</h2><blockquote class="pullquote primary"><p>其实我们只实现了 CommonJS 规范的一部分，即自定义模块的加载，其实在 CommonJS 的规范当中关于模块查找的规则还有很多，具体的我们就用下面的流程图来表示。</p></blockquote><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/06/26/20180626142825/commonjs-arrow.jpg" alt="CommonJS 模块加载流程图" title>                </div>                <div class="image-caption">CommonJS 模块加载流程图</div>            </figure><p><br></p><blockquote class="pullquote success"><p>这篇文章让我们了解了 CommonJS 是什么，主要目的在于理解 Node 模块化的实现思路，想要更深入的了解 CommonJS 的实现细节，建议看一看 NodeJS 源码对应的部分，如果觉得源码比较多，不容易找到模块化实现的代码，也可以在 VSCode 中通过调用 <code>require</code> 方法引入模块时，打断点调试，一步一步的跟进到 Node 源码中查看。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJS </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> CommonJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高阶函数应用 —— 柯里化与反柯里化</title>
      <link href="/2018/06/23/20180623084025/"/>
      <url>/2018/06/23/20180623084025/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/23/20180623084025/curring.png" title="函数柯里化与反柯里化"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>在 JavaScript 中，柯里化和反柯里化是高阶函数的一种应用，在这之前我们应该清楚什么是高阶函数，通俗的说，函数可以作为参数传递到函数中，这个作为参数的函数叫回调函数，而拥有这个参数的函数就是高阶函数，回调函数在高阶函数中调用并传递相应的参数，在高阶函数执行时，由于回调函数的内部逻辑不同，高阶函数的执行结果也不同，非常灵活，也被叫做函数式编程。</p></blockquote><a id="more"></a><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>在 JavaScript 中，函数柯里化是函数式编程的重要思想，也是高阶函数中一个重要的应用，其含义是给函数分步传递参数，每次传递部分参数，并返回一个更具体的函数接收剩下的参数，这中间可嵌套多层这样的接收部分参数的函数，直至返回最后结果。</p><h3 id="最基本的柯里化拆分"><a href="#最基本的柯里化拆分" class="headerlink" title="最基本的柯里化拆分"></a>最基本的柯里化拆分</h3><figure class="highlight js"><figcaption><span>柯里化拆分</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCurrying</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用原函数</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用柯里化函数</span></span><br><span class="line">addCurrying(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>被柯里化的函数 <code>addCurrying</code> 每次的返回值都为一个函数，并使用下一个参数作为形参，直到三个参数都被传入后，返回的最后一个函数内部执行求和操作，其实是充分的利用了闭包的特性来实现的。</p><h3 id="柯里化通用式"><a href="#柯里化通用式" class="headerlink" title="柯里化通用式"></a>柯里化通用式</h3><p>上面的柯里化函数没涉及到高阶函数，也不具备通用性，无法转换形参个数任意或未知的函数，我们接下来封装一个通用的柯里化转换函数，可以将任意函数转换成柯里化。</p><figure class="highlight js"><figcaption><span>柯里化通用式 ES5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">func, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 形参个数</span></span><br><span class="line">  <span class="keyword">var</span> arity = func.length;</span><br><span class="line">  <span class="comment">// 上一次传入的参数</span></span><br><span class="line">  <span class="keyword">var</span> args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数转化为数组</span></span><br><span class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将上次的参数与当前参数进行组合并修正传参顺序</span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.unshift.apply(_args, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果参数不够，返回闭包函数继续收集参数</span></span><br><span class="line">    <span class="keyword">if</span> (_args.length &lt; arity) &#123;</span><br><span class="line">      <span class="keyword">return</span> currying.call(<span class="literal">null</span>, func, _args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数够了则直接执行被转化的函数</span></span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="literal">null</span>, _args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面主要使用的是 ES5 的语法来实现，大量的使用了 <code>call</code> 和 <code>apply</code>，下面我们通过 ES6 的方式实现功能完全相同的柯里化转换通用式。</p><figure class="highlight js"><figcaption><span>柯里化通用式 ES6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">func, args = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arity = func.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">..._args</span>) </span>&#123;</span><br><span class="line">    _args.unshift(...args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_args.length &lt; arity) &#123;</span><br><span class="line">      <span class="keyword">return</span> currying(func, _args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func(..._args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>currying</code> 算是比较高级的转换柯里化的通用式，可以随意拆分参数，假设一个被转换的函数有多个形参，我们可以在任意环节传入任意个数的参数进行拆分，举一个例子，假如 <code>5</code> 个参数，第一次可以传入 <code>2</code> 个，第二次可以传入 <code>1</code> 个, 第三次可以传入剩下的，也有其他的多种传参和拆分方案，因为在 <code>currying</code> 内部收集参数的同时按照被转换函数的形参顺序进行了更正。</p><p>柯里化的一个很大的好处是可以帮助我们基于一个被转换函数，通过对参数的拆分实现不同功能的函数，如下面的例子。</p><figure class="highlight js"><figcaption><span>柯里化通用式应用 —— 普通函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被转换函数，用于检测传入的字符串是否符合正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFun</span>(<span class="params">reg, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> reg.test(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换柯里化</span></span><br><span class="line"><span class="keyword">const</span> check = currying(checkFun);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生新的功能函数</span></span><br><span class="line"><span class="keyword">const</span> checkPhone = check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>);</span><br><span class="line"><span class="keyword">const</span> checkEmail = check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br></pre></td></tr></table></figure><p>上面的例子根据一个被转换的函数通过转换变成柯里化函数，并用 <code>check</code> 变量接收，以后每次调用 <code>check</code> 传递不同的正则就会产生一个检测不同类型字符串的功能函数。</p><p>这种使用方式同样适用于被转换函数是高阶函数的情况，比如下面的例子。</p><figure class="highlight js"><figcaption><span>柯里化通用式应用 —— 高阶函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被转换函数，按照传入的回调函数对传入的数组进行映射</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapFun</span>(<span class="params">func, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.map(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换柯里化</span></span><br><span class="line"><span class="keyword">const</span> getNewArray = currying(mapFun);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生新的功能函数</span></span><br><span class="line"><span class="keyword">const</span> createPercentArr = getNewArray(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;item * <span class="number">100</span>&#125;</span>%`</span>);</span><br><span class="line"><span class="keyword">const</span> createDoubleArr = getNewArray(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新的功能函数</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> percentArr = createPercentArr(arr);</span><br><span class="line"><span class="comment">// ['100%', '200%', '300%', '400%', '500%',]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doubleArr = createDoubleArr(arr);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><h3 id="柯里化与-bind"><a href="#柯里化与-bind" class="headerlink" title="柯里化与 bind"></a>柯里化与 bind</h3><p><code>bind</code> 方法是经常使用的一个方法，它的作用是帮我们将调用 <code>bind</code> 函数内部的上下文对象 <code>this</code> 替换成我们传递的第一个参数，并将后面其他的参数作为调用 <code>bind</code> 函数的参数。</p><figure class="highlight js"><figcaption><span>bind 方法原理模拟</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind 方法的模拟</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(context, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出，其实 <code>bind</code> 方法就是一个柯里化转换函数，将调用 <code>bind</code> 方法的函数进行转换，即通过闭包返回一个柯里化函数，执行该柯里化函数的时候，借用 <code>apply</code> 将调用 <code>bind</code> 的函数的执行上下文转换成了 <code>context</code> 并执行，只是这个转换函数没有那么复杂，没有进行参数拆分，而是函数在调用的时候传入了所有的参数。</p><h2 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h2><p>反柯里化的思想与柯里化正好相反，如果说柯里化的过程是将函数拆分成功能更具体化的函数，那反柯里化的作用则在于扩大函数的适用性，使本来作为特定对象所拥有的功能函数可以被任意对象所使用。</p><h3 id="反柯里化通用式"><a href="#反柯里化通用式" class="headerlink" title="反柯里化通用式"></a>反柯里化通用式</h3><p>反柯里化通用式的参数为一个希望可以被其他对象调用的方法或函数，通过调用通用式返回一个函数，这个函数的第一个参数为要执行方法的对象，后面的参数为执行这个方法时需要传递的参数。</p><figure class="highlight js"><figcaption><span>反柯里化通用式 ES5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uncurring</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 取出要执行 fn 方法的对象，同时从 arguments 中删除</span></span><br><span class="line">    <span class="keyword">var</span> obj = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>反柯里化通用式 ES6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uncurring</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们通过一个例子来感受一下反柯里化的应用。</p><figure class="highlight js"><figcaption><span>反柯里化通用式应用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数 F</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接属性值的方法</span></span><br><span class="line">F.prototype.concatProps = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>[prev]&#125;</span>&amp;<span class="subst">$&#123;<span class="keyword">this</span>[next]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 concatProps 的对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Panda'</span>,</span><br><span class="line">  age: <span class="number">16</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反柯里化进行转化</span></span><br><span class="line"><span class="keyword">const</span> concatProps = uncurring(F.prototype.concatProps);</span><br><span class="line"></span><br><span class="line">concatProps(obj, <span class="string">'name'</span>, <span class="string">'age'</span>); <span class="comment">// Panda&amp;16</span></span><br></pre></td></tr></table></figure><p>反柯里化还有另外一个应用，用来代替直接使用 <code>call</code> 和 <code>apply</code>，比如检测数据类型的 <code>Object.prototype.toString</code> 等方法，以往我们使用时是在这个方法后面直接调用 <code>call</code> 更改上下文并传参，如果项目中多处需要对不同的数据类型进行验证是很麻的，常规的解决方案是封装成一个检测数据类型的模块。</p><figure class="highlight js"><figcaption><span>检测数据类型常规方案</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkType</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要这样封装的功能很多就麻烦了，代码量也会随之增大，其实我们也可以使用另一种解决方案，就是利用反柯里化通用式将这个函数转换并将返回的函数用变量接收，这样我们只需要封装一个 <code>uncurring</code> 通用式就可以了。</p><figure class="highlight js"><figcaption><span>反柯里化创建检测类型函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkType = uncurring(<span class="built_in">Object</span>.prototype.toString);</span><br><span class="line"></span><br><span class="line">checkType(<span class="number">1</span>); <span class="comment">// [object Number]</span></span><br><span class="line">checkType(<span class="string">'hello'</span>); <span class="comment">// [object String]</span></span><br><span class="line">checkType(<span class="literal">true</span>); <span class="comment">// [object Boolean]</span></span><br></pre></td></tr></table></figure><h3 id="通过函数调用生成反柯里化函数"><a href="#通过函数调用生成反柯里化函数" class="headerlink" title="通过函数调用生成反柯里化函数"></a>通过函数调用生成反柯里化函数</h3><p>在 JavaScript 我们经常使用面向对象的编程方式，在两个类或构造函数之间建立联系实现继承，如果我们对继承的需求仅仅是希望一个构造函数的实例能够使用另一个构造函数原型上的方法，那进行繁琐的继承很浪费，简单的继承父子类的关系又不那么的优雅，还不如之间不存在联系。</p><figure class="highlight js"><figcaption><span>将反柯里化方法扩展到函数原型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurring = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的问题通过上面给函数扩展的 <code>uncurring</code> 方法完全得到了解决，比如下面的例子。</p><figure class="highlight js"><figcaption><span>函数应用反柯里化原型方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">F.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"I'm "</span> + <span class="keyword">this</span>.name + <span class="string">", "</span> + <span class="keyword">this</span>.age + <span class="string">" years old."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望 sayHi 方法被任何对象使用</span></span><br><span class="line">sayHi = F.prototype.sayHi.uncurring();</span><br><span class="line"></span><br><span class="line">sayHi(&#123; <span class="attr">name</span>: <span class="string">'Panda'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;); <span class="comment">// I'm Panda, 20 years old.</span></span><br></pre></td></tr></table></figure><p>在 <code>Function</code> 的原型对象上扩展的 <code>uncurring</code> 中，难点是理解 <code>Function.prototype.call.apply</code>，我们知道在 <code>call</code> 的源码逻辑中 <code>this</code> 指的是调用它的函数，在 <code>call</code> 内部用第一个参数替换了这个函数中的 <code>this</code>，其余作为形参执行了函数。</p><p>而在 <code>Function.prototype.call.apply</code> 中 <code>apply</code> 的第一个参数更换了 <code>call</code> 中的 <code>this</code>，这个用于更换 <code>this</code> 的就是例子中调用 <code>uncurring</code> 的方法 <code>F.prototype.sayHi</code>，所以等同于 <code>F.prototype.sayHi.call</code>，<code>arguments</code> 内的参数会传入 <code>call</code> 中，而 <code>arguments</code> 的第一项正是用于修改 <code>F.prototype.sayHi</code> 中 <code>this</code> 的对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>看到这里你应该对柯里化和反柯里化有了一个初步的认识了，但要熟练的运用在开发中，还需要我们更深入的去了解它们内在的含义。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 高阶函数 </tag>
            
            <tag> 柯里化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas + WebSocket + Redis 实现一个视频弹幕</title>
      <link href="/2018/06/21/20180621113025/"/>
      <url>/2018/06/21/20180621113025/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/21/20180621113025/barrage.png" title="弹幕"><p><br></p><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><blockquote class="pullquote info"><p>首先，我们需要实现页面布局，在根目录创建 <code>index.html</code> 布局中我们需要有一个 <code>video</code> 多媒体标签引入我们的本地视频，添加输入弹幕的输入框、确认发送的按钮、颜色选择器、字体大小滑动条，创建一个 <code>style.css</code> 来调整页面布局的样式，这里我们顺便创建一个 <code>index.js</code> 文件用于后续实现我们的核心逻辑，先引入到页面当中。</p></blockquote><a id="more"></a><p><strong>HTML 布局代码如下：</strong></p><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>视频弹幕<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cantainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Canvas + WebSocket + Redis 实现视频弹幕<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">src</span>=<span class="string">"./barrage.mp4"</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入弹幕内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加弹幕按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"add"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 选择文字颜色 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"color"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 调整字体大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">max</span>=<span class="string">"40"</span> <span class="attr">min</span>=<span class="string">"20"</span> <span class="attr">id</span>=<span class="string">"range"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>CSS 样式代码如下：</strong></p><figure class="highlight css"><figcaption><span>文件：style.css</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#cantainer</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">640px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#canvas</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">video</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">640px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">360px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>布局效果如下图：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/06/21/20180621113025/barrage-html.png" alt="弹幕布局" title>                </div>                <div class="image-caption">弹幕布局</div>            </figure><p><br></p><h2 id="定义接口，构造假数据"><a href="#定义接口，构造假数据" class="headerlink" title="定义接口，构造假数据"></a>定义接口，构造假数据</h2><p>我们弹幕中的弹幕数据正常情况下应该是通过与后台数据交互请求回来，所以我们需要先定义数据接口，并构造假数据来实现前端逻辑。</p><p><strong>数据字段定义：</strong></p><ul><li>value：表示弹幕的内容（必填）</li><li>time：表示弹幕出现的时间（必填）</li><li>speed：表示弹幕移动的速度（选填）</li><li>color：表示弹幕文字的颜色（选填）</li><li>fontSize：表示弹幕的字体大小（选填）</li><li>opacity：表示弹幕文字的透明度（选填）</li></ul><p>上面的 <code>value</code> 和 <code>time</code> 是必填参数，其他的选填参数可以在前端设置默认值。</p><p><strong>前端定义的假数据如下：</strong></p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    value: <span class="string">'这是第一条弹幕'</span>,</span><br><span class="line">    speed: <span class="number">2</span>,</span><br><span class="line">    time: <span class="number">0</span>,</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    value: <span class="string">'这是第二条弹幕'</span>,</span><br><span class="line">    time: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="实现前端弹幕的逻辑"><a href="#实现前端弹幕的逻辑" class="headerlink" title="实现前端弹幕的逻辑"></a>实现前端弹幕的逻辑</h2><p>我们希望是把弹幕封装成一个功能，只要有需要的地方就可以使用，从而实现复用，那么不同的地方使用这个功能通常的方式是 <code>new</code> 一个实例，传入当前使用该功能对应的参数，我们也使用这种方式来实现，所以我们需要封装一个统一的构造函数或者类，参数为当前的 <code>canvas</code> 元素、<code>video</code> 元素和一个 <code>options</code> 对象，<code>options</code> 里面的 <code>data</code> 属性为我们的弹幕数据，之所以不直接传入 <code>data</code> 是为了后续参数的扩展，严格遵循开放封闭原则，这里我们就统一使用 ES6 的 <code>class</code> 类来实现。</p><h3 id="创建弹幕功能的类及基本参数处理"><a href="#创建弹幕功能的类及基本参数处理" class="headerlink" title="创建弹幕功能的类及基本参数处理"></a>创建弹幕功能的类及基本参数处理</h3><blockquote class="pullquote warning"><p>布局时需要注意 Canvas 的默认宽为 <code>300px</code>，高为 <code>150px</code>，我们要保证 Canvas 完全覆盖整个视频，需要让 Canvas 与 <code>video</code> 宽高相等。<br>因为我们不确定每一个使用该功能的视频的宽高都是一样的，所以 Canvas 画布的宽高并没有通过 CSS 来设置，而是通过 JS 在类创建实例初始化属性的时候动态设置。</p></blockquote><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasBarrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(canvas, video, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入 canvas 或者 video 直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (!canvas || !video) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.canvas = canvas; <span class="comment">// 当前的 canvas 元素</span></span><br><span class="line">    <span class="keyword">this</span>.video = video; <span class="comment">// 当前的 video 元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 canvas 与 video 等高</span></span><br><span class="line">    <span class="keyword">this</span>.canvas.width = video.clientWidth;</span><br><span class="line">    <span class="keyword">this</span>.canvas.height = video.clientHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认暂停播放，表示不渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.isPaused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没传参数的默认值</span></span><br><span class="line">    <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      color: <span class="string">'gold'</span>,</span><br><span class="line">      speed: <span class="number">2</span>,</span><br><span class="line">      opacity: <span class="number">0.3</span>,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, defaultOptions, options);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该挂在实例上的属性除了有当前的 <code>canvas</code> 元素、<code>video</code> 元素、弹幕数据的默认选项以及弹幕数据之外，还应该有一个代表当前是否渲染弹幕的参数，因为视频暂停的时候，弹幕也是暂停的，所以没有重新渲染，因为是否暂停与弹幕是否渲染的状态是一致的，所以我们这里就用 <code>isPaused</code> 参数来代表当前是否暂停或重新渲染弹幕，值类型为布尔值。</p><h3 id="创建构造每一条弹幕的类"><a href="#创建构造每一条弹幕的类" class="headerlink" title="创建构造每一条弹幕的类"></a>创建构造每一条弹幕的类</h3><p>我们知道，后台返回给我们的弹幕数据是一个数组，这个数组里的每一个弹幕都是一个对象，而对象上有着这条弹幕的信息，如果我们需要在每一个弹幕对象上再加一些新的信息或者在每一个弹幕对象的处理时用到了当前弹幕功能类 <code>CanvasBarrage</code> 实例的一些属性值，取值显然是不太方便的，这样为了后续方便扩展，遵循开放封闭原则，我们把每一个弹幕的对象转变成同一个类的实例，所以我们创建一个名为 <code>Barrage</code> 的类，让我们每一条弹幕的对象进入这个类里面走一遭，挂上一些扩展的属性。</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(item, ctx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = item.value; <span class="comment">// 弹幕的内容</span></span><br><span class="line">    <span class="keyword">this</span>.time = item.time; <span class="comment">// 弹幕出现的时间</span></span><br><span class="line">    <span class="keyword">this</span>.item = item; <span class="comment">// 每一个弹幕的数据对象</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx; <span class="comment">// 弹幕功能类的执行上下文</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的 <code>CanvasBarrage</code> 类上有一个存储弹幕数据的数组 <code>data</code>，此时我们需要给 <code>CanvasBarrage</code> 增加一个属性用来存放 “加工” 后的每条弹幕对应的实例。</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasBarrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(canvas, video, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入 canvas 或者 video 直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (!canvas || !video) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.canvas = canvas; <span class="comment">// 当前的 canvas 元素</span></span><br><span class="line">    <span class="keyword">this</span>.video = video; <span class="comment">// 当前的 video 元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 canvas 与 video 等高</span></span><br><span class="line">    <span class="keyword">this</span>.canvas.width = video.clientWidth;</span><br><span class="line">    <span class="keyword">this</span>.canvas.height = video.clientHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认暂停播放，表示不渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.isPaused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没传参数的默认值</span></span><br><span class="line">    <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      color: <span class="string">'gold'</span>,</span><br><span class="line">      speed: <span class="number">2</span>,</span><br><span class="line">      opacity: <span class="number">0.3</span>,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, defaultOptions, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">    <span class="comment">// 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类</span></span><br><span class="line">    <span class="keyword">this</span>.barrages = <span class="keyword">this</span>.data.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">new</span> Barrage(item, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实通过上面操作以后，我们相当于把 <code>data</code> 里面的每一条弹幕对象转换成了一个 <code>Barrage</code> 类的一个实例，把当前的上下文 <code>this</code> 传入后可以随时在每一个弹幕实例上获取 <code>CanvasBarrage</code> 类实例的属性，也方便我们后续扩展方法，遵循这种开放封闭原则的方式开发，意义是不言而喻的。</p><h3 id="在-CanvasBarrage-类实现渲染所有弹幕的-render-方法"><a href="#在-CanvasBarrage-类实现渲染所有弹幕的-render-方法" class="headerlink" title="在 CanvasBarrage 类实现渲染所有弹幕的 render 方法"></a>在 CanvasBarrage 类实现渲染所有弹幕的 render 方法</h3><p><code>CanvasBarrage</code> 的 <code>render</code> 方法是在创建弹幕功能实例的时候应该渲染 Canvas 所以应该在 <code>CanvasBarrage</code> 中调用，在 <code>render</code> 内部，每一次渲染之前都应该先将 Canvas 画布清空，所以需要给当前的 <code>CanvasBarrage</code> 类新增一个属性用于存储 Canvas 画布的内容。</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasBarrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(canvas, video, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入 canvas 或者 video 直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (!canvas || !video) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.canvas = canvas; <span class="comment">// 当前的 canvas 元素</span></span><br><span class="line">    <span class="keyword">this</span>.video = video; <span class="comment">// 当前的 video 元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 canvas 与 video 等高</span></span><br><span class="line">    <span class="keyword">this</span>.canvas.width = video.clientWidth;</span><br><span class="line">    <span class="keyword">this</span>.canvas.height = video.clientHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认暂停播放，表示不渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.isPaused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没传参数的默认值</span></span><br><span class="line">    <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      color: <span class="string">'gold'</span>,</span><br><span class="line">      speed: <span class="number">2</span>,</span><br><span class="line">      opacity: <span class="number">0.3</span>,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, defaultOptions, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类</span></span><br><span class="line">    <span class="keyword">this</span>.barrages = <span class="keyword">this</span>.data.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">new</span> Barrage(item, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">    <span class="comment">// Canvas 画布的内容</span></span><br><span class="line">    <span class="keyword">this</span>.context = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染所有的弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">    <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 渲染整个弹幕</span></span><br><span class="line">    <span class="comment">// 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染</span></span><br><span class="line">    <span class="keyword">this</span>.context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.height);</span><br><span class="line">    <span class="comment">// 渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.renderBarrage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPaused == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归渲染</span></span><br><span class="line">      requestAnimationFrame(<span class="keyword">this</span>.render.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的 <code>CanvasBarrage</code> 的 <code>render</code> 函数中，清空时由于 Canvas 性能比较好，所以将整个画布清空，所以从坐标 <code>(0, 0)</code> 点，清空的宽高为整个 Canvas 画布的宽高。</p><p>只要视频是在播放状态应该不断的调用 <code>render</code> 方法实现清空画布、渲染弹幕、判断是否暂停，如果非暂停状态继续渲染，所以我们用到了递归调用 <code>render</code> 去不断的实现渲染，但是递归时如果直接调用 <code>render</code>，性能特别差，程序甚至会挂掉，以往这种情况我们会在递归外层加一个 <code>setTimeout</code> 来定义一个短暂的递归时间，但是这个过程类似于动画效果，如果使用 <code>setTimeout</code> 其实是将同步代码转成了异步执行，会增加不确定性导致画面出现卡顿的现象。</p><p>这里我们使用 H5 的新 API <code>requestAnimationFrame</code>，可以在平均 <code>1/60 S</code> 内帮我执行一次该方法传入的回调，我们直接把 <code>render</code> 函数作为回调函数传入 <code>requestAnimationFrame</code>，该方法是按照帧的方式执行，动画流畅，需要注意的是，<code>render</code> 函数内使用了 <code>this</code>，所以应该处理一下 <code>this</code> 指向问题。</p><p>由于我们使用面向对象的方式，所以渲染弹幕的具体细节，我们抽离出一个单独的方法 <code>renderBarrage</code>，接下来看一下 <code>renderBarrage</code> 的实现。</p><h3 id="CanvasBarrage-类-render-内部-renderBarrage-的实现"><a href="#CanvasBarrage-类-render-内部-renderBarrage-的实现" class="headerlink" title="CanvasBarrage 类 render 内部 renderBarrage 的实现"></a>CanvasBarrage 类 render 内部 renderBarrage 的实现</h3><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasBarrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(canvas, video, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入 canvas 或者 video 直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (!canvas || !video) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.canvas = canvas; <span class="comment">// 当前的 canvas 元素</span></span><br><span class="line">    <span class="keyword">this</span>.video = video; <span class="comment">// 当前的 video 元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 canvas 与 video 等高</span></span><br><span class="line">    <span class="keyword">this</span>.canvas.width = video.clientWidth;</span><br><span class="line">    <span class="keyword">this</span>.canvas.height = video.clientHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认暂停播放，表示不渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.isPaused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没传参数的默认值</span></span><br><span class="line">    <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      color: <span class="string">'gold'</span>,</span><br><span class="line">      speed: <span class="number">2</span>,</span><br><span class="line">      opacity: <span class="number">0.3</span>,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, defaultOptions, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类</span></span><br><span class="line">    <span class="keyword">this</span>.barrages = <span class="keyword">this</span>.data.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">new</span> Barrage(item, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canvas 画布的内容</span></span><br><span class="line">    <span class="keyword">this</span>.context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染所有的弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 渲染整个弹幕</span></span><br><span class="line">    <span class="comment">// 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染</span></span><br><span class="line">    <span class="keyword">this</span>.context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.height);</span><br><span class="line">    <span class="comment">// 渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.renderBarrage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPaused == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归渲染</span></span><br><span class="line">      requestAnimationFrame(<span class="keyword">this</span>.render.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  renderBarrage() &#123;</span><br><span class="line">    <span class="comment">// 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕</span></span><br><span class="line">    <span class="keyword">let</span> time = <span class="keyword">this</span>.video.currentTime;</span><br><span class="line">    <span class="keyword">this</span>.barrages.forEach(<span class="function"><span class="params">barrage</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位）</span></span><br><span class="line">      <span class="keyword">if</span> (time &gt;= barrage.time) &#123;</span><br><span class="line">        <span class="comment">// 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化</span></span><br><span class="line">        <span class="comment">// 节省性能，初始化后再进行绘制</span></span><br><span class="line">        <span class="comment">// 如果没有初始化，先去初始化一下</span></span><br><span class="line">        <span class="keyword">if</span> (!barrage.isInited) &#123;</span><br><span class="line">          <span class="comment">// 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited</span></span><br><span class="line">          barrage.init();</span><br><span class="line">          barrage.isInited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 <code>renderBarrage</code> 方法内部主要对每一条弹幕实例所设置的出现时间和视频的播放时间做对比，如果视频的播放时间大于等于了弹幕出现的时间，说明弹幕需要绘制在 Canvas 画布内。</p><p>之前我们的每一条弹幕实例的属性可能不全，弹幕的其他未传参数并没有初始化，所以为了最大限度的节省性能，我们在弹幕该第一次绘制的时候去初始化参数，等到视频播放的时间变化再去重新绘制时，不再初始化参数，所以初始化参数的方法放在了判断弹幕出现时间的条件里面执行，又设置了代表弹幕实例是不是初始化了的参数 <code>isInited</code>，初始化函数 <code>init</code> 执行过一次后，马上修改 <code>isInited</code> 的值，保证只初始化参数一次。</p><p>在 <code>renderBarrage</code> 方法中我们可以看出来，其实我们是循环了专门存放每一条弹幕实例（<code>Barrage</code> 类的实例）的数组，我们在内部用实例去调用的方法 <code>init</code> 应该是在 <code>Barrage</code> 类的原型上，下面我们去 <code>Barrage</code> 类上实现 <code>init</code> 的逻辑。</p><h3 id="Barrage-类-init-的实现"><a href="#Barrage-类-init-的实现" class="headerlink" title="Barrage 类 init 的实现"></a>Barrage 类 init 的实现</h3><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(item, ctx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = item.value; <span class="comment">// 弹幕的内容</span></span><br><span class="line">    <span class="keyword">this</span>.time = item.time; <span class="comment">// 弹幕出现的时间</span></span><br><span class="line">    <span class="keyword">this</span>.item = item; <span class="comment">// 每一个弹幕的数据对象</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx; <span class="comment">// 弹幕功能类的执行上下文</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.opacity = <span class="keyword">this</span>.item.opacity || <span class="keyword">this</span>.ctx.opacity;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="keyword">this</span>.item.color || <span class="keyword">this</span>.ctx.color;</span><br><span class="line">    <span class="keyword">this</span>.fontSize = <span class="keyword">this</span>.item.fontSize || <span class="keyword">this</span>.ctx.fontSize;</span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="keyword">this</span>.item.speed || <span class="keyword">this</span>.ctx.speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求自己的宽度，目的是用来校验当前是否还要继续绘制（边界判断）</span></span><br><span class="line">    <span class="keyword">let</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能决定宽度的只有弹幕的内容和文字的大小，和字体</span></span><br><span class="line">    <span class="comment">// 字体默认为微软雅黑，我们就不做设置了</span></span><br><span class="line">    span.innerText = <span class="keyword">this</span>.value;</span><br><span class="line">    span.style.font = <span class="keyword">this</span>.fontSize + <span class="string">'px "Microsoft YaHei"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// span 为行内元素，取不到宽度，所以我们通过定位给转换成块级元素</span></span><br><span class="line">    span.style.position = <span class="string">'absolute'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(span); <span class="comment">// 放入页面</span></span><br><span class="line">    <span class="keyword">this</span>.width = span.clientWidth; <span class="comment">// 记录弹幕的宽度</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(span); <span class="comment">// 从页面移除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储弹幕出现的横纵坐标</span></span><br><span class="line">    <span class="keyword">this</span>.x = <span class="keyword">this</span>.ctx.canvas.width;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="keyword">this</span>.ctx.canvas.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理弹幕纵向溢出的边界处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.y &lt; <span class="keyword">this</span>.fontSize) &#123;</span><br><span class="line">      <span class="keyword">this</span>.y = <span class="keyword">this</span>.fontSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.y &gt; <span class="keyword">this</span>.ctx.canvas.height - <span class="keyword">this</span>.fontSize) &#123;</span><br><span class="line">      <span class="keyword">this</span>.y = <span class="keyword">this</span>.ctx.canvas.height - <span class="keyword">this</span>.fontSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码的 <code>init</code> 方法中我们其实可以看出，每条弹幕实例初始化的时候初始的信息除了之前说的弹幕的基本参数外，还获取了每条弹幕的宽度（用于后续做弹幕是否已经完全移出屏幕的边界判断）和每一条弹幕的 <code>x</code> 和 <code>y</code> 轴方向的坐标并为了防止弹幕在 <code>y</code> 轴显示不全做了边界处理。</p><h3 id="实现每条弹幕的渲染和弹幕移除屏幕的处理"><a href="#实现每条弹幕的渲染和弹幕移除屏幕的处理" class="headerlink" title="实现每条弹幕的渲染和弹幕移除屏幕的处理"></a>实现每条弹幕的渲染和弹幕移除屏幕的处理</h3><p>我们当时在 <code>CanvasBarrage</code> 类的 <code>render</code> 方法中的渲染每个弹幕的方法 <code>renderBarrage</code>中（原谅这么啰嗦，因为到现在内容已经比较多，说的具体一点方便知道是哪个步骤，哈哈）只做了对每一条弹幕实例的初始化操作，并没有渲染在 Canvas 画布中，这时我们主要做两部操作，实现每条弹幕渲染在画布中和左侧移出屏幕不再渲染的边界处理。</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasBarrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(canvas, video, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入 canvas 或者 video 直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (!canvas || !video) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.canvas = canvas; <span class="comment">// 当前的 canvas 元素</span></span><br><span class="line">    <span class="keyword">this</span>.video = video; <span class="comment">// 当前的 video 元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 canvas 与 video 等高</span></span><br><span class="line">    <span class="keyword">this</span>.canvas.width = video.clientWidth;</span><br><span class="line">    <span class="keyword">this</span>.canvas.height = video.clientHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认暂停播放，表示不渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.isPaused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没传参数的默认值</span></span><br><span class="line">    <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      color: <span class="string">'gold'</span>,</span><br><span class="line">      speed: <span class="number">2</span>,</span><br><span class="line">      opacity: <span class="number">0.3</span>,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, defaultOptions, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类</span></span><br><span class="line">    <span class="keyword">this</span>.barrages = <span class="keyword">this</span>.data.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">new</span> Barrage(item, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canvas 画布的内容</span></span><br><span class="line">    <span class="keyword">this</span>.context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染所有的弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 渲染整个弹幕</span></span><br><span class="line">    <span class="comment">// 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染</span></span><br><span class="line">    <span class="keyword">this</span>.context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.height);</span><br><span class="line">    <span class="comment">// 渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.renderBarrage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPaused == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归渲染</span></span><br><span class="line">      requestAnimationFrame(<span class="keyword">this</span>.render.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  renderBarrage() &#123;</span><br><span class="line">    <span class="comment">// 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕</span></span><br><span class="line">    <span class="keyword">let</span> time = <span class="keyword">this</span>.video.currentTime;</span><br><span class="line">    <span class="keyword">this</span>.barrages.forEach(<span class="function"><span class="params">barrage</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ********** 以下为改动的代码 **********</span></span><br><span class="line">      <span class="comment">// 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位）</span></span><br><span class="line">      <span class="keyword">if</span> (!barrage.flag &amp;&amp; time &gt;= barrage.time) &#123;</span><br><span class="line">        <span class="comment">// ********** 以上为改动的代码 **********</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化</span></span><br><span class="line">        <span class="comment">// 节省性能，初始化后再进行绘制</span></span><br><span class="line">        <span class="comment">// 如果没有初始化，先去初始化一下</span></span><br><span class="line">        <span class="keyword">if</span> (!barrage.isInited) &#123;</span><br><span class="line">          <span class="comment">// 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited</span></span><br><span class="line">          barrage.init();</span><br><span class="line">          barrage.isInited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">        barrage.x -= barrage.speed;</span><br><span class="line">        barrage.render(); <span class="comment">// 渲染该条弹幕</span></span><br><span class="line">        <span class="keyword">if</span> (barrage.x &lt; barrage.width * <span class="number">-1</span>) &#123;</span><br><span class="line">          barrage.flag = <span class="literal">true</span>; <span class="comment">// 是否出去了，出去了，做停止渲染的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个弹幕实例都有一个 <code>speed</code> 属性，该属性代表着弹幕移动的速度，换个说法其实就是每次减少的 <code>x</code> 轴的差值，所以我们其实是通过改变 <code>x</code> 轴的值再重新渲染而实现弹幕的左移，我们创建了一个标识 <code>flag</code> 挂在每个弹幕实例下，代表是否已经离开屏幕，如果离开则更改 <code>flag</code> 的值，使外层的 <code>CanvasBarrage</code> 类的 <code>render</code> 函数再次递归时不进入渲染程序。</p><p>每一条弹幕具体是怎么渲染的，通过代码可以看出每个弹幕实例在 <code>x</code> 坐标改变后都调用了实例方法 <code>render</code> 函数，注意此 <code>render</code> 非彼 <code>render</code>，该 <code>render</code> 函数属于 <code>Barrage</code> 类，目的是为了渲染每一条弹幕，而 <code>CanvasBarrage</code> 类下的 <code>render</code>，是为了在视频时间变化时清空并重新渲染整个 Canvas 画布。</p><h3 id="Barrage-类下的-render-方法的实现"><a href="#Barrage-类下的-render-方法的实现" class="headerlink" title="Barrage 类下的 render 方法的实现"></a>Barrage 类下的 render 方法的实现</h3><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(item, ctx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = item.value; <span class="comment">// 弹幕的内容</span></span><br><span class="line">    <span class="keyword">this</span>.time = item.time; <span class="comment">// 弹幕出现的时间</span></span><br><span class="line">    <span class="keyword">this</span>.item = item; <span class="comment">// 每一个弹幕的数据对象</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx; <span class="comment">// 弹幕功能类的执行上下文</span></span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.opacity = <span class="keyword">this</span>.item.opacity || <span class="keyword">this</span>.ctx.opacity;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="keyword">this</span>.item.color || <span class="keyword">this</span>.ctx.color;</span><br><span class="line">    <span class="keyword">this</span>.fontSize = <span class="keyword">this</span>.item.fontSize || <span class="keyword">this</span>.ctx.fontSize;</span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="keyword">this</span>.item.speed || <span class="keyword">this</span>.ctx.speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求自己的宽度，目的是用来校验当前是否还要继续绘制（边界判断）</span></span><br><span class="line">    <span class="keyword">let</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能决定宽度的只有弹幕的内容和文字的大小，和字体</span></span><br><span class="line">    <span class="comment">// 字体默认为微软雅黑，我们就不做设置了</span></span><br><span class="line">    span.innerText = <span class="keyword">this</span>.value;</span><br><span class="line">    span.style.font = <span class="keyword">this</span>.fontSize + <span class="string">'px "Microsoft YaHei'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// span 为行内元素，取不到宽度，所以我们通过定位给转换成块级元素</span></span><br><span class="line">    span.style.position = <span class="string">'absolute'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(span); <span class="comment">// 放入页面</span></span><br><span class="line">    <span class="keyword">this</span>.width = span.clientWidth; <span class="comment">// 记录弹幕的宽度</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(span); <span class="comment">// 从页面移除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储弹幕出现的横纵坐标</span></span><br><span class="line">    <span class="keyword">this</span>.x = <span class="keyword">this</span>.ctx.canvas.width;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="keyword">this</span>.ctx.canvas.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理弹幕纵向溢出的边界处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.y &lt; <span class="keyword">this</span>.fontSize) &#123;</span><br><span class="line">      <span class="keyword">this</span>.y = <span class="keyword">this</span>.fontSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.y &gt; <span class="keyword">this</span>.ctx.canvas.height - <span class="keyword">this</span>.fontSize) &#123;</span><br><span class="line">      <span class="keyword">this</span>.y = <span class="keyword">this</span>.ctx.canvas.height - <span class="keyword">this</span>.fontSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx.context.font = <span class="keyword">this</span>.fontSize + <span class="string">'px "Microsoft YaHei"'</span>;</span><br><span class="line">    <span class="keyword">this</span>.ctx.context.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">    <span class="keyword">this</span>.ctx.context.fillText(<span class="keyword">this</span>.value, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面新增代码我们可以看出，其实 <code>Barrage</code> 类的 <code>render</code> 方法只是将每一条弹幕的字号、颜色、内容、坐标等属性通过 Canvas 的 API 添加到了画布上。</p><h3 id="实现播放、暂停事件"><a href="#实现播放、暂停事件" class="headerlink" title="实现播放、暂停事件"></a>实现播放、暂停事件</h3><p>还记得我们的 <code>CanvasBarrage</code> 类里面有一个属性 <code>isPaused</code>，属性值控制了我们是否递归渲染，这个属性与视频暂停的状态是一致的，我们在播放的时候，弹幕不断的清空并重新绘制，当暂停的时候弹幕也应该跟着暂停，说白了就是不在调用 <code>CanvasBarrage</code> 类的 <code>render</code> 方法，其实就是在暂停、播放的过程中不断的改变 <code>isPaused</code> 的值即可。</p><p>还记得我们之前构造的两条假数据 <code>data</code> 吧，接下来我们添加播放、暂停事件，来尝试使用一下我们的弹幕功能。</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个简易选择器，方便获取元素，后面获取元素直接调用 $</span></span><br><span class="line"><span class="keyword">const</span> $ = <span class="built_in">document</span>.querySelector.bind(<span class="built_in">document</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Canvas 元素和 Video 元素</span></span><br><span class="line"><span class="keyword">const</span> canvas = $(<span class="string">'#canvas'</span>);</span><br><span class="line"><span class="keyword">const</span> video = $(<span class="string">'#video'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canvasBarrage = <span class="keyword">new</span> CanvasBarrage(canvas, video, &#123;</span><br><span class="line">  data</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加播放事件</span></span><br><span class="line">video.addEventListener(<span class="string">'play'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  canvasBarrage.isPaused = <span class="literal">false</span>;</span><br><span class="line">  canvasBarrage.render();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加暂停事件</span></span><br><span class="line">video.addEventListener(<span class="string">'pause'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  canvasBarrage.isPaused = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现发送弹幕事件"><a href="#实现发送弹幕事件" class="headerlink" title="实现发送弹幕事件"></a>实现发送弹幕事件</h3><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#add'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time = video.currentTime; <span class="comment">// 发送弹幕的时间</span></span><br><span class="line">  <span class="keyword">let</span> value = $(<span class="string">'#text'</span>).value; <span class="comment">// 发送弹幕的文字</span></span><br><span class="line">  <span class="keyword">let</span> color = $(<span class="string">'#color'</span>).value; <span class="comment">// 发送弹幕文字的颜色</span></span><br><span class="line">  <span class="keyword">let</span> fontSize = $(<span class="string">'#range'</span>).value; <span class="comment">// 发送弹幕的字体大小</span></span><br><span class="line">  <span class="keyword">let</span> sendObj = &#123; time, value, color, fontSize &#125;; <span class="comment">//发送弹幕的参数集合</span></span><br><span class="line">  canvasBarrage.add(sendObj); <span class="comment">// 发送弹幕的方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实我们发送弹幕时，就是向 <code>CanvasBarrage</code> 类的 <code>barrages</code> 数组里添加了一条弹幕的实例，我们单独封装了一个 <code>add</code> 的实例方法。</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasBarrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(canvas, video, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入 canvas 或者 video 直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (!canvas || !video) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.canvas = canvas; <span class="comment">// 当前的 canvas 元素</span></span><br><span class="line">    <span class="keyword">this</span>.video = video; <span class="comment">// 当前的 video 元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 canvas 与 video 等高</span></span><br><span class="line">    <span class="keyword">this</span>.canvas.width = video.clientWidth;</span><br><span class="line">    <span class="keyword">this</span>.canvas.height = video.clientHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认暂停播放，表示不渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.isPaused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没传参数的默认值</span></span><br><span class="line">    <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      color: <span class="string">'gold'</span>,</span><br><span class="line">      speed: <span class="number">2</span>,</span><br><span class="line">      opacity: <span class="number">0.3</span>,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, defaultOptions, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类</span></span><br><span class="line">    <span class="keyword">this</span>.barrages = <span class="keyword">this</span>.data.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">new</span> Barrage(item, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canvas 画布的内容</span></span><br><span class="line">    <span class="keyword">this</span>.context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染所有的弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 渲染整个弹幕</span></span><br><span class="line">    <span class="comment">// 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染</span></span><br><span class="line">    <span class="keyword">this</span>.context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.height);</span><br><span class="line">    <span class="comment">// 渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.renderBarrage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPaused == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归渲染</span></span><br><span class="line">      requestAnimationFrame(<span class="keyword">this</span>.render.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  renderBarrage() &#123;</span><br><span class="line">    <span class="comment">// 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕</span></span><br><span class="line">    <span class="keyword">let</span> time = <span class="keyword">this</span>.video.currentTime;</span><br><span class="line">    <span class="keyword">this</span>.barrages.forEach(<span class="function"><span class="params">barrage</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位）</span></span><br><span class="line">    <span class="keyword">if</span> (!barrage.flag &amp;&amp; time &gt;= barrage.time) &#123;</span><br><span class="line">        <span class="comment">// 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化</span></span><br><span class="line">        <span class="comment">// 节省性能，初始化后再进行绘制</span></span><br><span class="line">        <span class="comment">// 如果没有初始化，先去初始化一下</span></span><br><span class="line">        <span class="keyword">if</span> (!barrage.isInited) &#123;</span><br><span class="line">          <span class="comment">// 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited</span></span><br><span class="line">          barrage.init();</span><br><span class="line">          barrage.isInited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        barrage.x -= barrage.speed;</span><br><span class="line">        barrage.render(); <span class="comment">// 渲染该条弹幕</span></span><br><span class="line">        <span class="keyword">if</span> (barrage.x &lt; barrage.width * <span class="number">-1</span>) &#123;</span><br><span class="line">          barrage.flag = <span class="literal">true</span>; <span class="comment">// 是否出去了，出去了，做停止渲染的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.barrages.push(<span class="keyword">new</span> Barrage(item, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拖动进度条实现弹幕的前进和后退"><a href="#拖动进度条实现弹幕的前进和后退" class="headerlink" title="拖动进度条实现弹幕的前进和后退"></a>拖动进度条实现弹幕的前进和后退</h3><p>其实我们发现，弹幕虽然实现了正常的播放、暂停以及发送，但是当我们拖动进度条的时候弹幕应该是跟着视频时间同步播放的，现在的弹幕一旦播放过无论怎样拉动进度条弹幕都不会再出现，我们现在就来解决这个问题。</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拖动进度条事件</span></span><br><span class="line">video.addEventListener(<span class="string">'seeked'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  canvasBarrage.reset();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们在事件内部其实只是调用了一下 <code>CanvasBarrage</code> 类的 <code>reset</code> 方法，这个方法就是在拖动进度条的时候来帮我们初始化弹幕的状态。</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasBarrage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(canvas, video, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入 canvas 或者 video 直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (!canvas || !video) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.canvas = canvas; <span class="comment">// 当前的 canvas 元素</span></span><br><span class="line">    <span class="keyword">this</span>.video = video; <span class="comment">// 当前的 video 元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 canvas 与 video 等高</span></span><br><span class="line">    <span class="keyword">this</span>.canvas.width = video.clientWidth;</span><br><span class="line">    <span class="keyword">this</span>.canvas.height = video.clientHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认暂停播放，表示不渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.isPaused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没传参数的默认值</span></span><br><span class="line">    <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      color: <span class="string">'gold'</span>,</span><br><span class="line">      speed: <span class="number">2</span>,</span><br><span class="line">      opacity: <span class="number">0.3</span>,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, defaultOptions, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类</span></span><br><span class="line">    <span class="keyword">this</span>.barrages = <span class="keyword">this</span>.data.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">new</span> Barrage(item, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canvas 画布的内容</span></span><br><span class="line">    <span class="keyword">this</span>.context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染所有的弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 渲染整个弹幕</span></span><br><span class="line">    <span class="comment">// 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染</span></span><br><span class="line">    <span class="keyword">this</span>.context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.height);</span><br><span class="line">    <span class="comment">// 渲染弹幕</span></span><br><span class="line">    <span class="keyword">this</span>.renderBarrage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPaused == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归渲染</span></span><br><span class="line">      requestAnimationFrame(<span class="keyword">this</span>.render.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  renderBarrage() &#123;</span><br><span class="line">    <span class="comment">// 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕</span></span><br><span class="line">    <span class="keyword">let</span> time = <span class="keyword">this</span>.video.currentTime;</span><br><span class="line">    <span class="keyword">this</span>.barrages.forEach(<span class="function"><span class="params">barrage</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位）</span></span><br><span class="line">      <span class="keyword">if</span> (!barrage.flag &amp;&amp; time &gt;= barrage.time) &#123;</span><br><span class="line">        <span class="comment">// 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化</span></span><br><span class="line">        <span class="comment">// 节省性能，初始化后再进行绘制</span></span><br><span class="line">        <span class="comment">// 如果没有初始化，先去初始化一下</span></span><br><span class="line">        <span class="keyword">if</span> (!barrage.isInited) &#123;</span><br><span class="line">          <span class="comment">// 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited</span></span><br><span class="line">          barrage.init();</span><br><span class="line">          barrage.isInited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        barrage.x -= barrage.speed;</span><br><span class="line">        barrage.render(); <span class="comment">// 渲染该条弹幕</span></span><br><span class="line">        <span class="keyword">if</span> (barrage.x &lt; barrage.width * <span class="number">-1</span>) &#123;</span><br><span class="line">          barrage.flag = <span class="literal">true</span>; <span class="comment">// 是否出去了，出去了，做停止渲染的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.barrages.push(<span class="keyword">new</span> Barrage(item, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  reset() &#123;</span><br><span class="line">    <span class="comment">// 先清空 Canvas 画布</span></span><br><span class="line">    <span class="keyword">this</span>.context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.height);</span><br><span class="line">    <span class="keyword">let</span> time = <span class="keyword">this</span>.video.currentTime;</span><br><span class="line">    <span class="comment">// 循环每一条弹幕实例</span></span><br><span class="line">    <span class="keyword">this</span>.barrages.forEach(<span class="function"><span class="params">barrage</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 更改已经移出屏幕的弹幕状态</span></span><br><span class="line">      barrage.flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// 当拖动到的时间小于等于当前弹幕时间是，重新初始化弹幕的数据，实现渲染</span></span><br><span class="line">      <span class="keyword">if</span> (time &lt;= barrage.time) &#123;</span><br><span class="line">        barrage.isInited = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        barrage.flag = <span class="literal">true</span>; <span class="comment">// 否则将弹幕的状态设置为以移出屏幕</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>reset</code> 方法中值做了几件事：</p><ul><li>清空 Canvas 画布；</li><li>获取当前进度条拖动位置的时间；</li><li>循环存储弹幕实例的数组；</li><li>将所有弹幕更改为未移出屏幕；</li><li>判断拖动时间和每条弹幕的时间；</li><li>在当前时间以后的弹幕重新初始化数据；</li><li>以前的弹幕更改为已移出屏幕。</li></ul><p>从而实现了拖动进度条弹幕的 “前进” 和 “后退” 功能。</p><h2 id="使用-WebSocket-和-Redis-实现前后端通信及数据存储"><a href="#使用-WebSocket-和-Redis-实现前后端通信及数据存储" class="headerlink" title="使用 WebSocket 和 Redis 实现前后端通信及数据存储"></a>使用 WebSocket 和 Redis 实现前后端通信及数据存储</h2><h3 id="服务器代码的实现"><a href="#服务器代码的实现" class="headerlink" title="服务器代码的实现"></a>服务器代码的实现</h3><p>要使用 WebSocket 和 Redis 首先需要去安装 <code>ws</code>、<code>redis</code> 依赖，在项目根目录执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ws redis</span><br></pre></td></tr></table></figure><p>我们创建一个 <code>server.js</code> 文件，用来写服务端的代码：</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>); <span class="comment">// 引入 WebSocket</span></span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>); <span class="comment">// 引入 redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 WebSocket 服务器，端口号为 3000</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;</span><br><span class="line">  port: <span class="number">3000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 redis 客户端</span></span><br><span class="line"><span class="keyword">const</span> client = redis.createClient(); <span class="comment">// key value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生的 websocket 就两个常用的方法 on('message')、on('send')</span></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听连接</span></span><br><span class="line">  <span class="comment">// 连接上需要立即把 redis 数据库的数据取出返回给前端</span></span><br><span class="line">  client.lrange(<span class="string">'barrages'</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, applies</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 由于 redis 的数据都是字符串，所以需要把数组中每一项转成对象</span></span><br><span class="line">    applies = applies.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">JSON</span>.parse(item));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 websocket 服务器将 redis 数据库的数据发送给前端</span></span><br><span class="line">    <span class="comment">// 构建一个对象，加入 type 属性告诉前端当前返回数据的行为，并将数据转换成字符串</span></span><br><span class="line">    ws.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      type: <span class="string">'INIT'</span>,</span><br><span class="line">      data: applies</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当服务器收到消息时，将数据存入 redis 数据库</span></span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向数据库存储时存的是字符串，存入并打印数据，用来判断是否成功存入数据库</span></span><br><span class="line">    client.rpush(<span class="string">'barrages'</span>, data, redis.print);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再将当前这条数据返回给前端</span></span><br><span class="line">    <span class="comment">// 同样添加 type 字段告诉前端当前行为，并将数据转换成字符串</span></span><br><span class="line">    ws.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      type: <span class="string">'ADD'</span>,</span><br><span class="line">      data: <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>服务器的逻辑很清晰，在 WebSocket 连接上时，立即获取 Redis 数据库的所有弹幕数据返回给前端，当前端点击发送弹幕按钮发送数据时，接收数据存入 Redis 数据库中并打印验证数据是否成功存入，再通过 WebSocket 服务把当前这一条数返回给前端，需要注意一下几点：</p><ul><li>从 Redis 数据库中取出全部弹幕数据的数组内部都存储的是字符串，需要使用 <code>JSON.parse</code> 方法进行解析；</li><li>将数据发送前端时，最外层要使用 <code>JSON.stringify</code> 重新转换成字符串发送；</li><li>在初始化阶段 WebSocket 发送所有数据和前端添加新弹幕 WebSocket 将弹幕的单条数据重新返回时，需要添加对应的 <code>type</code> 值告诉前端，当前的操作行为。</li></ul><h3 id="前端代码的修改"><a href="#前端代码的修改" class="headerlink" title="前端代码的修改"></a>前端代码的修改</h3><p>在没有实现后端代码之前，前端使用的是 <code>data</code> 的假数据，是在添加弹幕事件中，将获取的新增弹幕信息通过 <code>CanvasBarrage</code> 类的 <code>add</code> 方法直接创建 <code>Barrage</code> 类的实例，并加入到存放弹幕实例的 <code>barrages</code> 数组中。</p><p>现在我们需要更正一下交互逻辑，在发送弹幕事件触发时，我们应该先将获取的单条弹幕数据通过 WebSocket 发送给后端服务器，在服务器重新将消息返还给我们的时候，去将这条数据通过 <code>CanvasBarrage</code> 类的 <code>add</code> 方法加入到存放弹幕实例的 <code>barrages</code> 数组中。</p><p>还有在页面初始化时，我们之前在创建 <code>CanvasBarrage</code> 类实例的时候直接传入了 <code>data</code> 假数据，现在需要通过 WebSocket 的连接事件，在监听到连接 WebSocket 服务时，去创建 <code>CanvasBarrage</code> 类的实例，并直接把服务端返回 Redis 数据库真实的数据作为参数传入，前端代码修改如下：</p><figure class="highlight js"><figcaption><span>文件：index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ********** 下面代码被删掉了 **********</span></span><br><span class="line"><span class="comment">// let canvasBarrage = new CanvasBarrage(canvas, video, &#123;</span></span><br><span class="line"><span class="comment">//     data</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// ********** 上面代码被删掉了 **********</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line"><span class="keyword">let</span> canvasBarrage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 WebSocket 连接</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接事件</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听消息</span></span><br><span class="line">  socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将收到的消息从字符串转换成对象</span></span><br><span class="line">    <span class="keyword">let</span> message = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同情况判断是初始化还是发送弹幕</span></span><br><span class="line">    <span class="keyword">if</span> (message.type === <span class="string">'INIT'</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 CanvasBarrage 的实例添加弹幕功能，传入真实的数据</span></span><br><span class="line">      canvasBarrage = <span class="keyword">new</span> CanvasBarrage(canvas, video, &#123;</span><br><span class="line">        data: message.data</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.type === <span class="string">'ADD'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是添加弹幕直接将 WebSocket 返回的单条弹幕存入 barrages 中</span></span><br><span class="line">      canvasBarrage.add(message.data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'#add'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time = video.currentTime; <span class="comment">// 发送弹幕的时间</span></span><br><span class="line">  <span class="keyword">let</span> value = $(<span class="string">'#text'</span>).value; <span class="comment">// 发送弹幕的文字</span></span><br><span class="line">  <span class="keyword">let</span> color = $(<span class="string">'#color'</span>).value; <span class="comment">// 发送弹幕文字的颜色</span></span><br><span class="line">  <span class="keyword">let</span> fontSize = $(<span class="string">'#range'</span>).value; <span class="comment">// 发送弹幕的字体大小</span></span><br><span class="line">  <span class="keyword">let</span> sendObj = &#123; time, value, color, fontSize &#125;; <span class="comment">//发送弹幕的参数集合</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  socket.send(<span class="built_in">JSON</span>.stringify(sendObj));</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 下面代码被删掉了 **********</span></span><br><span class="line">  <span class="comment">// canvasBarrage.add(sendObj); // 发送弹幕的方法</span></span><br><span class="line">  <span class="comment">// ********** 上面代码被删掉了 **********</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在我们可以打开 <code>index.html</code> 文件并启动 <code>server.js</code> 服务器，就可以实现真实的视频弹幕操作了，但是我们还是差了最后一步，当前的服务只能同时服务一个人，但真实的场景是同时看视频的有很多人，而且发送的弹幕是共享的。</p><h3 id="实现多端通信、弹幕共享"><a href="#实现多端通信、弹幕共享" class="headerlink" title="实现多端通信、弹幕共享"></a>实现多端通信、弹幕共享</h3><p>我们需要处理两件事情：</p><ul><li>第一件事情是实现多端通信共享数据库信息；</li><li>第二件事情是当有人离开的时候清除关闭的 WebSocket 对象。</li></ul><figure class="highlight js"><figcaption><span>文件：server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>); <span class="comment">// 引入 WebSocket</span></span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>); <span class="comment">// 引入 redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 WebSocket 服务器，端口号为 3000</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;</span><br><span class="line">    port: <span class="number">3000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 redis 客户端</span></span><br><span class="line"><span class="keyword">const</span> client = redis.createClient(); <span class="comment">// key value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line"><span class="comment">// 存储所有 WebSocket 用户</span></span><br><span class="line"><span class="keyword">const</span> clientsArr = [];</span><br><span class="line"><span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生的 websocket 就两个常用的方法 on('message')、on('send')</span></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  <span class="comment">// 将所有通过 WebSocket 连接的用户存入数组中</span></span><br><span class="line">  clientsArr.push(ws);</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听连接</span></span><br><span class="line">  <span class="comment">// 连接上需要立即把 redis 数据库的数据取出返回给前端</span></span><br><span class="line">  client.lrange(<span class="string">'barrages'</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, applies</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 由于 redis 的数据都是字符串，所以需要把数组中每一项转成对象</span></span><br><span class="line">    applies = applies.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">JSON</span>.parse(item));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 websocket 服务器将 redis 数据库的数据发送给前端</span></span><br><span class="line">    <span class="comment">// 构建一个对象，加入 type 属性告诉前端当前返回数据的行为，并将数据转换成字符串</span></span><br><span class="line">    ws.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      type: <span class="string">'INIT'</span>,</span><br><span class="line">      data: applies</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当服务器收到消息时，将数据存入 redis 数据库</span></span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向数据库存储时存的是字符串，存入并打印数据，用来判断是否成功存入数据库</span></span><br><span class="line">    client.rpush(<span class="string">'barrages'</span>, data, redis.print);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ********** 以下为修改后的代码 **********</span></span><br><span class="line">    <span class="comment">// 循环数组，将某一个人新发送的弹幕在存储到 Redis 之后返回给所有用户</span></span><br><span class="line">    clientsArr.forEach(<span class="function"><span class="params">w</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 再将当前这条数据返回给前端</span></span><br><span class="line">      <span class="comment">// 同样添加 type 字段告诉前端当前行为，并将数据转换成字符串</span></span><br><span class="line">      w.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        type: <span class="string">'ADD'</span>,</span><br><span class="line">        data: <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ********** 以上为修改后的代码 **********</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  <span class="comment">// 监听关闭连接事件</span></span><br><span class="line">  ws.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当某一个人关闭连接离开时，将这个人从当前存储用户的数组中移除</span></span><br><span class="line">    clientsArr = clientsArr.filter(<span class="function"><span class="params">client</span> =&gt;</span> client != ws);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>上面就是 Canvas + WebSocket + Redis 视频弹幕的实现，实现过程可能有些复杂，但整个过程写的还是比较详细，可能需要一定的耐心慢慢的读完，并最好一步一步跟着写一写，希望这篇文章可以让读到的人解决视频弹幕类似的需求，真正理解整个过程和开放封闭原则，认识到前端面向对象编程思想的美。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> Canvas </tag>
            
            <tag> WebSocket </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步发展流程 —— 异步编程的终极大招 async/await</title>
      <link href="/2018/06/15/20180615212040/"/>
      <url>/2018/06/15/20180615212040/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/15/20180615212040/async-await.jpg" title="async/await"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这篇文章是异步发展流程系列的最后一篇，可能会涉及 Promise、Generators、co 等前置知识，如果对这些不是很了解可以看这个系列的前三篇：</p><ul><li><a href="https://www.overtaking.top/2018/06/12/20180612045005/" target="_blank">异步发展流程 —— Promise 的基本使用</a></li><li><a href="https://www.overtaking.top/2018/06/13/20180613193626/" target="_blank">异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise</a></li><li><a href="https://www.overtaking.top/2018/06/14/20180614161413/" target="_blank">异步发展流程 —— Generators + co 让异步更优雅</a></li></ul><p>如果已经具备这些前置知识，那我们继续看看今天的主角，JavaScript 异步编程的终极大招 <code>async/await</code>。</p></blockquote><a id="more"></a><h2 id="async-await-简介"><a href="#async-await-简介" class="headerlink" title="async/await 简介"></a>async/await 简介</h2><blockquote class="pullquote danger"><p><code>async/await</code> 指的是两个关键字，是 ES7 引入的新标准，<code>async</code> 关键字用于声明 <code>async</code> 函数，<code>await</code> 关键字用来等待异步（必须是 Promise）操作，说白了 <code>async/await</code> 就是 Generators + co 的语法糖。</p></blockquote><p><code>async/await</code> 和 Generators + co 的写法非常的相似，只是把用于声明 Generator 函数的 <code>*</code> 关键字替换成了 <code>async</code> 并写在了 <code>function</code> 关键字的前面，把 <code>yield</code> 关键字替换成了 <code>await</code>；另外，<code>async</code> 函数是基于 Promise 的，<code>await</code> 关键字后面等待的异步操作必须是一个 Promise 实例，当然也可以是原始类型的值，只不过这时的执行效果等同于同步，与 Generator 不同的是，<code>await</code> 关键字前可以使用变量去接收这个正在等待的 Promise 实例执行后的结果。</p><h2 id="async-函数的基本用法"><a href="#async-函数的基本用法" class="headerlink" title="async 函数的基本用法"></a>async 函数的基本用法</h2><blockquote class="pullquote info"><p><code>async</code> 函数返回一个 Promise 实例，可以使用 <code>then</code> 方法添加回调函数。当函数执行的时候，只要遇到 <code>await</code> 就会等待，直到 <code>await</code> 后面的同步或异步操作完成，再接着执行函数体内后面的语句。</p></blockquote><h3 id="async-函数声明"><a href="#async-函数声明" class="headerlink" title="async 函数声明"></a>async 函数声明</h3><p><code>async</code> 的声明方式大概有以下几种：</p><figure class="highlight js"><figcaption><span>async 函数声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象的方法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">async</span> fn() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> getName() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="keyword">await</span> <span class="keyword">this</span>.name;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一篇介绍 Generators + co 的文章中我们举了一个例子，使用 NodeJS 的 <code>fs</code> 模块连续异步读文件，第一个文件名为 <code>a.txt</code>，读到的内容为 <code>b.txt</code>，作为要读的第二个文件的文件名，继续读 <code>b.txt</code> 后将读到的内容 “Hello world” 打印出来。</p><p>我们来使用 <code>async/await</code> 的方式来实现一下：</p><figure class="highlight js"><figcaption><span>async 函数实现文件读取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 fs.readFile 转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> readFile = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> aData = <span class="keyword">await</span> readFile(file, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">let</span> bData = <span class="keyword">await</span> readFile(aData, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">return</span> bData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 async 函数</span></span><br><span class="line">read(<span class="string">'a.txt'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实对比上一篇文章 Generator 的案例，与 Generator 函数一样，写法像同步，执行是异步，不同的是我们即没有手动调用 <code>next</code> 方法，也没有借助 <code>co</code> 库，其实是 <code>async</code> 函数内部集成了类似于 <code>co</code> 的执行器，帮我们在异步完成后自动向下执行代码，所以说 <code>async/await</code> 是 Generators + co 的语法糖。</p><h3 id="async-函数错误处理"><a href="#async-函数错误处理" class="headerlink" title="async 函数错误处理"></a>async 函数错误处理</h3><p><code>async</code> 函数内部如果执行错误可以有三种方式进行错误处理：</p><ul><li>在 <code>await</code> 后面的 Promise 实例使用 <code>then</code> 方法错误的回调或 <code>catch</code> 方法进行错误处理；</li><li>如果有多个 <code>await</code>，可以在 <code>async</code> 函数执行完后使用 <code>catch</code> 方法统一处理；</li><li>由于 <code>async</code> 内部代码是同步的写法，多个 <code>await</code> 的情况也可以使用 <code>try...catch...</code> 进行处理。</li></ul><p>需要注意的是，如果在 <code>async</code> 函数内部使用了 <code>try...catch...</code> 又在函数执行完后使用了 <code>catch</code>，错误会优先被同步的 <code>try...catch...</code> 捕获到，后面的 <code>catch</code> 就不会再捕获了。</p><figure class="highlight js"><figcaption><span>async 函数异常捕获</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>);</span><br><span class="line">    <span class="keyword">let</span> val2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> val1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">  <span class="keyword">let</span> val2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().catch((<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="await-异步并发"><a href="#await-异步并发" class="headerlink" title="await 异步并发"></a>await 异步并发</h3><p>在 <code>async</code> 函数中，如果有多个 <code>await</code> 互不依赖，这种情况下如果执行一个，等待一个完成，再执行一个，再等待完成，这样是很浪费性能的，所以我们要把这些异步操作同时触发。</p><p>假设我们异步读取两个文件，且这两个文件不相关，我可以使用下面的方式来实现：</p><figure class="highlight js"><figcaption><span>await 异步并发</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要改进的 async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> aData = <span class="keyword">await</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">let</span> bData = <span class="keyword">await</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">return</span> [aData, bData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 async 函数外部触发异步</span></span><br><span class="line"><span class="keyword">let</span> aDataPromise = readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">let</span> bDataPromise = readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> aData = <span class="keyword">await</span> aDataPromise;</span><br><span class="line">  <span class="keyword">let</span> bData = <span class="keyword">await</span> bDataPromise;</span><br><span class="line">  <span class="keyword">return</span> [aData, bData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise.all</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dataArr = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>),</span><br><span class="line">    readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> dataArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h3 id="使用-async-await-的注意点"><a href="#使用-async-await-的注意点" class="headerlink" title="使用 async/await 的注意点"></a>使用 async/await 的注意点</h3><p>使用 <code>async/await</code> 应注意以下几点：</p><ul><li>对 <code>await</code> 习惯性错误处理；</li><li><code>await</code> 命令后互不依赖的异步应同时触发；</li><li><code>async</code> 函数中，函数的执行上/下文发生变化时，不能使用 <code>await</code>（如使用 <code>forEach</code> 循环的回调中）。</li></ul><p>针对第一点，在 <code>async</code> 函数中 <code>await</code> 命令后面大多情况下是 Promise 异步操作，运行结果可能出现错误并调用 <code>reject</code> 函数，最好对这个 <code>await</code> 语句进行错误处理，具体方式参照 <code>async</code> 函数基本用法中关于错误处理的内容。</p><p>针对第二点，如果两个或多个 <code>await</code> 命令后的异步操作没有依赖关系，执行时，需先触发第一个，等待异步完成，再触发第二个，再等异步完成，依次类推，这样比较耗时，性能不好，所以应该将这些异步操作同时触发，触发方式参照 <code>async</code> 函数基本用法中的 <code>await</code> 异步并发的内容。</p><p>针对第三点，如果声明一个 <code>async</code> 函数并传入一个数组，数组里面存储的都是 Promise 实例，若使用 <code>forEach</code> 循环数组，由于函数的执行上/下文发生了变化，此时使用 <code>await</code> 命令会报错。</p><figure class="highlight js"><figcaption><span>循环内使用 await</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Promise 实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">'p1 success'</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">'p2 success'</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">'p3 success'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  promise.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> promise;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn([p1, p2, p3]); <span class="comment">// 执行时报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改方式</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> pormises[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn([p1, p2, p3]); <span class="comment">// 正常执行</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>async/await</code> 的实现原理，其实就是在 <code>async</code> 函数内部逻辑映射成了 Generator 函数并集成了一个类似于 <code>co</code> 的执行器，所以我们使用 <code>async/await</code> 的时候，代码更简洁，没有了自己触发遍历器的 <code>next</code> 或调用 <code>co</code> 充当执行器的过程，只需要关心 <code>async</code> 函数的内部逻辑就可以了，因为写法与同步相同，更提高了代码的可读性，所以说 <code>async/await</code> 是异步编程的终极大招。</p><blockquote class="pullquote warning"><p>由于 <code>async/await</code> 是 ES7 规范，在浏览器端的支持并不是那么的友好，所以现在这种写法多用在 NodeJS 的异步操作当中，在 NodeJS 框架 <code>Koa 2.x</code> 版本得到广泛应用。</p></blockquote><blockquote class="pullquote success"><p>最后希望大家在读过异步发展流程这个系列之后，对 JavaScript 异步已经有了较深的认识，并可以在不同情况下游刃有余的使用这些处理异步的编程手段。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 异步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJS </tag>
            
            <tag> 异步 </tag>
            
            <tag> Promise </tag>
            
            <tag> ES7 </tag>
            
            <tag> async/await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步发展流程 —— Generators + co 让异步更优雅</title>
      <link href="/2018/06/14/20180614161413/"/>
      <url>/2018/06/14/20180614161413/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/14/20180614161413/generators.png" title="Generators + Co"><p><br></p><h2 id="Generators-简介"><a href="#Generators-简介" class="headerlink" title="Generators 简介"></a>Generators 简介</h2><blockquote class="pullquote warning"><p>Generator 函数是 ES6 提供的一种异步编程解决方案，是一个生成器，用于生成一个遍历器的函数，语法行为与传统函数完全不同。</p></blockquote><a id="more"></a><h2 id="Iterator-遍历器"><a href="#Iterator-遍历器" class="headerlink" title="Iterator 遍历器"></a>Iterator 遍历器</h2><p>JavaScript 原有的表示 “集合” 的数据结构，主要有 <code>Array</code> 和 <code>Object</code>，在 ES6 中又加入了 <code>Set</code> 和 <code>Map</code>，这样就有了四种数据集合，还可以组合使用它们，如数组的成员是 <code>Map</code> 或 <code>Object</code>，这样就需要一种统一的接口机制，用来处理所有不同的数据结构。</p><p>遍历器 Iterator 就是这样一种机制，它是一种接口，为不同的数据结构提供统一的、简便的访问机制，任何数据结构只要部署了 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员。</p><p>Iterator 遍历器其实就是一个指针对象，上面有 <code>next</code> 方法，第一次调用 <code>next</code> 指针指向数据结构的第一个成员，第二次 <code>next</code> 调用指针指向第二个成员，直到指针指向最后一个成员。</p><p>我们可以使用 ES6 的展开运算符 <code>...</code> 和 <code>for...of...</code> 去遍历带有 Iterator 接口的数据结构，需要注意的是，<code>Object</code> 本身不具备 Iterator 接口，所以我们无法通过 <code>...</code> 把一个对象扩展到一个数组中，并且会报错，我们可以通过代码手动将 <code>Object</code> 类型实现 Iterator 接口。</p><figure class="highlight js"><figcaption><span>给对象扩展 Iterator 接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 Generator 函数给 Object 扩展 Iterator 接口</span></span><br><span class="line"><span class="built_in">Object</span>.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 Iterator 接口</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...obj];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面我们其实是通过 ES6 的 Generator 函数简单粗暴的给 <code>Object</code> 类型实现了 Iterator 接口，后面我们会简单模拟 Generator 生成器。</p><h2 id="模拟-Generator"><a href="#模拟-Generator" class="headerlink" title="模拟 Generator"></a>模拟 Generator</h2><p>Generator 函数是一个生成器，调用后会返回给我们一个 Iterator 遍历器对象，在对象中有一个 <code>next</code> 方法，调用一次 <code>next</code>，帮我遍历一次，返回值为一个对象，内部有 <code>value</code> 和 <code>done</code> 两个属性，<code>value</code> 属性代表当前遍历的值，<code>done</code> 属性代表是否遍历完成，如果遍历完成后继续调用 <code>next</code>，返回的对象中 <code>value</code> 属性值为 <code>undefined</code>，<code>done</code> 属性值为 <code>true</code>，这个遍历器在进行数据遍历时更像给我们提供了一个暂停功能，每次都需要手动调用 <code>next</code> 去进行下一次遍历。</p><p>我们根据 Generator 的特性用 ES5 简单模拟一个遍历器生成函数：</p><figure class="highlight js"><figcaption><span>模拟遍历器生成函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> done = i &gt;= arr.length;</span><br><span class="line">      <span class="keyword">var</span> value = !done ? arr[i++] : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: value,</span><br><span class="line">        done: done</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下模拟的遍历器生成函数：</p><figure class="highlight js"><figcaption><span>测试 iterator 函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历器</span></span><br><span class="line"><span class="keyword">var</span> result = iterator(arr);</span><br><span class="line"></span><br><span class="line">result.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">result.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">result.next(); <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line">result.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Generator-的基本使用"><a href="#Generator-的基本使用" class="headerlink" title="Generator 的基本使用"></a>Generator 的基本使用</h2><p>在普通的函数 <code>function</code> 关键字后加一个 <code>*</code> 就代表声明了一个生成器函数，执行后返回一个遍历器对象，每次调用遍历器的 <code>next</code> 方法时，遇到 <code>yield</code> 关键字暂停执行，并将 <code>yield</code> 关键字后面的值会作为返回对象中 <code>value</code> 的值，如果函数有返回值，会把返回值作为调用 <code>next</code> 方法进行遍历完成后返回的对象中 <code>value</code> 的值，果已经遍历完成，再次 <code>next</code> 调用这个 <code>value</code> 的值会变成 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历器</span></span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 3, done: true&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>在 Generator 函数中可以使用变量接收 <code>yield</code> 关键字执行后的返回值，只是接收的值并不是 <code>yield</code> 关键字后面表达式执行的结果，而是遍历器在下一次调用 <code>next</code> 方法时传入的参数。</p></blockquote><p>也就是说我们第一次调用 <code>next</code> 方法进行遍历时是不需要传递参数的，因为上面并没有变量来接收它，即使传参也会被忽略掉，我们用一个例子感受一下这种比较特殊的执行机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a;</span><br><span class="line">  <span class="keyword">let</span> c = <span class="keyword">yield</span> b;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历器</span></span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">2</span>); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">3</span>); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">4</span>); <span class="comment">// &#123;value: 4, done: true&#125;</span></span><br><span class="line">it.next(<span class="number">5</span>); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>如果已经遍历完成，并把上次遍历接收到的值作为返回值传递给返回对象 <code>value</code> 属性的值，后面再次调用 <code>next</code> 传入的参数也会被忽略，返回对象的 <code>value</code> 值为 <code>undefined</code>。</p><blockquote class="pullquote warning"><p>在 Generator 函数中，如果在其他函数或方法调用的回调内部（函数的执行上/下文发生变化）不能直接使用 <code>yield</code> 关键字。</p></blockquote><figure class="highlight js"><figcaption><span>循环中使用 yield</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.forEach(*<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>* item;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在一个 Generator 函数中调用了另一个 Generator 函数，在调用外层函数返回遍历器的 <code>next</code> 方法时是不会遍历内部函数返回的遍历器的。</p><figure class="highlight js"><figcaption><span>合并生成器 —— 错误</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层的生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genOut</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> genIn();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'c'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内层的生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genIn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历器</span></span><br><span class="line"><span class="keyword">const</span> it = genOut();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// 返回 genIn 的遍历器对象</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'c', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码如果想在调用 <code>genOut</code> 返遍历器的 <code>next</code> 方法时，同时遍历 <code>genIn</code> 调用后返回的遍历器，需要使用 <code>yield*</code> 表达式。</p><figure class="highlight js"><figcaption><span>合并生成器 —— yield*</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层的生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genOut</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* genIn();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'c'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内层的生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genIn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历器</span></span><br><span class="line"><span class="keyword">const</span> it = genOut();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'c', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>genOut</code> 返回的遍历器调用 <code>next</code> 遇到 <code>yield*</code> 表达式时帮我们去遍历了 <code>genIn</code> 返回的遍历器，其实 <code>yield*</code> 内部做了处理，等同于下面代码：</p><figure class="highlight js"><figcaption><span>合并生成器 —— for of</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层的生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genOut</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> genIn()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'c'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内层的生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genIn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历器</span></span><br><span class="line"><span class="keyword">const</span> it = genOut();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'c', done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Generators-与-Promise-结合"><a href="#Generators-与-Promise-结合" class="headerlink" title="Generators 与 Promise 结合"></a>Generators 与 Promise 结合</h2><blockquote class="pullquote primary"><p>Promise 也是 ES6 的规范，同样是解决异步的一种手段，如果对 Promise 还不了解，可以阅读下面两篇文章：</p><ul><li><a href="https://www.overtaking.top/2018/06/12/20180612045005/" target="_blank">异步发展流程 —— Promise 的基本使用</a></li><li><a href="https://www.overtaking.top/2018/06/13/20180613193626/" target="_blank">异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise</a></li></ul></blockquote><p>因为 Generator 函数在执行时遇到 <code>yield</code> 关键字会暂停执行，那么 <code>yield</code> 后面可以是异步操作的代码，比如 Promise，需要继续执行，就手动调用返回遍历器的 <code>next</code> 方法，因为中间有一个等待的过程，所以在执行异步代码的时候避免了回调函数的嵌套，在写法上更像同步，更容易理解。</p><p>我们来设计一个 Generator 函数与 Promise 异步操作结合的使用场景，假设我们需要使用 NodeJS 的 <code>fs</code> 模块读取一个文件 <code>a.txt</code> 的内容，而 <code>a.txt</code> 的内容是另一个需要读取文件 <code>b.txt</code> 的文件名，读取 <code>b.txt</code> 最后打印读取到的内容 “Hello world”。</p><p>回调函数的实现：</p><figure class="highlight js"><figcaption><span>连续读取文件 —— 异步回调</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    fs.readFile(data, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码因为只有两层回调函数嵌套，所以感觉没那么复杂，但是嵌套的回调函数多了，代码就不那么的优雅了，我们接下来使用 Generator 结合 Promise 来实现，为了方便将 <code>fs</code> 异步的方法转换成 Promise，我们引入 <code>util</code> 模块，并转换 <code>readFile</code> 方法。</p><figure class="highlight js"><figcaption><span>连续读取文件 —— Generator + Promise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 readFile 方法转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> aData = <span class="keyword">yield</span> read(<span class="string">'1.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">let</span> bData = <span class="keyword">yield</span> read(aData, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">return</span> bData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历器</span></span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"></span><br><span class="line">it.next().value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  it.next(data).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们只看 Generator 函数 <code>gen</code> 内部的执行，虽然是异步操作，但是在写法上几乎和同步没有区别，理解起来更容易，唯一美中不足的是，我们需要自己手动的调用遍历器的 <code>next</code> 和 Promise 实例的 <code>then</code>，这个问题 <code>co</code> 库可以帮我们解决。</p><h2 id="co-库的使用"><a href="#co-库的使用" class="headerlink" title="co 库的使用"></a>co 库的使用</h2><blockquote class="pullquote info"><p>co 库的作者是著名的 NodeJS 大神 TJ，是基于 Generator 和 Promise 的，这个库能帮我们实现自动调用 Generator 函数返回遍历器的 <code>next</code> 方法，并执行 <code>yield</code> 后面 Promise 实例的 <code>then</code> 方法，所以每次 <code>yield</code> 后面的异步操作返回的必须是一个 Promise 实例，代码看起来像同步，执行其实是异步，不用自己手动进行下一次遍历，这更是我们想要的。</p></blockquote><p>由于 co 是一个第三方的模块，所以在使用时需要我们提前下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install co</span><br></pre></td></tr></table></figure><p>我们使用 <code>co</code> 来实现之前异步连续读文件的案例：</p><figure class="highlight js"><figcaption><span>连续读取文件 —— Generator + co</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 readFile 方法转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> aData = <span class="keyword">yield</span> read(<span class="string">'1.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">let</span> bData = <span class="keyword">yield</span> read(aData, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">return</span> bData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 co 库代替手动调用 next</span></span><br><span class="line">co(gen()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<code>co</code> 库的 <code>co</code> 函数参数是一个遍历器，即 Generator 函数执行后的返回结果，在 <code>co</code> 内部操作遍历器并遍历完成后返回了一个 Promise 实例，遍历器最终的返回结果的 <code>value</code> 值作为 <code>then</code> 方法回调的参数，所以我们可以使用 <code>then</code> 对结果进行后续的处理。</p><h2 id="co-库的实现原理"><a href="#co-库的实现原理" class="headerlink" title="co 库的实现原理"></a>co 库的实现原理</h2><p>我们其实在上面使用 <code>co</code> 的过程中对于 <code>co</code> 函数的内部做了什么已经有所了解，主要就是帮助我们调用遍历器的 <code>next</code> 和调用 <code>yield</code> 后面代码执行后返回 Promise 实例的 <code>then</code>，并在整个遍历结束后，返回一个新的 Promise 实例。</p><p>下面我们根据上面分析的 <code>co</code> 函数的原理来模拟一个简易版的 <code>co</code> 库：</p><figure class="highlight js"><figcaption><span>文件：myCo.js —— co 原理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// co 函数，it 为遍历器对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">it</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回 Promise 实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步递归</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 第一次调用 next 不需要传参</span></span><br><span class="line">      <span class="keyword">let</span> &#123; value, done &#125; = it.next(data);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="comment">// 如果没完成遍历，调用返回 Promise 的 then 方法</span></span><br><span class="line">        value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果 Promise 成功，继续递归，如果失败直接执行 reject</span></span><br><span class="line">          next(data);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果遍历完成直接执行 resolve 并传入 value</span></span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = co;</span><br></pre></td></tr></table></figure><p>验证 <code>myCo.js</code> 实现的 <code>co</code> 函数：</p><figure class="highlight js"><figcaption><span>验证 myCo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> myCo = <span class="built_in">require</span>(<span class="string">'./myCo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 readFile 方法转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> aData = <span class="keyword">yield</span> read(<span class="string">'1.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">let</span> bData = <span class="keyword">yield</span> read(aData, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">return</span> bData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 co 库代替手动调用 next</span></span><br><span class="line">myCo(gen()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们将引入的 <code>co</code> 库替换成了自己实现的简易版 <code>myCo</code> 模块，上面读取文件的案例依然生效，这说明我们模拟的 <code>co</code> 库核心逻辑是没问题的，跟原版不同的是并没有处理很多细节，并定义指针，如果对 <code>co</code> 库感兴趣建议看看 TJ 大神的源码，整个库写的非常精简，值得学习。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>Generators 相当于把一个函数拆分成若干个部分执行，执行一次时将指针指向下一段要执行的代码，直到结束位置，Generators 配合 <code>co</code> 库的使用场景多在 NodeJS 当中，并在 <code>Koa 1.x</code> 版本中居多，现在已经升级到 <code>Koa 2.x</code> 版本，使用更多的是基于 Generators 和 <code>co</code> 库衍生出来的 ES7 新标准 <code>async/await</code>，我们在下一篇异步发展流程系列的文章中来详细介绍。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 异步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJS </tag>
            
            <tag> ES6 </tag>
            
            <tag> 异步 </tag>
            
            <tag> Promise </tag>
            
            <tag> Generators </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise</title>
      <link href="/2018/06/13/20180613193626/"/>
      <url>/2018/06/13/20180613193626/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/13/20180613193626/promise-A+.png" title="Promise 原理"><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote class="pullquote default"><p>Promise 是 js 异步编程的一种解决方案，避免了 “回调地狱” 给编程带来的麻烦，在 ES6 中成为了标准，这篇文章重点不是叙述 Promise 的基本用法，而是从零开始，手写一版符合 Promise/A+ 规范的 Promise，如果想了解更多 Promise 的基本用法，可以看 <a href="https://www.overtaking.top/2018/06/12/20180612045005/" target="_blank">异步发展流程 —— Promise 的基本使用</a> 这篇文章。</p></blockquote><h2 id="Promise-构造函数的实现"><a href="#Promise-构造函数的实现" class="headerlink" title="Promise 构造函数的实现"></a>Promise 构造函数的实现</h2><p>我们在使用 Promise 的时候其实是使用 <code>new</code> 关键字创建了一个 Promise 的实例，其实 Promise 是一个类，即构造函数，下面来实现 Promise 构造函数。</p><a id="more"></a><blockquote class="pullquote info"><p>Promise/A+ 规范的内容比较多，详情查看 <a><a href="https://promisesaplus.com/" target="_blank" rel="noopener">https://promisesaplus.com/</a></a>，我们在实现 Promise 逻辑时会根据实现的部分介绍相关的 Promise/A+ 规范内容。</p></blockquote><p><strong>在 Promise/A+ 规范中规定:</strong></p><ul><li>构造函数的参数为一个名为 <code>executor</code> 的执行器，即函数，在创建实例时该函数内部逻辑为同步，即立即执行；</li><li><code>executor</code> 执行时的参数分别为 <code>resolve</code> 和 <code>reject</code>，一个为成功时执行的函数，一个为失败时执行的函数；</li><li>在 <code>executor</code> 执行时，一旦出现错误立即调用 <code>reject</code> 函数，并设置错误信息给 <code>reason</code> 属性；</li><li>每个 Promise 实例有三个状态 <code>pending</code>、<code>fulfilled</code> 和 <code>rejected</code>，默认状态为 <code>pending</code>；</li><li>状态只能从 <code>pending</code> 到 <code>fulfilled</code> 或从 <code>pending</code> 到 <code>rejected</code>，不可逆；</li><li>执行 <code>resolve</code> 函数会使状态从 <code>pending</code> 变化到 <code>fulfilled</code> 并将参数存入实例的 <code>value</code> 属性中；</li><li>执行 <code>reject</code> 函数会使状态从 <code>pending</code> 变化到 <code>rejected</code> 并将错误信息存入实例的 <code>reason</code> 属性中。</li></ul><p><strong>针对上面的 Promise/A+ 规范，Promise 构造函数代码实现如下：</strong></p><figure class="highlight js"><figcaption><span>promise.js -- Promise 构造函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.status = <span class="string">'pending'</span>; <span class="comment">// 当前 Promise 实例的状态</span></span><br><span class="line">  self.value = <span class="literal">undefined</span>; <span class="comment">// 当前 Promise 实例成功状态下的值</span></span><br><span class="line">  self.reason = <span class="literal">undefined</span>; <span class="comment">// 当前 Promise 实例失败状态的错误信息</span></span><br><span class="line">  self.onFulfilledCallbacks = []; <span class="comment">// 存储成功的回调函数的数组</span></span><br><span class="line">  self.onRejectedCallbacks = []; <span class="comment">// 存储失败的回调函数的数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成功的执行的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理 executor 执行时，调用 resolve 将一个新的 Promise 实例作为结果返回</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.status = <span class="string">'fulfilled'</span>;</span><br><span class="line">      self.value = value;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 每次调用 resolve 时</span></span><br><span class="line">      <span class="comment">// 执行 onFulfilledCallbacks 内部存储的所有的函数</span></span><br><span class="line">      <span class="comment">// 在实现 then 方法中详细说明</span></span><br><span class="line">      self.onFulfilledCallbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 失败执行的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      self.reason = reason;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 每次调用 reject 时</span></span><br><span class="line">      <span class="comment">// 执行 onRejectedCallbacks 内部存储的所有的函数</span></span><br><span class="line">      <span class="comment">// 在实现 then 方法中详细说明</span></span><br><span class="line">      self.onRejectedCallbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用执行器函数</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 如果执行器执行时出现错误，直接调用失败的函数</span></span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将自己的 Promise 导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure><p>上面构造函数中的 <code>resolve</code> 和 <code>reject</code> 方法在执行的时候都进行了当前状态的判断，只有状态为 <code>pending</code> 时，才能执行判断内部逻辑，当两个函数有一个执行后，此时状态发生变化，再执行另一个函数时就不会通过判断条件，即不会执行判断内部的逻辑，从而实现了两个函数只有一个执行判断内部逻辑的效果，使用如下：</p><figure class="highlight js"><figcaption><span>verify-promise.js -- 验证 promise.js 的代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入自己的 Promise 模块</span></span><br><span class="line"><span class="comment">// 因为都验证代码都写在 verify-promise.js 文件中，后面就不再引入了</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'./promise.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...同步代码</span></span><br><span class="line">  resolve();</span><br><span class="line">  reject();</span><br><span class="line">  <span class="comment">// 上面两个函数只有先执行的 resolve 生效</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="实例方法的实现"><a href="#实例方法的实现" class="headerlink" title="实例方法的实现"></a>实例方法的实现</h2><h3 id="then-方法的实现"><a href="#then-方法的实现" class="headerlink" title="then 方法的实现"></a>then 方法的实现</h3><p>没有 Promise 之前在一个异步操作的回调函数中返回一个结果在输入给下一个异步操作，下一个异步操作结束后需要继续执行回调，就形成回调函数的嵌套，在 Promise 中，原来回调函数中的逻辑只需要调用当前 Promise 实例的 <code>then</code> 方法，并在 <code>then</code> 方法的回调中执行，改变了原本异步的书写方式。</p><p><strong>在 then 方法中涉及到的 Promise/A+ 规范：</strong></p><ul><li>Promise 实例的 <code>then</code> 方法中有两个参数，都为函数，第一个参数为成功的回调 <code>onFulfilled</code>，第二个参数为失败的回调 <code>onRejected</code>；</li><li>当 Promise 内部执行 <code>resolve</code> 时，调用实例的 <code>then</code> 方法执行成功的回调 <code>onFulfilled</code>，当 Promise 内部执行 <code>reject</code> 或执行出错时，调用实例的 <code>then</code> 方法执行错误的回调 <code>onRejected</code>；</li><li><code>then</code> 方法需要支持异步，即如果 <code>resovle</code> 或 <code>reject</code> 执行为异步时，<code>then</code> 方法的回调 <code>onFulfilled</code> 或 <code>onRejected</code> 需要在后面执行；</li><li>Promise 需要支持链式调用，Promise 实例调用 <code>then</code> 方法后需要返回一个新的 Promise 实例。如果 <code>then</code> 的回调中有返回值且是一个 Promise 实例，则该 Promise 实例执行后成功或失败的结果传递给下一个 Promise 实例的 <code>then</code> 方法 <code>onFulfilled</code> （成功的回调）或 <code>onRejected</code>（失败的回调）的参数，如果返回值不是 Promise 实例，直接将这个值传递给下一个 Promise 实例 <code>then</code> 方法回调的参数，<code>then</code> 的回调如果没有返回值相当于返回 <code>undefined</code>；</li><li>Promise 实例链式调用 <code>then</code> 时，当任何一个 <code>then</code> 执行出错，链式调用下一个 <code>then</code> 时会执行错误的回调，错误的回调没有返回值相当于返回了 <code>undefined</code>，再次链式调用 <code>then</code> 时会执行成功的回调；</li><li>Promise 实例的链式调用支持值的穿透，即当上一个 <code>then</code> 没有传递回调函数，或参数不是一个函数时（<code>null</code>），参数要被忽略，需要后面调用的 <code>then</code> 的回调函数来接收之前执行成功或失败的结果；</li><li><code>executor</code> 在 Promise 构造函数中执行时使用 <code>try...catch...</code> 捕获异常，但是内部执行的代码有可能是异步的，所以需要在 <code>then</code> 方法中使用 <code>try...catch...</code> 再次捕获；</li><li>Promise 实例的 <code>then</code> 方法中的回调为 <code>micro-tasks</code>（微任务），回调内的代码应晚于同步代码执行，在浏览器内部调用微任务接口，我们这里模拟使用宏任务代替。</li></ul><p><strong>针对上面的 Promise/A+ 规范，then 方法代码实现如下：</strong></p><figure class="highlight js"><figcaption><span>promise.js -- then 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实现值的穿透</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回新的 Promise，规范中规定这个 Promise 实例叫 promise2</span></span><br><span class="line">  <span class="keyword">var</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">      <span class="comment">// 用宏任务替代模拟微任务，目的是使 `then` 的回调晚于同步代码执行</span></span><br><span class="line">      <span class="comment">// 并保证执行 resolvePromise 时可以获取到 promise2 作为参数</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// 捕获异步的异常</span></span><br><span class="line">          <span class="comment">// onFulfilled 执行完返回值的处理，x 为成功回调的返回值</span></span><br><span class="line">          <span class="keyword">var</span> x = onFulfilled(self.value);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理返回值单独封装一个方法</span></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// onRejected 执行完返回值的处理，x 为失败回调的返回值</span></span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.reason);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在 Promise 执行 resolve 或 renject 为异步</span></span><br><span class="line">    <span class="comment">// 将 then 的执行程序存储在实例对应的</span></span><br><span class="line">    <span class="comment">// onFulfilledCallbacks 或 onRejectedCallbacks 中</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.onFulfilledCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> x = onFulfilled(self.value);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> x = onRejected(self.reason);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>在处理 <code>then</code> 回调的返回值时，其实就是在处理该返回值与 <code>then</code> 方法在执行后返回的新 Promise 实例（即 promise2）之间的关系，因为无论 Promise 的执行器在执行 <code>resolve</code> 还是 <code>reject</code> 是同步或是异步，都需要进行处理，所以我们单独封装一个函数 <code>resolvePromise</code> 来处理。</p></blockquote><p><strong>resolvePromise 函数有四个参数：</strong></p><ul><li>promise2：<code>then</code> 执行后返回的 Promise 实例；</li><li>x：<code>then</code> 的回调返回的结果；</li><li>resolve：promise2 的 <code>resolve</code> 函数；</li><li>reject：promise2 的 <code>reject</code> 函数。</li></ul><p><strong>在 resolvePromise 函数中涉及到的 Promise/A+ 规范：</strong></p><ul><li>将每个 Promise 实例调用 <code>then</code> 后返回的新 Promise 实例称为 <code>promise2</code>，将 <code>then</code> 回调返回的值称为 <code>x</code>；</li><li>如果 <code>promise2</code> 和 <code>x</code> 为同一个对象，由于 <code>x</code> 要将执行成功或失败的结果传递 <code>promise2</code> 的 <code>then</code> 方法回调的参数，因为是同一个 Promise 实例，此时既不能成功也不能失败（自己不能等待自己完成），造成循环引用，这种情况下规定应该抛出一个类型错误来回绝；</li><li>如果 <code>x</code> 是一个对象或者函数且不是 <code>null</code>，就去取 <code>x</code> 的 <code>then</code> 方法，如果 <code>x</code> 是对象，防止 <code>x</code> 是通过 <code>Object.defineProperty</code> 添加 <code>then</code> 属性，并添加 <code>get</code> 和 <code>set</code> 监听，如果在监听中抛出异常，需要被捕获到，<code>x.then</code> 是一个函数，就当作 <code>x</code> 是一个 Promise 实例，直接执行<code>x</code> 的 <code>then</code> 方法，执行成功就让 <code>promise2</code> 成功，执行失败就让 <code>promise2</code> 失败，如果 <code>x.then</code> 不是函数，则说明 <code>x</code> 为普通值，直接调用 <code>promise2</code> 的 <code>resolve</code> 方法将 <code>x</code> 传入，不满足条件说明该返回值就是一个普通值，直接执行 <code>promise2</code> 的 <code>resolve</code> 并将 <code>x</code> 作为参数传入；</li><li>如果每次执行 <code>x</code> 的 <code>then</code> 方法，回调中传入的参数还是一个 Promise 实例，循环往复，需要递归 <code>resolvePromise</code> 进行解析；</li><li>在递归的过程中如果返回的 Promise 是其他人的，并且在其他人 Promise 实现的 <code>then</code> 方法中同时调用了 <code>resolve</code> 和 <code>reject</code> 的情况，应该声明一个标识变量 <code>called</code> 做判断来避免这种情况，第一次调用 <code>resolve</code> 或 <code>reject</code> 生效，然后更改标识来忽略其他的调用。</li></ul><p><strong>针对上面的 Promise/A+ 规范，resolvePromise 函数代码实现如下：</strong></p><figure class="highlight js"><figcaption><span>promise.js -- resolvePromise 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 x 和 promise2 是不是同一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// x 是对象或者函数并且不是 null，如果不满足该条件说明 x 只是一个普通的值</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="comment">// 标识变量，防止递归内外层 resolve 和 reject 同时调用</span></span><br><span class="line">    <span class="comment">// 针对 Promise，x 为普通值的时候可以放行</span></span><br><span class="line">    <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了捕获 Object.defineProperty 创建的 then 属性时添加监听所抛出的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// then 只取一次，防止 Object.defineProperty getter 内，用次数控制报错</span></span><br><span class="line">      <span class="keyword">var</span> then = x.then;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// then 为一个方法，就当作 x 为一个 promise</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行 then，第一个参数为 this（即 x）</span></span><br><span class="line">        <span class="comment">// 第二个参数为成功的回调，第三个参数为失败的回调</span></span><br><span class="line">        then.call(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果 y 是 Promise 就继续递归解析</span></span><br><span class="line">          resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// x 是一个普通对象，直接成功即可</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>注意：Promise 是一套规范，是通用的，每个人都可以实现一个符合 <code>A+</code> 规范的 Promise，其他人实现的 Promise 可能会在我们的 Promise 的 <code>then</code> 方法中返回，所以当我们取出这个对象查看是否含有 <code>then</code> 方法，如果有则认为这个对象是一个 Promise 的实例。</strong></p></blockquote><p>上面我们按照 Promise/A+ 规范实现了 Promise 的 <code>then</code> 方法，接下来针对上面的规范，用一些有针对行的案例来对 <code>then</code> 方法一一进行验证。</p><p>验证异步调用 <code>resolve</code> 或 <code>reject</code>：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 异步调用 resolve 或 reject</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'执行了'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行了</span></span><br></pre></td></tr></table></figure><p>验证链式调用 <code>then</code> 返回 Promise 实例：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js then 回调返回 Promise 实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="string">'hello'</span>));</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">()</span> =&gt;</span> p2).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>验证链式调用 <code>then</code> 返回普通值：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js then 回调返回普通值</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'hello'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>验证链式调用 <code>then</code> 中执行出错链式调用 <code>then</code> 执行错误的回调后，再次链式调用 <code>then</code>：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 链式调用 then 中执行出错</span></span><br><span class="line"><span class="comment">// 链式调用 then 执行错误的回调后，再次链式调用 then</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功'</span>);</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'失败'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: error  at p.then...</span></span><br><span class="line"><span class="comment">// 成功</span></span><br></pre></td></tr></table></figure><p>验证 <code>then</code> 的参数穿透：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 then 的参数穿透</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="string">'ok'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then().then(<span class="literal">null</span>, err =&gt; <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>验证 <code>then</code> 方法是否晚于同步代码执行：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 then 方法是否晚于同步代码执行</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>验证循环引用：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 循环引用</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 p1 then 方法的回调返回自己</span></span><br><span class="line"><span class="keyword">var</span> p2 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功'</span>);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: 循环引用  at resolvePromise...</span></span><br></pre></td></tr></table></figure><p>验证 <code>then</code> 回调返回对象通过 <code>Object.definePropertype</code> 添加 <code>then</code> 属性并添加 <code>get</code> 监听，在触发监听时抛出异常：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js then 回调</span></span><br><span class="line"><span class="comment">// 返回对象通过 Object.definePropertype 添加 then 和 get 监听，捕获异常</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'then'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功'</span>);</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>验证每次执行 <code>resolve</code> 都传入 Promise 实例，需要将最终的执行结果传递给下一个 Promise 实例 <code>then</code> 的回调中：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 每次执行 resolve 都传入 Promise 实例</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(<span class="number">200</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 200</span></span><br></pre></td></tr></table></figure><h3 id="catch-方法的实现"><a href="#catch-方法的实现" class="headerlink" title="catch 方法的实现"></a>catch 方法的实现</h3><figure class="highlight js"><figcaption><span>promise.js -- catch 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><code>catch</code> 方法可以理解为是 <code>then</code> 方法的一个简写，只是参数中少了成功的回调，所以利用 Promise/A+ 规范中参数穿透的特性，很容易就实现了 <code>catch</code> 方法，<code>catch</code> 方法的真相就是这么的简单。</p></blockquote><p>验证 <code>catch</code> 方法：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 的 catch 方法</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'err'</span>));</span><br><span class="line"></span><br><span class="line">p.then().catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// err</span></span><br><span class="line"><span class="comment">// 成功了</span></span><br></pre></td></tr></table></figure><h3 id="finally-方法的实现"><a href="#finally-方法的实现" class="headerlink" title="finally 方法的实现"></a>finally 方法的实现</h3><figure class="highlight js"><figcaption><span>promise.js -- finally 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><code>finally</code> 方法是在 <code>ES9</code> 的规范中实现的，特点是无论成功或者失败都会执行传入的回调函数，并且回调函数没有任何参数，而在 <code>finally</code> 后可以再链式调用 <code>then</code> 或 <code>catch</code> 去处理后续逻辑或捕获异常，因为参数不是在 <code>finally</code> 方法传入的回调中返回的，所以借助了静态方法 <code>Promise.resolve</code>（该方法实现方式在静态方法中会说明），在 <code>finally</code> 内部调用 <code>then</code> 返回 Promise 实例，并传入成功和失败的回调用来返回最初成功或失败的结果，<code>finally</code> 的回调中执行的返回结果不生效。</p></blockquote><p>验证 <code>finally</code> 方法：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 的 finally 方法</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="string">'nihao'</span>));</span><br><span class="line"></span><br><span class="line">p.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// node版本的问题 8以上</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'error'</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'err'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data'</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// err error</span></span><br><span class="line"><span class="comment">// data nihao</span></span><br></pre></td></tr></table></figure><h2 id="静态方法的实现"><a href="#静态方法的实现" class="headerlink" title="静态方法的实现"></a>静态方法的实现</h2><h3 id="Promise-resolve-方法的实现"><a href="#Promise-resolve-方法的实现" class="headerlink" title="Promise.resolve 方法的实现"></a>Promise.resolve 方法的实现</h3><blockquote class="pullquote success"><p><code>Promise.resolve</code> 方法传入一个参数，并返回一个新的 Promise 实例，这个参数作为新 Promise 实例 <code>then</code> 方法成功回调的参数，在调用时感觉直接成功了，其实是直接执行了返回 Promise 实例的 <code>resolve</code>。</p></blockquote><figure class="highlight js"><figcaption><span>promise.js -- Promise.resolve 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(val);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证 <code>Promise.resolve</code> 方法：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 的 Promise.resolve 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'成功了'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功了</span></span><br></pre></td></tr></table></figure><h3 id="Promise-reject-方法的实现"><a href="#Promise-reject-方法的实现" class="headerlink" title="Promise.reject 方法的实现"></a>Promise.reject 方法的实现</h3><blockquote class="pullquote default"><p><code>Promise.reject</code> 方法与 <code>Promise.resolve</code> 的实现思路相同，不同的是，直接调用了返回新 Promise 实例的 <code>reject</code>。</p></blockquote><figure class="highlight js"><figcaption><span>promise.js -- Promise.reject 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证 <code>Promise.reject</code> 方法：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 的 Promise.reject 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'失败了'</span>).then(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败了</span></span><br></pre></td></tr></table></figure><h3 id="Promise-all-方法的实现"><a href="#Promise-all-方法的实现" class="headerlink" title="Promise.all 方法的实现"></a>Promise.all 方法的实现</h3><blockquote class="pullquote primary"><p><code>Promise.all</code> 方法可以实现多个 Promise 实例的并行，返回值为一个新的 Promise 实例，当所有结果都为成功时，返回一个数组，该数组存储的为每一个 Promise 实例的返回结果，这些 Promise 实例的返回顺序先后不确定，但是返回值的数组内存储的返回结果是按照数组中 Promise 实例最初顺序进行排列的，返回的数组作为返回 Promise 实例成功回调的参数，当其中一个失败，直接返回错误信息，并作为返回 Promise 实例失败回调的参数。</p></blockquote><figure class="highlight js"><figcaption><span>promise.js -- Promise.all 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存储返回值</span></span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表存入的个数，因为 Promise 为异步</span></span><br><span class="line">    <span class="comment">// 不知道哪个 Promise 先成功，不能用数组的长度来判断</span></span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来构建全部成功的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">index, data</span>) </span>&#123;</span><br><span class="line">      result[index] = data; <span class="comment">// 将返回值存入数组</span></span><br><span class="line">      idx++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (idx === promises.length) &#123;</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> current = promises[i];</span><br><span class="line">      <span class="comment">// 因为 Promise 为异步，保证 i 值是顺序传入</span></span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current &amp;&amp; current.then &amp;&amp; <span class="keyword">typeof</span> current.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">          current.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            processData(i, data);</span><br><span class="line">          &#125;, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          processData(i, current);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证 <code>Promise.all</code> 方法：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 的 Promise.all 方法</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, <span class="number">3</span>]).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="number">2</span>), <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p3, p4]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race-方法的实现"><a href="#Promise-race-方法的实现" class="headerlink" title="Promise.race 方法的实现"></a>Promise.race 方法的实现</h3><blockquote class="pullquote info"><p><code>Promise.race</code> 方法与 <code>Promise.all</code> 类似，同样可以实现多个 Promise 实例的并行，同样返回值为一个新的 Promise 实例，参数同样为一个存储多个 Promise 实例的数组，区别是只要有一个 Promise 实例返回结果，无论成功或失败，则直接返回这个结果，并作为新 Promise 实例 <code>then</code> 方法中成功或失败的回调函数的参数。</p></blockquote><figure class="highlight js"><figcaption><span>promise.js -- Promise.race 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> current = promises[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current &amp;&amp; current.then &amp;&amp; <span class="keyword">typeof</span> current.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        current.then(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证 <code>Promise.race</code> 方法：</p><figure class="highlight js"><figcaption><span>文件：verify-promise.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 promise.js 的 Promise.race 方法</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p3, p4]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="测试-Promise-是否符合-Promise-A-规范"><a href="#测试-Promise-是否符合-Promise-A-规范" class="headerlink" title="测试 Promise 是否符合 Promise/A+ 规范"></a>测试 Promise 是否符合 Promise/A+ 规范</h2><p><code>promises-aplus-test</code> 是专门用来验证 Promise 代码（构造函数和 <code>then</code> 方法）是否符合 Promise/A+ 规范的模块，需要通过 <code>npm</code> 下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install promises-aplus-test -g</span><br></pre></td></tr></table></figure><p><strong>测试方法：</strong></p><ul><li>在 <code>promise.js</code> 中写入测试代码；</li><li>在命令行中输入命令 <code>promises-aplus-test</code> + <code>fileName</code>。</li></ul><p><strong>测试代码：</strong></p><figure class="highlight js"><figcaption><span>promise.js -- 测试方法 Promise.derfer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise 语法糖</span></span><br><span class="line"><span class="comment">// 好处：解决 Promise 嵌套问题</span></span><br><span class="line"><span class="comment">// 坏处：错误处理不方便</span></span><br><span class="line"><span class="built_in">Promise</span>.derfer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dfd = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-test promise.js</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>执行上面命令后，会根据 Promise/A+ 规范一条一条进行极端的验证，当验证通过后会在窗口中这一条对应的执行项前打勾，验证不通过打叉，直到所有的规范都验证完毕。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 异步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> ES6 </tag>
            
            <tag> 异步 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步发展流程 —— Promise 的基本使用</title>
      <link href="/2018/06/12/20180612045005/"/>
      <url>/2018/06/12/20180612045005/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/12/20180612045005/promise.png" title="Promise 基本用法"><p><br></p><h2 id="Promise-简介"><a href="#Promise-简介" class="headerlink" title="Promise 简介"></a>Promise 简介</h2><blockquote class="pullquote info"><p>Promise 是 ES6 的新特性，提供了对 js 异步编程控制的新的解决方案，在过去书写异步代码时要靠回调函数，当异步操作依赖于其他异步操作的返回值时，会出现一种现象，被程序员们称为 “回调地狱”，即多层回调函数嵌套，这种代码的可读性、维护性都很差，因此诞生了 Promise，当然 Promise 并不是完全摆脱回调，而只是改变了传递回调的位置，大大减少了回调函数嵌套。</p></blockquote><a id="more"></a><h2 id="Promise-的使用"><a href="#Promise-的使用" class="headerlink" title="Promise 的使用"></a>Promise 的使用</h2><h3 id="实例方法-then"><a href="#实例方法-then" class="headerlink" title="实例方法 then"></a>实例方法 then</h3><p>Promise 中的代码默认是同步执行的，<code>then</code> 方法中的回调在微任务队列中执行，在 Promise 的 <code>then</code> 方法中支持传入两个参数，一个是成功的回调，一个是失败的回调，在 Promise 中调用了 <code>resolve</code> 方法，就会在 <code>then</code> 中执行成功的回调，调用了 <code>reject</code> 方法，就会在 <code>then</code> 中执行失败的回调，成功的回调和失败的回调只能执行一个，<code>resolve</code> 和 <code>reject</code> 方法调用时传入的参数会传递给 <code>then</code> 方法中对应的回调函数。</p><figure class="highlight js"><figcaption><span>执行 resolve</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resovle(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>执行 reject</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果 Promise 中发生错误，就会在 <code>then</code> 中执行失败的回调。</p><figure class="highlight js"><figcaption><span>失败的回调</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'报错啦'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错啦</span></span><br></pre></td></tr></table></figure><p>当同一个 Promise 实例的 <code>then</code> 方法多次调用时，就会多次执行。</p><figure class="highlight js"><figcaption><span>多次调用 then</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="comment">// 成功</span></span><br></pre></td></tr></table></figure><p>Promise 支持链式调用，每次调用一次 <code>then</code> 方法都会返回一个新的 Promise实例，如果该 then 方法中执行的回调函数有返回值，并且这个返回值会作为返回的下一个 Promise 实例的 <code>then</code> 方法回调的参数，如果 <code>then</code> 方法的返回值是一个 Promise 实例，那就返回一个新的 Promise 实例，将 <code>then</code> 返回的 Promise 实例执行后的结果作为返回 Promise 实例回调的参数。</p><figure class="highlight js"><figcaption><span>链式调用 then</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'1.txt'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 假设此时读到的内容为 Hello world</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="comment">// Hello world</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">read(<span class="string">'1.txt'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 假如此时读到的 1.txt 的内容为 2.txt 的字符串，2.txt 的内容为 Hello world</span></span><br><span class="line">  <span class="keyword">return</span> read(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="comment">// Hello world</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 Promise 实例的 <code>then</code> 中如果有错误产生，在返回的新的 Promise 实例中的 <code>then</code> 方法中会执行错误的回调。</p><figure class="highlight js"><figcaption><span>链式调用 then 出错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, <span class="number">2</span>);</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, <span class="number">2</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// success 1</span></span><br><span class="line"><span class="comment">// error 2</span></span><br></pre></td></tr></table></figure><p><strong>在 Promise 中有三个状态：</strong></p><ul><li>pending：等待态</li><li>fulfilled：成功态</li><li>rejected：失败态</li></ul><blockquote class="pullquote warning"><p>Promise 实例的状态只能从 <code>pending</code> 到 <code>fulfilled</code> 或从 <code>pending</code> 到 <code>rejected</code>，状态一旦发生变化就不可逆，所以 Promise 实现链式调用与 jQuery 不同，返回的不是 <code>this</code>，只能是一个新的 Promise。</p></blockquote><h3 id="实例方法-catch"><a href="#实例方法-catch" class="headerlink" title="实例方法 catch"></a>实例方法 catch</h3><p>在 Promise 中实例的 <code>catch</code> 方法可以捕获创建 Promise 过程中和链式调用中的异常，不需要每次调用 <code>then</code> 方法中都传入错误的回调，在链式调用的过程中只要有任何一个 <code>then</code> 中出现错误，都会被 <code>catch</code> 方法捕获到。</p><figure class="highlight js"><figcaption><span>创建 Promise 实例时出错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>调用 then 方法时出错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, <span class="number">2</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, <span class="number">2</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// success 1</span></span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><h3 id="实例方法-finally"><a href="#实例方法-finally" class="headerlink" title="实例方法 finally"></a>实例方法 finally</h3><p>Promise 的实例方法 <code>finally</code> 是 <code>ES7</code> 标准引入的，不管最后 Promise 实例的状态是成功还是失败出传入的回调都会执行，回调函数没有参数，这说明 <code>finally</code> 方法里的操作与 Promise 实例状态无关，不依赖于 Promise 的执行结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Primise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行了</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Primise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行了</span></span><br></pre></td></tr></table></figure><p><code>finally</code> 方法执行后返回一个新的 Promise，继续调用 <code>then</code> 方法，返回值为执行 <code>finally</code> 之前的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Primise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fanilly'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Primise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行了'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="静态方法-Promise-all"><a href="#静态方法-Promise-all" class="headerlink" title="静态方法 Promise.all"></a>静态方法 Promise.all</h3><p>Promise 中的静态方法 <code>all</code> 可以实现多个 Promise 实例的并行，当所有结果都为成功时，返回一个数组，该数组存储的为每一个 Promise 实例的返回结果，每一个 Promise 实例的返回顺序先后不固定，但是返回值的数组内存储每一个 Promise 的返回值的结果按照最初传入的顺序排列，<code>all</code> 方法的返回值为一个新的 Promise 实例，返回的数组作为返回新 Promise 的 <code>then</code> 方法成功回调的参数。</p><p>当 <code>all</code> 传入的参数数组中的 Promise 实例执行时，只要有一个失败，则直接返回该 Promise 实例失败的结果或错误信息。</p><figure class="highlight js"><figcaption><span>Promise.all 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Promise.all 错误捕获</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="静态方法-Promise-race"><a href="#静态方法-Promise-race" class="headerlink" title="静态方法 Promise.race"></a>静态方法 Promise.race</h3><p>Promise 的静态方法 <code>race</code> 的用法和 <code>all</code> 类似，参数同为一个存储 Promise 实例的数组，返回值同样是一个新的 Promise 的实例，不同的是，数组中的 Promise 实例只有一个结果为成功，那就直接返回这个结果（只取出最快返回的结果），在没有成功的结果之前有一个出错，就直接返回这个错误。</p><figure class="highlight js"><figcaption><span>Promise.race 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Promise.race 错误捕获</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">2</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="静态方法-Promise-resolve"><a href="#静态方法-Promise-resolve" class="headerlink" title="静态方法 Promise.resolve"></a>静态方法 Promise.resolve</h3><p>Promise 的静态方法 <code>resolve</code> 可以直接将 Promise 的状态变为成功并返回一个新的 Promise 实例，<code>resolve</code> 的参数会传递给返回的新 Promise 实例 <code>then</code> 中成功回调。</p><figure class="highlight js"><figcaption><span>Promise.resolve 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'hello'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="静态方法-Promise-reject"><a href="#静态方法-Promise-reject" class="headerlink" title="静态方法 Promise.reject"></a>静态方法 Promise.reject</h3><p>Promise 的静态方法 <code>reject</code> 与 <code>resolve</code> 使用完全相同，都返回一个新的 Promise 实例，不同的是 <code>reject</code> 的参数会传递给新 Promise 实例的 <code>then</code> 方法失败回调。</p><figure class="highlight js"><figcaption><span>Promise.reject 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>).then(<span class="literal">null</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>当成功的回调不传递时，可以使用 <code>null</code> 代替，因为 <code>null</code> 作为参数会被忽略掉，将参数穿透到下一个 <code>then</code> 的回调中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>Promise 是异步编程的一大趋势，也是当前更先进的异步解决方案的基础，下一篇我们着重讨论一下 Promise 的实现原理以及 <code>A+</code> 规范。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 异步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> 异步 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九种 “姿势” 让你彻底解决跨域问题</title>
      <link href="/2018/06/11/20180611010638/"/>
      <url>/2018/06/11/20180611010638/</url>
      
        <content type="html"><![CDATA[<img src="/2018/06/11/20180611010638/browser.png" title="跨域"><p><br></p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote class="pullquote info"><p>同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 <code>XSS</code>、<code>CSRF</code> 等攻击。所谓同源是指 “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 <code>ip</code> 地址，也非同源。</p></blockquote><a id="more"></a><h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>当协议、域名、端口号，有一个或多个不同时，有希望可以访问并获取数据的现象称为跨域访问，同源策略限制下 <code>cookie</code>、<code>localStorage</code>、<code>dom</code>、<code>ajax</code>、<code>IndexDB</code> 都是不支持跨域的。</p><p>假设 cookie 支持了跨域，http 协议无状态，当用户访问了一个银行网站登录后，银行网站的服务器给返回了一个 sessionId，当通过当前浏览器再访问一个恶意网站，如果 cookie 支持跨域，恶意网站将获取 sessionId 并访问银行网站，出现安全性问题；IndexDB、localStorage 等数据存储在不同域的页面切换时是获取不到的；假设 dom 元素可以跨域，在自己的页面写入一个 iframe 内部嵌入的地址是 <a href="javascript:;" target="_blank" rel="noopener">www.baidu.com</a>，当在百度页面登录账号密码时就可以在自己的页面获取百度的数据信息，这显然是不合理的。</p><p>这就是为什么 <code>cookie</code>、<code>localStorage</code>、<code>dom</code>、<code>ajax</code>、<code>IndexDB</code> 会受到同源策略会限制，下面还有一点对跨域理解的误区：</p><blockquote class="pullquote warning"><p>误区：同源策略限制下，访问不到后台服务器的数据，或访问到后台服务器的数据后没有返回；<br>正确：同源策略限制下，可以访问到后台服务器的数据，后台服务器会正常返回数据，而被浏览器给拦截了。</p></blockquote><h2 id="实现跨域的方式"><a href="#实现跨域的方式" class="headerlink" title="实现跨域的方式"></a>实现跨域的方式</h2><h3 id="使用-jsonp-跨域"><a href="#使用-jsonp-跨域" class="headerlink" title="使用 jsonp 跨域"></a>使用 jsonp 跨域</h3><p>使用场景：当自己的项目前端资源和后端部署在不同的服务器地址上，或者其他的公司需要访问自己对外公开的接口，需要实现跨域获取数据，如百度搜索。</p><figure class="highlight js"><figcaption><span>封装 jsonp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装 jsonp 跨域请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, cb &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 script 标签帮助我们发送请求</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    params = &#123; ...params, cb &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环构建键值对形式的参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      arr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建全局函数</span></span><br><span class="line">    <span class="built_in">window</span>[cb] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">// 在跨域拿到数据以后将 script 标签销毁</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接发送请求的参数并赋值到 src 属性</span></span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arr.join(<span class="string">'&amp;'</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法跨域请求百度搜索的接口</span></span><br><span class="line">json(&#123;</span><br><span class="line">  url: <span class="string">'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    wd: <span class="string">'jsonp'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  cb: <span class="string">'show'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 打印请求回的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>只能发送 get 请求 不支持 post、put、delete；</li><li>不安全，容易引发 xss 攻击，别人在返回的结果中返回了下面代码。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`let script = document.createElement('script');</span></span><br><span class="line"><span class="string">script.src = 'http://192.168.0.57:8080/xss.js';</span></span><br><span class="line"><span class="string">document.body.appendChild(script);`</span>;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p>会把别人的脚本引入到自己的页面中执行，如：弹窗、广告等，甚至更危险的脚本程序。</p></blockquote><h3 id="使用-CORS-跨域"><a href="#使用-CORS-跨域" class="headerlink" title="使用 CORS 跨域"></a>使用 CORS 跨域</h3><blockquote class="pullquote info"><p>跨源资源共享/CORS（Cross-Origin Resource Sharing）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p></blockquote><p>使用场景：多用于开发时，前端与后台在不同的 <code>ip</code> 地址下进行数据访问。</p><p>现在启动两个端口号不同的服务器，创建跨域条件，服务器（NodeJS）代码如下：</p><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器1</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(express);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器2</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/getDate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'I love you'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><p>由于我们的 NodeJS 服务器使用 <code>express</code> 框架，在我们的项目根目录下的命令行中输入下面代码进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure><p>通过访问 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000/index.html</a> 获取 <code>index.html</code> 文件并执行其中的 <code>Ajax</code> 请求 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:4000/getDate</a> 接口去获取数据，<code>index.html</code> 文件内容如下：</p><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>CORS 跨域<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 正常 cookie 是不允许跨域的</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.cookie = <span class="string">'name=hello'</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// cookie 想要实现跨域必须携带凭证</span></span></span><br><span class="line"><span class="javascript">    xhr.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// xhr.open('GET', 'http://localhost:4000/getDate', true);</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:4000/getDate'</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置名为 name 的自定义请求头</span></span></span><br><span class="line"><span class="javascript">    xhr.setRequestHeader(<span class="string">'name'</span>, <span class="string">'hello'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 打印返回的数据</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(xhr.response);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 打印后台设置的自定义头信息</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">'name'</span>));</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    xhr.send();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面 <code>index.html</code> 代码中发送请求访问不在同源的服务器 <code>2</code>，此时会在控制台给出错误信息，告诉我们缺少了哪些响应头，我们对应报错信息去修改访问的服务器 <code>2</code> 的代码，添加对应的响应头，实现 CORS 跨域。</p><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器2</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许访问域的白名单</span></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">'http://localhost:3000'</span>];</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.header.origin;</span><br><span class="line">  <span class="keyword">if</span> (whiteList.includes(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置那个源可以访问我，参数为 * 时</span></span><br><span class="line">    <span class="comment">// 允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想要获取 ajax 的头信息，需设置响应头</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理复杂请求的头</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许发送 cookie 凭证的响应头</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许前端获取哪个头信息</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Expose-Headers'</span>, <span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 OPTIONS 预检的存活时间，单位 s</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 PUT 请求会做一个试探性的请求 OPTIONS</span></span><br><span class="line">    <span class="comment">// 其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理</span></span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.put(<span class="string">'/getDate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// res.setHeader('name', 'nihao'); // 设置自定义响应头信息</span></span><br><span class="line">  res.end(<span class="string">'I love you'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/getDate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'I love you'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h3 id="使用-postMessage-实现跨域"><a href="#使用-postMessage-实现跨域" class="headerlink" title="使用 postMessage 实现跨域"></a>使用 postMessage 实现跨域</h3><blockquote class="pullquote info"><p>postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时候简称为 XMD，指的是在来自不同域的页面间传递消息。</p></blockquote><p>调用方式：<strong>window.postMessage(message, targetOrigin)</strong></p><ul><li>message：发送的数据</li><li>targetOrigin：发送的窗口的域</li></ul><p>在对应的页面中用 message 事件接收，事件对象中有 <code>data</code>、<code>origin</code>、<code>source</code> 三个重要信息</p><ul><li>data：接收到的数据</li><li>origin：接收到数据源的域（数据来自哪个域）</li><li>source：接收到数据源的窗口对象（数据来自哪个窗口对象）</li></ul><p>使用场景：不是使用 <code>Ajax</code> 的数据通信，更多是在两个页面之间的通信，在 <code>A</code> 页面中引入 <code>B</code> 页面，在 <code>A</code>、<code>B</code> 两个页面之间通信。</p><p>与上面 CORS 类似，我们要创建跨域场景，搭建两个端口号不同的 Nodejs 服务器，后面相同方式就不多赘述了。</p><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器1</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(express);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器2</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(express);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><p>通过访问 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000/a.html</a>，在 <code>a.html</code> 中使用 <code>iframe</code> 标签引入 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:4000/b.html</a>，在两个窗口间传递数据。</p><figure class="highlight html"><figcaption><span>文件：a.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 A<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/b.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>);</span></span><br><span class="line"><span class="javascript">      frame.contentWindow.postMessage(<span class="string">'I love you'</span>, <span class="string">'http://localhost:4000'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>文件：b.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 B<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 打印来自页面 A 的消息</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 给页面 A 发送回执</span></span></span><br><span class="line"><span class="javascript">      e.source.postMessage(<span class="string">'I love you, too'</span>, e.origin);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-window-name-实现跨域"><a href="#使用-window-name-实现跨域" class="headerlink" title="使用 window.name 实现跨域"></a>使用 window.name 实现跨域</h3><p>同样是页面之间的通信，需要借助 <code>iframe</code> 标签，<code>A</code> 页面和 <code>B</code> 页面是同域的 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000</a>，<code>C</code> 页面在独立的域 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:4000</a>。</p><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器1</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(express);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器2</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(express);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><p>实现思路：在 <code>A</code> 页面中将 <code>iframe</code> 的 <code>src</code> 指向 <code>C</code> 页面，在 <code>C</code> 页面中将属性值存入 <code>window.name</code> 中，再把 <code>iframe</code> 的 <code>src</code> 换成同域的 <code>B</code> 页面，在当前的 <code>iframe</code> 的 <code>window</code> 对象中取出 <code>name</code> 的值，访问 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000/a.html</a>。</p><figure class="highlight html"><figcaption><span>文件：a.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 A<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> isFirst = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (isFirst) &#123;</span></span><br><span class="line"><span class="javascript">        frame.src = <span class="string">'http://localhost:3000/b.html'</span>;</span></span><br><span class="line"><span class="javascript">        isFirst = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(frame.contentWindow.name);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>文件：c.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 C<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'I love you'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-location-hash-实现跨域"><a href="#使用-location-hash-实现跨域" class="headerlink" title="使用 location.hash 实现跨域"></a>使用 location.hash 实现跨域</h3><p>与 <code>window.name</code> 跨域的情况相同，是不同域的页面间的参数传递，需要借助 <code>iframe</code> 标签，<code>A</code> 页面和 <code>B</code> 页面是同域的 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000</a>，<code>C</code> 页面是独立的域 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:4000</a>。</p><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器1</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(express);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器2</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(express);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><p>实现思路：<code>A</code> 页面通过 <code>iframe</code> 引入 <code>C</code> 页面，并给 <code>C</code> 页面传一个 <code>hash</code> 值，<code>C</code> 页面收到 <code>hash</code> 值后创建 <code>iframe</code> 引入 <code>B</code> 页面，把 <code>hash</code> 值传给 <code>B</code> 页面，<code>B</code> 页面将自己的 <code>hash</code> 值放在 <code>A</code> 页面的 <code>hash</code> 值中，访问 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000/a.html</a>。</p><figure class="highlight html"><figcaption><span>文件：a.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 A<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:4000/c.html#Iloveyou"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>文件：c.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 C<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打印 A 页面引入 C 页面设置的 hash 值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(location.hash);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.src = <span class="string">'http://localhost:3000/b.html#Iloveyoutoo'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>文件：b.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 B<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将 C 页面引入 B 页面设置的 hash 值设置给 A页面</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.parent.parent.location.hash = location.hash;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-document-domain-实现跨域"><a href="#使用-document-domain-实现跨域" class="headerlink" title="使用 document.domain 实现跨域"></a>使用 document.domain 实现跨域</h3><p>使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 <a href="javascript:;" target="_blank" rel="noopener">www.baidu.com</a> 与 <a href="javascript:;" target="_blank" rel="noopener">video.baidu.com</a> 之间。</p><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>想要模拟使用 <code>document.domain</code> 跨域的场景需要做些小小的准备，到 <a href="javascript:;" target="_blank" rel="noopener">C:\Windows\System32\drivers\etc</a> 该路径下找到 <code>hosts</code> 文件，在最下面创建一个一级域名和一个二级域名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   www.domainacross.com</span><br><span class="line">127.0.0.1   sub.domainacross.com</span><br></pre></td></tr></table></figure><p>命名是随意的，只要是符合一级域名与 二级域名的关系即可，然后访问 <a href="javascript:;" target="_blank" rel="noopener">http://www.domainacross.com:3000/a.html</a>。</p><figure class="highlight html"><figcaption><span>文件：a.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 A<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是页面 A 的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"http://sucess.domainacross.com:3000/b.html"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onload</span>=<span class="string">"load()"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"frame"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domainacross.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(frame.contentWindow.message);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>文件：b.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面 B<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是 B 页面的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domainacross.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> message = <span class="string">'Hello A'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-WebSocket-实现跨域"><a href="#使用-WebSocket-实现跨域" class="headerlink" title="使用 WebSocket 实现跨域"></a>使用 WebSocket 实现跨域</h3><blockquote class="pullquote info"><p>WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 <code>socket.io</code> 的库，WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），协议是 <code>ws://</code> 和 <code>wss://</code> 对应 <code>http://</code> 和 <code>https://</code>，因为没有跨域限制，所以使用 <code>file://</code> 协议也可以进行通信。</p></blockquote><p>由于我们在 NodeJS 服务中使用了 WebSocket，所以需要安装对应的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ws --save</span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建 webSocket</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 连接上触发</span></span></span><br><span class="line"><span class="javascript">    socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      socket.send(<span class="string">'I love you'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 收到消息触发</span></span></span><br><span class="line"><span class="javascript">    socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 打印收到的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data); <span class="comment">// I love you, too</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 webSocket</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"><span class="comment">// 创建连接，端口号与前端相对应</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">3000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听消息</span></span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 打印消息</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// I love you</span></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    ws.send(<span class="string">'I love you, too'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用-nginx-实现跨域"><a href="#使用-nginx-实现跨域" class="headerlink" title="使用 nginx 实现跨域"></a>使用 nginx 实现跨域</h3><p><code>nginx</code> 本身就是一个服务器，因此我们需要去 <code>nginx</code> 官网下载服务环境 <a><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></a>。</p><ul><li>下载后解压到一个文件夹中</li><li>双击 <code>nginx.exe</code> 启动（此时可以通过 <a href="javascript:;" target="_blank" rel="noopener">http://localhost</a> 访问 <code>nginx</code> 服务）</li><li>在目录新建 <code>json</code> 文件夹</li><li>进入 <code>json</code> 文件夹新建 <code>data.json</code> 文件并写入内容</li><li>回到 <code>nginx</code> 根目录进入 <code>conf</code> 文件夹</li><li>使用编辑器打开 <code>nginx.conf</code> 进行配置</li></ul><p><strong>data.json 文件：</strong></p><figure class="highlight json"><figcaption><span>文件：data.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"nginx"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nginx.conf 文件：</strong></p><figure class="highlight nginx"><figcaption><span>nginx 配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  <span class="attribute">location</span> ~.*\.json &#123;</span><br><span class="line">    <span class="attribute">root</span> json;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">"Access-Control-Allow-Origin"</span> <span class="string">"*"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含义：</strong></p><ul><li>~.*\.json：代表忽略大小写，后缀名为 json 的文件；</li><li>root json：代表 <code>json</code> 文件夹；</li><li>add_header：代表加入跨域的响应头及允许访问的域，<code>*</code> 为允许任何访问。</li></ul><p>在 <code>nginx</code> 根目录启动 <code>cmd</code> 命令行（windows 系统必须使用 <code>cmd</code> 命令行）执行下面代码重启 <code>nginx</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>不跨域访问：<a href="javascript:;" target="_blank" rel="noopener">http://localhost/data.json</a></p><p>跨域访问时需要创建跨域条件代码如下：</p><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>跨域访问：<a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000/index.html</a></p><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>nginx跨域<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">'GET'</span>, <span class="string">'http://localhost/data.json'</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(xhr.response);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    xhr.send();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="使用-http-proxy-middleware-实现跨域"><a href="#使用-http-proxy-middleware-实现跨域" class="headerlink" title="使用 http-proxy-middleware 实现跨域"></a>使用 http-proxy-middleware 实现跨域</h3><p>NodeJS 中间件 <code>http-proxy-middleware</code> 实现跨域代理，原理大致与 <code>nginx</code> 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 <code>cookieDomainRewrite</code> 参数修改响应头中 <code>cookie</code> 中的域名，实现当前域的 <code>cookie</code> 写入，方便接口登录认证。</p><h4 id="非-vue-框架的跨域（2-次跨域）"><a href="#非-vue-框架的跨域（2-次跨域）" class="headerlink" title="非 vue 框架的跨域（2 次跨域）"></a>非 vue 框架的跨域（2 次跨域）</h4><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>proxy 跨域<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 前端开关：浏览器是否读写 cookie</span></span></span><br><span class="line"><span class="javascript">    xhr.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 访问 http-proxy-middleware 代理服务器</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.proxy1.com:3000/login?user=admin'</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">    xhr.send();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>中间代理服务中使用了 <code>http-proxy-middleware</code> 中间件，因此需要提前下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install http-proxy-middleware --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>中间代理服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  proxy(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    target: <span class="string">'http://www.proxy2.com:8080'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带 cookie</span></span><br><span class="line">    onProxyRes: <span class="function"><span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">      res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://www.proxy1.com'</span>);</span><br><span class="line">      res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="string">'true'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应信息中的 cookie 域名</span></span><br><span class="line">    cookieDomainRewrite: <span class="string">'www.proxy1.com'</span> <span class="comment">// 可以为 false，表示不修改</span></span><br><span class="line">  &#125;);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向前台写 cookie</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="comment">// HttpOnly：脚本无法读取</span></span><br><span class="line">    <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.proxy2.com;HttpOnly'</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br></pre></td></tr></table></figure><h4 id="vue-框架的跨域（1-次跨域）"><a href="#vue-框架的跨域（1-次跨域）" class="headerlink" title="vue 框架的跨域（1 次跨域）"></a>vue 框架的跨域（1 次跨域）</h4><p>利用 <strong>node + webpack + webpack-dev-server</strong> 代理接口跨域。在开发环境下，由于 <code>Vue</code> 渲染服务和接口代理服务都是 <code>webpack-dev-server</code>，所以页面与代理接口之间不再跨域，无须设置 <code>Headers</code> 跨域信息了。</p><figure class="highlight js"><figcaption><span>导出服务器配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;&#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">  ...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    proxy: [&#123;</span><br><span class="line">      context: <span class="string">'/login'</span>,</span><br><span class="line">      target: <span class="string">'http://www.proxy2.com:8080'</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      secure: <span class="literal">false</span>,  <span class="comment">// 当代理某些 https 服务报错时用</span></span><br><span class="line">      cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为 false，表示不修改</span></span><br><span class="line">    &#125;],</span><br><span class="line">    noInfo: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>本篇文章在于帮助我们理解跨域，以及不同跨域方式的基本原理，在公司的项目比较多，多个域使用同一个服务器或者数据，以及在开发环境时，跨域的情况基本无法避免，一般会有各种各样形式的跨域解决方案，但其根本原理基本都在上面的跨域方式当中方式，我们可以根据开发场景不同，选择最合适的跨域解决方案。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTTP </tag>
            
            <tag> 跨域 </tag>
            
            <tag> JSONP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟 Vue 手写一个 MVVM</title>
      <link href="/2018/03/28/20180328140039/"/>
      <url>/2018/03/28/20180328140039/</url>
      
        <content type="html"><![CDATA[<img src="/2018/03/28/20180328140039/mvvm.png" title="MVVM"><p><br></p><h2 id="MVVM-的前世今生"><a href="#MVVM-的前世今生" class="headerlink" title="MVVM 的前世今生"></a>MVVM 的前世今生</h2><blockquote class="pullquote info"><p>MVVM 设计模式，是由 MVC（最早来源于后端）、MVP 等设计模式进化而来，M - 数据模型（Model），VM - 视图模型（ViewModel），V - 视图层（View）。</p></blockquote><p>在 MVC 模式中，除了 Model 和 View 层以外，其他所有的逻辑都在 Controller 中，Controller 负责显示页面、响应用户操作、网络请求及与 Model 的交互，随着业务的增加和产品的迭代，Controller 中的处理逻辑越来越多、越来越复杂，难以维护。为了更好的管理代码，为了更方便的扩展业务，必须要为 Controller “瘦身”，需要更清晰的将用户界面（UI）开发从应用程序的业务逻辑与行为中分离，MVVM 为此而生。</p><p>很多 MVVM 的实现都是通过数据绑定来将 View 的逻辑从其他层分离，可以用下图来简略的表示。</p><a id="more"></a><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/28/20180328140039/mvvm-content.png" alt="MVVM 模型图" title>                </div>                <div class="image-caption">MVVM 模型图</div>            </figure><p><br></p><p>使用 MVVM 设计模式的前端框架很多，其中渐进式框架 Vue 是典型的代表，并在开发使用中深得广大前端开发者的青睐，我们这篇就根据 Vue 对于 MVVM 的实现方式来简单模拟一版 MVVM 库。</p><h2 id="MVVM-的流程分析"><a href="#MVVM-的流程分析" class="headerlink" title="MVVM 的流程分析"></a>MVVM 的流程分析</h2><p>在 Vue 的 MVVM 设计中，我们主要针对 <code>Compile</code>（模板编译）、<code>Observer</code>（数据劫持）、<code>Watcher</code>（数据监听）和 <code>Dep</code>（发布订阅）几个部分来实现，核心逻辑流程可参照下图：</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/28/20180328140039/mvvm-flow.jpg" alt="MVVM 流程图" title>                </div>                <div class="image-caption">MVVM 流程图</div>            </figure><p><br></p><p>类似这种 “造轮子” 的代码毋庸置疑一定是通过面向对象编程来实现的，并严格遵循开放封闭原则，由于 ES5 的面向对象编程比较繁琐，所以，在接下来的代码中统一使用 ES6 的 <code>class</code> 来实现。</p><h2 id="MVVM-类的实现"><a href="#MVVM-类的实现" class="headerlink" title="MVVM 类的实现"></a>MVVM 类的实现</h2><p>在 Vue 中，对外只暴露了一个名为 <code>Vue</code> 的构造函数，在使用的时候 <code>new</code> 一个 <code>Vue</code> 实例，然后传入了一个 <code>options</code> 参数，类型为一个对象，包括当前 <code>Vue</code> 实例的作用域 <code>el</code>、模板绑定的数据 <code>data</code> 等等。</p><p>我们模拟这种 MVVM 模式的时候也构建一个类，名字就叫 <code>MVVM</code>，在使用时同 Vue 框架类似，需要通过 <code>new</code> 指令创建 <code>MVVM</code> 的实例并传入 <code>options</code>。</p><figure class="highlight js"><figcaption><span>文件：MVVM.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVVM</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 先把 el 和 data 挂在 MVVM 实例上</span></span><br><span class="line">    <span class="keyword">this</span>.$el = options.el;</span><br><span class="line">    <span class="keyword">this</span>.$data = options.data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有要编译的模板就开始编译</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$el) &#123;</span><br><span class="line">      <span class="comment">// 数据劫持，就是把对象所有的属性添加 get 和 set</span></span><br><span class="line">      <span class="keyword">new</span> Observer(<span class="keyword">this</span>.$data);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将数据代理到实例上</span></span><br><span class="line">      <span class="keyword">this</span>.proxyData(<span class="keyword">this</span>.$data);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用数据和元素进行编译</span></span><br><span class="line">      <span class="keyword">new</span> Compile(<span class="keyword">this</span>.el, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  proxyData(data) &#123; <span class="comment">// 代理数据的方法</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> data[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">          data[key] = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码，我们可以看出，在我们 <code>new</code> 一个 <code>MVVM</code> 的时候，在参数 <code>options</code> 中传入了一个 <code>Dom</code> 的根元素节点和数据 <code>data</code> 并挂在了当前的 <code>MVVM</code> 实例上。</p><p>当存在根节点的时候，通过 <code>Observer</code> 类对 <code>data</code> 数据进行了劫持，并通过 <code>MVVM</code> 实例的方法 <code>proxyData</code> 把 <code>data</code> 中的数据挂在当前 <code>MVVM</code> 实例上，同样对数据进行了劫持，是因为我们在获取和修改数据的时候可以直接通过 <code>this</code> 或 <code>this.$data</code>，在 Vue 中实现数据劫持的核心方法是 <code>Object.defineProperty</code>，我们也使用这个方式通过添加 <code>getter</code> 和 <code>setter</code> 来实现数据劫持。</p><p>最后使用 <code>Compile</code> 类对模板和绑定的数据进行了解析和编译，并渲染在根节点上，之所以数据劫持和模板解析都使用类的方式实现，是因为代码方便维护和扩展，其实不难看出，<code>MVVM</code> 类其实作为了 <code>Compile</code> 类和 <code>Observer</code> 类的一个桥梁。</p><h2 id="模板编译-Compile-类的实现"><a href="#模板编译-Compile-类的实现" class="headerlink" title="模板编译 Compile 类的实现"></a>模板编译 Compile 类的实现</h2><p><code>Compile</code> 类在创建实例的时候需要传入两个参数，第一个参数是当前 <code>MVVM</code> 实例作用的根节点，第二个参数就是 <code>MVVM</code> 实例，之所以传入 <code>MVVM</code> 的实例是为了更方便的获取 <code>MVVM</code> 实例上的属性。</p><p>在 <code>Compile</code> 类中，我们会尽量的把一些公共的逻辑抽取出来进行最大限度的复用，避免冗余代码，提高维护性和扩展性，我们把 <code>Compile</code> 类抽取出的实例方法主要分为两大类，辅助方法和核心方法，在代码中用注释标明。</p><h3 id="解析根节点内的-Dom-结构"><a href="#解析根节点内的-Dom-结构" class="headerlink" title="解析根节点内的 Dom 结构"></a>解析根节点内的 Dom 结构</h3><figure class="highlight js"><figcaption><span>文件：Compile.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="keyword">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如过传入的根元素存在，才开始编译</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.el) &#123;</span><br><span class="line">      <span class="comment">// 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片）</span></span><br><span class="line">      <span class="keyword">let</span> fragment = <span class="keyword">this</span>.node2fragment(<span class="keyword">this</span>.el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 辅助方法 */</span></span><br><span class="line">  <span class="comment">// 判断是否是元素节点</span></span><br><span class="line">  isElementNode(node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 核心方法 */</span></span><br><span class="line">  <span class="comment">// 将根节点转移至文档碎片</span></span><br><span class="line">  node2fragment(el) &#123;</span><br><span class="line">    <span class="comment">// 创建文档碎片</span></span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="comment">// 第一个子节点</span></span><br><span class="line">    <span class="keyword">let</span> firstChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环取出根节点中的节点并放入文档碎片中</span></span><br><span class="line">    <span class="keyword">while</span> (firstChild = el.firstChild) &#123;</span><br><span class="line">      fragment.appendChild(firstChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面编译模板的过程中，前提条件是必须存在根元素节点，传入的根元素节点允许是一个真实的 <code>Dom</code> 元素，也可以是一个选择器，所以我们创建了辅助方法 <code>isElementNode</code> 来帮我们判断传入的元素是否是 <code>Dom</code>，如果是就直接使用，是选择器就获取这个 <code>Dom</code>，最终将这个根节点存入 <code>this.el</code> 属性中。</p><p>解析模板的过程中为了性能，我们应取出根节点内的子节点存放在文档碎片中（内存），需要注意的是将一个 <code>Dom</code> 节点内的子节点存入文档碎片的过程中，会在原来的 <code>Dom</code> 容器中删除这个节点，所以在遍历根节点的子节点时，永远是将第一个节点取出存入文档碎片，直到节点不存在为止。</p><h3 id="编译文档碎片中的结构"><a href="#编译文档碎片中的结构" class="headerlink" title="编译文档碎片中的结构"></a>编译文档碎片中的结构</h3><p>在 Vue 中的模板编译的主要就是两部分，也是浏览器无法解析的部分，元素节点中的指令和文本节点中的 Mustache 语法（双大括号）。</p><figure class="highlight js"><figcaption><span>文件：Compile.js —— 完善</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="keyword">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如过传入的根元素存在，才开始编译</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.el) &#123;</span><br><span class="line">      <span class="comment">// 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片）</span></span><br><span class="line">      <span class="keyword">let</span> fragment = <span class="keyword">this</span>.node2fragment(<span class="keyword">this</span>.el);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">      <span class="comment">// 2、将模板中的指令中的变量和 &#123;&#123;&#125;&#125; 中的变量替换成真实的数据</span></span><br><span class="line">      <span class="keyword">this</span>.compile(fragment);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3、把编译好的 fragment 再塞回页面中</span></span><br><span class="line">      <span class="keyword">this</span>.el.appendChild(fragment);</span><br><span class="line">      <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 辅助方法 */</span></span><br><span class="line">  <span class="comment">// 判断是否是元素节点</span></span><br><span class="line">  isElementNode(node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  <span class="comment">// 判断属性是否为指令</span></span><br><span class="line">  isDirective(name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name.includes(<span class="string">'v-'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 核心方法 */</span></span><br><span class="line">  <span class="comment">// 将根节点转移至文档碎片</span></span><br><span class="line">  node2fragment(el) &#123;</span><br><span class="line">    <span class="comment">// 创建文档碎片</span></span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="comment">// 第一个子节点</span></span><br><span class="line">    <span class="keyword">let</span> firstChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环取出根节点中的节点并放入文档碎片中</span></span><br><span class="line">    <span class="keyword">while</span> (firstChild = el.firstChild) &#123;</span><br><span class="line">      fragment.appendChild(firstChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ********** 以下为新增代码 **********</span></span><br><span class="line">  <span class="comment">// 解析文档碎片</span></span><br><span class="line">  compile(fragment) &#123;</span><br><span class="line">    <span class="comment">// 当前父节点节点的子节点，包含文本节点，类数组对象</span></span><br><span class="line">    <span class="keyword">let</span> childNodes = fragment.childNodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成数组并循环判断每一个节点的类型</span></span><br><span class="line">    <span class="built_in">Array</span>.from(childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isElementNode(node)) &#123; <span class="comment">// 是元素节点</span></span><br><span class="line">        <span class="comment">// 递归编译子节点</span></span><br><span class="line">        <span class="keyword">this</span>.compile(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译元素节点的方法</span></span><br><span class="line">        <span class="keyword">this</span>.compileElement(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 是文本节点</span></span><br><span class="line">        <span class="comment">// 编译文本节点的方法</span></span><br><span class="line">        <span class="keyword">this</span>.compileText(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译元素</span></span><br><span class="line">  compileElement(node) &#123;</span><br><span class="line">    <span class="comment">// 取出当前节点的属性，类数组</span></span><br><span class="line">    <span class="keyword">let</span> attrs = node.attributes;</span><br><span class="line">    <span class="built_in">Array</span>.form(attrs).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取属性名，判断属性是否为指令，即含 v-</span></span><br><span class="line">      <span class="keyword">let</span> attrName = attr.name;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isDirective(attrName)) &#123;</span><br><span class="line">        <span class="comment">// 如果是指令，取到该属性值得变量在 data 中对应得值，替换到节点中</span></span><br><span class="line">        <span class="keyword">let</span> exp = attr.value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出方法名</span></span><br><span class="line">        <span class="keyword">let</span> [, type] = attrName.split(<span class="string">'-'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用指令对应得方法</span></span><br><span class="line">        CompileUtil[type](node, <span class="keyword">this</span>.vm, exp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译文本</span></span><br><span class="line">  compileText(node) &#123;</span><br><span class="line">    <span class="comment">// 获取文本节点的内容</span></span><br><span class="line">    <span class="keyword">let</span> exp = node.contentText;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建匹配 &#123;&#123;&#125;&#125; 的正则表达式</span></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;([^&#125;+])\&#125;\&#125;/g</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在 &#123;&#123;&#125;&#125; 则使用 text 指令的方法</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(exp)) &#123;</span><br><span class="line">      CompileUtil[<span class="string">'text'</span>](node, <span class="keyword">this</span>.vm, exp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ********** 以上为新增代码 **********</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码新增内容得主要逻辑就是做了两件事：</p><ul><li>调用 <code>compile</code> 方法对 <code>fragment</code> 文档碎片进行编译，即替换内部指令和 Mustache 语法中变量对应的值；</li><li>将编译好的 <code>fragment</code> 文档碎片塞回根节点。</li></ul><p>在第一个步骤当中逻辑是比较繁琐的，首先在 <code>compile</code> 方法中获取所有的子节点，循环进行编译，如果是元素节点需要递归 <code>compile</code>，传入当前元素节点。在这个过程当中抽取出了两个方法，<code>compileElement</code> 和 <code>compileText</code> 用来对元素节点的属性和文本节点进行处理。</p><p><code>compileElement</code> 中的核心逻辑就是处理指令，取出元素节点所有的属性判断是否是指令，是指令则调用指令对应的方法。<code>compileText</code> 中的核心逻辑就是取出文本的内容通过正则表达式匹配出被 Mustache 语法的 “&#123;&#123; &#125;&#125;” 包裹的内容，并调用处理文本的 <code>text</code> 方法。</p><p>文本节点的内容有可能存在 “&#123;&#123; &#125;&#125; &#123;&#123; &#125;&#125; &#123;&#123; &#125;&#125;”，正则匹配默认是贪婪的，为了防止第一个 “&#123;” 和最后一个 “&#125;” 进行匹配，所以在正则表达式中应使用非贪婪匹配。</p><p>在调用指令的方法时都是调用的 <code>CompileUtil</code> 下对应的方法，我们之所以单独把这些指令对应的方法抽离出来存储在 <code>CompileUtil</code> 对象下的目的是为了解耦，因为后面其他的类还要使用。</p><h3 id="CompileUtil-对象中指令方法的实现"><a href="#CompileUtil-对象中指令方法的实现" class="headerlink" title="CompileUtil 对象中指令方法的实现"></a>CompileUtil 对象中指令方法的实现</h3><p><code>CompileUtil</code> 中存储着所有的指令方法及指令对应的更新方法，由于 Vue 的指令很多，我们这里只实现比较典型的 <code>v-model</code> 和 “&#123;&#123; &#125;&#125;” 对应的方法，考虑到后续更新的情况，我们统一把设置值到 <code>Dom</code> 中的逻辑抽取出对应上面两种情况的方法，存放到 <code>CompileUtil</code> 的 <code>updater</code> 对象中。</p><figure class="highlight js"><figcaption><span>文件：CompileUtil.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompileUtil = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点数据的方法</span></span><br><span class="line">CompileUti.updater = &#123;</span><br><span class="line">  <span class="comment">// 文本更新</span></span><br><span class="line">  textUpdater(node, value) &#123;</span><br><span class="line">    node.textContent = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输入框更新</span></span><br><span class="line">  modelUpdater(node, value) &#123;</span><br><span class="line">    node.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这部分的整个思路就是在 <code>Compile</code> 编译模板后处理 <code>v-model</code> 和 “&#123;&#123; &#125;&#125;” 时，其实都是用 <code>data</code> 中的数据替换掉 <code>fragment</code> 文档碎片中对应的节点中的变量。因此会经常性的获取 <code>data</code> 中的值，在更新节点时又会重新设置 <code>data</code> 中的值，所以我们抽离出了三个方法 <code>getVal</code>、<code>getTextVal</code> 和 <code>setVal</code> 挂在了 <code>CompileUtil</code> 对象下。</p><figure class="highlight js"><figcaption><span>文件：CompileUtil.js —— 取值方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 data 值的方法</span></span><br><span class="line">CompileUtil.getVal = <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将匹配的值用 . 分割开，如 vm.data.a.b</span></span><br><span class="line">  exp = exp.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并取值</span></span><br><span class="line">  <span class="keyword">return</span> exp.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev[next];</span><br><span class="line">  &#125;, vm.$data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文本 &#123;&#123;&#125;&#125; 中变量在 data 对应的值</span></span><br><span class="line">CompileUtil.getTextVal = <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用正则匹配出 &#123;&#123; &#125;&#125; 间的变量名，再调用 getVal 获取值</span></span><br><span class="line">  <span class="keyword">return</span> exp.replace(<span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>, (...args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getVal(vm, args[<span class="number">1</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 data 值的方法</span></span><br><span class="line">CompileUtil.setVal = <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp, newVal</span>) </span>&#123;</span><br><span class="line">  exp = exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">return</span> exp.reduce(<span class="function">(<span class="params">prev, next, currentIndex</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前归并的为数组的最后一项，则将新值设置到该属性</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex === exp.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> prev[next] = newVal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续归并</span></span><br><span class="line">    <span class="keyword">return</span> prev[next];</span><br><span class="line">  &#125;, vm.$data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取和设置 <code>data</code> 的值两个方法 <code>getVal</code> 和 <code>setVal</code> 思路相似，由于获取的变量层级不定，可能是 <code>data.a</code>，也可能是 <code>data.obj.a.b</code>，所以都是使用归并的思路，借用 <code>reduce</code> 方法实现的，区别在于 <code>setVal</code> 方法在归并过程中需要判断是不是归并到最后一级，如果是则设置新值，而 <code>getTextVal</code> 就是在 <code>getVal</code> 外包了一层处理 “&#123;&#123; &#125;&#125;” 的逻辑。</p><p>在这些准备工作就绪以后就可以实现我们的主逻辑，即对 <code>Compile</code> 类中解析的文本节点和元素节点指令中的变量用 <code>data</code> 值进行替换，还记得前面说针对 <code>v-model</code> 和 “&#123;&#123; &#125;&#125;” 进行处理，因此设计了 <code>model</code> 和 <code>text</code> 两个核心方法。</p><p><code>CompileUtil.model</code> 方法的实现：</p><figure class="highlight js"><figcaption><span>文件：CompileUtil.js —— model 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理 v-model 指令的方法</span></span><br><span class="line">CompileUtil.model = <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取赋值的方法</span></span><br><span class="line">  <span class="keyword">const</span> updateFn = <span class="keyword">this</span>.updater[<span class="string">'modelUpdater'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 data 中对应的变量的值</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="keyword">this</span>.getVal(vm, exp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加观察者，作用与 text 方法相同</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, exp, newValue =&gt; &#123;</span><br><span class="line">    updateFn &amp;&amp; updateFn(node, newValue);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v-model 双向数据绑定，对 input 添加事件监听</span></span><br><span class="line">  node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取输入的新值</span></span><br><span class="line">    <span class="keyword">let</span> newValue = e.target.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新到节点</span></span><br><span class="line">    <span class="keyword">this</span>.setVal(vm, exp, newValue);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一次设置值</span></span><br><span class="line">  updateFn &amp;&amp; updateFn(vm, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>CompileUtil.text</code> 方法的实现：</p><figure class="highlight js"><figcaption><span>文件：CompileUtil.js —— text 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理文本节点 &#123;&#123;&#125;&#125; 的方法</span></span><br><span class="line">CompileUtil.text = <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取赋值的方法</span></span><br><span class="line">  <span class="keyword">const</span> updateFn = <span class="keyword">this</span>.updater[<span class="string">'textUpdater'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 data 中对应的变量的值</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="keyword">this</span>.getTextVal(vm, exp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过正则替换，将取到数据中的值替换掉 &#123;&#123; &#125;&#125;</span></span><br><span class="line">  exp.replace(<span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>, (...args) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 解析时遇到了模板中需要替换为数据值的变量时，应该添加一个观察者</span></span><br><span class="line">    <span class="comment">// 当变量重新赋值时，调用更新值节点到 Dom 的方法</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, arg[<span class="number">1</span>], newValue =&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果数据发生变化，重新获取新值</span></span><br><span class="line">      updateFn &amp;&amp; updateFn(node, newValue);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一次设置值</span></span><br><span class="line">  updateFn &amp;&amp; updateFn(vm, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面两个方法逻辑相似，都获取了各自的 <code>updater</code> 中的方法，对值进行设置，并且在设置的同时为了后续 <code>data</code> 中的数据修改，视图的更新，创建了 <code>Watcher</code> 的实例，并在内部用新值重新更新节点，不同的是 Vue 的 <code>v-model</code> 指令在表单中实现了双向数据绑定，只要表单元素的 <code>value</code> 值发生变化，就需要将新值更新到 <code>data</code> 中，并响应到页面上。</p><p>所以我们的实现方式是给这个绑定了 <code>v-model</code> 的表单元素监听了 <code>input</code> 事件，并在事件中实时的将新的 <code>value</code> 值更新到 <code>data</code> 中，至于 <code>data</code> 中的改变后响应到页面中需要另外三个类 <code>Watcher</code>、<code>Observer</code> 和 <code>Dep</code> 共同实现，我们下面就来实现 <code>Watcher</code> 类。</p><h2 id="观察者-Watcher-类的实现"><a href="#观察者-Watcher-类的实现" class="headerlink" title="观察者 Watcher 类的实现"></a>观察者 Watcher 类的实现</h2><p>在 <code>CompileUtil</code> 对象的方法中创建 <code>Watcher</code> 实例的时候传入了三个参数，即 <code>MVVM</code> 的实例、模板绑定数据的变量名 <code>exp</code> 和一个 <code>callback</code>，这个 <code>callback</code> 内部逻辑是为了更新数据到 <code>Dom</code>，所以我们的 <code>Watcher</code> 类内部要做的事情就清晰了，获取更改前的值存储起来，并创建一个 <code>update</code> 实例方法，在值被更改时去执行实例的 <code>callback</code> 以达到视图的更新。</p><figure class="highlight js"><figcaption><span>文件：Watcher.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, exp, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.exp = exp;</span><br><span class="line">    <span class="keyword">this</span>.callback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改前的值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// 将当前的 watcher 添加到 Dep 类的静态属性上</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取值触发数据劫持</span></span><br><span class="line">    <span class="keyword">let</span> value = CompileUtil.getVal(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.exp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 Dep 上的 Watcher，防止重复添加</span></span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获取新值</span></span><br><span class="line">    <span class="keyword">let</span> newValue = CompileUtil.getVal(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.exp);</span><br><span class="line">    <span class="comment">// 获取旧值</span></span><br><span class="line">    <span class="keyword">let</span> oldValue = <span class="keyword">this</span>.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新值和旧值不相等，就执行 callback 对 dom 进行更新</span></span><br><span class="line">    <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callback(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到上面代码一定有两个疑问：</p><ul><li>使用 <code>get</code> 方法获取旧值得时候为什么要将当前的实例挂在 <code>Dep</code> 上，在获取值后为什么又清空了；</li><li><code>update</code> 方法内部执行了 <code>callback</code> 函数，但是 <code>update</code> 在什么时候执行。</li></ul><p>这就是后面两个类 <code>Dep</code> 和 <code>observer</code> 要做的事情，我们首先来介绍 <code>Dep</code>，再介绍 <code>Observer</code> 最后把他们之间的关系整个串联起来。</p><h2 id="发布订阅-Dep-类的实现"><a href="#发布订阅-Dep-类的实现" class="headerlink" title="发布订阅 Dep 类的实现"></a>发布订阅 Dep 类的实现</h2><p>其实发布订阅说白了就是把要执行的函数统一存储在一个数组中管理，当达到某个执行条件时，循环这个数组并执行每一个成员。</p><figure class="highlight js"><figcaption><span>文件：Dep.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加订阅</span></span><br><span class="line">  addSub(watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(watcher);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher.update());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Dep</code> 类中只有一个属性，就是一个名为 <code>subs</code> 的数组，用来管理每一个 <code>watcher</code>，即 <code>Watcher</code> 类的实例，而 <code>addSub</code> 就是用来将 <code>watcher</code> 添加到 <code>subs</code> 数组中的，我们看到 <code>notify</code> 方法就解决了上面的一个疑问，<code>Watcher</code> 类的 <code>update</code> 方法是怎么执行的，就是这样循环执行的。</p><p>接下来我们整合一下盲点：</p><ul><li><code>Dep</code> 实例在哪里创建声明，又是在哪里将 <code>watcher</code> 添加进 <code>subs</code> 数组的；</li><li><code>Dep</code> 的 <code>notify</code> 方法应该在哪里调用；</li><li><code>Watcher</code> 内容中，使用 <code>get</code> 方法获取旧值得时候为什么要将当前的实例挂在 <code>Dep</code> 上，在获取值后为什么又清空了。</li></ul><p>这些问题在最后一个类 <code>Observer</code> 实现的时候都将清晰，下面我们重点来看最后一部分核心逻辑。</p><h2 id="数据劫持-Observer-类的实现"><a href="#数据劫持-Observer-类的实现" class="headerlink" title="数据劫持 Observer 类的实现"></a>数据劫持 Observer 类的实现</h2><p>还记得实现 <code>MVVM</code> 类的时候就创建了这个类的实例，当时传入的参数是 <code>MVVM</code> 实例的 <code>data</code> 属性，在 <code>MVVM</code> 中把数据通过 <code>Object.defineProperty</code> 挂到了实例上，并添加了 <code>getter</code> 和 <code>setter</code>，其实 <code>Observer</code> 类主要目的就是给 <code>data</code> 内的所有层级的数据都进行这样的操作。</p><figure class="highlight js"><figcaption><span>文件：Observer.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observe(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加数据监听</span></span><br><span class="line">  observe(data) &#123;</span><br><span class="line">    <span class="comment">// 验证 data</span></span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要对这个 data 数据将原有的属性改成 set 和 get 的形式</span></span><br><span class="line">    <span class="comment">// 要将数据一一劫持，先获取到 data 的 key 和 value</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 劫持（实现数据响应式）</span></span><br><span class="line">      <span class="keyword">this</span>.defineReactive(data, key, data[key]);</span><br><span class="line">      <span class="keyword">this</span>.observe(data[key]); <span class="comment">// 深度劫持</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数据响应式</span></span><br><span class="line">  defineReactive (object, key, value) &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 每个变化的数据都会对应一个数组，这个数组是存放所有更新的操作</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取某个值被监听到</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(object, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123; <span class="comment">// 当取值时调用的方法</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newValue) &#123; <span class="comment">// 当给 data 属性中设置的值适合，更改获取的属性的值</span></span><br><span class="line">        <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">          _this.observe(newValue); <span class="comment">// 重新赋值如果是对象进行深度劫持</span></span><br><span class="line">          value = newValue;</span><br><span class="line">          dep.notify(); <span class="comment">// 通知所有人数据更新了</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在的代码中 <code>observe</code> 的目的是遍历对象，在内部对数据进行劫持，即添加 <code>getter</code> 和 <code>setter</code>，我们把劫持的逻辑单独抽取成 <code>defineReactive</code> 方法，需要注意的是 <code>observe</code> 方法在执行最初就对当前的数据进行了数据类型验证，然后再循环对象每一个属性进行劫持，目的是给同为 <code>Object</code> 类型的子属性递归调用 <code>observe</code> 进行深度劫持。</p><p>在 <code>defineReactive</code> 方法中，创建了 <code>Dep</code> 的实例，并对 <code>data</code> 的数据使用 <code>get</code> 和 <code>set</code> 进行劫持，还记得在模板编译的过程中，遇到模板中绑定的变量，就会解析，并创建 <code>watcher</code>，会在 <code>Watcher</code> 类的内部获取旧值，即当前的值，这样就触发了 <code>get</code>，在 <code>get</code> 中就可以将这个 <code>watcher</code> 添加到 <code>Dep</code> 的 <code>subs</code> 数组中进行统一管理，因为在代码中获取 <code>data</code> 中的值操作比较多，会经常触发 <code>get</code>，我们又要保证 <code>watcher</code> 不会被重复添加，所以在 <code>Watcher</code> 类中，获取旧值并保存后，立即将 <code>Dep.target</code> 赋值为 <code>null</code>，并且在触发 <code>get</code> 时对 <code>Dep.target</code> 进行了短路操作，存在才调用 <code>Dep</code> 的 <code>addSub</code> 进行添加。</p><p>而 <code>data</code> 中的值被更改时，会触发 <code>set</code>，在 <code>set</code> 中做了性能优化，即判断重新赋的值与旧值是否相等，如果相等就不重新渲染页面，不等的情况有两种，如果原来这个被改变的值是基本数据类型没什么影响，如果是引用类型，我们需要对这个引用类型内部的数据进行劫持，因此递归调用了 <code>observe</code>，最后调用 <code>Dep</code> 的 <code>notify</code> 方法进行通知，执行 <code>notify</code> 就会执行 <code>subs</code> 中所有被管理的 <code>watcher</code> 的 <code>update</code>，就会执行创建 <code>watcher</code> 时的传入的 <code>callback</code>，就会更新页面。</p><p>在 <code>MVVM</code> 类将 <code>data</code> 的属性挂在 <code>MVVM</code> 实例上并劫持与通过 <code>Observer</code> 类对 <code>data</code> 的劫持还有一层联系，因为整个发布订阅的逻辑都是在 <code>data</code> 的 <code>get</code> 和 <code>set</code> 上，只要触发了 <code>MVVM</code> 中的 <code>get</code> 和 <code>set</code> 内部会自动返回或设置 <code>data</code> 对应的值，就会触发 <code>data</code> 的 <code>get</code> 和 <code>set</code>，就会执行发布订阅的逻辑。</p><p>通过上面长篇大论的叙述后，这个 MVVM 模式用到的几个类的关系应该完全叙述清晰了，虽然比较抽象，但是细心琢磨还是会明白之间的关系和逻辑，下面我们就来对我们自己实现的这个 MVVM 进行验证。</p><h2 id="验证-MVVM"><a href="#验证-MVVM" class="headerlink" title="验证 MVVM"></a>验证 MVVM</h2><p>我们按照 Vue 的方式根据自己的 MVVM 实现的内容简单的写了一个模板如下：</p><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>MVVM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 双向数据绑定 靠的是表单 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 引入依赖的 js 文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/Watcher.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/Observer.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/Compile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/CompileUtil.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/Dep.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/MVVM.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> MVVM(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        message: <span class="string">'hello world!'</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开 Chrom 浏览器的控制台，在上面通过下面操作来验证：</p><ul><li>输入 <code>vm.message = &#39;hello&#39;</code> 看页面是否更新；</li><li>输入 <code>vm.$data.message = &#39;hello&#39;</code> 看页面是否更新；</li><li>改变文本输入框内的值，看页面的其他元素是否更新。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>通过上面的测试，相信应该理解了 MVVM 模式对于前端开发重大的意义，实现了双向数据绑定，实时保证 View 层与 Model 层的数据同步，并可以让我们在开发时基于数据编程，而最少的操作 <code>Dom</code>，这样大大提高了页面渲染的性能，也可以使我们把更多的精力用于业务逻辑的开发上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> Vue </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析 event-loop 事件轮询</title>
      <link href="/2018/03/25/20180325170208/"/>
      <url>/2018/03/25/20180325170208/</url>
      
        <content type="html"><![CDATA[<img src="/2018/03/25/20180325170208/libuv.png" title="event-loop"><p><br></p><h2 id="浏览器中的事件轮询"><a href="#浏览器中的事件轮询" class="headerlink" title="浏览器中的事件轮询"></a>浏览器中的事件轮询</h2><blockquote class="pullquote default"><p>JavaScript 是一门单线程语言，之所以说是单线程，是因为在浏览器中，如果是多线程，并且两个线程同时操作了同一个 Dom 元素，那最后的结果会出现问题。所以，JavaScript 是单线程的，但是如果完全由上至下的一行一行执行代码，假如一个代码块执行了很长的时间，后面必须要等待当前执行完毕，这样的效率是非常低的，所以有了异步的概念，确切的说，JavaScript 的主线程是单线程的，但是也有其他的线程去帮我们实现异步操作，比如定时器线程、事件线程、Ajax 线程。</p></blockquote><p>在浏览器中执行 JavaScript 有两个区域，一个是我们平时所说的同步代码执行，是在栈中执行，原则是先进后出，而在执行异步代码的时候分为两个队列，<code>macro-task</code>（宏任务）和 <code>micro-task</code>（微任务），遵循先进先出的原则。</p><a id="more"></a><figure class="highlight js"><figcaption><span>作用域链</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    three();</span><br><span class="line">  &#125;</span><br><span class="line">  two();</span><br><span class="line">&#125;</span><br><span class="line">one();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面的代码都是同步的代码，在执行的时候先将全局作用域放入栈中，执行全局作用域中的代码，解析了函数 <code>one</code>，当执行函数调用 <code>one()</code> 的时候将 <code>one</code> 的作用域放入栈中，执行 <code>one</code> 中的代码，打印了 <code>1</code>，解析了 <code>two</code>，执行 <code>two()</code>，将 <code>two</code> 放入栈中，执行 <code>two</code>，打印了 <code>2</code>，解析了 <code>three</code>，执行了 <code>three()</code>，将 <code>three</code> 放入栈中，执行 <code>three</code>，打印了 <code>3</code>。</p><p>在函数执行完释放的过程中，因为全局作用域中有 <code>one</code> 正在执行，<code>one</code> 中有 <code>two</code> 正在执行，<code>two</code> 中有 <code>three</code> 正在执行，所以释放内存时必须由内层向外层释放，<code>three</code> 执行后释放，此时 <code>three</code> 不再占用 <code>two</code> 的执行环境，将 <code>two</code> 释放，<code>two</code> 不再占用 <code>one</code> 的执行环境，将 <code>one</code> 释放，<code>one</code> 不再占用全局作用域的执行环境，最后释放全局作用域，这就是在栈中执行同步代码时的先进后出原则，更像是一个杯子，先放进去的在最下面，需要最后取出。</p><p>而异步队列更像时一个管道，有两个口，从入口进，从出口出，所以是先进先出，在宏任务队列中代表的有 <code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>MessageChannel</code>，微任务的代表为 Promise 的 <code>then</code> 方法、<code>MutationObserve</code>（已废弃）。</p><p><strong>案例 1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> messageChannel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">const</span> prot2 = messageChannel.port2;</span><br><span class="line"></span><br><span class="line">messageChannel.port1.postMessage(<span class="string">'I love you'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">prot2.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// I love you</span></span><br></pre></td></tr></table></figure><p>从上面案例中可以看出，<code>MessageChannel</code> 是宏任务，晚于同步代码执行。</p><p><strong>案例 2</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">2000</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码可以看出其实 <code>setTimeout</code> 并不是在同步代码执行的时候就放入了异步队列，而是等待时间到达时才会放入异步队列，所以才会有了上面的结果。</p><p><strong>案例 3</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br><span class="line"><span class="comment">// setImmediate</span></span><br></pre></td></tr></table></figure><p>同为宏任务，<code>setImmediate</code> 在 <code>setTimeout</code> 延迟时间为 <code>0</code> 时是晚于 <code>setTimeout</code> 被放入异步队列的，这里需要注意的是 <code>setImmediate</code> 在浏览器端，到目前为止只有 IE 实现了。</p><p>上面的案例都是关于宏任务，下面我们举一个有微任务的案例来看一看微任务和宏任务的执行机制，在浏览器端微任务的代表其实就是 Promise 的 <code>then</code> 方法。</p><p><strong>案例 4</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise2</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>从上面的执行结果其实可以看出，同步代码在栈中执行完毕后会先去执行微任务队列，将微任务队列执行完毕后，会去执行宏任务队列，宏任务队列执行一个宏任务以后，会去看看有没有产生新的微任务，如果有则清空微任务队列后再执行下一个宏任务，依次轮询，直到清空整个异步队列。</p></blockquote><h2 id="Node-中的事件轮询"><a href="#Node-中的事件轮询" class="headerlink" title="Node 中的事件轮询"></a>Node 中的事件轮询</h2><blockquote class="pullquote primary"><p>在 Node 中的事件轮询机制与浏览器相似又不同，相似的是，同样先在栈中执行同步代码，同样是先进后出，不同的是 Node 有自己的多个处理不同问题的阶段和对应的队列，也有自己内部实现的微任务 <code>process.nextTick</code>，Node 的整个事件轮询机制是 Libuv 库实现的。</p></blockquote><p><strong>Node 中事件轮询的流程如下图：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/25/20180325170208/event-loop.jpg" alt="Node 事件环流程图" title>                </div>                <div class="image-caption">Node 事件环流程图</div>            </figure><p><br></p><blockquote class="pullquote info"><p>从图中可以看出，在 Node 中有多个队列，分别执行不同的操作，而每次在队列切换的时候都去执行一次微任务队列，反复的轮询。</p></blockquote><p><strong>案例 1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setInmediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>默认情况下 <code>setTimeout</code> 和 <code>setImmediate</code> 是不知道哪一个先执行的，顺序不固定，Node 执行的时候有准备的时间，<code>setTimeout</code> 延迟时间设置为 <code>0</code> 其实是大概 <code>4ms</code>，假设 Node 准备时间在 <code>4ms</code> 之内，开始执行轮询，定时器没到时间，所以轮询到下一队列，此时要等再次循环到 <code>timer</code> 队列后执行定时器，所以会先执行 <code>check</code> 队列的 <code>setImmediate</code>。</p><p>如果 Node 执行的准备时间大于了 <code>4ms</code>，因为执行同步代码后，定时器的回调已经被放入 <code>timer</code> 队列，所以会先执行 <code>timer</code> 队列。</p><p><strong>案例 2</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br></pre></td></tr></table></figure><p>Node 事件轮询中，轮询到每一个队列时，都会将当前队列任务清空后，在切换下一队列之前清空一次微任务队列，这是与浏览器端不一样的。</p><p>浏览器端会在宏任务队列当中执行一个任务后插入执行微任务队列，清空微任务队列后，再回到宏任务队列执行下一个宏任务。</p><p>上面案例在 Node 事件轮询中，会将 <code>timer</code> 队列清空后，在轮询下一个队列之前执行微任务队列。</p><p><strong>案例 3</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br></pre></td></tr></table></figure><p>上面代码的执行过程是，先执行栈，栈执行时打印 <code>1</code>，<code>Promise.resolve()</code> 产生微任务，栈执行完毕，从栈切换到 <code>timer</code> 队列之前，执行微任务队列，再去执行 <code>timer</code> 队列。</p><p><strong>案例 4</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果1</span></span><br><span class="line"><span class="comment">// setImmediate1</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br><span class="line"><span class="comment">// setImmediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果2</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br><span class="line"><span class="comment">// setImmediate1</span></span><br><span class="line"><span class="comment">// setImmediate2</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br></pre></td></tr></table></figure><p><code>setImmediate</code> 和 <code>setTimeout</code> 执行顺序不固定，假设 <code>check</code> 队列先执行，会执行 <code>setImmediate</code> 打印 <code>setImmediate1</code>，将遇到的定时器放入 <code>timer</code> 队列，轮询到 <code>timer</code> 队列，因为在栈中执行同步代码已经在 <code>timer</code> 队列放入了一个定时器，所以按先后顺序执行两个 <code>setTimeout</code>，执行第一个定时器打印 <code>setTimeout2</code>，将遇到的 <code>setImmediate</code> 放入 <code>check</code> 队列，执行第二个定时器打印 <code>setTimeout1</code>，再次轮询到 <code>check</code> 队列执行新加入的 <code>setImmediate</code>，打印 <code>setImmediate2</code>，产生结果 <code>1</code>。</p><p>假设 <code>timer</code> 队列先执行，会执行 <code>setTimeout</code> 打印 <code>setTimeout2</code>，将遇到的 <code>setImmediate</code> 放入 <code>check</code> 队列，轮询到 <code>check</code> 队列，因为在栈中执行同步代码已经在 <code>check</code> 队列放入了一个 <code>setImmediate</code>，所以按先后顺序执行两个 <code>setImmediate</code>，执行第一个 <code>setImmediate</code> 打印 <code>setImmediate1</code>，将遇到的 <code>setTimeout</code> 放入 <code>timer</code> 队列，执行第二个 <code>setImmediate</code> 打印 <code>setImmediate2</code>，再次轮询到 <code>timer</code> 队列执行新加入的 <code>setTimeout</code>，打印 <code>setTimeout1</code>，产生结果 <code>2</code>。</p><p><strong>案例 5</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果1</span></span><br><span class="line"><span class="comment">// setImmediate1</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// setImmediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果2</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// setImmediate1</span></span><br><span class="line"><span class="comment">// setImmediate2</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br></pre></td></tr></table></figure><p>这与上面一个案例类似，不同的是在 <code>setTimeout</code> 执行的时候产生了一个微任务 <code>nextTick</code>，我们只要知道，在 Node 事件轮询中，在切换队列时要先去执行微任务队列，无论是 <code>check</code> 队列先执行，还是 <code>timer</code> 队列先执行，都会很容易分析出上面的两个结果。</p><p><strong>案例 6</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./.gitignore'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setImmediate</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure><p>上面案例的 <code>setTimeout</code> 和 <code>setImmediate</code> 的执行顺序是固定的，前面都是不固定的，这是为什么？</p><p>因为前面的不固定是在栈中执行同步代码时就遇到了 <code>setTimeout</code> 和 <code>setImmediate</code>，因为无法判断 Node 的准备时间，不确定准备结束定时器是否到时并加入 <code>timer</code> 队列。</p><p>而上面代码明显可以看出 Node 准备结束后会直接执行 <code>poll</code> 队列进行文件的读取，在回调中将 <code>setTimeout</code> 和 <code>setImmediate</code> 分别加入 <code>timer</code> 队列和 <code>check</code> 队列，Node 队列的轮询是有顺序的，在 <code>poll</code> 队列后应该先切换到 <code>check</code> 队列，然后再重新轮询到 <code>timer</code> 队列，所以得到上面的结果。</p><p><strong>案例 7</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Promise'</span>));</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// Promise</span></span><br></pre></td></tr></table></figure><p>在 Node 中有两个微任务，<code>Promise</code> 的 <code>then</code> 方法和 <code>process.nextTick</code>，从上面案例的结果我们可以看出，在微任务队列中 <code>process.nextTick</code> 是优先执行的。</p><blockquote class="pullquote success"><p>上面内容就是浏览器与 Node 在事件轮询的规则，相信在读完以后应该已经彻底弄清了浏览器的事件轮询机制和 Node 的事件轮询机制，并深刻的体会到了他们之间的相同和不同。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 异步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJS </tag>
            
            <tag> 异步 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 命令总结，从零到熟悉</title>
      <link href="/2017/12/14/20171214024101/"/>
      <url>/2017/12/14/20171214024101/</url>
      
        <content type="html"><![CDATA[<img src="/2017/12/14/20171214024101/git-image.png" title="Git"><p><br></p><h2 id="什么是-Git？"><a href="#什么是-Git？" class="headerlink" title="什么是 Git？"></a>什么是 Git？</h2><blockquote class="pullquote warning"><p><code>Git</code> 是一个免费的开源分布式版本控制系统，它的设计目的是为了速度和效率的处理从小型到大型的项目；Git 可以帮我们管理我们的代码，记录历史，只要代码提交到 Git 上就永久不会丢失，可以随时 “穿越”（回到之前的某一个版本）；可以多端共享，团队协作中，多个人操作了同一个文件时，可以实现自动合并（模块化，组件化）、标记冲突，拥有强大的分支管理系统。</p></blockquote><a id="more"></a><h2 id="Git-与-SVN-的区别"><a href="#Git-与-SVN-的区别" class="headerlink" title="Git 与 SVN 的区别"></a>Git 与 SVN 的区别</h2><p><code>SVN</code>：集中式，需要一台中央服务器，所有代码的拉取和提交都是在中央服务器，一旦中央服务器或者网络出现故障，则不能拉取和提交代码，需要不断去备份中央服务器，防止代码丢失。</p><p><code>Git</code>：分布式，有一个中央服务器的同时，每个开发者本地都有自己的本地仓库，拥有完整的版本库，不用担心代码丢失，Git 存储的是代码变化的快照，更新代码的速度要比 SVN 更快。</p><h2 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h2><p><strong>Windows</strong></p><ul><li><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></li></ul><p><strong>Mac</strong></p><ul><li>如果安装过 <code>Xcode</code> 自带 <code>Git</code>，<a><a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">https://developer.apple.com/xcode/</a></a></li><li>可以安装 Homebrew，是 <code>wmac</code> 的包管理器，<a><a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></a>，下面是两款界面美化插件：<ul><li><code>Oh My ZSH</code>：<a><a href="http://ohmyz.sh/" target="_blank" rel="noopener">http://ohmyz.sh/</a></a></li><li><code>iTerm2</code>：<a><a href="https://www.iterm2.com/" target="_blank" rel="noopener">https://www.iterm2.com/</a></a></li></ul></li></ul><h2 id="常用-Linux-命令"><a href="#常用-Linux-命令" class="headerlink" title="常用 Linux 命令"></a>常用 Linux 命令</h2><h3 id="查看当前工作目录"><a href="#查看当前工作目录" class="headerlink" title="查看当前工作目录"></a>查看当前工作目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 文件夹名</span><br></pre></td></tr></table></figure><h3 id="改变路径"><a href="#改变路径" class="headerlink" title="改变路径"></a>改变路径</h3><figure class="highlight bash"><figcaption><span>进入盘符</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> d:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>进入文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 文件夹名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>回上一级目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>进入某一个路径</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 路径</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>想要进入某一个不知道路径的文件夹中，可以直接拖拽该文件到命令窗口，会自动识别路径。</p></blockquote><h3 id="查看文件列表"><a href="#查看文件列表" class="headerlink" title="查看文件列表"></a>查看文件列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p>下面命令加了 <code>-a</code> 参数可以查看隐藏文件，加了 <code>-al</code> 参数可以查看所有文件及权限位。</p></blockquote><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名</span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 文件/文件夹 路径</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>移动文件时可以通过第二个参数对文件进行重命名操作。</p></blockquote><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 文件/文件夹 路径</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>将文件或者文件夹移动或拷贝到所输入的路径下。</p></blockquote><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件名</span><br></pre></td></tr></table></figure><h3 id="删除文件-文件夹"><a href="#删除文件-文件夹" class="headerlink" title="删除文件 / 文件夹"></a>删除文件 / 文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf 文件夹名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm 文件名</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><code>-rf</code> 为递归删除，后面加上 <code>*</code> 为参数会递归删除整个文件夹的内容，<code>rm -rf *</code>（慎用）。</p></blockquote><h3 id="清空命令窗口"><a href="#清空命令窗口" class="headerlink" title="清空命令窗口"></a>清空命令窗口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><h3 id="查看命令历史"><a href="#查看命令历史" class="headerlink" title="查看命令历史"></a>查看命令历史</h3><figure class="highlight bash"><figcaption><span>直接在命令行中查看</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>将当前 Git 的命令历史写入文件中</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> &gt; 文件名</span><br></pre></td></tr></table></figure><h3 id="使用-vi-编辑器编辑文件"><a href="#使用-vi-编辑器编辑文件" class="headerlink" title="使用 vi 编辑器编辑文件"></a>使用 vi 编辑器编辑文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>进入编辑模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>进入命令模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Esc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>保存并退出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>强制退出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure><h3 id="使用命令编辑文件"><a href="#使用命令编辑文件" class="headerlink" title="使用命令编辑文件"></a>使用命令编辑文件</h3><figure class="highlight bash"><figcaption><span>向文件输入内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 内容 &gt; 文件名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>向文件追加内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 内容 &gt;&gt; 文件名</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>当使用 <code>echo</code> 编辑了一个不存在的文件时，会创建一个新文件并将内容编辑到文件中，而 <code>touch</code> 创建的是空文件。</p></blockquote><h2 id="Git-的本地操作"><a href="#Git-的本地操作" class="headerlink" title="Git 的本地操作"></a>Git 的本地操作</h2><blockquote class="pullquote success"><p>Git 在管理文件时，所有文件都具有三种状态，已修改、已暂存、已提交。<br>Git 在本地仓库中由三部分组成，工作区、暂存区、版本库。<br>Git 管理的文件夹下都有一个名为 <code>.git</code> 的隐藏文件夹。</p></blockquote><p><strong>对应关系如下：</strong></p><ul><li>已修改 → 工作区</li><li>已暂存 → 暂存区（<code>.git</code> 文件夹下的 <code>index</code> 文件中）</li><li>已提交 → 版本库</li></ul><h3 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h3><blockquote class="pullquote warning"><p>不配置用户无法提交代码。</p></blockquote><figure class="highlight bash"><figcaption><span>查看配置信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>配置用户名</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">'你的名字'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>配置邮箱</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">'你的邮箱'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看某一项配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>配置用户信息参数：</p><ul><li><code>--local</code>：只对某一个仓库生效；</li><li><code>--global</code>：对计算机当前用户所有仓库生效；</li><li><code>--system</code>：对计算机整个操作系统生效。</li></ul></blockquote><h3 id="初始化-Git-仓库"><a href="#初始化-Git-仓库" class="headerlink" title="初始化 Git 仓库"></a>初始化 Git 仓库</h3><blockquote class="pullquote warning"><p>在要初始化的文件夹下执行下面命令，告诉 Git 哪个文件夹被 Git 所管理，一个项目初始化一次，不能嵌套。</p></blockquote><figure class="highlight bash"><figcaption><span>把已有项目纳入 Git 管理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目代码所在文件夹</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>新建项目直接用 Git 管理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 希望创建项目的文件夹</span><br><span class="line">git init your_project <span class="comment">#会在当前路径下创建和项目名称同名的文件夹</span></span><br><span class="line"><span class="built_in">cd</span> your_project</span><br></pre></td></tr></table></figure><h3 id="查看-Git-状态"><a href="#查看-Git-状态" class="headerlink" title="查看 Git 状态"></a>查看 Git 状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>文件为红色，代表有修改，文件名为绿色，代表已经加入暂存区。</p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><figure class="highlight bash"><figcaption><span>将单个文件变化提交到暂存区，参数支持多个</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名/文件夹</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>将已经被 Git 管理的文件变化全部提交</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>将修改、添加文件的变化全部提交</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>将修改、添加、删除文件的变化全部提交</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure><h3 id="删除暂存区"><a href="#删除暂存区" class="headerlink" title="删除暂存区"></a>删除暂存区</h3><figure class="highlight bash"><figcaption><span>删除暂存区，工作区不保留，参数支持多个</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件名/文件夹</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>删除暂存区，工作区保留</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>删除全部暂存区</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached . -r</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>当参数为 <code>.</code> 的时候删除全部暂存区，所以需要加上代表递归删除的参数 <code>-r</code>。</p></blockquote><h3 id="重命名暂存区文件"><a href="#重命名暂存区文件" class="headerlink" title="重命名暂存区文件"></a>重命名暂存区文件</h3><figure class="highlight bash"><figcaption><span>方式一（不常用）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv oldname newname</span><br><span class="line">git rm oldname</span><br><span class="line">git add newname</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>方式二</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv oldname newname</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>当对一个已被 <code>Git</code> 管理的文件使用 <code>mv</code> 重命名时，执行 <code>git status</code> 命令时，会提示删除该文件（旧名字），新增该文件（新名字），使用 <code>git rm</code>、<code>git add</code> 命令进行删除和添加，执行 <code>git status</code> 命令时会提示该文件从 <code>renamed: oldname -&gt; newname</code>，而 <code>git mv</code> 命令等于将上面三个步骤合并成一个。</p></blockquote><blockquote class="pullquote warning"><p><strong>注意：<code>OS</code> 系统中大小写不敏感，重命名后的文件名只是大小写改变，<code>git mv</code> 命令执行会失效。</strong></p></blockquote><h3 id="提交到版本库"><a href="#提交到版本库" class="headerlink" title="提交到版本库"></a>提交到版本库</h3><figure class="highlight bash"><figcaption><span>从暂存区提交到版本库</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'版本信息'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>从工作区直接提交到版本库（需要之前添加过暂存区）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am <span class="string">'版本信息'</span></span><br></pre></td></tr></table></figure><h3 id="查看提交日志（版本库）"><a href="#查看提交日志（版本库）" class="headerlink" title="查看提交日志（版本库）"></a>查看提交日志（版本库）</h3><figure class="highlight bash"><figcaption><span>最详细的信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看某一个分支的提交历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> 分支名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>单行查看，只有版本号和提交信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --online</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看最近 4 个提交，数字根据需要配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n4</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看所有分支的提交历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看所有分支图形化的提交历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --graph</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看全部版本记录，包含被删除的提交记录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>以列表的方式查看单个文件的提交</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame 文件名</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><ul><li><code>--oneline</code>、<code>-n*</code>（<code>n</code> 可省略）、<code>--all</code> 和 <code>--graph</code> 等参数可以组合使用；</li><li><code>log</code> 和 <code>reflog</code> 的区别在于 <code>reflog</code> 可以查看被删除的提交记录，当想回退被删除的提交时使用；</li><li>查看图形化分支时，红色线代表主分支，绿色线代表新创建的分支，分支上的 <code>*</code> 代表提交到版本库的节点。</li></ul></blockquote><h3 id="查看-Git-命令-Web-文档"><a href="#查看-Git-命令-Web-文档" class="headerlink" title="查看 Git 命令 Web 文档"></a>查看 Git 命令 Web 文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> --web 命令</span><br></pre></td></tr></table></figure><h3 id="暂存更改"><a href="#暂存更改" class="headerlink" title="暂存更改"></a>暂存更改</h3><blockquote class="pullquote primary"><p>分支工作区有更改不能直接切换其他分支，可以提交更改或者暂存更改，若暂存更改（使用暂存区覆盖掉工作区），等待重新切回分支时，还原暂存。<br>此处所说的暂存不是之前的将代码提交到暂存区，因为当前分支工作区的代码会变成要切换分支工作区的代码，而导致当前分支工作区的更改丢失，此处的暂存类似于将修改寄存，重新切回该分支时再还原。</p></blockquote><figure class="highlight bash"><figcaption><span>暂存更改</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看暂存列表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash --list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>还原暂存的内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply|pop stash@&#123;n&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><code>apply</code> 与 <code>pop</code> 都是用于还原暂存的内容到工作区，<code>stash@{n}</code> 代表还原指定的暂存，<code>n</code> 代表暂存的序号，若省略 <code>stash@{n}</code> 则代表默认取出最新的暂存，<code>apply</code> 与 <code>pop</code> 的区别是，<code>apply</code> 还原的暂存，在暂存栈中依然存在，可多次还原，<code>pop</code> 还原的暂存在覆盖到工作区同时，暂存栈中删除该暂存。</p></blockquote><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight bash"><figcaption><span>查看本地分支及分支最后一次提交信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看本地分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看所有分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看所有分支及最后一次提交信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br></pre></td></tr></table></figure><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><figure class="highlight bash"><figcaption><span>从当前所在分支的 commit 创建分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>基于已有分支的 commit 创建分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支名 分支名</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>注意：</strong></p><ul><li><em><strong>新创建的分支和主分支 <code>master</code> 还是同一个区域，新建的文件只有提交到新分支的版本库才真正脱离关系；</strong></em></li><li><em><strong><code>Git</code> 刚刚初始化管理的的文件夹必须有一次提交到版本库（<code>root-commit</code>：根提交）以后才会有主分支 <code>master</code>，否则即使创建了新分支也无法切换回 <code>master</code>。</strong></em></li></ul></blockquote><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight bash"><figcaption><span>切换分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>创建并切换分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight bash"><figcaption><span>删除已经合并的分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>删除未合并的分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D 分支名</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p>需切换出要删除的分支，才能进行删除操作，使用 <code>-d</code> 在删除前 <code>Git</code> 会判断在该分支上开发的功能是否被 <code>merge</code> 到其它分支，如果没有，不能删除，如果 <code>merge</code> 到其它分支，但之后又在其上做了开发，使用 <code>-d</code> 还是不能删除，<code>-D</code> 会强制删除。</p></blockquote><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><blockquote class="pullquote success"><p>将指定分支合并到当前所在的分支，所以，在分支开发完毕后，合并分支需要先切换回目标分支。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 指定的分支名</span><br></pre></td></tr></table></figure><h3 id="比较变更"><a href="#比较变更" class="headerlink" title="比较变更"></a>比较变更</h3><figure class="highlight bash"><figcaption><span>两个不同分支的比较，文件名参数省略比较所有文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 分支1 分支2 文件名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>两个不同的 commit 比较，文件名参数省略比较所有文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 61db01a 968adc7 文件名</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><code>commit</code> 也可以用 <code>HEAD</code> 指代当前 <code>HEAD</code> 所在的提交，参数详情如下：</p><ul><li><code>HEAD^</code>：父节点；</li><li><code>HEAD^n</code>：第 <code>n</code> 个父节点；</li><li><code>HEAD^^</code>：父节点的父节点；</li><li><code>HEAD～</code>：父节点；</li><li><code>HEAD～2</code>：父节点的父节点。</li></ul><p><code>HEAD^^</code> 等同于 <code>HEAD～2</code>，一个节点可以有多个子节点（在某个 <code>commit</code> 下创建多个分支），也可以有多个父节点（多个分支的 <code>commit</code> 合并）。</p></blockquote><figure class="highlight bash"><figcaption><span>工作区和暂存区比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>工作区和版本库比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 分支名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>暂存区和版本库比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached|--staged</span><br></pre></td></tr></table></figure><h3 id="撤销和回退操作"><a href="#撤销和回退操作" class="headerlink" title="撤销和回退操作"></a>撤销和回退操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 文件名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>撤销某一个版本的文件到工作区</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 版本号 文件名</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>撤销操作是将暂存区覆盖到工作区，会放弃掉当前工作区修改的内容，. 参数是将整个暂存区覆盖当前工作区，一旦撤销就回不到之前的工作区了。<br>当不小心将当前工作区错误的代码提交到暂存区，可以使用下面命令将暂存区回滚到上一个暂存区，只可回滚一次。</p></blockquote><figure class="highlight bash"><figcaption><span>文件名参数，省略后为撤销全部文件更改的暂存</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD 文件名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>按版本号回退版本</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>回退到上一个版本</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><code>reset</code> 指令的参数有三种，区别如下：</p><ul><li><code>--mixed</code>：默认参数，可省略，暂存区、版本库修改为指定的 <code>commit</code> 状态；</li><li><code>--soft</code>：只将版本库修改为指定的 <code>commit</code> 状态；</li><li><code>--hard</code>：工作区、暂存区、版本库都修改为指定的 <code>commit</code> 状态。</li></ul></blockquote><blockquote class="pullquote danger"><p><em><strong>注意：当想要改变工作区内容时使用 <code>checkout</code>，当想要改变暂存区内容时使用 <code>reset</code>。</strong></em></p></blockquote><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><blockquote class="pullquote success"><p>当创建分支后，分支和 <code>master</code> 主分支分别提交代码到版本库，此时切换回 <code>master</code> 主分支，合并分支会出现冲突，需手动处理后，重新提交到暂存区并提交到版本库。</p></blockquote><figure class="highlight plain"><figcaption><span>代码冲突</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改)</span><br><span class="line">master 分支代码</span><br><span class="line">=======</span><br><span class="line">开发分支的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 开发的分支 (传入的更改)</span><br></pre></td></tr></table></figure><h2 id="Git-操作远程仓库"><a href="#Git-操作远程仓库" class="headerlink" title="Git 操作远程仓库"></a>Git 操作远程仓库</h2><blockquote class="pullquote default"><p>远程仓库可以是 <code>Github</code>、<code>Gitee</code>（码云）、<code>Coding</code> 或者中央服务器等等。</p></blockquote><p><strong>以下是常用免费仓库的地址，可以在首页注册账号：</strong></p><ul><li><strong>Github：</strong> <a><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></a></li><li><strong>Gitee：</strong> <a><a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a></a></li><li><strong>Coding：</strong> <a><a href="https://coding.net" target="_blank" rel="noopener">https://coding.net</a></a></li></ul><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><h4 id="克隆仓库带工作区"><a href="#克隆仓库带工作区" class="headerlink" title="克隆仓库带工作区"></a>克隆仓库带工作区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 项目地址 项目别名</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>上面命令项目别名是可选的，相当于给项目根文件夹重命名。</p></blockquote><h4 id="克隆裸仓库"><a href="#克隆裸仓库" class="headerlink" title="克隆裸仓库"></a>克隆裸仓库</h4><figure class="highlight bash"><figcaption><span>使用哑协议</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /Users/pandashen/Study/git_learning</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> --bare /Users/pandashen/Study/git_learning/.git ya.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cloning into bare repository 'ya.git'...</span></span><br><span class="line"><span class="comment"># done.</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>使用智能协议</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare fill:///Users/pandashen/Study/git_learning/.git zhineng.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cloning into bare repository 'zhineng.git'...</span></span><br><span class="line"><span class="comment"># remote: Enumerating objects: 23, done.</span></span><br><span class="line"><span class="comment"># remote: Counting objects: 100% (23/23), done.</span></span><br><span class="line"><span class="comment"># remote: Compressing objects: 100% (18/18), done.</span></span><br><span class="line"><span class="comment"># remote: Total 23 (delta 2), reused 0 (delta 0)</span></span><br><span class="line"><span class="comment"># Receiving objects: 100% (23/23), done.</span></span><br><span class="line"><span class="comment"># Resolving deltas: 100% (2/2), done.</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>裸仓库是一个文件夹，内部存储的与带有工作区仓库的 <code>.git</code> 相同，使用哑协议和智能协议的区别是哑协议没有进度信息，而且智能协议由于对传输的信息进行了打包、压缩，所以传输速度更快。</p></blockquote><h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><figure class="highlight bash"><figcaption><span>创建关联</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 远程仓库地址</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看关联的远程仓库</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>删除远程仓库的关联</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm 地址别名</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p>地址别名指的是上面的 <code>origin</code>，也可以是其他名称，必须对应要删除关联的地址别名。</p></blockquote><h3 id="处理需要提交时过滤的文件-文件夹"><a href="#处理需要提交时过滤的文件-文件夹" class="headerlink" title="处理需要提交时过滤的文件/文件夹"></a>处理需要提交时过滤的文件/文件夹</h3><p>使用 WebStrom 编辑器编辑代码时，会自动在根目录生成 <code>.idea</code> 文件夹，使用 Mac 开发时根目录下的 <code>.DS_Store</code> 文件夹，以及在项目开发时会安装依赖存放在 <code>node_modules</code> 文件夹中，此类文件夹都是在把代码上传到远程仓库或中央服务器时不应该上传的，因此应该在上传之前过滤掉。</p><p><strong>在根目录创建 <code>.gitignore</code> 文件用于记录上传时被忽略的文件夹，内容（可根据需要自行配置）如下：</strong></p><figure class="highlight plain"><figcaption><span>文件：.gitignore</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.idea</span><br><span class="line">.DS_Store</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><code>Git</code> 上传时会自动忽略空文件夹，假设想要上传一个名为 <code>public</code> 的空文件夹，需要在文件夹内新建一个名为 <code>.gitkeep</code> 的文件（名字随意，最好有语义化），目的是使要提交的空文件夹不再为空。</p></blockquote><h3 id="推送代码到远程仓库"><a href="#推送代码到远程仓库" class="headerlink" title="推送代码到远程仓库"></a>推送代码到远程仓库</h3><figure class="highlight bash"><figcaption><span>将本地所有分支推送到远端</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push 地址别名 --all</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>将本地分支推送到远端</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push 地址别名 分支名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u 地址别名 分支名</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>如果加上了 <code>-u</code> 参数，以后再次提交时可省略地址别名和分支名称，直接执行下面命令进行提交。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>注意：<code>-f</code> 参数是在 <code>Git</code> 默认不允许的情况下也能将代码推送到远程服务器，是一个非常危险的命令，团队中一般禁止使用。</strong></em></p></blockquote><h3 id="拉取远程仓库的代码"><a href="#拉取远程仓库的代码" class="headerlink" title="拉取远程仓库的代码"></a>拉取远程仓库的代码</h3><blockquote class="pullquote default"><p>在提交代码时，如果直接提交到远程仓库，会将当前代码覆盖到远程仓库，如果别人之前也向远程仓库提交了代码，会在远程仓库中造成冲突，所以一般在提交代码之前先拉取远程仓库的代码与本地代码进行合并，并产生一个新的历史记录，若出现冲突，手动处理冲突后再统一提交到远程仓库。</p></blockquote><figure class="highlight bash"><figcaption><span>拉取但不合并代码（与 merge 配合，不常用）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch 地址别名 分支名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>拉取并合并代码（常用）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>拉去代码执行变基操作</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><h3 id="创建并拉取远程仓库的分支"><a href="#创建并拉取远程仓库的分支" class="headerlink" title="创建并拉取远程仓库的分支"></a>创建并拉取远程仓库的分支</h3><figure class="highlight bash"><figcaption><span>创建、切换并拉取远程分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名 地址别名/分支名</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>上面命令的意思是在本地创建并切换分支，同时将远端分支代码拉取到这个刚创建的分支。</p></blockquote><h3 id="创建-gh-pages-分支来发布静态页"><a href="#创建-gh-pages-分支来发布静态页" class="headerlink" title="创建 gh-pages 分支来发布静态页"></a>创建 gh-pages 分支来发布静态页</h3><p><strong>涉及到远程仓库网站上的操作均以 Github 为例，其他仓库大同小异：</strong></p><ul><li>在项目中创建一个静态页分支，我们使用 <code>gh-pages</code> 作为分支名；</li><li>将 <code>gh-pages</code> 分支提交到线上仓库；</li><li>找到提供仓库网站的 <code>Settings</code> 设置，切换到 <code>github-pages</code> 分支；</li><li>点击该栏顶端的地址可以访问我们的静态页。</li></ul><figure class="highlight bash"><figcaption><span>创建静态页命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b gh-pages</span><br><span class="line">touch index.html</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'提交信息'</span></span><br><span class="line">git push origin gh-pages</span><br></pre></td></tr></table></figure><h3 id="向别人的项目提问"><a href="#向别人的项目提问" class="headerlink" title="向别人的项目提问"></a>向别人的项目提问</h3><ul><li>在远程仓库网站进入别人的项目页面；</li><li>点击 <code>Issue</code> 选项；</li><li>输入问题标题和问题描述并点击提交；</li><li>项目所有者可以回复或关闭问题。</li></ul><h3 id="更改别人的项目代码"><a href="#更改别人的项目代码" class="headerlink" title="更改别人的项目代码"></a>更改别人的项目代码</h3><ul><li>在别人项目的主页上有一个叉子的图标，操作名为 <code>Fork</code>；</li><li><code>Fork</code> 是在当前项目下克隆了一份，如果代码更新，不会随之更新；</li><li>使用 <code>clone</code> 命令克隆自己的地址将项目拉到本地，进行操作；</li><li>默认就是 Git 仓库而且有 <code>origin</code> 地址，修改后可以将代码提交到自己的仓库上；</li><li>只有 <code>Fork</code> 关系才能修改别人代码后点击 <code>New pull request</code> 发送提交请求；</li><li>点击 <code>Create pull request</code> 按钮，填写提交标题，和提交详情，确认提交；</li><li>项目所有者可以在自己的项目页面中 <code>Pull request</code> 菜单中查看提交并处理；</li><li>点击 <code>Close pull request</code> 关闭，点击 <code>Merge pull request</code> 同意提交并合并。</li></ul><blockquote class="pullquote info"><p>如果是一个团队的其他人需要操作同一个项目，上面的过程显得很繁琐，项目所有者可以在 <code>Settings</code> 的 <code>Collaborators</code> 选项中通过添加别人的账号或用户名向项目中添加贡献者，被添加的人拥有最大权限。</p></blockquote><h2 id="GUI-界面化"><a href="#GUI-界面化" class="headerlink" title="GUI 界面化"></a>GUI 界面化</h2><blockquote class="pullquote primary"><p>在当前的前端开发编辑器中，如 <code>VSCode</code> 和 <code>WebStorm</code> 等都集成了 <code>Git</code>，也有专门用于管理代码的软件 <code>Sourcetree</code> 等，可以直接点击按钮操作，不必使用命令行，这种操作 <code>Git</code> 的界面称作 <code>GUI</code> 界面，个人建议还是尽量少的使用 <code>GUI</code> 界面，命令行是根本，还是多敲命令，孰能生巧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 命令行 </tag>
            
            <tag> 代码管理/版本控制 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 的继承方式及优缺点</title>
      <link href="/2017/07/10/20170710162724/"/>
      <url>/2017/07/10/20170710162724/</url>
      
        <content type="html"><![CDATA[<img src="/2017/07/10/20170710162724/extends.png" title="JS 继承"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>JavaScript 原本不是纯粹的 “OOP” 语言，因为在 ES5 规范中没有类的概念，在 ES6 中才正式加入了 <code>class</code> 的编程方式，在 ES6 之前，也都是使用面向对象的编程方式，当然是 JavaScript 独有的面向对象编程，而且这种编程方式是建立在 JavaScript 独特的原型链的基础之上的，我们本篇就将对原型链以及面向对象编程最常用到的继承进行刨析。</p></blockquote><a id="more"></a><h2 id="继承简介"><a href="#继承简介" class="headerlink" title="继承简介"></a>继承简介</h2><blockquote class="pullquote default"><p>在 JavaScript 的中的面向对象编程，继承是给构造函数之间建立关系非常重要的方式，根据 JavaScript 原型链的特点，其实继承就是更改原本默认的原型链，形成新的原型链的过程。</p></blockquote><h2 id="复制的方式进行继承"><a href="#复制的方式进行继承" class="headerlink" title="复制的方式进行继承"></a>复制的方式进行继承</h2><p>复制的方式进行继承指定是对象与对象间的浅复制和深复制，这种方式到底算不算继承的一种备受争议，我们也把它放在我们的内容中，当作一个 “不正经” 的继承。</p><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p>创建一个浅复制的函数，第一个参数为复制的源对象，第二个参数为目标对象。</p><figure class="highlight js"><figcaption><span>浅复制</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅复制方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">p, c = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> p) &#123;</span><br><span class="line">    c[k] = p[k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源对象</span></span><br><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">let</span> child = &#123;</span><br><span class="line">  c: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">extend(parent, child);</span><br><span class="line"><span class="built_in">console</span>.log(child); <span class="comment">// &#123; c: 2, a: 1, b: ƒ &#125;</span></span><br></pre></td></tr></table></figure><p>上面的 <code>extend</code> 方法在 ES6 标准中可以直接使用 <code>Object.assign</code> 方法所替代。</p><h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>可以组合使用 <code>JSON.stringify</code> 和 <code>JSON.parse</code> 来实现，但是有局限性，不能处理函数和正则类型，所以我们自己实现一个方法，参数与浅复制相同。</p><figure class="highlight js"><figcaption><span>深复制</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深复制方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendDeeply</span>(<span class="params">p, c = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> p[k] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> p[k] !== <span class="literal">null</span>) &#123;</span><br><span class="line">      c[k] = p[k] <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">      extendDeeply(p[k], c[k]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c[k] = p[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源对象</span></span><br><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  c: <span class="number">1</span>,</span><br><span class="line">  d: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line"><span class="keyword">let</span> child = extendDeeply(parent);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child); <span class="comment">// &#123; a: &#123;b: 1&#125;, b: [1, 2, 3], c: 1, d: ƒ &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.a === parent.a); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(child.b === parent.b); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(child.d === parent.d); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在上面可以看出复制后的新对象 <code>child</code> 的 <code>a</code> 属性和 <code>b</code> 的引用是独立的，与 <code>parent</code> 的 <code>a</code> 和 <code>b</code> 毫无关系，实现了深复制，但是 <code>extendDeeply</code> 函数并没有对函数类型做处理，因为函数内部执行相同的逻辑指向不同引用是浪费内存的。</p><h2 id="原型替换"><a href="#原型替换" class="headerlink" title="原型替换"></a>原型替换</h2><p>原型替换是继承当中最简单也是最直接的方式，即直接让父类和子类共用同一个原型对象，一般有两种实现方式。</p><figure class="highlight js"><figcaption><span>原型替换</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单粗暴的写法</span></span><br><span class="line">Child.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种种实现方式</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Child.prototype, Parent.prototype);</span><br></pre></td></tr></table></figure><p>上面这种方式 <code>Child</code> 的原型被替换掉，<code>Child</code> 的实例可以直接调用 <code>Parent</code> 原型上的方法，实现了对父类原型方法的继承。</p><p>上面第二种方式使用了 <code>Object.setPrototypeOf</code> 方法，该方法是将传入第一个参数对象的原型设置为第二个参数传入的对象，所以我们第一个参数传入的是 <code>Child</code> 的原型，将 <code>Child</code> 原型的原型设置成了 <code>Parent</code> 的原型，使父、子类原型链产生关联，<code>Child</code> 的实例继承了 <code>Parent</code> 原型上的方法，在 NodeJS 中的内置模块 <code>util</code> 中用来实现继承的方法 <code>inherits</code>，底层就是使用这种方式实现的。</p><blockquote class="pullquote warning"><p><em><strong>缺点：父类的实例也同样可以调用子类的原型方法，我们希望继承是单向的，否则无法区分父、子类关系，这种方式一般是不可取的。</strong></em></p></blockquote><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>原型链继承的思路是子类的原型的原型是父类的原型，形成了一条原型链，建立子类与父类原型的关系。</p><figure class="highlight js"><figcaption><span>原型链继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.hobby = [<span class="string">'basketball'</span>, <span class="string">'football'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>上面用 <code>Parent</code> 的实例替换了 <code>Child</code> 自己的原型，由于父类的实例原型直接指向 <code>Parent.prototype</code>，所以也使父、子类原型链产生关联，子类实例继承了父类原型的方法。</p><blockquote class="pullquote warning"><p><em><strong>缺点 1：只能继承父类原型上的方法，却无法继承父类上的属性。</strong></em><br><em><strong>缺点 2：由于原型对象被替换，原本原型的 <code>constructor</code> 属性丢失。</strong></em><br><em><strong>缺点 3：如果父类的构造函数中有属性，则创建的父类的实例也会有这个属性，用这个实例的作为子类的原型，这个属性就变成了所有子类实例所共有的，这个属性可能是多余的，并不是我们想要的，也可能我们希望它不是共有的，而是每个实例自己的。</strong></em></p></blockquote><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>构造函数继承又被国内的开发者叫做 “经典继承”。</p><figure class="highlight js"><figcaption><span>构造函数继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child(<span class="string">'Panda'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123; name: 'Panda' &#125;</span></span><br></pre></td></tr></table></figure><p>构造函数继承的原理就是在创建 <code>Child</code> 实例的时候执行了 <code>Child</code> 构造函数，并借用 <code>call</code> 或 <code>apply</code> 在内部执行了父类 <code>Parent</code>，并把父类的属性创建给了 <code>this</code>，即子类的实例，解决了原型链继承不能继承父类属性的缺点。</p><blockquote class="pullquote warning"><p><em><strong>缺点：子类的实例只能继承父类的属性，却不能继承父类的原型的方法。</strong></em></p></blockquote><h2 id="构造函数原型链组合继承"><a href="#构造函数原型链组合继承" class="headerlink" title="构造函数原型链组合继承"></a>构造函数原型链组合继承</h2><p>为了使子类既能继承父类原型的方法，又能继承父类的属性到自己的实例上，就有了这种组合使用的方式。</p><figure class="highlight js"><figcaption><span>构造函数原型链组合继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child(<span class="string">'Panda'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123; name: 'Panda' &#125;</span></span><br><span class="line">c.sayName(); <span class="comment">// Panda</span></span><br></pre></td></tr></table></figure><p>这种继承看似完美，但是之前 <code>constructor</code> 丢失和子类原型上多余共有属性的问题还是没有解决，在这基础上又产生了新的问题。</p><blockquote class="pullquote warning"><p><em><strong>缺点：父类被执行了两次，在使用 <code>call</code> 或 <code>apply</code> 继承属性时执行一次，在创建实例替换子类原型时又被执行了一次。</strong></em></p></blockquote><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承主要用来解决用父类的实例替换子类的原型时共有属性的问题，以及父类构造函数执行两次的问题，也就是说通过原型式继承能保证子类的原型是 “干净的”，而保证只在继承父类的属性时执行一次父类。</p><figure class="highlight js"><figcaption><span>原型式继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">Child.prototype = create(Parent.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child(<span class="string">'Panda'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123; name: 'Panda' &#125;</span></span><br></pre></td></tr></table></figure><p>原型式继承其实是借助了一个中间的构造函数，将中间构造函数 <code>F</code> 的 <code>prototype</code> 替换成了父类的原型，并创建了一个 <code>F</code> 的实例返回，这个实例是不具备任何属性的（干净的），用这个实例替换子类的原型，因为这个实例的原型指向 <code>F</code> 的原型，<code>F</code> 的原型同时又是父类的原型对象，所以子类实例继承了父类原型的方法，父类只在创建子类实例的时候执行了一次，省去了创建父类实例的过程。</p><p>原型式继承在 ES5 标准中被封装成了一个专门的方法 <code>Object.create</code>，该方法的第一个参数与上面 <code>create</code> 函数的参数相同，即要作为原型的对象，第二个参数则可以传递一个对象，会把对象上的属性添加到这个原型上，一般第二个参数用来弥补 <code>constructor</code> 的丢失问题，这个方法不兼容 IE 低版本浏览器。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承就是用来解决子统一为原型式继承中返回的对象统一添加方法的问题，只是在原型式继承的基础上做了小小的修改。</p><figure class="highlight js"><figcaption><span>寄生式继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类方法私有化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatFunction</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用继承函数</span></span><br><span class="line">  <span class="keyword">let</span> clone = create(obj);</span><br><span class="line">  <span class="comment">// 子类原型方法（多个）</span></span><br><span class="line">  clone.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  clone.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">Child.prototype = creatFunction(Parent.prototype);</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>缺点：因为寄生式继承最后返回的是一个对象，如果用一个变量直接来接收它，那相当于添加的所有方法都变成这个对象自身的了，如果创建了多个这样的对象，无法实现相同方法的复用。</strong></em></p></blockquote><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><figure class="highlight js"><figcaption><span>寄生组合式继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P.prototype.headCount = <span class="number">1</span>;</span><br><span class="line">P.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'eating...'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  P.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生组合式继承方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCreate</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = Parent.prototype;</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  Child.prototype.constructor = Child;</span><br><span class="line">  <span class="comment">// 让 Child 子类的静态属性 super 和 base 指向父类的原型</span></span><br><span class="line">  Child.super = Child.base = Parent.prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法实现继承</span></span><br><span class="line">myCreate(C, P);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向子类原型添加属性方法，因为子类构造函数的原型被替换，所以属性方法仍然在替换之后</span></span><br><span class="line">C.prototype.language = <span class="string">'javascript'</span>;</span><br><span class="line">C.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'writing code use '</span> + <span class="keyword">this</span>.language);</span><br><span class="line">&#125;;</span><br><span class="line">C.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.super.eat();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承是否成功</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> C(<span class="string">'nihao'</span>, <span class="number">16</span>);</span><br><span class="line">f.work();</span><br><span class="line">C.work();</span><br><span class="line"></span><br><span class="line"><span class="comment">// writing code use javascript</span></span><br><span class="line"><span class="comment">// eating...</span></span><br></pre></td></tr></table></figure><p>寄生组合式继承基本规避了其他继承的大部分缺点，应该比较强大了，也是平时使用最多的一种继承，其中 <code>Child.super</code> 方法的作用是为了在调用子类静态属性的时候可以调用父类的原型方法。</p><blockquote class="pullquote warning"><p><em><strong>缺点：子类没有继承父类的静态方法。</strong></em></p></blockquote><h2 id="class…extends…-继承"><a href="#class…extends…-继承" class="headerlink" title="class…extends… 继承"></a>class…extends… 继承</h2><p>在 ES6 规范中有了类的概念，使继承变得容易，在规避上面缺点的完成继承的同时，又在继承时继承了父类的静态属性。</p><figure class="highlight js"><figcaption><span>class...extends... 继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    supper(name, age); <span class="comment">// 继承父类的属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    P.sayHi();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> sayHello() &#123;</span><br><span class="line">    <span class="keyword">super</span>.sayHi();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C(<span class="string">'jack'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">c.sayName(); <span class="comment">// jack</span></span><br><span class="line">c.sayHello(); <span class="comment">// Hello</span></span><br><span class="line">C.sayHi(); <span class="comment">// Hello</span></span><br><span class="line">C.sayHello(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>在子类的 <code>constructor</code> 中调用 <code>supper</code> 可以实现对父类属性的继承，父类的原型方法和静态方法直接会被子类继承，在子类的原型方法中使用父类的原型方法只需使用 <code>this</code> 或 <code>supper</code> 调用即可，此时 <code>this</code> 指向子类的实例，如果在子类的静态方法中使用 <code>this</code> 或 <code>supper</code> 调用父类的静态方法，此时 <code>this</code> 指向子类本身。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 JavaScript 原型链</title>
      <link href="/2017/07/09/20170709131856/"/>
      <url>/2017/07/09/20170709131856/</url>
      
        <content type="html"><![CDATA[<img src="/2017/07/09/20170709131856/proto.png" title="JS 原型链"><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote class="pullquote default"><p>在 JavaScript 中有种说法叫 “万物皆对象”，就是说无论是构造函数创建的实例，构造函数本身、原型对象、数组、函数本质上都是对象，都拥有 <code>__proto__</code> 属性，即隐式原型，所有函数都拥有 <code>prototype</code> 属性，即显式原型（仅限函数），原型对象（<code>prototype</code> 属性指向的对象），在定义函数时就被创建。</p></blockquote><a id="more"></a><h2 id="原型链指向概述"><a href="#原型链指向概述" class="headerlink" title="原型链指向概述"></a>原型链指向概述</h2><p>在 JavaScript 中整个原型链及查找机制用下图可以完整的表示出来。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/07/09/20170709131856/prototype.png" alt="JS 原型链" title>                </div>                <div class="image-caption">JS 原型链</div>            </figure><p><br></p><p><strong>原型链指向：</strong></p><p>1、通过字面量和 <code>new Object()</code> 所创建的对象，他们是构造函数是 <code>function Object()</code> 的实例，<code>Object</code> 构造函数的 <code>prototype</code> 指向原型对象 <code>Object.prototype</code>，<code>Object.prototype</code> 的 <code>constructor</code> 指向构造函数 <code>Object</code>，而实例的 <code>__proto__</code> 也指向 <code>Object.prototype</code>，<code>Object.prototype</code> 的 <code>__proto__</code> 指向 <code>null</code>，所以 <code>Object.prototype</code> 也叫做顶级原型对象。</p><p>2、上图中 <code>new Foo()</code> 创建的对象是构造函数 <code>function Foo()</code> 的实例，<code>Foo</code> 的 <code>prototype</code> 指向原型对象 <code>Foo.prototype</code>，<code>Foo.prototype</code> 的 <code>constructor</code> 指向构造函数 <code>Foo</code>，而实例的 <code>__proto__</code> 也指向 <code>Foo.prototype</code>，并且 <code>Foo.prototype</code> 虽然是原型对象，但也是对象，所以是构造函数 <code>Object</code> 的实例，<code>__proto__</code> 指向顶级原型对象 <code>Object.prototype</code>。</p><p>3、数组的构造函数是 <code>function Array()</code> 原型链的指向与其他除 <code>Object</code> 以外的构造函数相同，<code>Array.prototype</code> 的 <code>__proto__</code> 也指向顶级原型对象 <code>Object.prototype</code>，每一个数组都是 <code>Array</code> 的实例，<code>__proto__</code> 都指向 <code>Array.prototype</code>。</p><p>4、<code>Object</code>、<code>Array</code>、<code>Foo</code> 等构造函数的本质也是对象，他们的构造函数是 <code>function Function()</code>，<code>Function</code> 的 <code>prototype</code> 指向 <code>Function.prototype</code>，<code>Function.prototype</code> 的 <code>constructor</code> 指向 <code>Function</code>，所有的构造函数的 <code>__proto__</code> 都指向 <code>Function.prototype</code>，包括 <code>Function</code> 本身，也就是说构造函数 <code>Function</code> 是由自己构造的，<code>Function.prototype</code> 的 <code>__proto__</code> 同样指向顶级原型对象 <code>Object.prototype</code>。</p><h2 id="prototype-原型对象"><a href="#prototype-原型对象" class="headerlink" title="prototype 原型对象"></a>prototype 原型对象</h2><p><code>prototype</code> 是函数的一个属性，属性的值指向了一个对象，所以，只有函数才有 <code>prototype</code> 原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Person.prototype; <span class="comment">// object</span></span><br><span class="line">Person.prototype.constructor; <span class="comment">// Person &#123;&#125;</span></span><br><span class="line">Person.prototype.job = <span class="string">'qianduan'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'panda'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'shen'</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">p1.constructor.prototype; <span class="comment">// 实例对象查找构造函数原型对象的方法</span></span><br></pre></td></tr></table></figure><p>一般会把对象共有的属性和方法都放在构造函数的原型对象上。</p><h2 id="实例、构造函数、原型对象的关系"><a href="#实例、构造函数、原型对象的关系" class="headerlink" title="实例、构造函数、原型对象的关系"></a>实例、构造函数、原型对象的关系</h2><p>构造函数的原型 <code>prototype</code> 属性指向一个原型对象，实例也可以通过 <code>__proto__</code> 指向原型对象，但本质上实例和构造函数之间是没有关系的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'nihao'</span>, <span class="number">16</span>);</span><br><span class="line">p.constructor = &#123; <span class="attr">name</span>: <span class="string">'haha'</span> &#125;;</span><br><span class="line">p.name; <span class="comment">// nihao</span></span><br></pre></td></tr></table></figure><p>上面的代码中改变了构造函数的值为一个对象，对象中的属性 <code>name</code> 并没有影响实例的 <code>name</code> 属性值。</p><h2 id="实例属性-proto"><a href="#实例属性-proto" class="headerlink" title="实例属性 __proto__"></a>实例属性 __proto__</h2><p>上面访问实例 <code>p</code> 的原型，实际使用 <code>p.constructor.prototype</code> 去找原型对象，当构造函数的值改变后是找不到原型对象的，所以实例并不是通过 <code>constructor.prototype</code> 去查找原型对象的，而是通过每一个实例都有的 <code>__proto__</code> 属性，这个属性指向创建实例的构造函数原本的原型对象，这个属性不是标准，在 IE 下不存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.job = <span class="string">'qianduan'</span>;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'nihao'</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">p.__proto__.job; <span class="comment">// qianduan</span></span><br></pre></td></tr></table></figure><p>当构造函数的 <code>prototype</code> 属性值被改变之后，在之前创建的实例的 <code>__proto__</code> 属性值的仍然引用原型对象，所以对构造函数改变前创建的实例是没有影响的，会影响后面创建的实例。</p><h2 id="原型链查找机制"><a href="#原型链查找机制" class="headerlink" title="原型链查找机制"></a>原型链查找机制</h2><p>实例对象在调用了一个属性或方法时，如果对象本身没有这个属性或方法，会去自己的原型对象查找，也就是 <code>__proto__</code> 中查找，如果原型对象中没有，去原型对象的原型对象查找，一般（原型链没有被修改）情况下就是去 <code>__proto__</code> 的 <code>__proto__</code> 中查找，即顶级原型对象 <code>Object.prototype</code>，如果实例对象本身有这个属性，则直接输出，不再向上查找，如果对象本身和原型对象具有同名属性，则会屏蔽掉原型对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.job = <span class="string">'qianduan'</span>;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'nihao'</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">p.job; <span class="comment">// qianduan</span></span><br><span class="line">p.job = <span class="string">'houtai'</span>;</span><br><span class="line">p.job; <span class="comment">// houtai</span></span><br><span class="line">p.__proto__.job; <span class="comment">// qianduan</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>原型链的指向及原型链的查找机制是 JavaScript 中非常重要的基础知识，理解原型链是更深入了解继承和面向对象编程的必经之路。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装一个 cookie 功能</title>
      <link href="/2017/07/02/20170702182645/"/>
      <url>/2017/07/02/20170702182645/</url>
      
        <content type="html"><![CDATA[<img src="/2017/07/02/20170702182645/cookie.png" title="cookie"><p><br></p><h2 id="cookie-概述"><a href="#cookie-概述" class="headerlink" title="cookie 概述"></a>cookie 概述</h2><blockquote class="pullquote info"><p>由于浏览器无状态的特性，cookie 技术应运而生，cookie 是一个会话级的存储，用于某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密），通过访问某些服务器而特定携带的存储信息，不支持跨域，在浏览器清空缓存或超过有效期后失效。</p></blockquote><a id="more"></a><h2 id="JavaScript-中的-cookie"><a href="#JavaScript-中的-cookie" class="headerlink" title="JavaScript 中的 cookie"></a>JavaScript 中的 cookie</h2><p>在 JavaScript 中操作 <code>cookie</code> 通过 <code>document.cookie</code> 来实现：</p><figure class="highlight js"><figcaption><span>操作 cookie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'key1=value1; key2=value2; path=/; domain=pandashen.com'</span>;</span><br></pre></td></tr></table></figure><p>在传递 <code>cookie</code> 过程中，使用上面这样的方式对于参数的传递和拼接都是不太方便的，下面我们来封装一个自己的 <code>cookie</code> 功能。</p><h2 id="封装一个-cookie-模块"><a href="#封装一个-cookie-模块" class="headerlink" title="封装一个 cookie 模块"></a>封装一个 cookie 模块</h2><h3 id="整体思路设计"><a href="#整体思路设计" class="headerlink" title="整体思路设计"></a>整体思路设计</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kvTool = &#123;</span><br><span class="line">    maxage: <span class="string">'max-age'</span>,</span><br><span class="line">    path: <span class="string">'path'</span>,</span><br><span class="line">    domain: <span class="string">'domain'</span>,</span><br><span class="line">    secure: <span class="string">'secure'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cookieUtil = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.cookieUtil = cookieUtil;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我们封装了一个自执行函数，在内部将 <code>cookie</code> 基本参数的键名存入 <code>kvTool</code> 对象当中设计的 <code>options</code> 参数的键名一一对应，并单独声明一个设置 <code>cookie</code> 的方法 <code>setCookie</code> 和获取 <code>cookie</code> 的方法 <code>getCookie</code>，最后用函数表达式的形式声明一个 <code>cookieUtil</code> 暴露给全局作用域。</p><h3 id="setCookie-方法的实现"><a href="#setCookie-方法的实现" class="headerlink" title="setCookie 方法的实现"></a>setCookie 方法的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kvTool = &#123;</span><br><span class="line">    maxage: <span class="string">'max-age'</span>,</span><br><span class="line">    path: <span class="string">'path'</span>,</span><br><span class="line">    domain: <span class="string">'domain'</span>,</span><br><span class="line">    secure: <span class="string">'secure'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">k, v, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">      <span class="built_in">document</span>.cookie = k + <span class="string">'='</span> + v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">        <span class="comment">// &#123; path='/', domain='pandashen.com' &#125;</span></span><br><span class="line">        tmp.push(kvTool[key] + <span class="string">'='</span> + options[key]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">document</span>.cookie = k + <span class="string">'='</span> + v + <span class="string">'; '</span> + tmp.join(<span class="string">'; '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cookieUtil = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.cookieUtil = cookieUtil;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><strong>setCookie 方法的有三个参数：</strong></p><ul><li>k：cookie 发送信息的键</li><li>v：cookie 发送信息的值</li><li>options：cookie 的基本参数</li></ul><p>当没有传入基本参数 <code>options</code> 的时候直接将 <code>cookie</code> 发送信息的键值拼接赋值给 <code>document.cookie</code>。</p><p>传入基本参数 <code>options</code> 的时候取出 <code>kvTool</code> 真正的键名，并和 <code>cookie</code> 发送的信息的键值拼接成 <code>k=v; k=v</code> 形式的字符串赋值给 <code>document.cookie</code>。</p><h3 id="getCookie-方法的实现"><a href="#getCookie-方法的实现" class="headerlink" title="getCookie 方法的实现"></a>getCookie 方法的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kvTool = &#123;</span><br><span class="line">    maxage: <span class="string">'max-age'</span>,</span><br><span class="line">    path: <span class="string">'path'</span>,</span><br><span class="line">    domain: <span class="string">'domain'</span>,</span><br><span class="line">    secure: <span class="string">'secure'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">k, v, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">      <span class="built_in">document</span>.cookie = k + <span class="string">'='</span> + v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">        <span class="comment">// &#123; path='/', domain='pandashen.com' &#125;</span></span><br><span class="line">        tmp.push(kvTool[key] + <span class="string">'='</span> + options[key]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">document</span>.cookie = k + <span class="string">'='</span> + v + <span class="string">'; '</span> + tmp.join(<span class="string">'; '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> strCookie = <span class="built_in">document</span>.cookie;</span><br><span class="line">    <span class="comment">// 形如: 'k=v; k=v; k=v; k=v'</span></span><br><span class="line">    <span class="keyword">var</span> kvs = strCookie.split(<span class="string">';'</span>).map(<span class="function"><span class="params">v</span> =&gt;</span> v.trim());</span><br><span class="line">    <span class="keyword">var</span> objCookie = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    kvs.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> kv = v.split(<span class="string">'='</span>);</span><br><span class="line">      objCookie[kv[<span class="number">0</span>]] = kv[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objCookie[k];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cookieUtil = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.cookieUtil = cookieUtil;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><code>getCookie</code> 方法只有一个参数，即我们要获取的 <code>cookie</code> 的某一个属性的键，函数会将对应的值返回。</p><p>其实对外暴露的方法只有 <code>cookieUtil</code>，所以 <code>setCookie</code> 和 <code>getCookie</code> 都是在 <code>cookieUtil</code> 内部调用的。</p><h3 id="cookieUtil-方法的实现"><a href="#cookieUtil-方法的实现" class="headerlink" title="cookieUtil 方法的实现"></a>cookieUtil 方法的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kvTool = &#123;</span><br><span class="line">    maxage: <span class="string">'max-age'</span>,</span><br><span class="line">    path: <span class="string">'path'</span>,</span><br><span class="line">    domain: <span class="string">'domain'</span>,</span><br><span class="line">    secure: <span class="string">'secure'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">k, v, options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">        <span class="built_in">document</span>.cookie = k + <span class="string">'='</span> + v;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">          <span class="comment">// &#123; path='/', domain='pandashen.com' &#125;</span></span><br><span class="line">          tmp.push(kvTool[key] + <span class="string">'='</span> + options[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">document</span>.cookie = k + <span class="string">'='</span> + v + <span class="string">'; '</span> + tmp.join(<span class="string">'; '</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> strCookie = <span class="built_in">document</span>.cookie;</span><br><span class="line">      <span class="comment">// 形如: 'k=v; k=v; k=v; k=v'</span></span><br><span class="line">      <span class="keyword">var</span> kvs = strCookie.split(<span class="string">';'</span>).map(<span class="function"><span class="params">v</span> =&gt;</span> v.trim());</span><br><span class="line">      <span class="keyword">var</span> objCookie = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      kvs.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> kv = v.split(<span class="string">'='</span>);</span><br><span class="line">        objCookie[kv[<span class="number">0</span>]] = kv[<span class="number">1</span>];</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> objCookie[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cookieUtil = <span class="function"><span class="keyword">function</span>(<span class="params">key, value, options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        <span class="comment">// 没有传参, 得到数据</span></span><br><span class="line">        <span class="keyword">return</span> getCookie(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setCookie(key, value, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.cookieUtil = cookieUtil;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><code>cookieUtil</code> 的逻辑为当 <code>key</code> 和 <code>value</code> 两个参数都传入时，调用 <code>setCookie</code> 来设置 <code>cookie</code>，只传入 <code>key</code> 时，调用 <code>getCookie</code> 获取 <code>cookie</code> 对应参数的值。</p><blockquote class="pullquote success"><p>上面就是我们封装的 <code>cookie</code> 功能模块来帮主我们设置和获取 <code>cookie</code>，之所以封装这个功能最终的目的就是让我们更方便的通过 <code>JavaScript</code> 来操作 <code>cookie</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTTP </tag>
            
            <tag> cookie/session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单封装一个靠谱的检测数据类型模块</title>
      <link href="/2017/06/30/20170630162209/"/>
      <url>/2017/06/30/20170630162209/</url>
      
        <content type="html"><![CDATA[<img src="/2017/06/30/20170630162209/javascript-types.png" title="check javascript types"><p><br></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote class="pullquote warning"><p>本篇主要对 JavaScript 数据类型检测做一些介绍，并封装一个相对靠谱的数据类型检测模块。</p></blockquote><h2 id="常见检测数据类型的三种方式"><a href="#常见检测数据类型的三种方式" class="headerlink" title="常见检测数据类型的三种方式"></a>常见检测数据类型的三种方式</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 可以满足大部分基本数据类型的检测，如 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code> 和 <code>symbol</code>，对于 <code>null</code> 使用 <code>typeof</code> 则会直接返回 <code>object</code>，对于引用类型的检测，只有 <code>function</code> 是可以正确返回的，其他都返回 <code>object</code>，可以看出 <code>typeof</code> 只适用于部分场景，并不是那么的靠谱。</p><a id="more"></a><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 本质是用来检测一个对象是不是一个构造函数的实例，因为基本数据类型是基本包装类，已经不是对象了，所以 <code>instanceof</code> 是用不适合检测基本数据类型，<code>instanceof</code> 也有一个缺点，用 <code>instanceof</code> 检测一个对象原型链上的其他原型对象对应的构造函数时，也返回 <code>true</code>，所以说 <code>instanceof</code> 也不能保证绝对的准确。</p><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call"></a>Object.prototype.toString.call</h3><p><code>Object.prototype.toString.call</code> 在我们传入数据的时候，可以 <code>[object Object]</code> 的形式精准的返回给我们当前的数据类型，如 <code>[object Array]</code> 等等，我们本次要封装的类型检测工具就是基于这个方法。</p><h2 id="封装检测类型模块"><a href="#封装检测类型模块" class="headerlink" title="封装检测类型模块"></a>封装检测类型模块</h2><p>最终在全局会产生一个 <code>checkTypes</code> 的对象，上面对应着检测不同类型的方法，每个方法的参数都为被检测数据，返回值都为布尔值。</p><figure class="highlight js"><figcaption><span>检测类型模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存储检测数据类型方法的对象</span></span><br><span class="line">  <span class="keyword">var</span> checkTypesFun = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 涉及到的数据类型</span></span><br><span class="line">  <span class="keyword">var</span> types = [</span><br><span class="line">    <span class="string">'String'</span>,</span><br><span class="line">    <span class="string">'Number'</span>,</span><br><span class="line">    <span class="string">'Boolean'</span>,</span><br><span class="line">    <span class="string">'Undefined'</span>,</span><br><span class="line">    <span class="string">'Null'</span>,</span><br><span class="line">    <span class="string">'Symbol'</span>,</span><br><span class="line">    <span class="string">'Function'</span>,</span><br><span class="line">    <span class="string">'Array'</span>,</span><br><span class="line">    <span class="string">'Object'</span>,</span><br><span class="line">    <span class="string">'RegExp'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过闭包返回检测单个类型的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="built_in">Object</span>.prototype.toString.call(content);</span><br><span class="line">      <span class="keyword">return</span> type === result.replace(<span class="regexp">/\[object\s|\]/g</span>, <span class="string">''</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  types.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构建检测不同类型的方法，返回布尔值</span></span><br><span class="line">    checkTypesFun[<span class="string">'is'</span> + type] = isType(type);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将检测类型模块暴露在全局</span></span><br><span class="line">  <span class="built_in">window</span>.checkTypes = checkTypesFun;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>上面代码是自执行函数，执行后会将 <code>checkTypes</code> 对象暴露在全局，可以直接使用。</p><figure class="highlight js"><figcaption><span>使用模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkTypes.isString(<span class="string">'123'</span>); <span class="comment">// true</span></span><br><span class="line">checkTypes.isNumber(<span class="string">'123'</span>); <span class="comment">// false</span></span><br><span class="line">checkTypes.isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line">checkTypes.isRegExp(<span class="regexp">/^[0-9]$/</span>); <span class="comment">// true</span></span><br><span class="line">checkTypes.isObject(&#123;&#125;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>可以使用 <code>console.log(checkTypes)</code> 查看所有的方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据类型检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端优化 —— 函数的节流和防抖</title>
      <link href="/2017/06/12/20170612130942/"/>
      <url>/2017/06/12/20170612130942/</url>
      
        <content type="html"><![CDATA[<img src="/2017/06/12/20170612130942/throttle-vs-debounce.png" title="函数节流和防抖"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>在前端开发当中我们经常会绑定一些事件触发的某些程序执行，有时这些事件会连续触发，如浏览器窗口的 <code>scroll</code>、<code>resize</code>，输入框的 <code>keyup</code>、<code>input</code>，以及 <code>click</code> 事件在连续点击时连续发送请求等等，这些情况有些会严重影响前端性能，有些会增加服务器压力，使用户体验大打折扣，而函数节流和防抖就是为了解决这样的问题。</p></blockquote><a id="more"></a><h2 id="函数节流-throtter"><a href="#函数节流-throtter" class="headerlink" title="函数节流 throtter"></a>函数节流 throtter</h2><blockquote class="pullquote info"><p><strong>函数节流：当持续发生事件时，保证在一个固定的时间间隔只执行一次真正的事件处理程序，通俗的说就像 “节流” 的名字一样，打开水龙头时要秉承勤俭节约的原则，把阀门关小，最好是达到在固定间隔内水一滴一滴的往下流。</strong></p></blockquote><h3 id="节流函数的时序图"><a href="#节流函数的时序图" class="headerlink" title="节流函数的时序图"></a>节流函数的时序图</h3><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/06/12/20170612130942/fun-throtter.png" alt="函数节流时序图" title>                </div>                <div class="image-caption">函数节流时序图</div>            </figure><p><br></p><p>从图中可以看出，连续触发事件时，真正执行事件处理程序的间隔是固定的，多次触发，也只会在某一个时间间隔内触发一次，由于事件处理函数内部执行逻辑各不相同，我们就封装一版可通用的节流函数。</p><h3 id="节流函数的封装"><a href="#节流函数的封装" class="headerlink" title="节流函数的封装"></a>节流函数的封装</h3><figure class="highlight js"><figcaption><span>文件：throtter.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流函数</span></span><br><span class="line"><span class="keyword">const</span> throtter = <span class="function">(<span class="params">func, delay = <span class="number">60</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 锁的标识</span></span><br><span class="line">  <span class="keyword">let</span> lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个事件处理函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 lock 为 true 则跳出</span></span><br><span class="line">    <span class="keyword">if</span> (lock) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数并更改锁的状态</span></span><br><span class="line">    func(...args);</span><br><span class="line">    lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加定时器，在到达时间间隔时重置锁的状态</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> lock = <span class="literal">false</span>, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>throtter</code> 函数有两个参数，第一个参数为在事件触发时真正要执行的函数，第二个参数为定义的间隔时间，在函数执行时定义了 <code>lock</code> 的初始值，通过闭包返回一个函数作为事件处理函数，在返回的函数内部判断 <code>lock</code> 状态并确定执行真正的函数 <code>func</code> 还是跳出，每次执行 <code>func</code> 后会更改 <code>lock</code> 状态，通过定时器在规定的时间间隔内重置 <code>lock</code>，这就是函数节流的原理。</p><h3 id="验证节流函数"><a href="#验证节流函数" class="headerlink" title="验证节流函数"></a>验证节流函数</h3><figure class="highlight js"><figcaption><span>文件：throtter-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用节流函数</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, throtter(<span class="built_in">console</span>.log));</span><br></pre></td></tr></table></figure><p>上面我们给 <code>document</code> 对象添加了滚动事件，并不断的打印事件对象，事件处理函数的默认参数为事件对象，从执行效果应该可以看出，平均每 <code>60ms</code> 才会触发一次事件，达到了优化性能的目的，如果想让真正执行的函数 <code>func</code> 传入更多的参数，只需如下处理。</p><figure class="highlight js"><figcaption><span>文件：throtter-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a b 为函数要传入的参数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回事件处理函数</span></span><br><span class="line"><span class="keyword">const</span> func = throtter(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件监听</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, e =&gt; func(e, a, b));</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>节流函数一般用于 <code>scroll</code>、<code>resize</code> 事件的情况较多，因为这些事件的触发是连续性的，需要在一个时间间隔内只触发一次。</strong></p></blockquote><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖 debounce"></a>函数防抖 debounce</h2><blockquote class="pullquote primary"><p><strong>函数防抖：当持续发生事件时，事件只在上一次触发后的一段时间内没再触发事件，才会真正的执行事件处理逻辑，如果每两次触发的间隔小于这个时间，则不执行事件逻辑。</strong></p></blockquote><h3 id="防抖函数的时序图"><a href="#防抖函数的时序图" class="headerlink" title="防抖函数的时序图"></a>防抖函数的时序图</h3><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/06/12/20170612130942/fun-debounce.png" alt="函数防抖时序图" title>                </div>                <div class="image-caption">函数防抖时序图</div>            </figure><p><br></p><p>从图中可以看出，连续触发事件时并没有执行事件处理函数，只有在某一阶段连续触发后的最后一次才执行，也就是上一次触发的时间间隔要大于设定值才执行，同样的，事件处理函数内部执行逻辑各不相同，我们就封装一版可通用的防抖函数。</p><h3 id="防抖函数的封装"><a href="#防抖函数的封装" class="headerlink" title="防抖函数的封装"></a>防抖函数的封装</h3><figure class="highlight js"><figcaption><span>文件：debounce.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖函数</span></span><br><span class="line"><span class="keyword">const</span> dobounce = <span class="function">(<span class="params">func, delay = <span class="number">300</span>, timer = <span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清除定时器</span></span><br><span class="line">    clearInterval(timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在定时器到时后执行事件处理函数</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> func(...args), delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dobounce</code> 函数有三个参数，第一个参数为在事件触发时真正要执行的函数，第二个参数为执行事件的延迟时间，第三个参数为定时器 <code>ID</code> 的初始值，执行 <code>dobounce</code> 通过闭包返回了事件处理函数，在处理函数内部先清除定时器，然后定义定时器并将 <code>ID</code> 赋值给 <code>timer</code>，如果事件连续触发，则会不断的清除定时器，直到有一次触发间隔超过了设定延时时间 <code>delay</code>，才会真正执行 <code>func</code>。</p><h3 id="验证防抖函数"><a href="#验证防抖函数" class="headerlink" title="验证防抖函数"></a>验证防抖函数</h3><figure class="highlight html"><figcaption><span>文件：index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>函数防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"ipt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：debounce-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用防抖函数</span></span><br><span class="line"><span class="keyword">let</span> ipt = <span class="built_in">document</span>.querySelector(<span class="string">'#ipt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件监听</span></span><br><span class="line">ipt.addEventListener(<span class="string">'keyup'</span>, debounce(<span class="built_in">console</span>.log));</span><br></pre></td></tr></table></figure><p>上面的功能跟 <code>throtter</code> 类似，真正执行事件处理函数时打印事件对象，通过验证，连续输入触发 <code>keyup</code> 事件，上一次触发和下一次触发间隔时间必须大于 <code>300ms</code> 才会执行打印事件对象的逻辑，如果想传入多个参数套路相同。</p><figure class="highlight js"><figcaption><span>文件：debounce-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 dom 元素</span></span><br><span class="line"><span class="keyword">let</span> ipt = <span class="built_in">document</span>.querySelector(<span class="string">'#ipt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b 为函数要传入的参数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回事件处理函数</span></span><br><span class="line"><span class="keyword">const</span> func = debounce(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件监听</span></span><br><span class="line">ipt.addEventListener(<span class="string">'keyup'</span>, e =&gt; func(e, a, b));</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong>防抖函数一般用于输入框事件，常用场景就是搜索或查询，如果不使用防抖会连续发送请求，增加服务器的压力，使用防抖后，会在用户输入要查询的关键词后才发送请求，这也更符合用户的习惯，例如百度搜索，就是这样实现的。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“节流” 和 “防抖” 是前端在项目中经常使用的优化手段，代码虽然不多，但是确是前端面试 “出镜率” 非常高的知识点，从而能看出它们的重要性，所以建议前端同学们一定要知道，并能手写，这是 “一箭双雕” 的事，可以用来通过面试，也可以因为工作中遇到直接就写而提高工作效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 基础 —— call、apply 和 bind 的原理</title>
      <link href="/2017/05/24/20170524162030/"/>
      <url>/2017/05/24/20170524162030/</url>
      
        <content type="html"><![CDATA[<img src="/2017/05/24/20170524162030/call-apply-bind.jpg" title="call、apply 和 bind 的原理"><p><br></p><h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h2><p><code>call</code> 和 <code>apply</code> 是 <code>Function</code> 构造函数原型对象上的方法，所有的函数都可以调用 <code>call</code> 和 <code>apply</code>，作用是可以改变调用 <code>call</code> 和 <code>apply</code> 函数内部的 <code>this</code> 指向，并执行函数。</p><h3 id="call-的使用方法"><a href="#call-的使用方法" class="headerlink" title="call 的使用方法"></a>call 的使用方法</h3><figure class="highlight js"><figcaption><span>不指定 this</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;</span></span><br><span class="line"><span class="comment">// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure><p>不指定替换的 <code>this</code>，则调用 <code>call</code> 的函数在运行时决定 <code>this</code> 指向，当前案例中在浏览器中运行，则指向 <code>window</code> 对象。</p><figure class="highlight js"><figcaption><span>一次调用 call</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(<span class="string">'hello'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String &#123; "hello" &#125;</span></span><br><span class="line"><span class="comment">// Arguments(2) ["1", "2", callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure><p>在上面案例中，<code>call</code> 将 <code>fn</code> 内部的 <code>this</code> 更改为 <code>hello</code> 的基本包装类（对象），而 <code>1</code> 和 <code>2</code> 作为 <code>fn</code> 的参数，以 <code>arguments</code> 的形式被打印出来。</p><figure class="highlight js"><figcaption><span>多次调用 call</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1.call.call(fn2, <span class="string">'1'</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String &#123; "1" &#125;</span></span><br><span class="line"><span class="comment">// Arguments ["2", callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure><p>由于 <code>call</code> 是函数原型的方法，当然也可以被 <code>call</code> 自己调用，在上面的案例中，第一个 <code>call</code> 内部的 <code>this</code> 为调用者 <code>fn1</code>，通过第二个 <code>call</code> 将第一个 <code>call</code> 内部的 <code>this</code> 由 <code>fn1</code> 更改为 <code>fn2</code>，<code>1</code> 和 <code>2</code> 作为参数传递给第一个 <code>call</code>，而 <code>1</code> 又作为第一个 <code>call</code> 内部 <code>this</code> 指向的 <code>fn2</code> 内部的 <code>this</code>，<code>2</code> 作为 <code>fn2</code> 的参数，最后执行 <code>fn2</code>，固有上面执行结果。</p><h3 id="call-的实现原理"><a href="#call-的实现原理" class="headerlink" title="call 的实现原理"></a>call 的实现原理</h3><p>根据 <code>call</code> 方法的特点，来模拟实现一个自己封装的 <code>call</code> 方法，代码如下。</p><figure class="highlight js"><figcaption><span>call 的实现原理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context 参数为要替换的 this</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将传入的 this 转换成对象，若没传则使用 window 作为 this</span></span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用 call 的函数作为属性赋值给传入的 this</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将传递给调用 call 函数的参数转化成字符串取值的形式</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="comment">// args ['arguments[1]', 'arguments[2]']</span></span><br><span class="line">    args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用 eval 执行 context.fn，并利用数组转换字符串的 toString 去掉 [ ]</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除 context 上多余的 fn 属性</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现方式重点解决两个问题：</p><ul><li>如何让调用 <code>call</code> 函数内部的 <code>this</code> 指向传入的 <code>this</code>，我们通过将传入 <code>this</code> 上加一个属性 <code>fn</code>，值为调用 <code>call</code> 的函数，在执行函数时并不直接调用 <code>this</code>，而是执行 <code>context.fn</code>，这样内部的 <code>this</code> 指向了调用者 <code>context</code>，即指向了传入要替换的 <code>this</code>。</li><li>如何将 <code>call</code> 调用时除第一个参数以外的参数列表作为调用 <code>call</code> 函数的参数依次传入，我们这里借用了 <code>eval</code> 提供执行环境，将要执行的代码拼接成字符串，这样就可以容易的将 <code>argument</code> 第二项后面的所有项通过循环的方式拼接。</li></ul><blockquote class="pullquote danger"><p><strong>给 <code>context</code> 添加的多余属性 <code>fn</code>，要在函数 <code>context.fn</code> 执行后删除。</strong></p></blockquote><h3 id="apply-的使用方法"><a href="#apply-的使用方法" class="headerlink" title="apply 的使用方法"></a>apply 的使用方法</h3><p><code>apply</code> 与 <code>call</code> 的作用相同，基本用法如下。</p><figure class="highlight js"><figcaption><span>apply 用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.apply(<span class="string">'hello'</span>, [<span class="string">'1'</span>, <span class="string">'2'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String &#123; "hello" &#125;</span></span><br><span class="line"><span class="comment">// Arguments(2) ["1", "2", callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure><h3 id="apply-的实现原理"><a href="#apply-的实现原理" class="headerlink" title="apply 的实现原理"></a>apply 的实现原理</h3><p>通过用法可以看出 <code>apply</code> 与 <code>call</code> 唯一不同的就是传参方式，<code>call</code> 传递给调用它的函数传参靠调用时使用参数列表的方式依次传入，而 <code>apply</code> 是通过数组的方式传入，只需要将 <code>call</code> 的代码稍加改造就可以实现 <code>apply</code>。</p><figure class="highlight js"><figcaption><span>apply 的实现原理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context 参数为要替换的 this，args 为调用 apply 函数执行的参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否传入参数列表，如果没传则直接执行</span></span><br><span class="line">  <span class="keyword">if</span> (!args) <span class="keyword">return</span> context.fn();</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="bind-的使用方法"><a href="#bind-的使用方法" class="headerlink" title="bind 的使用方法"></a>bind 的使用方法</h3><p><code>bind</code> 函数是 <code>Function</code> 原型对象上的方法，<code>bind</code> 的作用是可以将调用它的函数内部的 <code>this</code> 绑定成所指定的 <code>this</code>，第一个参数为指定的 <code>this</code>，与 <code>call</code> 和 <code>apply</code> 不同的是，调用 <code>bind</code> 的函数并不会执行，而是返回一个新的函数，新的函数调用时传入的参数会和 <code>bind</code> 调用时传入的除第一个以外的参数进行合并，并作为调用 <code>bind</code> 的函数执行的参数，下面是 <code>bind</code> 的基本用法。</p><figure class="highlight js"><figcaption><span>返回的函数当做普通函数调用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Shen'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFn = sayName.bind(obj);</span><br><span class="line">bindFn();</span><br><span class="line"><span class="comment">// Shen</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>调用 bind 和执行返回函数分开传参</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Shen'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' have a '</span> + name + <span class="string">' is '</span> + age + <span class="string">' years old.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFn = animal.bind(<span class="literal">null</span>, <span class="string">'cat'</span>);</span><br><span class="line">bindFn(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// Shen have a cat is 2 years old.</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>返回的函数当做构造函数执行</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Shen'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物类别为哺乳类</span></span><br><span class="line">Animal.prototype.category = <span class="string">'mammalia'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BindFn = Animal.bind(obj, <span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> BindFn(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat); <span class="comment">// Animal &#123;name: "cat", age: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.category); <span class="comment">// mammalia</span></span><br></pre></td></tr></table></figure><h3 id="bind-的原理"><a href="#bind-的原理" class="headerlink" title="bind 的原理"></a>bind 的原理</h3><p>从上面的例子已经可以看出 <code>bind</code> 不但能绑定 <code>this</code>，收集参数，返回的函数既可以直接调用，又可以作为构造函数实例化对象，而实例化的对象的方式，<code>bind</code> 绑定的 <code>this</code> 不生效，<code>this</code> 指向被创建的实例，实例依然可以找到原来函数原型上的属性和方法，根据 <code>bind</code> 的特性，模拟实现的代码如下。</p><figure class="highlight js"><figcaption><span>bind 的实现原理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context 参数为要绑定的 this</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this 为调用 bind 的函数</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收集除了 context 以外所有的参数</span></span><br><span class="line">  <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的新函数 fBound</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fBound</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 收集 fBound 的参数</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行调用 bind 的函数</span></span><br><span class="line">    <span class="comment">// 若是普通函数调用，this 为 context，若是作为构造函数则 this 为实例</span></span><br><span class="line">    self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来继承的中间函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fNOP</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为构造函数调用 fBound 时，为了实例可以找到调用 bind 函数的原型对象，进行继承</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">    <span class="comment">// Function.prototype 为函数，可以调用 bind，当时没有原型对象，所以要判断</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>在上面代码中，如果调用 <code>bind</code> 返回函数作为构造函数使用，则需要通过继承找回原函数的属性和方法，但是有一个特例，就是 <code>Function.prototype</code>，类型为函数，却没有 <code>prototype</code> 属性，所以需要判断。</strong></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote class="pullquote success"><p>上面就是 <code>call</code>、<code>apply</code> 和 <code>bind</code> 的基本用法、实现原理以及区别，希望读者可以通过这篇文章加深对 <code>call</code>、<code>apply</code> 和 <code>bind</code> 的印象，运用自如。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 基础 —— new 的实现原理</title>
      <link href="/2017/05/22/20170522115959/"/>
      <url>/2017/05/22/20170522115959/</url>
      
        <content type="html"><![CDATA[<img src="/2017/05/22/20170522115959/new.jpg" title="new 的实现原理"><p><br></p><h2 id="构造函数和实例化"><a href="#构造函数和实例化" class="headerlink" title="构造函数和实例化"></a>构造函数和实例化</h2><p>在 <code>JavaScript</code> 可以通过构造函数批量创建对象，这个创建的过程通过 <code>new</code> 关键字实现，也被称作实例化，对象被创建时会有默认的属性和原型方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="string">"My name is "</span> + <span class="keyword">this</span>.name + <span class="string">", I'm "</span> + <span class="keyword">this</span>.age + <span class="string">" years old."</span></span><br><span class="line">  <span class="built_in">console</span>.log(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> panda = <span class="keyword">new</span> Person(<span class="string">'panda'</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">panda.sayHi(); <span class="comment">// My name is panda, I'm 25 years old.</span></span><br></pre></td></tr></table></figure><h2 id="new-的过程都做了什么"><a href="#new-的过程都做了什么" class="headerlink" title="new 的过程都做了什么"></a>new 的过程都做了什么</h2><p><strong>在 <code>new</code> 的过程中主要做了 4 件事：</strong></p><ul><li>创建一个空对象；</li><li>将这个空对象的原型指向构造函数的原型；</li><li>执行构造函数，并将默认属性挂载到这个空对象上；</li><li>判断构造函数的返回值，如果是对象则返回这个对象，否则返回新创建的对象。</li></ul><h2 id="模拟-new-关键字"><a href="#模拟-new-关键字" class="headerlink" title="模拟 new 关键字"></a>模拟 new 关键字</h2><p>清楚了构造函数实例化的过程，我们就来手动实现一个 <code>New</code> 函数，来替代关键字 <code>new</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New 函数的第一个参数为构造函数，剩余的参数为实例化传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Constructor = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  <span class="keyword">var</span> result = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用 New 创建实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> panda = New(Person, <span class="string">'panda'</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(panda); <span class="comment">// Person &#123;name: "panda", age: 25&#125;</span></span><br><span class="line">panda.sayHi(); <span class="comment">// My name is panda, I'm 25 years old.</span></span><br></pre></td></tr></table></figure><p>上面的方法已经实现了 <code>new</code> 关键字的功能，但是美中不足的是，不能将构造函数和实例化的参数区分清晰，下面稍微优化一下。</p><figure class="highlight js"><figcaption><span>优化后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> result = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用 New 创建实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> panda = New(Person)(<span class="string">'panda'</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(panda); <span class="comment">// Person &#123;name: "panda", age: 25&#125;</span></span><br><span class="line">panda.sayHi(); <span class="comment">// My name is panda, I'm 25 years old.</span></span><br></pre></td></tr></table></figure><p>与第一种相比只是 <code>New</code> 函数的使用方式有所变化，<code>New</code> 执行后返回一个函数，调用这个返回的函数，才会进行实例化，传入的参数为实例化对象的参数，这样是 <code>New</code> 的功能变的单一，也将构造函数与实例化的参数分开。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 中 Markdown 特殊字符的处理方法</title>
      <link href="/2017/05/19/20170519135903/"/>
      <url>/2017/05/19/20170519135903/</url>
      
        <content type="html"><![CDATA[<img src="/2017/05/19/20170519135903/hexo-markdown.png" title="markdown questions in hexo"><p><br></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote class="pullquote default"><p>在 Hexo 搭建的博客中对文章进行编写，经常会用到一些特殊字符需要转译，比如 <code>-</code>、<code>.</code>、空格、制表符等等，在正常情况下可以使用 <code>\</code> 进行转译，但是有一些字符无法转译，使用后在执行 <code>hexo server</code> 命令的时候会报错。</p></blockquote><p><strong>报错信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unhandled rejection Template render error: (unknown path) [Line 7, Column 23]</span><br><span class="line">  Error: Unable to call `worldcount`, <span class="built_in">which</span> is undefined or falsey......</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>报错的原因是，Hexo 编译时发生错误，可能是文章中存在特殊字符，如：&#123; &#91; &#40; &#41; &#93; &#125; 等等。如下面这段代码：</p><p><strong>在页面中：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; worldcount(post.content) &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Markdown 中：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;#123;&amp;#123; worldcount&amp;#40;post.content&amp;#41; &amp;#125;&amp;#125;</span><br></pre></td></tr></table></figure><p>在 Markdown 中使用 <code>\</code> 无法转译的字符需要使用字符的命名实体或十进制编码，如上面代码中。</p><blockquote class="pullquote warning"><p><em><strong>注意：需要转义的字符只是文本中的特殊字符，代码块中的特殊字符无需转译或使用转译字符。</strong></em></p></blockquote><h2 id="常见特殊字符"><a href="#常见特殊字符" class="headerlink" title="常见特殊字符"></a>常见特殊字符</h2><p>常用特殊字符转译字符对照表：</p><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">命名实体</th><th style="text-align:center">十进制编码</th></tr></thead><tbody><tr><td style="text-align:center">空格</td><td style="text-align:center">&#38;&#110;&#98;&#115;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#54;&#48;&#59;</td></tr><tr><td style="text-align:center">全角空格</td><td style="text-align:center">&#38;&#101;&#109;&#115;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#50;&#50;&#56;&#56;&#59;</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">&#38;&#97;&#112;&#111;&#115;&#59;</td><td style="text-align:center">&#38;&#35;&#51;&#57;&#59;</td></tr><tr><td style="text-align:center">“</td><td style="text-align:center">&#38;&#113;&#117;&#111;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#51;&#52;&#59;</td></tr><tr><td style="text-align:center">(</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#52;&#48;&#59;</td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#52;&#49;&#59;</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">&#38;&#108;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#54;&#48;&#59;</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">&#38;&#103;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#54;&#50;&#59;</td></tr><tr><td style="text-align:center">[</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#57;&#49;&#59;</td></tr><tr><td style="text-align:center">]</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#57;&#51;&#59;</td></tr><tr><td style="text-align:center">{</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#49;&#50;&#51;&#59;</td></tr><tr><td style="text-align:center">}</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#49;&#50;&#53;&#59;</td></tr><tr><td style="text-align:center">´</td><td style="text-align:center">&#38;&#97;&#99;&#117;&#116;&#101;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#56;&#48;&#59;</td></tr><tr><td style="text-align:center">°</td><td style="text-align:center">&#38;&#100;&#101;&#103;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#55;&#54;&#59;</td></tr><tr><td style="text-align:center">®</td><td style="text-align:center">&#38;&#114;&#101;&#103;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#55;&#52;&#59;</td></tr><tr><td style="text-align:center">©</td><td style="text-align:center">&#38;&#99;&#111;&#112;&#121;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#54;&#57;&#59;</td></tr></tbody></table><p>常用数学转译字符对照表：</p><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">命名实体</th><th style="text-align:center">十进制编码</th></tr></thead><tbody><tr><td style="text-align:center">≤</td><td style="text-align:center">&#38;&#108;&#101;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#56;&#48;&#52;&#59;</td></tr><tr><td style="text-align:center">≥</td><td style="text-align:center">&#38;&#103;&#101;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#56;&#48;&#53;&#59;</td></tr><tr><td style="text-align:center">≈</td><td style="text-align:center">&#38;&#97;&#115;&#121;&#109;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#55;&#51;&#59;</td></tr><tr><td style="text-align:center">≠</td><td style="text-align:center">&#38;&#110;&#101;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#56;&#48;&#48;&#59;</td></tr><tr><td style="text-align:center">∩</td><td style="text-align:center">&#38;&#99;&#97;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#52;&#53;&#59;</td></tr><tr><td style="text-align:center">∪</td><td style="text-align:center">&#38;&#99;&#117;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#52;&#54;&#59;</td></tr><tr><td style="text-align:center">∠</td><td style="text-align:center">&#38;&#97;&#110;&#103;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#51;&#54;&#59;</td></tr><tr><td style="text-align:center">∞</td><td style="text-align:center">&#38;&#105;&#110;&#102;&#105;&#110;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#51;&#52;&#59;</td></tr><tr><td style="text-align:center">±</td><td style="text-align:center">&#38;&#112;&#108;&#117;&#115;&#109;&#110;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#55;&#55;&#59;</td></tr><tr><td style="text-align:center">√</td><td style="text-align:center">&#38;&#114;&#97;&#100;&#105;&#99;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#51;&#48;&#59;</td></tr><tr><td style="text-align:center">∑</td><td style="text-align:center">&#38;&#115;&#117;&#109;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#50;&#50;&#59;</td></tr><tr><td style="text-align:center">∫</td><td style="text-align:center">&#38;&#105;&#110;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#52;&#55;&#59;</td></tr><tr><td style="text-align:center">Δ</td><td style="text-align:center">&#38;&#68;&#101;&#108;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#49;&#54;&#59;</td></tr></tbody></table><p>常用希腊字母转译字符对照表：</p><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">命名实体</th><th style="text-align:center">十进制编码</th></tr></thead><tbody><tr><td style="text-align:center">Φ</td><td style="text-align:center">&#38;&#80;&#104;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#51;&#52;&#59;</td></tr><tr><td style="text-align:center">Ω</td><td style="text-align:center">&#38;&#79;&#109;&#101;&#103;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#51;&#55;&#59;</td></tr><tr><td style="text-align:center">α</td><td style="text-align:center">&#38;&#97;&#108;&#112;&#104;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#53;&#59;</td></tr><tr><td style="text-align:center">β</td><td style="text-align:center">&#38;&#98;&#101;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#54;&#59;</td></tr><tr><td style="text-align:center">γ</td><td style="text-align:center">&#38;&#103;&#97;&#109;&#109;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#55;&#59;</td></tr><tr><td style="text-align:center">δ</td><td style="text-align:center">&#38;&#100;&#101;&#108;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#56;&#59;</td></tr><tr><td style="text-align:center">ε</td><td style="text-align:center">&#38;&#101;&#112;&#115;&#105;&#108;&#111;&#110;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#57;&#59;</td></tr><tr><td style="text-align:center">ζ</td><td style="text-align:center">&#38;&#122;&#101;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#48;&#59;</td></tr><tr><td style="text-align:center">η</td><td style="text-align:center">&#38;&#101;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#49;&#59;</td></tr><tr><td style="text-align:center">θ</td><td style="text-align:center">&#38;&#116;&#104;&#101;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#50;&#59;</td></tr><tr><td style="text-align:center">λ</td><td style="text-align:center">&#38;&#108;&#97;&#109;&#98;&#100;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#53;&#59;</td></tr><tr><td style="text-align:center">μ</td><td style="text-align:center">&#38;&#109;&#117;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#54;&#59;</td></tr><tr><td style="text-align:center">ξ</td><td style="text-align:center">&#38;&#120;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#56;&#59;</td></tr><tr><td style="text-align:center">π</td><td style="text-align:center">&#38;&#112;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#48;&#59;</td></tr><tr><td style="text-align:center">ρ</td><td style="text-align:center">&#38;&#114;&#104;&#111;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#49;&#59;</td></tr><tr><td style="text-align:center">σ</td><td style="text-align:center">&#38;&#115;&#105;&#103;&#109;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#51;&#59;</td></tr><tr><td style="text-align:center">φ</td><td style="text-align:center">&#38;&#112;&#104;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#54;&#59;</td></tr><tr><td style="text-align:center">ψ</td><td style="text-align:center">&#38;&#112;&#115;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#56;&#59;</td></tr><tr><td style="text-align:center">ω</td><td style="text-align:center">&#38;&#111;&#109;&#101;&#103;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#57;&#59;</td></tr><tr><td style="text-align:center">∂</td><td style="text-align:center">&#38;&#112;&#97;&#114;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#48;&#54;&#59;</td></tr><tr><td style="text-align:center">∅</td><td style="text-align:center">&#38;&#101;&#109;&#112;&#116;&#121;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#48;&#57;&#59;</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
