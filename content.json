[{"title":"React 基础篇 —— Router 4.0 的基本使用","date":"2018-09-21T10:27:54.000Z","path":"2018/09/21/20180921182754/","text":"React 路由简介在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，React 全家桶中也有配套的路由系统，在路由 2.0 版本时叫做 react-router，在路由 4.0 时更名为 react-router-dom，我们本次就针对较新版本的 Router 系统进行介绍。 创建项目为了方便演示如何 Router，我们使用 create-react-app 创建一个 React 项目，并删除 src 文件夹内多余文件，创建我们需要的文件 index.js，目录结构如下。 react-router |- public | |- favicon.ico | |- index.html | |- manifest.json |- src | |- pages | | |- Add.js | | |- Detail.js | | |- Home.js | | |- Index.js | | |- List.js | | |- Login.js | | |- Logo.js | | |- MenuLink.js | | |- Profile.js | | |- Protected.js | | |- User.js | |- App.js | |- index.css | |- index.js |- .gitignore |- package.json |- README.md |- yarn.lock 其中主组件为 App，在 index.js 中渲染，index.js 代码如下。 路径：&#126;react-router/src/index.js12345import React from 'react';import ReactDOM from 'react-dom';import App from './App';ReactDOM.render(&lt;App/&gt;, window.root); 而 App 组件主要用来渲染菜单导航和路由组件，我们将在下面完善代码。 HashRouter 和 BrowserRouter在 React Router 中，给我们提供了一些路由相关的组件，其中最重要的就是实现路由的 HashRouter 和 BrowserRouter，我们知道浏览器的 hash 值发生变化会阻止页面的跳转，而 HashRouter 就是利用这个特性实现的，通过监听 onhanshchange 事件在 hash 值改变的时候做出响应，BrowserRouter 则是利用 H5 的新 History API 的 pushState 方法构造的的历史记录集合来实现的。 通常情况下，在开发的时候使用 HashRouter 更多，而在真正上线时替换成 BrowserRouter，两种 Router 在地址栏上的表现上区别只是是否含有 #，两种 Router 的使用如下。 路径：&#126;react-router/src/App.js —— HashRouter123456789101112import React, &#123; Component &#125; from 'react';import &#123; HashRouter &#125; from 'react-router-dom';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &#123;/* 路由相关代码 */&#125; &lt;/HashRouter&gt; ) &#125;&#125; 路径：&#126;react-router/src/App.js —— BrowserRouter123456789101112import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter &#125; from 'react-router-dom';export default class App extends Component &#123; render() &#123; return ( &lt;BrowserRouter&gt; &#123;/* 路由相关代码 */&#125; &lt;/BrowserRouter&gt; ) &#125;&#125; 其实就是使用 React Router 中提供的这两种类型的路由组件对路由相关的 JSX 进行包裹。 Route 和 Link 组件Route 组件是用来定义路由跳转的切换组件的区域，通过 path 属性定义匹配的路由，component 属性来定义渲染的组件，渲染后就是一个 div 标签，Link 是用来点击跳转路由的，通常用来定义导航栏内容，通过 to 属性设置匹配的路由，需要与 Route 的 path 一一对应，点击后可切换到对应的路由组件，渲染后为一个 a 标签。 创建路由跳转的组件下面我们来创建三个路由对应的组件，分别为首页、用户、个人中心，对应的组件分别为 Home.js、User.js、Profile.js 路径：&#126;react-router/src/pages/Home.js123456789import React, &#123; Component &#125; from 'react';export default class Home extends Component &#123; render() &#123; return ( &lt;div&gt;主页&lt;/div&gt; ) &#125;&#125; 路径：&#126;react-router/src/pages/User.js123456789import React, &#123; Component &#125; from 'react';export default class User extends Component &#123; render() &#123; return ( &lt;div&gt;用户&lt;/div&gt; ) &#125;&#125; 路径：&#126;react-router/src/pages/Profile.js123456789import React, &#123; Component &#125; from 'react';export default class Profile extends Component &#123; render() &#123; return ( &lt;div&gt;个人中心&lt;/div&gt; ) &#125;&#125; 配合使用 Route 和 Link使用 Link 和 Route 配合使用如下，点击 Link 会在类名 container 的元素种加载路由路径对应的组件。 路径：&#126;react-router/src/App.js1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react';import &#123; HashRouter, Route, Link &#125; from 'react-router-dom';import Home from './pages/Home';import User from './pages/User';import Profile from './pages/Profile';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;div&gt; &lt;ul className=\"nav\"&gt; &lt;li&gt;&lt;Link to=\"/home\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/user\"&gt;用户&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/profile\"&gt;个人中心&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div className=\"container\"&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" component=&#123;User&#125;/&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/HashRouter&gt; ) &#125;&#125; 启动项目后上面的代码已经可以帮助我们实现页面路由的切换，但是上面的代码 Link 和 Route 组件混在一起，我们其实可以将 App 拆分成两个组件，一个用来存放 Link 部分，一个用来存放 Route 部分，创建 Index 组件，将 Link 的部分抽取出去，代码修改如下。 路径：&#126;react-router/src/App.js —— 修改后1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import &#123; HashRouter, Route &#125; from 'react-router-dom';import Home from './pages/Home';import User from './pages/User';import Profile from './pages/Profile';import Index from './pages/Index';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" component=&#123;User&#125;/&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) &#125;&#125; 路径：&#126;react-router/src/pages/Index.js1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import &#123; Link &#125; from 'react-router-dom';export default class Index extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;a className=\"navbar-brand\"&gt;管理系统&lt;/a&gt; &lt;/div&gt; &lt;ul className=\"nav\"&gt; &lt;li&gt;&lt;Link to=\"/home\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/user\"&gt;用户&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/profile\"&gt;个人中心&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div className=\"container\"&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125; 经过修改之后 Index 组件专门用来维护导航组件 Link，App 组件专门用来维护路由组件 Route，这样代码看起来就不那么混乱了。 Route 组件的 exact 属性上面我们所定义的路由为一级路由，在路由匹配并成功加载对应组件后，如果组件又由多个组件组成，并有类似导航的操作（当然不仅限于导航）来控制其他的组件视图的切换，则需要匹配二级路由，这就出现了一个问题，我们以 /user 为例，假设添加一个新的路由 /user/add，那么 React 会由上到下依次匹配，/user/add 中包含 /user，因此会同时渲染两个组件，这不是我们希望的。 在 React 内部给我们提供了解决方案，就是给路由设置严格匹配，我们只需要让 /user 对应的 Route 组件添加 exact 属性，并将值设置为 true 即可，所以匹配 /user/add 时就不会出现 /user 对应的路由组件也被渲染的情况，当然也可以将 exact 简写到 Route 组件上省略赋值为 true 的过程。 路径：&#126;react-router/src/App.js —— 添加 exact123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import &#123; HashRouter, Route &#125; from 'react-router-dom';import Home from './pages/Home';import User from './pages/User';import Profile from './pages/Profile';import Index from './pages/Index';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" exact=&#123;true&#125; component=&#123;User&#125;/&gt; &lt;Route path=\"/user/add\" component=&#123;User&#125;/&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) &#125;&#125; Switch 组件因为 React 的路由是由上至下依次进行匹配的，如果有两个同名路由进行匹配，会同时加载两个组件，这也是我们需要优化的，React Router 的 Switch 组件就是来做这件事的，只需要将多个 Route 组件包裹起来，就可以实现只要成功匹配一个路由就不再继续匹配。 路径：&#126;react-router/src/App.js —— 添加 Switch 组件123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';import Home from './pages/Home';import User from './pages/User';import Profile from './pages/Profile';import Index from './pages/Index';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" exact=&#123;true&#125; component=&#123;User&#125;/&gt; &lt;Route path=\"/user/add\" component=&#123;User&#125;/&gt; &lt;Route path=\"/user/add\" component=&#123;User&#125;/&gt; &#123;/* 同名路由 */&#125; &lt;Route path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) &#125;&#125; 使用 Switch 组件优化后，启动项目就可以发现只渲染了一个 User 组件。 Redirect 组件在 React 开发中经常遇到路径输入错误的情况，通常情况有两种处理方式，第一种是跳转到一个 404 页面，第二种方式是将页面路由重定向到主页，而 React Router 提供的 Redirect 组件就是帮助我们在所有路由都匹配失败时重定向的，使用时通常放在最后一个 Route 组件的下面用来 “兜底”，使用 to 属性来定义重定向的路由。 路径：&#126;react-router/src/App.js —— 添加 Redirect 组件1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';import Home from './pages/Home';import User from './pages/User';import Profile from './pages/Profile';import Index from './pages/Index';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" exact=&#123;true&#125; component=&#123;User&#125;/&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;Redirect to=\"/home\"/&gt; &#123;/* 无法匹配路由时重定向 */&#125; &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) &#125;&#125; 注意：不能放在 Route 组件的上面，因为放在上面不会匹配任何的路由，而会直接重定向到设置的页面。 对于路由都没有匹配而返回 404 页面我们这里也简单说一下，但是这样的用法非常少，使用 Redirect 重定向到指定页面的方式会更多一些。 路径：&#126;react-router/src/App.js —— 匹配失败跳转 404 页面1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';import Home from './pages/Home';import User from './pages/User';import Profile from './pages/Profile';import Index from './pages/Index';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" exact=&#123;true&#125; component=&#123;User&#125;/&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;Route path=\"/\" component=&#123;Error&#125;/&gt; &#123;/* Error 组件代表 404 */&#125; &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) &#125;&#125; 由于其他的路由都匹配失败，最后会和 / 匹配，所以会显示 Error 组件，这里的 Route 的组件也必须放在最下面来 “兜底”。 二级路由实现二级路由在了解 React Router 的基本使用后，我们用同样的知识点来给 User 组件写一个二级路由，User 中有一个子导航，分别对应用户列表 List 组件和添加用户 Add 组件，代码的套路与之前相同。 路径：&#126;react-router/src/pages/User.js1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; Link, Route, Switch &#125; from 'react-router-dom';import Add from './Add';import List from './List';export default class User extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;ul className=\"sub-nav\"&gt; &lt;li&gt;&lt;Link to=\"/user/list\"&gt;用户列表&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/user/add\"&gt;添加用户&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div className=\"sub-container\"&gt; &lt;Switch&gt; &lt;Route path=\"/user/list\" component=&#123;List&#125;/&gt; &lt;Route path=\"/user/add\" component=&#123;Add&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 解决默认路径不匹配的问题当通过 React Router 访问 /user 的时候，会先加载 User 组件，再加载 User 内部的组件包括子导航，但是 /user 的路径既没有和 /user/add 匹配，也没有和 /user/list 匹配，这样渲染了一个空的类名为 sub-containe 的 div 标签，我们应该让 User 组件加载时子路由默认可以匹配一个路由组件，解决方式如下。 路径：&#126;react-router/src/pages/User.js —— Redirect 组件重定向的方式123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; Link, Route, Switch &#125; from 'react-router-dom';import Add from './Add';import List from './List';export default class User extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;ul className=\"sub-nav\"&gt; &lt;li&gt;&lt;Link to=\"/user/list\"&gt;用户列表&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/user/add\"&gt;添加用户&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div className=\"sub-container\"&gt; &lt;Switch&gt; &lt;Route path=\"/user/list\" component=&#123;List&#125;/&gt; &lt;Route path=\"/user/add\" component=&#123;Add&#125;/&gt; &lt;Redirect to=\"/user/list\"/&gt; &#123;/* 重定向到 List 组件 */&#125; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 上面的方式是使用 Redirect 组件重定向的方式实现的，但是这样访问的 /user，路径会自动改变为 /user/list，感觉上有一些奇怪，当然还有另外的解决方式。 路径：&#126;react-router/src/pages/User.js —— Route 组件严格匹配123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; Link, Route, Switch &#125; from 'react-router-dom';import Add from './Add';import List from './List';export default class User extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;ul className=\"sub-nav\"&gt; &lt;li&gt;&lt;Link to=\"/user/list\"&gt;用户列表&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/user/add\"&gt;添加用户&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div className=\"sub-container\"&gt; &lt;Switch&gt; &lt;Route path=\"/user\" exact component=&#123;List&#125;/&gt; &lt;Route path=\"/user/list\" component=&#123;List&#125;/&gt; &lt;Route path=\"/user/add\" component=&#123;Add&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 上面的方式是当匹配到了 /user 的路由也加载默认要渲染的 List 组件实现的，但是为了防止向下继续匹配，可以添加 exact 设置严格匹配，进一步优化可以使用 Switch 组件，让路由成功匹配一次后不再向下匹配。 编程式导航我们经常会遇到一个场景，就是在某些交互之后实现页面的自动跳转，而对于 React 搭建的单页面应用来说就是路由切换，在 React 中都最初是通过 Link 组件的点击手动实现的路由切换，那么怎么通过纯编程的方式在某些交互后自动切换路由呢，其实 React Router 的 Route 组件会给内部渲染的组件传递路由相关的三个参数 history、location 和 match。 三个属性值均为对象，history 上存储了 length 属性代表当前支持存入历史记录的数量，也同样存储了 location，用来存储路由路径的相关信息，还有用来操作路由跳转的方法 go（传入数字代表前进或后退几页）、goBack（后退）、goForward（前进）、replace（用其他路由替换当前历史）、push，其中最常用的就是 push 方法，下面会着重介绍，match 中存储了一些路由匹配的相关信息，如 url，即浏览器输入的路径，真正匹配的路径 path 属性以及是代表否严格匹配的 isExact 属性，在 match 中最重要的是 params 属性，值为对象，用来存储路由参数，这个我们放在后面来说。 下面在 Add 组件中添加一输入框和按钮，当点击按钮是将输入框的数据存入 localStorage 中，并自动将路由跳转到 /user/list，即渲染 List 组件，然后将数据取出渲染到 List 组件中，这是一个很常见的需求，添加数据然后跳到详情页的场景，下面是 Add 组件中的实现。 路径：&#126;react-router/src/pages/Add.js123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';export default class Add extends Component &#123; input = React.createRef() // 非受控组件取值 // 表单提交事件 handleSubmit = (e) =&gt; &#123; e.preventDefault(); // 取消默认的页面跳转事件 // 先从 localStorage 获取已有数据 const lists = JSON.parse(localStorage.getItem('lists')) || []; // 添加新数据 lists.push(&#123; id: lists.length + 1, username: this.input.current.value &#125;); // 存入 localStorage localStorage.setItem('lists', JSON.stringify(lists)); // 编程式导航，自动跳转到 List this.props.history.push('/user/list'); &#125; render() &#123; return ( &lt;div&gt; &lt;form className=\"form\" onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label htmlFor=\"username\" className=\"control-label\"&gt;用户名&lt;/label&gt; &lt;input className=\"form-control\" type=\"text\" id=\"username\" ref=&#123;this.input&#125; /&gt; &lt;br/&gt; &lt;input type=\"submit\" className=\"btn btn-success\"/&gt; &lt;/form&gt; &lt;/div&gt; ) &#125;&#125; 在上面我们通过 Route 传递给渲染组件的 history 的 push 方法实现了路由的自动跳转，push 方法接收的参数就是将要跳转的路径字符串，List 组件代码如下。 路径：&#126;react-router/src/pages/List.js123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from 'react';export default class List extends Component &#123; state = &#123; users: [] &#125; componentWillMount() &#123; // 取出 localStorage 数据并更新状态 const users = JSON.parse(localStorage.getItem('lists')) || []; this.setState(&#123; users &#125;); &#125; render() &#123; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户 ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123; this.state.users.map((&#123; id, username &#125;) =&gt; &#123; return ( &lt;tr key=&#123;id&#125;&gt; &lt;td&gt;&#123;id&#125;&lt;/td&gt; &lt;td&gt;&#123;username&#125;&lt;/td&gt; &lt;/tr&gt; ) &#125;) &#125; &lt;/tbody&gt; &lt;/table&gt; ) &#125;&#125; 取出 localStorage 中的数据在 List 中渲染时有两点注意，第一是取出数据和设置状态应该在 render 渲染 JSX 之前，这样在没有执行 render 时会合并状态并只渲染一次，也就是说 componentWillMount “钩子” 和 render “钩子” 的 return 语句前更新状态都是可以的，如果在 componentDidMount “钩子” 中更新会导致组件渲染两次，在 React 开发中如果获取数据的过程是同步的（localStorage 取值是同步的），不需要渲染两次。 第二点是在使用表格元素 table 渲染时，必须要含有 thead 和 tbody，这是 React 规定的，不可以省略。 路由参数的传递现在在我们的 List 组件表格中，点击每一行都可以跳转到学生 ID 对应的详情 Detail 组件中，由于每一个学生的 ID 不同渲染的详情也不相同，此时需要将学生 ID 作为路由参数进行传递，并在 Detail 内渲染对应的内容，由于 Detail 组件的渲染与 List 组件是同一区域，所以仍然是二级路由，我们需要在 User 组件中进行添加。 路径：&#126;react-router/src/pages/User.js —— 增加 Detail 二级路由1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react';import &#123; Link, Route, Switch &#125; from 'react-router-dom';import Add from './Add';import List from './List';import Detail from './Detail';export default class User extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;ul className=\"sub-nav\"&gt; &lt;li&gt;&lt;Link to=\"/user/list\"&gt;用户列表&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/user/add\"&gt;添加用户&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div className=\"sub-container\"&gt; &lt;Switch&gt; &lt;Route path=\"/user\" exact component=&#123;List&#125;/&gt; &lt;Route path=\"/user/list\" component=&#123;List&#125;/&gt; &lt;Route path=\"/user/add\" component=&#123;Add&#125;/&gt; &lt;Route path=\"/user/detail/:id\" component=&#123;Detail&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 在 React Router 中，我们通过给路由后面添加 /:paramname 的方式添加参数，也可以通过 /:paramname/:paramname 传递多个参数（形参），由于在 List 中点击表格的的某行的单元格跳转路由，所以 List 组件修改如下。 路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数12345678910111213141516171819202122232425262728293031323334353637import React, &#123; Component &#125; from 'react';import &#123; Link &#125; from 'react-router-dom';export default class List extends Component &#123; state = &#123; users: [] &#125; componentWillMount() &#123; // 取出 localStorage 数据并更新状态 const users = JSON.parse(localStorage.getItem('lists')) || []; this.setState(&#123; users &#125;); &#125; render() &#123; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户 ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123; this.state.users.map((&#123; id, username &#125;) =&gt; &#123; return ( &lt;tr key=&#123;id&#125;&gt; &lt;td&gt;&#123;id&#125;&lt;/td&gt; &lt;td&gt;&lt;Link to=&#123;`/user/detail/$&#123;id&#125;`&#125;&gt;&#123;username&#125;&lt;/Link&gt;&lt;/td&gt; &lt;/tr&gt; ) &#125;) &#125; &lt;/tbody&gt; &lt;/table&gt; ) &#125;&#125; 在 List 组件中，同样使用 Link 组件对要点击切换路由的节点进行包裹，并用 to 属性设置跳转的路由和路由参数（实参），现在点击就可以实现从 List 组件到 Detail 组件的切换，如果我们有些 List 的数据想在跳转到 Detail 组件时直接带过去，则可以使用另一种写法如下。 路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数和数据123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';import &#123; Link &#125; from 'react-router-dom';export default class List extends Component &#123; state = &#123; users: [] &#125; componentWillMount() &#123; // 取出 localStorage 数据并更新状态 const users = JSON.parse(localStorage.getItem('lists')) || []; this.setState(&#123; users &#125;); &#125; render() &#123; return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户 ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123; this.state.users.map((&#123; id, username &#125;) =&gt; &#123; return ( &lt;tr key=&#123;id&#125;&gt; &lt;td&gt;&#123;id&#125;&lt;/td&gt; &lt;td&gt; &lt;Link to=&#123;&#123; pathname: `/user/detail/$&#123;id&#125;`, state: username &#125;&#125;&gt;&#123;username&#125;&lt;/Link&gt; &lt;/td&gt; &lt;/tr&gt; ) &#125;) &#125; &lt;/tbody&gt; &lt;/table&gt; ) &#125;&#125; 不同的是给 to 属性传入的值从一个代表路由的字符串变成了一个对象，而把路由的字符串作为了 pathname 属性的值，state 属性则代表了路由跳转传给渲染组件的数据，还记得渲染的组件使用 Route 组件包裹的，会传入 history、loacltion 和 match 三个属性，同样的，通过点击 Link 传递的路由参数和数据都可以在 props 上获取到，前者通过 location.state 或者 history.location.state 上获取到，后者可以通过 match.params 上获取到，那么 Detail 组件将传递过来的参数渲染，代码如下。 路径：&#126;react-router/src/pages/Detail.js12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react';export default class Detail extends Component &#123; state = &#123; user: &#123;&#125; &#125; componentWillMount() &#123; // 有值说明是点击过来的，否则是地址栏输入的 const data = this.props.location.state; // 获取路由参数 const id = parseInt(this.props.match.params.id); // 如果是点击过来的直接将数据设置给 state，否则去 localStorage 取值设置给 state if (data) &#123; this.setState(&#123; user: &#123; id, username: data &#125;&#125;); &#125; else &#123; const users = JSON.parse(localStorage.getItem('lists')) || []; const user = users.find(item =&gt; item.id === id); this.setState(&#123; user: &#123; id, username: user.username &#125;&#125;); &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;span&gt;&#123;this.state.user.id&#125;&lt;/span&gt; &lt;span&gt; ------- &lt;/span&gt; &lt;span&gt;&#123;this.state.user.username&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;&#125; 这里有两点注意点，首先通过组件 props.match.params 获取的路由参数都是字符串格式，如果原本类型为数字，使用时应转换成数字类型，其次是传递的数据，也就是组件通过 props.location.state 获取的数据，只有在通过 Link组件点击过去才会存在，在地址栏输入为 undefined，所以防止用户刷新页面导致数据丢失，应该在两种情况下处理不同的获取数据的逻辑。 withRouter 函数在之前的编程式导航中我们使用了 Route 传递给渲染组件的 props.history.push 方法实现的，现在假设我们要对一个不是路由跳转的组件，通过点击事件来获取 history、location 和 match 属性，并使用 history 上的路由设置方法进行跳转路由，这应该如何实现呢？ 其实 React Route 给我们提供了一个函数 withRouter 方法，在调用该方法时，则会返回一个新的组件，当然其实这是一个高阶组件的应用，withRouter 方法内部帮我们在传入的组件外层包装了一层 Route 组件，并传入了 history、location 和 match 属性作为参数，所以当我们使用返回的组件时可以通过 props 属性获取 history、location 和 match。 下面针对我们之前的 Index 组件的内的 “管理系统” 的标签抽出一个新的组件，并将这个组件添加点击可以跳转到登录页 Login 组件的功能，Login 组件为一级路由，所以我们应该修改 App 组件，添加一个 /login 的路由，Login 和修改后的 App 组件如下。 路径：&#126;react-router/src/App.js —— 添加 Login 组件路由12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';import Home from './pages/Home';import User from './pages/User';import Profile from './pages/Profile';import Index from './pages/Index';import Login from './pages/Login';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" exact=&#123;true&#125; component=&#123;User&#125;/&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; &#123;/* 添加登录页路由 */&#125; &lt;Redirect to=\"/home\"/&gt; &#123;/* 无法匹配路由时重定向 */&#125; &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) &#125;&#125; 路径：&#126;react-router/src/pages/Login.js —— 添加登录和退出功能1234567891011121314151617181920import React, &#123; Component &#125; from 'react';export default class Login extends Component &#123; login = () =&gt; &#123; localStorage.setItem('login', 'ok'); &#125; exit = () =&gt; &#123; localStorage.removeItem('login'); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.login&#125;&gt;登录&lt;/button&gt; &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 在 Login 中顺便添加了两个按钮来模拟 “登录” 和 “退出”，并给按钮添加了事件，在登录时向 localStorage 中添加 login 属性，在退出时清除这个属性，以模拟登录状态。 抽取出 Logo 后的 Index 组件也应该添加一个新的导航为 “登录”，Login 组件和修改后的 Index 组件如下。 路径：&#126;react-router/src/pages/Index.js —— 抽出 Logo 组件并添加登录导航12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import &#123; Link &#125; from 'react-router-dom';import Logo from './Logo';export default class Index extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Logo&gt;&lt;/Logo&gt; &lt;/div&gt; &lt;ul className=\"nav\"&gt; &lt;li&gt;&lt;Link to=\"/home\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/user\"&gt;用户&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/profile\"&gt;个人中心&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/login\"&gt;登录&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div className=\"container\"&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125; 路径：&#126;react-router/src/pages/Logo.js1234567891011121314151617import React, &#123; Component &#125; from 'react';import &#123; withRouter &#125; from 'react-router-dom';class Logo extends Component &#123; change = () =&gt; &#123; console.log(this.props); this.props.history.push('/login'); &#125; render() &#123; return ( &lt;div className=\"navbar-brand\" onClick=&#123;this.change&#125;&gt;管理系统&lt;/div&gt; ) &#125;&#125;export default withRouter(Logo); 通过 Logo 案例的代码我们可以看出，其实最后导出的并不是 Logo 组件，而是使用 withRouter 函数包装后返回的高阶组件，withRouter 方法内部帮我们搞定了 Logo 组件的 props 没有 history、location 和 match 属性的问题。 受保护的路由以前在点击个人中心时会直接渲染 Profile 组件，在给 Login 组件添加 “登录” 和 “退出” 之后，再次点击个人中心时，应该先对登录状态进行验证，如果 localStorage 中存在 login 属性，则渲染 Profile 的 Route 组件，否则重定向到登录页，如果在登录页点击登录后再重新跳回个人中心（从哪来回哪去）。 这就需要我对 App 组件路由部分的代码进行修改，使用高阶组件来添加登录验证逻辑，当然，这个高阶组件不是 React Router 提供的，需要我们自己来实现，这种做法被官方称作 “受保护的路由”。 路径：&#126;react-router/src/App.js —— 添加受保护的路由12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';import Home from './pages/Home';import User from './pages/User';import Profile from './pages/Profile';import Index from './pages/Index';import Login from './pages/Login';import Protected from './pages/Protected';export default class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" exact=&#123;true&#125; component=&#123;User&#125;/&gt; &#123;/* 添加受保护的路由 */&#125; &lt;Protected path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; &#123;/* 无法匹配路由时重定向 */&#125; &lt;Redirect to=\"/home\"/&gt; &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) &#125;&#125; 我们重写了 App 组件中个人中心对应的路由，将原来的 Route 组件用高阶组件 Protected 代替，也就等于是将原本传入的参数 path 和 component 传入了高阶组件 Protected，下面来看一下高阶组件 Protected 的实现。 路径：&#126;react-router/src/pages/Protected.js —— 添加受保护的路由1234567891011import React, &#123; Component &#125; from 'react';import &#123; Route, Redirect &#125; from 'react-router-dom';export default class Protected extends Component &#123; render() &#123; const login = localStorage.getItem('login'); return login ? &lt;Route &#123;...this.props&#125;/&gt; : &lt;Redirect to=&#123;&#123; pathname: '/login', state: &#123; 'from': '/profile' &#125;&#125;&#125;/&gt; &#125;&#125; 在 Protected 获取登录状态，存在时直接渲染了 Route 组件，并将 path 和 component 参数传入，如果不存在则渲染 Redirect 组件重定向到登录页，传入的参数同 Link 组件的规则相同，pathname 代表重定向的路径，state 代表带过去的数据，我们这里添加了一个 from 属性，用来记录渲染登录页的来源，即个人中心。 接下来就是 Login 组件中在点击登录后验证是否存在 state，如果存在则返回存储的 from 对应的路由，即个人中心，不存在则跳回首页，Login 修改如下。 路径：&#126;react-router/src/pages/Login.js —— 完善登录功能123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react';export default class Login extends Component &#123; login = () =&gt; &#123; localStorage.setItem('login', 'ok'); // 获取上一个路由传递的 state const prevPathDate = this.props.location.state; // 存在 state 则返回来源对应的页面，否则回主页 if (prevPathDate) &#123; this.props.history.push(prevPathDate.from); &#125; else &#123; this.props.history.push('/home'); &#125; &#125; exit = () =&gt; &#123; localStorage.removeItem('login'); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.login&#125;&gt;登录&lt;/button&gt; &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 这样 “受保护的路由” 功能就实现了，其实就是在跳转路由之前起到了一个 “拦截” 的作用，经常的使用场景是权限管理，这是一个路由的应用，也是一个高阶组件的应用，这样的应用在大型复杂的 React 中会频繁使用，还是比较重要的。 NavLink 组件在实际项目开发中，我们经常遇到导航标签被选中时被添加一个代表 “激活” 的类名，用于添加与其他导航选项不同的样式，React Router 已经给我们提供了 NavLink 组件用于实现这个功能，NavLink 组件具备 Link 组件所有的功能，唯一不同的就是 NavLink 组件在被选中时不止发生路由跳转，还会给渲染后的 a 标签添加一个名为 active 的 class 属性，而我们只需要通过 css 去给类名 active 设置样式即可。 路径：&#126;react-router/src/index.css —— 激活样式123a.active &#123; color: skyblue !important;&#125; 设置好激活样式以后，我们只需要在 Index 组件中引入激活样式的 css 文件并将 Link 组件替换成 NavLink 组件即可。 路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; NavLink &#125; from 'react-router-dom';import Logo from './Logo';// 引入激活样式import '../index.css';export default class Index extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Logo&gt;&lt;/Logo&gt; &lt;/div&gt; &lt;ul className=\"nav\"&gt; &lt;li&gt;&lt;NavLink to=\"/home\"&gt;首页&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=\"/user\"&gt;用户&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=\"/profile\"&gt;个人中心&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=\"/login\"&gt;登录&lt;/NavLink&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div className=\"container\"&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125; 自定义导航组件实现激活React Router 在给我们提供的导航组件 NavLink 功能有限，只会给内部的 a 标签在选中时添加 active 类名，如果我们想实现给一个 li 标签添加 active 就需要我们自己封装一个组件来实现这个功能，其实还是通过高阶组件来实现的，首先我们定义这个高阶组件的名字为 MenuLink，将 Index 组件中的 li 标签和 NavLink 组件统一替换成 MenuLink 组件，代码如下。 路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; NavLink &#125; from 'react-router-dom';import Logo from './Logo';import MenuLink from './MenuLink'export default class Index extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Logo&gt;&lt;/Logo&gt; &lt;/div&gt; &lt;ul className=\"nav\"&gt; &lt;MenuLink to=\"/home\"&gt;首页&lt;/MenuLink&gt; &lt;MenuLink to=\"/user\"&gt;用户&lt;/MenuLink&gt; &lt;MenuLink to=\"/profile\"&gt;个人中心&lt;/MenuLink&gt; &lt;MenuLink to=\"/login\"&gt;登录&lt;/MenuLink&gt; &lt;/ul&gt; &lt;div className=\"container\"&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125; 在实现 MenuLink 组件之前我们分析一下实现思路，首先我们依然模拟 NavLink 的方式给 MenuLink 传入了 to 属性，值为将要跳转的路由，所以我们应该在 MenuLink 组件中来接收这个路由，而 MenuLink 内部一定是包含 li 和 Link 组件的，我们可以将这个 to 属性传递给 Link 组件，如果想要通过激活状态给外层的 li 标签设置状态我们需要知道是否匹配了路由，并可以通过 match 属性获得，所以在 li 的外层应该有 Route 组件配合，因为只有 Route 组件才会将 history、location 和 match 作为参数传递给其内部渲染的组件。 这就要说到 Route 组件的渲染模式，在传入 component 属性时，只有匹配组件才会渲染内部组件，我们显然是需要时时刻刻都渲染内部的 li 和 Link，并通过点击 Link 渲染真正的路由组件，所以我们需要用到第二种渲染方式，就是通过 children 属性指定时刻需要渲染的组件，实现代码如下。 路径：&#126;react-router/src/pages/MenuLink.js1234567891011121314151617import React, &#123; Component &#125; from 'react';import &#123; Route, Link &#125; from 'react-router-dom';import '../index.css';export default class MenuLink extends Component &#123; render() &#123; return ( &lt;Route path=&#123;this.props.to&#125; children=&#123;(&#123; match &#125;) =&gt; &#123; return ( &lt;li className=&#123;match ? 'active' : ''&#125;&gt; &lt;Link to=&#123;this.props.to&#125;&gt;&#123;this.props.children&#125;&lt;/Link&gt; &lt;/li&gt; ) &#125;&#125;/&gt; ) &#125;&#125; 上面代码中由于 children 组件并不需要操作状态和使用生命周期 “钩子”，所以我们直接使用了函数组件实现，因为 active 类名添加给了 li，所以我们需要在 MenuLink 组件中引入样式文件 index.css 并将修改，代码如下。 路径：&#126;react-router/src/index.css —— 激活样式修改后123li.active a &#123; color: skyblue !important;&#125; 总结本篇通过一个简单的案例使用了由 React Router 所提供的，开发中常用的功能，但美中不足的是并没有使用一些 UI 库或者 CSS 样式来美化，为了更明显的看到 React Router 各个功能使用后的效果，建议大家在实现上面代码的同时自己添加一些 CSS 样式。","tags":[{"name":"React","slug":"React","permalink":"https://www.pandashen.com/tags/React/"},{"name":"Router","slug":"Router","permalink":"https://www.pandashen.com/tags/Router/"}]},{"title":"React 基础篇 —— 组件间的参数传递","date":"2018-09-18T16:26:29.000Z","path":"2018/09/19/20180919002629/","text":"单向数据流每一个可以组件化开发的前端框架如 React、Vue，组件间的参数传递都是一定会谈论的话题，而 React 中数据传递是单向的，也被称为单向数据流，即数据只能从父组件传递到子组件，而子组件只需要通过 props 属性渲染即可，如果顶层组件的某个属性的值改变了，React 将由外向内遍历整个组件树，将使用了该属性的组件重新渲染。 创建项目首先使用 create-react-app 脚手架创建 React 项目，项目生成后删除 src 文件目录下的多余文件，留下 index.js，命令如下。 npm install -g create-react-app create-react-app transfer-props 该项目最后的目录结构如下： transfer-props |- public | |- favicon.ico | |- index.html | |- manifest.json |- src | |- components | | |- App.js | | |- Child.js | | |- Parent.js | |- context.js | |- index.js |- .gitignore |- package.json |- README.md |- yarn.lock 父组件传参给子组件创建一个最外层组件 App，并在 index.js 中进行渲染。 路径：&#126;transfer-props/src/index.js12345import React from 'react';import ReactDOM from 'react';import App from './components/App';ReactDOM.render(&lt;App&gt;&lt;/App&gt;, window.root); App 组件内部状态中含有 users 属性，值为数组，含有 title 属性，现在要将这两个参数传递给 Parent 组件，传参方式如下。 路径：&#126;transfer-props/src/components/App.js123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import Parent from './Parent';export default class App extends Component &#123; // 状态 state = &#123; users: [ &#123; id: 1, name: 'panda', age: '28' &#125;, &#123; id: 2, name: 'shen', age: '18' &#125; ], title: '学生信息' &#125; render() &#123; return ( &lt;div&gt; &lt;Parent &#123;...this.state&#125;&gt;&lt;/Parent&gt; &lt;/div&gt; ) &#125;&#125; Parent 组件中接收到参数，要根据参数中数组的数量来渲染下一个子组件 Child，Child 组件中需要使用父组件 users 数组的学生 id，传参如下。 路径：&#126;transfer-props/src/components/Parent.js1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import Child from './Child';export default class App extends Component &#123; render() &#123; const &#123; users, title &#125; = this.props; return ( &lt;div&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &#123;/* 显示标题 */&#125; &lt;ul&gt; &#123; // 循环创建 Child 组件 users.map(item =&gt; &#123; return ( &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/Child&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; 最后是 Child 组件，用来渲染学生的基本信息，在 Parent 中我们已经将参数传递，最后看看在 Child 中的接收。 路径：&#126;transfer-props/src/components/Child.js1234567891011121314import React, &#123; Component &#125; from 'react';export default class App extends Component &#123; render() &#123; const &#123; id, name, age &#125; = this.props; return ( &lt;li&gt; &lt;span&gt;&#123;id&#125;&lt;/span&gt; &lt;span&gt;&#123;name&#125;&lt;/span&gt; &lt;span&gt;&#123;age&#125;&lt;/span&gt; &lt;/li&gt; ) &#125;&#125; 注意：子组件接收父组件的 props 属性是只读的，不可以修改，修改会报错。 其实在这个过程中参数经历了三个组件，都是由父组件传向子组件，可以看出 React 单向数据流的特点，但是子组件是不可以通过某些操作直接修改父组件的数据的，下面来看看子组件如何修改父组件的数据。 子组件修改父组件的数据在 React 中如果要修改父组件的参数，可以给子组件传入一个修改父组件参数的函数，然后在子组件中执行这个函数，就可以实现父组件数据的更新。 我们创建一个与 Parent 组件平行的 Input 组件，两个组件都是 App 的直接子组件，在 Input 组件内通过某些操作给父组件的状态中的 users 属性新增一条数据。 路径：&#126;transfer-props/src/components/Input.js1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react';export default class Input extends Component &#123; name = React.createRef(); age = React.createRef(); handleSubmit = e =&gt; &#123; // 取消默认事件 e.preventDefault(); // 执行父组件方法，取出输入框的值构造成对象作为参数传入 this.props.addStudent(&#123; name: this.name.current.value, age: this.age.current.value &#125;); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; 姓名：&lt;input type=\"text\" required ref=&#123;this.name&#125;/&gt; &lt;br/&gt; 年龄：&lt;input type=\"text\" required ref=&#123;this.age&#125;/&gt; &lt;br/&gt; &lt;button type=\"submit\"&gt;Add&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 上面是 Input 组件，在修改时没有直接使用按钮的点击事件，而是添加了 form 标签并使用 submit 事件，是因为可以使用 H5 的自带的校验功能，但是使用 form 会自动提交页面，所以在执行 submit 事件时应取消默认事件，然后调用父组件传来的方法 addStudent，并传入输入框获取的值（非受控组件的取值方式），父组件 App 修改如下。 路径：&#126;transfer-props/src/components/App.js —— 修改后1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';import Parent from './Parent';import Input from './Input';export default class App extends Component &#123; // 状态 state = &#123; users: [ &#123; id: 1, name: 'panda', age: '28' &#125;, &#123; id: 2, name: 'shen', age: '18' &#125; ], title: '学生信息' &#125; // 添加学生信息事件 addStudent = val =&gt; &#123; // 使用 push 添加 // this.state.users.push(&#123; id: this.state.users.length + 1, ...val &#125;); // this.setState(&#123;&#125;); // 使用 setState 添加 this.setState(&#123; users: [ ...this.state.users, &#123; id: this.state.users.length + 1, ...val &#125; ] &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;Parent &#123;...this.state&#125;&gt;&lt;/Parent&gt; &lt;Input addStudent=&#123;this.addStudent&#125;&gt;&lt;/Input&gt; &lt;/div&gt; ) &#125;&#125; 首先父组件 App 应该创建 addStudent 方法作为参数传递给子组件 Input，而在 addStudent 方法内部通过 push 和 setState 两种方式进行添加，发现都可以更新状态和视图，区别是 push 操作的原来的引用，而 setState 创建了新的引用空间。 注意：在 React 所有状态的更改都不建议操作原来的引用，通常做法都是通过 setState 返回一个新的 state（创建新的引用），使用解构赋值的方式来保留原始数据，用新数据覆盖旧数据，原因是在 React 类组件种有一个 PureComponent 纯组件类型，对 shouldComponentUpdate 生命周期 “钩子” 做了优化，使用了 props 和 state 的浅比较，所以在纯组件类型操作原来的引用是无法更新视图的。 context 实现跨组件传参在上面的案例当中，父子组件关系的层级是三层，无论是普通的数据还是修改父组件的事件都是作为参数一级一级往下传的，如果组件的层级多了，当跨组件传参时是非常不方便的（通常三级还可以接受）。 跨组件传参是指父级组件与非直接子组件的传参、同级组件之间的传参，同级之间可以找到相同的父级，没有相同的父级就创造相同的父级，最后将问题统一到了父级组件与非直接子组件的传参传递。 在 React 中给我们提供了 context API 用来实现组件树数据的共享，分为新旧两个版本，这里旧版和新版的 API 都会介绍。 旧版 context在旧版的 context 需要配合属性类型检测的 prop-types 模块共同使用，需要在共同的父组件上定义一个方法 getChildContext，返回值为一个对象，对象中存储的是当前要传递给其他子组件的数据，同时还有一个静态属性 childContextTypes，值为一个对象，属性的值与 getChildContext 方法内返回的对象的属性一一对应，并用 prop-types 模块对每一个传递给子组件属性的数据类型进行定义，在使用父组件传递属性的子组件中需要定义静态属性 contextTypes 对所使用的属性的数据类型进行校验，需要父组件与 childContextTypes 内的定义一致，然后可以通过子组件实例的 context 属性获取，我们可以使用 context 将上面的案例修改如下。 路径：&#126;transfer-props/src/components/App.js —— 旧版 context1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; Component &#125; from 'react';import Parent from './Parent';import Input from './Input';import PropTypes from 'prop-types'; // 引入参数类型检测模块export default class App extends Component &#123; // 状态 state = &#123; users: [ &#123; id: 1, name: 'panda', age: '28' &#125;, &#123; id: 2, name: 'shen', age: '18' &#125; ], title: '学生信息' &#125; // 定义参数类型 static childContextTypes = &#123; state: PropTypes.object, addStudent: PropTypes.func &#125; // 上下文对象传给子组件的参数 getChildContext() &#123; return &#123; state: this.state, addStudent: this.addStudent &#125; &#125; // 添加学生信息事件 addStudent = val =&gt; &#123; // 使用 setState 添加 this.setState(&#123; users: [ ...this.state.users, &#123; id: this.state.users.length + 1, ...val &#125; ] &#125;); &#125; render() &#123; return ( &lt;div&gt; &#123;/* 不再需要传参 */&#125; &lt;Parent&gt;&lt;/Parent&gt; &lt;Input&gt;&lt;/Input&gt; &lt;/div&gt; ) &#125;&#125; 上面只是将 APP 组件中原本传给子组件的参数去掉，按照要求添加了 getChildContext 方法和 childContextTypes 静态属性。 路径：&#126;transfer-props/src/components/Input.js —— 旧版 context12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react';export default class Input extends Component &#123; name = React.createRef(); age = React.createRef(); // 类型检测与父组件定义的类型对应 static contextTypes = &#123; addStudent: PropTypes.func &#125; handleSubmit = e =&gt; &#123; // 取消默认事件 e.preventDefault(); // 从上下文对象上获取父组件的方法并执行 this.context.addStudent(&#123; name: this.name.current.value, age: this.age.current.value &#125;); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; 姓名：&lt;input type=\"text\" required ref=&#123;this.name&#125;/&gt; &lt;br/&gt; 年龄：&lt;input type=\"text\" required ref=&#123;this.age&#125;/&gt; &lt;br/&gt; &lt;button type=\"submit\"&gt;Add&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 在 Input 组件中定义 contextTypes 属性，将 addStudent 方法从原来的 props 获取改为了从 context 上获取。 路径：&#126;transfer-props/src/components/Parent.js —— 旧版 context1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react';import Child from './Child';export default class App extends Component &#123; // 类型检测与父组件定义的类型对应 static contextTypes = &#123; state: PropTypes.object &#125; render() &#123; // 从 context 对象上获取 state 并解构 const &#123; users, title &#125; = this.context.state; return ( &lt;div&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &#123;/* 显示标题 */&#125; &lt;ul&gt; &#123; // 循环创建 Child 组件 users.map(item =&gt; &#123; return ( &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/Child&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; 在 Parent 组件中同样定义 contextTypes 属性，将 state 属性从原来的 props 获取改为了从 context 上获取。 新版 context新版 context 其实是 React 对象提供给我们的方法 createContext 实现的，方法在调用时返回一个对象，对象上有两个组件分别为 Provider（提供者）和 Consumer（消费者），由于两个配合使用的组件必须有同一次调用 createContext 时创建，所以我们单独创建文件 context.js 代码如下。 路径：&#126;transfer-props/src/context.js —— 新版 context1234567import React from 'react';// 创建上下文对象const &#123; Provider, Consumer &#125; = React.createContext();// 到处上下文对象的组件export &#123; Provider, Consumer &#125;; 还是之前的案例，我们可以使用新版 context 修改如下。 路径：&#126;transfer-props/src/components/App.js —— 新版 context12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from 'react';import Parent from './Parent';import Input from './Input';import &#123; Provider &#125; from '../context';export default class App extends Component &#123; // 状态 state = &#123; users: [ &#123; id: 1, name: 'panda', age: '28' &#125;, &#123; id: 2, name: 'shen', age: '18' &#125; ], title: '学生信息' &#125; // 添加学生信息事件 addStudent = val =&gt; &#123; // 使用 setState 添加 this.setState(&#123; users: [ ...this.state.users, &#123; id: this.state.users.length + 1, ...val &#125; ] &#125;); &#125; render() &#123; return ( &lt;Provider value=&#123;&#123; addStudent: this.addStudent, state: this.state &#125;&#125;&gt; &lt;div&gt; &lt;Parent &#123;...this.state&#125;&gt;&lt;/Parent&gt; &lt;Input addStudent=&#123;this.addStudent&#125;&gt;&lt;/Input&gt; &lt;/div&gt; &lt;/Provider&gt; ) &#125;&#125; 提供参数的父组件 App 应该使用 Provider 进行包裹，将传入的参数以 value 为参数名（规定），传入 context 对象中。 路径：&#126;transfer-props/src/components/Input.js —— 新版 context1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react';import &#123; Consumer &#125; from '../context.js';export default class Input extends Component &#123; name = React.createRef(); age = React.createRef(); handleSubmit = e =&gt; &#123; // 取消默认事件 e.preventDefault(); // 执行父组件方法，取出输入框的值构造成对象作为参数传入 this.props.addStudent(&#123; name: this.name.current.value, age: this.age.current.value &#125;); &#125; render() &#123; return ( &lt;Consumer&gt; &#123; (&#123; addStudent &#125;) =&gt; &#123; return ( &lt;form onSubmit=&#123;e =&gt; &#123; // 取消默认事件 e.preventDefault(); // 执行父组件方法，取出输入框的值构造成对象作为参数传入 addStudent(&#123; name: this.name.current.value, age: this.age.current.value &#125;); &#125;&#125;&gt; 姓名：&lt;input type=\"text\" required ref=&#123;this.name&#125;/&gt; &lt;br/&gt; 年龄：&lt;input type=\"text\" required ref=&#123;this.age&#125;/&gt; &lt;br/&gt; &lt;button type=\"submit\"&gt;Add&lt;/button&gt; &lt;/form&gt; ) &#125; &#125; &lt;/Consumer&gt; ) &#125;&#125; 在使用 “提供者” 提供数据的 “消费者” 子组件中，应该引入与 Provider 对应的 Consumer 组件，用 Consumer 组件替换原本组件返回的 JSX，内部传入一个函数，函数的形参即为 context 对象，函数内部返回值为原本子组件返回的 JSX，子组件使用父组件的属性可直接从函数的形参获取或解构。 路径：&#126;transfer-props/src/components/Parent.js —— 新版 context12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import Child from './Child';import &#123; Consumer &#125; from '../context.js';export default class App extends Component &#123; render() &#123; return ( &lt;Consumer&gt; &#123; (&#123; users, title &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &#123;/* 显示标题 */&#125; &lt;ul&gt; &#123; // 循环创建 Child 组件 users.map(item =&gt; &#123; return ( &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/Child&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; &lt;/Consumer&gt; ) &#125;&#125; Parent 作为 App 的子组件，修改的方式同 Input 组件相同，如上面代码。 总结关于 React 组件之间传参的各中放式上面基本介绍完了，但是这些传参方式并不能满足于所有的需求，如果是两个毫不相关的组件并且距离共同的父组件层级比较远，即使使用 context 的方式也会显得有些无力，组件间互相传参的需求比较多代码也会冗余和繁琐，因此就有了 Redux、Mobx 等数据状态管理工具，可以将各个组件的状态数据统一管理，各个组件的之间的参数都更容易获取，关于数据状态管理相关的内容我也会在后面的博客中继续更新，敬请期待吧 ^ ^。","tags":[{"name":"React","slug":"React","permalink":"https://www.pandashen.com/tags/React/"}]},{"title":"React 基础篇 —— 生命周期详解","date":"2018-09-15T11:44:39.000Z","path":"2018/09/15/20180915194439/","text":"前言本篇文章主要内容针对 React 类组件的生命周期展开，会详细介绍生命周期 “钩子” 的执行和用法，如果一点也不了解 React 的同学建议先学习一下 React 比较基础的内容，当然也可以看我的文章 React 基础篇 —— 带你走进 React 世界。 创建项目首先使用 create-react-app 脚手架创建一个 React 项目，脚手架工具的安装和项目创建命令如下。 npm install -g create-react-app create-react-app life-cycle 创建项目后删除 src 目录中的无用文件，只留下 index.js 入口文件即可。 类组件的生命周期静态属性 defaultPropsdefaultProps 是用来给 React 类组件设置参数初始值的，也是最早执行的，算不算生命周期说法不一，但是觉得有必要说一下，因为在 React 15.x 版本的时候可以用 React.createClass 创建类组件，组件中有与 defaultProps 静态属性作用相同的生命周期 “钩子” getDefaultProps，随着 React 16.x 版本废弃了 React.createClass，也就使用 defaultProps 属性替代了 getDefaultProps。 1234567891011121314import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; static defaultProps = &#123; num: 0 &#125; render() &#123; return &lt;div&gt;&#123;this.props.num&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root); 启动项目后，发现页面上成功的渲染了节点中的数字，这说明设置初始值生效了。 constructor 方法constructor 是 ES6 中类的写法中给实例设置属性的钩子，在类的实例被创建时执行，下面是对比 defaultProps 静态属性执行顺序的代码。 123456789101112131415161718import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; constructor(props) &#123; super(); console.log(props.number); // 0 &#125; static defaultProps = &#123; num: 0 &#125; render() &#123; return &lt;div&gt;&#123;this.props.num&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root); 从上面案例中可以看到当执行 constructor 时，props 对象中的 num 属性已经有值了，这也充分说明了说明 constructor 是晚于 defaultProps 执行的。 状态对象 state在 React 中，每一个类组件都有一个属于自己的状态，可以使用 setState 方法更新状态，在 React 15.x 中，通过 React.createClass 创建类组件，使用对应的生命周期 “钩子” getInitialState 来创建，同样的，React 16.x 废弃了 React.createClass，创建 state 的过程自然由新的方式代替。 创建 state 的方式大概有两种，分别是在 constructor 中创建或者直接创建 state 属性，代码如下。 第一种创建 state 的方式123456789101112131415161718import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; constructor(props) &#123; super(); this.state = &#123; num: 0 &#125;; &#125; // 创建 state 方式 2 state = &#123; num: 0 &#125; render() &#123; return &lt;div&gt;&#123;this.state.num&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root); 第二种创建 state 的方式123456789101112131415161718import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; constructor(props) &#123; super(); console.log(this.state.num); // 0 &#125; // 创建 state state = &#123; num: 0 &#125; render() &#123; return &lt;div&gt;&#123;this.state.num&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root); 从上面可以看出直接创建 state 属性的方式与创建静态属性 defaultProps 类似，执行要早于 constructor。 componentWillMount 钩子componentWillMount 生命周期 “钩子” 在组件将要挂载时执行，也就是说在组件挂载前会调用 componentWillMount，整个组件的生命周期中只执行一次，一般用于发送当前组件需要的 Ajax 请求获取数据。 在 React 16.3 版本中标识了该 “钩子” 会被在未来版本中废弃，目前仍然可以使用，在 componentWillMount 的可以迁移到 constructor，但不能包含 setState 操作，因为 constructor 中无法调用 setState。 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; constructor(props) &#123; console.log('constructor'); super(); &#125; state = &#123; num: 0 &#125; componentWillMount() &#123; console.log('componentWillMount'); this.setState(&#123; num: 3 &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.num&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// constructor// componentWillMount 从上面的打印结果可以看出 componentWillMount “钩子” 的执行是晚于 constructor 的，从页面渲染 3 的结果来看，在 componentWillMount “钩子” 中已经可以使用 setState 更改状态了。 render 钩子render 钩子的主要作用是返回组件内部要被渲染的 JSX，即所谓的挂载过程，将上面例子简单修改一下。 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; constructor(props) &#123; console.log('constructor'); super(); &#125; state = &#123; num: 0 &#125; componentWillMount() &#123; console.log('componentWillMount'); &#125; render() &#123; console.log('render'); return &lt;div&gt;&#123;this.state.num&#125;&lt;/div&gt;; &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// constructor// componentWillMount// render 从打印结果可以看出 constructor 最先执行，其次是 componentWillMount，最后是 render，由于状态或属性的更新可能导致组件重新渲染，所以 render 可能会被执行多次。 componentDidMount 钩子componentDidMount 生命周期 “钩子” 在组件挂载后执行，一般会将一些依赖于 DOM 的操作放在该 “钩子” 内执行，整个生命周期只执行一次。 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; constructor(props) &#123; console.log('constructor'); super(); &#125; state = &#123; num: 0 &#125; componentWillMount() &#123; console.log('componentWillMount'); &#125; componentDidMount() &#123; console.log('componentDidMount'); &#125; render() &#123; console.log('render'); return &lt;div&gt;&#123;this.state.num&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// constructor// componentWillMount// render// componentDidMount 执行顺序：constructor → componentWillMount → render → componentDidMount。 componentWillUpdate 钩子在调用 setState 更新数据后会触发 render 钩子对组件重新渲染，在执行 render 前会调用 componentWillUpdate 钩子，即将要更新时执行（此时状态和页面都没更新），钩子默认有三个参数，分别为 nextProps、nextState 和 nextContext，即更新后的属性对象、状态对象和上下文对象。 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; // 点击事件 handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('componentWillUpdate'); console.log('nowState', this.state); console.log('nextProps', nextProps); console.log('nextState', nextState); console.log('nextContext', nextContext); &#125; render() &#123; console.log('render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// componentWillUpdate// nowState &#123; num: 0 &#125;// nextProps &#123;&#125;// nextState &#123; num: 1 &#125;// nextContext &#123;&#125;// render 从执行点击事件后的结果来看，在重新渲染之前 componentWillUpdate 早于 render 执行，而在 componentWillUpdate 执行时 state 的状态还未更新。 componentDidUpdate 钩子在调用 setState 更新数据后执行 render 钩子对组件重新渲染，渲染后会立即调用 componentDidUpdate 钩子，此时 state 状态和页面都已经更新，钩子默认有三个参数，分别为 prevProps、prevState 和 prevContext，即更新前的属性对象、状态对象和上下文对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; // 点击事件 handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('componentWillUpdate'); &#125; componentDidUpdate(prevProps, prevState, prevContext) &#123; console.log('componentDidUpdate'); console.log('nowState', this.state); console.log('prevProps', prevProps); console.log('prevState', prevState); console.log('prevContext', prevContext); &#125; render() &#123; console.log('render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// componentWillUpdate// render// componentDidUpdate// nowState &#123; num: 1 &#125;// prevProps &#123;&#125;// prevState &#123; num: 0 &#125;// prevContext &#123;&#125; 触发点击事件后的执行顺序为：componentWillUpdate → render → componentDidUpdate。 shouldComponentUpdate 钩子在使用 setState 更改状态时，其实还会默默的执行 shouldComponentUpdate “钩子”，该钩子有返回值，不使用该 “钩子” 的情况下默认返回值为 true，若使用该 “钩子” 必须指定布尔类型的返回值 true 或 false，当返回值为 true 时代表更新状态和视图，否则不更新，只要使用 setState 就会触发该 “钩子”，该钩子有三个参数，与 componentWillUpdate “钩子” 相同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; // 点击事件 handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('componentWillUpdate'); &#125; componentDidUpdate(prevProps, prevState, prevContext) &#123; console.log('componentDidUpdate'); &#125; shouldComponentUpdate(nextProps, nextState, nextContext) &#123; console.log('shouldComponentUpdate'); console.log('nowState', this.state); console.log('nextProps', nextProps); console.log('nextState', nextState); console.log('nextContext', nextContext); return true; &#125; render() &#123; console.log('render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// shouldComponentUpdate// nowState &#123; num: 0 &#125;// nextProps &#123;&#125;// nextState &#123; num: 1 &#125;// nextContext &#123;&#125;// componentWillUpdate// render// shouldComponentUpdate 当 shouldComponentUpdate “钩子” 返回值为 true 时，触发点击事件后的执行顺序为：shouldComponentUpdate → componentWillUpdate → render → shouldComponentUpdate。 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; // 点击事件 handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('componentWillUpdate'); &#125; componentDidUpdate(prevProps, prevState, prevContext) &#123; console.log('componentDidUpdate'); &#125; shouldComponentUpdate(nextProps, nextState, nextContext) &#123; console.log('shouldComponentUpdate'); console.log('nextState', nextState); return false; &#125; render() &#123; console.log('render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// shouldComponentUpdate// nextState &#123; num: 1 &#125; 不断更新 当 shouldComponentUpdate “钩子” 返回值为 false 时，触发点击事件后只有 shouldComponentUpdate 执行了，并且随着触发点击事件的次数增加，nextState 参数的状态不断变化，但是 state 和页面都不更新。 componentWillUnmount 钩子componentWillUnmount “钩子” 会在组件卸载之前触发，卸载组件需调用 ReactDOM 的 unmountComponentAtNode 方法，并传入一个根节点，将会卸载这个根节点内部的所有组件。 123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; // 点击事件 handleClick = () =&gt; &#123; // 卸载组件 ReactDOM.unmountComponentAtNode(window.root); &#125; componentWillUnmount () &#123; console.log('componentWillUnmount'); &#125; render() &#123; console.log('render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;Kill&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// componentWillUnmount componentWillUnmount 钩子一般用来在卸载组件之前清除可能会调用 setState 的异步操作，为了防止在卸载组件后继续更新状态而报错。 复合组件的生命周期上面着重介绍了单个类组件的生命周期，有的生命周期由于一个组件不容易演示，所以放在了这节中，这节也会将复合组件的生命周期执行顺序进行分析，并阐明一些使用的注意事项。 复合组件渲染生命周期的执行顺序在复合组件中，父组件套着子组件，两个组件都有自己的生命周期，那么执行顺序会是怎么样的，看下面案例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 子组件class ChildCounter extends Component &#123; state = &#123; num: 0 &#125; componentWillMount() &#123; console.log('child-componentWillMount'); &#125; componentDidMount() &#123; console.log('child-componentDidMount'); &#125; render() &#123; console.log('child-render'); return &lt;div&gt;&#123;this.state.num&#125;&lt;/div&gt; &#125;&#125;// 父组件class Counter extends Component &#123; componentWillMount() &#123; console.log('parent-componentWillMount'); &#125; componentDidMount() &#123; console.log('parent-componentDidMount'); &#125; render() &#123; console.log('parent-render'); return ( &lt;div&gt; &lt;ChildCounter&gt;&lt;/ChildCounter&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// parent-componentWillMount// parent-render// child-componentWillMount// child-render// child-componentDidMount// parent-componentDidMount 从上面的执行顺序可以看出，在执行父组件生命周期的时候，执行 render 会渲染子组件，渲染子组件会将子组件的生命周期优先执行，等子组件完成渲染继续父组件的渲染，即继续执行父组件渲染后的生命周期。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 子组件class ChildCounter extends Component &#123; state = &#123; num: 0 &#125; componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('child-componentWillUpdate'); &#125; componentDidUpdate(prevProps, prevState, prevContext) &#123; console.log('child-componentDidUpdate'); &#125; handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num - 1 &#125;); &#125; render() &#123; console.log('child-render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;update-child&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// 父组件class Counter extends Component &#123; componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('parent-componentWillUpdate'); &#125; componentDidUpdate(prevProps, prevState, prevContext) &#123; console.log('parent-componentDidUpdate'); &#125; handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; render() &#123; console.log('parent-render'); return ( &lt;div&gt; &lt;ChildCounter&gt;&lt;/ChildCounter&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;update-parent&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// 点击子组件更新按钮// child-componentWillUpdate// clild-render// child-componentDidUpdate// 点击父组件更新按钮// parent-componentWillUpdate// parent-render// child-componentWillUpdate// clild-render// child-componentDidUpdate// parent-componentDidUpdate 当子组件更新时，父组件不会重新渲染，只会执行子组件的生命周期，当父组件更新时，子组件也会重新渲染，此时当父组件执行 render 时会执行子组件更新相关的生命周期，在继续执行父组件更新相关的生命周期。 点击父组件更新按钮生命周期的执行顺序：parent-componentWillUpdate → parent-render → child-componentWillUpdate → clild-render → child-componentDidUpdate → parent-componentDidUpdate。 点击子组件更新按钮生命周期的执行顺序：child-componentWillUpdate → clild-render → child-componentDidUpdate。 注意：如果更新父组件时，不希望子组件重新渲染，可以通过子组件的 shouldComponentUpdate “钩子” 将返回值设置为 false 的方式来控制。 componentWillReceiveProps 钩子当传入组件的参数，即 props 发生变化时，componentWillReceiveProps “钩子” 执行，该钩子有一个参数，代表下一次更新的 props 对象，执行该 “钩子” 时，props 并没有更新，也就是说是在 props 变化之前执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 子组件class ChildCounter extends Component &#123; componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('child-componentWillUpdate'); &#125; componentDidUpdate(prevProps, prevState, prevContext) &#123; console.log('child-componentDidUpdate'); &#125; shouldComponentUpdate(nextProps, nextState, nextContext) &#123; console.log('child-shouldComponentUpdate'); return true; &#125; componentWillReceiveProps(nextProps) &#123; console.log('child-componentWillReceiveProps'); console.log('nowProps, 'this.props); console.log('nextProps', nextProps); &#125; render() &#123; console.log('child-render'); return &lt;div&gt;&#123;this.props.n&#125;&lt;/div&gt; &#125;&#125;// 父组件class Counter extends Component &#123; state = &#123; num: 0 &#125; componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('parent-componentWillUpdate'); &#125; componentDidUpdate(prevProps, prevState, prevContext) &#123; console.log('parent-componentDidUpdate'); &#125; handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; render() &#123; console.log('parent-render'); return ( &lt;div&gt; &lt;ChildCounter n=&#123;this.state.num&#125;&gt;&lt;/ChildCounter&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;update-parent&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// parent-componentWillUpdate// parent-render// child-componentWillReceiveProps// nowProps &#123; n: 0 &#125;// nextProps &#123; n: 1 &#125;// child-shouldComponentUpdate// child-componentWillUpdate// child-render// child-componentDidUpdate// parent-componentDidUpdate 点击父组件更新按钮后，父子组件生命周期的执行顺序如下： parent-componentWillUpdate → parent-render → child-componentWillReceiveProps → child-shouldComponentUpdate → child-componentWillUpdate → child-render → child-componentDidUpdate → parent-componentDidUpdate。 由此可以说明 componentWillReceiveProps 钩子在 shouldComponentUpdate 之前执行。 注意：componentWillReceiveProps “钩子” 在第一次渲染父子组件时不执行，在 React 16.x 版本中被标记为 “已废弃”。 关于 setState 在生命周期中的使用在 React 生命周期 “钩子” 中，只有 componentWillMount、componentDidMount 和 componentWillReceiveProps 中可以调用 setState。 原因是 setState 方法会触发 render “钩子” 执行，而 shouldComponentUpdate、componentWillUpdate、componentDidUpdate 是在 render 后触发，包括在 render 中调用 setState，都会出现更新 “死循环” 的现象，最后造成堆栈溢出，而 componentWillUnmount “钩子” 执行时，组件将被卸载，在此时更新状态毫无意义。 注意：在 componentWillReceiveProps 中使用 setState，其目的是为了将新更改的属性更新为该组件的状态，但 React 官方不建议这样使用。 React 生命周期流程图下面是一张关于目前版本比较常用的 React 生命周期 “钩子” 执行顺序的流程图，帮助大家快速理解 React 生命周期中各个钩子函数的执行过程。 React 生命周期流程图 React 16.3 新增生命周期getDerivedStateFromProps 静态方法getDerivedStateFromProps 是一个类组件的静态方法，用来替代 componentWillReceiveProps “钩子”，在传入的属性变化之前执行，方法的参数与 componentWillReceiveProps 相同，是更新的属性对象，该方法要求必须返回一个状态对象的返回值，且使用该方法的组件必须含有 state，不能和 componentWillMount “钩子” 同时使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 子组件class ChildCounter extends Component &#123; state = &#123; num: 0 &#125; componentDidUpdate(prevProps, prevState, prevContext) &#123; console.log('child-componentDidUpdate'); console.log('nowState', this.state); &#125; static getDerivedStateFromProps(nextProps) &#123; console.log('child-getDerivedStateFromProps'); console.log('nextProps', nextProps); return &#123; num: nextProps.n &#125;; &#125; render() &#123; console.log('child-render'); return &lt;div&gt;&#123;this.props.n&#125;&lt;/div&gt; &#125;&#125;// 父组件class Counter extends Component &#123; state = &#123; num: 0 &#125; handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; render() &#123; console.log('parent-render'); return ( &lt;div&gt; &lt;ChildCounter n=&#123;this.state.num&#125;&gt;&lt;/ChildCounter&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;update-parent&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// parent-render// child-render// child-getDerivedStateFromProps// nextProps &#123; n: 1 &#125;// child-componentDidUpdate// nowState &#123; num: 1 &#125; 点击父组件的更新按钮钩子的执行顺序如下：parent-render → child-render → child-getDerivedStateFromProps → child-componentDidUpdate。 注意：getDerivedStateFromProps 除了上面叙述的用法的注意事项，与 componentWillReceiveProps 相比还有两个优势，第一点是默认第一次渲染时也会执行该方法，第二点是不需要在通过调用 setState 将新的 props 转换成组件的状态，可以直接通过方法的返回值设置状态。 getSnapshotBeforeUpdate 钩子getSnapshotBeforeUpdate “钩子” 用于替代 componentWillUpdate “钩子”，不能与 componentWillMount “钩子” 同时使用，必须与 componentDidUpdate “钩子” 同时使用，需返回一个值或者 null，该值会传给 componentWillUpdate “钩子” 的第三个参数。 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; // 点击事件 handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125; getSnapshotBeforeUpdate() &#123; console.log('getSnapshotBeforeUpdate'); return 123; &#125; componentDidUpdate(prevProps, prevState, prop) &#123; console.log('componentDidUpdate'); console.log('prop', prop); &#125; render() &#123; console.log('render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root);// render// getSnapshotBeforeUpdate// componentDidUpdate// prop 123 点击更新按钮执行顺序为：render → getSnapshotBeforeUpdate → componentDidUpdate。 总结以上就是关于 React 生命周期的内容，涵盖了在 React 开发中对生命周期大部分的应用，也是 React 知识体系中非常重要的部分，React 生命周期和 Vue 相比的特点是名字长，不容易记，希望大家在学习理解之后多巩固，孰能生巧。","tags":[{"name":"React","slug":"React","permalink":"https://www.pandashen.com/tags/React/"},{"name":"生命周期","slug":"生命周期","permalink":"https://www.pandashen.com/tags/生命周期/"}]},{"title":"React 基础篇 —— 带你走进 React 世界","date":"2018-09-09T18:59:59.000Z","path":"2018/09/10/20180910025959/","text":"React 介绍React 是前端最流行的框架之一，由 Facebook 产出，由于其独特的 JSX 语法与组件化开发模式，将原本前端基于 DOM 的编程方式变成了基于组件和数据编程，给前端带来的益处是颠覆性的，因为我们知道 DOM 操作是 “昂贵” 的，React 在提高应用性能的同时又大大提高了开发效率，所以受到很多前端开发者的支持，也就有了庞大的生态，如今 React 已经成为前端工程师之必备技术栈。 创建 React 项目在创建 React 项目时，可以使用当下最流行的脚手架 create-react-app 和 generator-react-webpack，前者是由 Facebook 官方出品，后者是第三方构建工具。 create-react-appcreate-react-app 适用于大部分项目，集成了对 React、JSX、ES6 和 Flow 的支持，支持热更新，默认情况下无需对 Webpack 进行配置，如果要单独配置 Webpack，需要执行命令弹出配置项，下面命令分别对应安装脚手架工具、构建项目和弹出配置项。 npm install -g create-react-app create-react-app project-name npm run eject 注意：创建 React 项目时，项目名称不能含大写字母，使用 eject 命令弹出配置项的过程不可逆。 generator-react-webpackgenerator-react-webpack 适用于构建大型项目，它是需要 yeoman 的支持，几乎具备了 create-react-app 的全部功能，不同的是默认可以对 Webpack 进行配置，生成项目需要手动创建项目根目录，安装脚手架工具和构建项目的命令如下。 npm install -g yo generator-react-webpack mkdir project-namecd project-name yo react-webpack 目录结构我们本次使用 create-react-app 来构建一个项目，并弹出配置项，src 目录为我们主要的开发文件，必须含有一个入口文件 index.js，所以我们在构建项目后删除 src 中的无用文件，目录结构如下（可以通过 npm run start 启动项目）。 react-demo |- config | |- jest | | |- cssTransform.js | | |- fileTransform.js | |- env.js.js | |- paths.js | |- webpack.config.dev.js | |- webpack.config.prod.js | |- webpackDevServer.config.js |- public | |- favicon.ico | |- index.html | |- manifest.json |- scripts | |- build.js | |- start.js | |- test.js |- src | |- index.js |- .gitignore |- package.json |- README.md |- yarn.lock 探索 React引入 React 变量必须大写React 的核心模块分为两个，分别为 react 和 react-dom，前者为 React 的核心逻辑，后者为 React 的渲染逻辑，在 React 中规定引入 react 模块的变量名必须大写。 文件位置：&#126;react-demo/src/index.js12345678import react from 'react';import ReactDOM from 'react-dom';// 创建一个 JSXlet h1 = &lt;h1&gt;hello world&lt;/h1&gt;;// 渲染到页面ReactDOM.render(h1, window.root); 如果向上面代码中将引入 react 的变量小写，报错信息如下。 React 变量错写报错 该报错信息的意思是当前使用了 JSX，必须要有一个大写的 React，从而可以看出这是 React 所规定的，当将接收 react 的变量改成大写后，页面正常渲染。 React 必须有 createElement 方法文件位置：&#126;react-demo/src/index.js12345// 创建一个大写的 React 对象const React = &#123;&#125;;// 创建一个 JSXlet h1 = &lt;h1&gt;hello world&lt;/h1&gt;; 为了进一步验证，上面代码中创建一个名为 React 的对象，报错信息如下。 React 没有 createElement 方法报错 这个报错非常明显的在告诉我们，React 对象中缺少了 createElement 方法，我们将代码修改如下后发现报错信息消失。 文件位置：&#126;react-demo/src/index.js1234567// 创建一个大写的 React 对象const React = &#123; createElement() &#123;&#125;&#125;;// 创建一个 JSXlet h1 = &lt;h1&gt;hello world&lt;/h1&gt;; 页面 “白屏” 是因为并没有使用 react-dom 进行渲染，我们定义的 h1 是一个组件，同时也是 JSX，所以会调用 createElement 对 JSX 进行解析。 解析后的 JSX 长什么样文件位置：&#126;react-demo/src/index.js1234567import React from 'react';// 创建一个 JSXlet h1 = &lt;h1&gt;hello world&lt;/h1&gt;;// 查看 JSX 解析后的结果console.log(h1); 打开 Chorme 浏览器控制台查看打印结果如下。 JSX 解析后的虚拟 DOM 结构 从结果可以看出 createElement 方法最终将 JSX 解析成了一个对象结构，其中 props 带表属性对象，其中的 children 代表子元素，也就是文本节点 hello world，type 代表标签类型为 h1，这样用来表述 DOM 结构的对象被称为虚拟 DOM。 模拟解析和渲染过程在上面我们知道了 React 可以自动将 JSX 转换成虚拟 DOM，而 ReactDOM 的 render 方法将虚拟 DOM 渲染成了真实的 DOM，用法如下。 文件位置：&#126;react-demo/src/index.js1234567891011import React from 'react';import ReactDOM from 'react-dom';// 创建 JSXlet el = &lt;h1 name=\"hi\"&gt; hello &lt;span&gt;world&lt;/span&gt;&lt;/h1&gt;// 渲染到页面ReactDOM.render(el, window.root); 查看页面可以看到正常渲染了，现在就用前面对 React 的了解来简单模拟解析与渲染的过程，代码如下。 文件位置：&#126;react-demo/src/index.js123456789101112131415161718192021222324252627282930313233343536373839404142// 创建 React 对象和 createElement 方法const React = &#123; createElement(type, props, ...children) &#123; return &#123; type, props, children &#125;; &#125;&#125;;// 创建 JSXlet el = &lt;h1 name=\"hi\"&gt; hello &lt;span&gt;world&lt;/span&gt;&lt;/h1&gt;// 渲染的 render 方法function render(vnode, container) &#123; // 如果是字符串说明是文本节点，创建文本节点并插入到父元素中 if (typeof vnode === 'string') &#123; return container.appendChild(document.createTextNode(vnode)); &#125; // 如果不是字符串说明是元素节点，解构元素类型、属性和子元素的数组 let &#123; type, props, children &#125; = vnode; // 创建元素 let tag = document.createElement(type); // 循环添加属性 for (let key in props) &#123; tag.getAttribute(key, props[key]); &#125; // 循环子元素，并递归创建子元素 children.forEach(child =&gt; &#123; render(child, tag); &#125;); // 将元素插入到容器中，root container.appendChild(tag);&#125;// 渲染虚拟 DOMrender(el, window.root); 通过上面实现的代码同样可以完成渲染，当然仅限于简单结构，React 内部的实现更为复杂，兼容了多种组件类型和复杂的 DOM 结构。 JSX 最外层只能有一个元素文件位置：&#126;react-demo/src/index.js1234567import React from 'react';import ReactDOM from 'react-dom';// 创建 JSXlet el = &lt;h1 name=\"hi\"&gt;hello&lt;/h1&gt;&lt;div&gt;world&lt;/div&gt;;ReactDOM.render(el, window.root); 在对上面代码中的 JSX 进行渲染时会有如下报错信息。 JSX 没有唯一父元素包裹报错 上面的报错信息告诉我们 JSX 元素必须包裹在一个闭合的标签内，所以说在写 JSX 语法的时候我们必须保证最外层只有一个元素节点。 React 的基本使用在 JSX 全称为 JavaScript XML，但是和普通的 HTML 相比，有一些不同的用法，如元素属性 class、for、style、dangerouslyInnerHTML 以及注释写法等等。 className 属性在 JSX 语法中，在标签中应使用 className 替代 HTML 中的 class 属性，因为在 JavaScript 中 class 为关键字。 class 属性在 JSX 中的写法1234import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;h1 className=\"active\"&gt;hello&lt;/h1&gt;, window.root); htmlFor 属性在 HTML 中，通过点击 label 标签让 input 输入框获取焦点是很常见的，只需要让 label 标签 for 属性的值与 input 标签的 id 值相等即可，但是在 JSX 中这这样的写法会报错，必须将 label 标签的 for 属性使用 htmlFor 替代，代码如下。 for 属性在 JSX 中的写法123456789101112import React from 'react';import ReactDOM from 'react-dom';let el = ( &lt;div&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;label htmlFor=\"username\"&gt;用户名&lt;/label&gt; &lt;input type=\"text\" id=\"username\"/&gt; &lt;/div&gt;)ReactDOM.render(el, window.root); style 属性style 属性错误的写法123456import React from 'react';import ReactDOM from 'react-dom';let el = &lt;h1 style=\"color: red;\"&gt;hello&lt;/h1&gt;;ReactDOM.render(el, window.root); 在 JSX 中关于 style 属性的写法发生了变化，如果用 HTML 中的写法会报错，错误信息如下。 JSX 中 style 属性错误写法报错 报错信息中明确的告诉我们 style 属性必须是一个含有代表样式键值的对象，而不是一个字符串，并给出正确的结构，正确的写法如下。 style 属性在 JSX 中的写法123456import React from 'react';import ReactDOM from 'react-dom';let el = &lt;h1 style=&#123;&#123;color: 'red'&#125;&#125;&gt;hello&lt;/h1&gt;;ReactDOM.render(el, window.root); 注意：在解析 JSX 的过程中，&lt; 和 &gt; 包裹 JSX 元素，元素属性中最外层的 { 和 } 包裹 JS 代码，而内层的 { 和 } 则代表一个 JS 对象，所以 style 是被两层 “花括号” 所包裹，并不是 mustache 语法。 取值表达式在 JSX 中，所有的 JS 代码都可以写在 JSX 元素起始和闭合标签中间的 { 和 } 内，会将执行结果渲染到该元素上。 取值表达式的使用1234567891011121314151617import React from 'react';import ReactDOM from 'react-dom';let str = 'world';let obj = &#123; hello: 'world' &#125;;const fn = () =&gt; &lt;p&gt;hello&lt;/p&gt;;let el = ( &lt;div&gt; &lt;h1&gt;&#123;fn()&#125;&lt;/h1&gt; &lt;div&gt;&#123;str&#125;&lt;/div&gt; &lt;div&gt;&#123;JSON.stringify(obj)&#125;&lt;/div&gt; &lt;div&gt;&#123;true ? &lt;span&gt;nihao&lt;/span&gt; : null&#125;&lt;/div&gt; &lt;/div&gt;);ReactDOM.render(el, window.root); 启动项目可以看到页面上已经成功的渲染了 hello、world、{ hello: &#39;world&#39; } 和 nihao，上面三元运算符结果如果为 null 则不会渲染这个节点，viod 0 与 null 作用相同。 dangerouslySetInnerHTML 属性在 JSX 中，如果想要把一个含有标签元素的字符串插入到某一个节点中，应该使用 dangerouslySetInnerHTML 替代原生 JS 中的 innerHTML。 dangerouslySetInnerHTML 的用法1234567import React from 'react';import ReactDOM from 'react-dom';let str = '&lt;h1&gt;hello&lt;/h1&gt;';let el = &lt;h1 dangerouslySetInnerHTML=&#123;&#123;__html: str&#125;&#125;&gt;&lt;/h1&gt;;ReactDOM.render(el, window.root); 在上面的代码中，dangerouslySetInnerHTML 属性的值为对象，将要插入的 HTML 字符串作为对象中 __html 属性的值即可，设置 dangerouslySetInnerHTML 属性的 JSX 元素中不能有任何的子元素。 注意：dangerouslySetInnerHTML 属性非常危险，容易引发 XSS 攻击，轻易不要使用。 JSX 中注释的写法在 JSX 的 DOM 结构中，如果需要对代码进行注释不能使用 JS 中的 // 注释，也不能使用 HTML 中的 &lt;!-- 注释 --&gt;，注释必须使用 { } 包裹，写法如下。 注释在 JSX 中的写法123456789101112import React from 'react';import ReactDOM from 'react-dom';let el = ( &lt;div&gt; &lt;h1 name=\"hi\"&gt;hello&lt;/h1&gt; &#123;/* 这是注释，支持多行 */&#125; &lt;span&gt;world&lt;/span&gt; &lt;/div&gt;);ReactDOM.render(el, window.root); Fragment 组件在 React 16.3 中提供了一个组件，类似于原生 JS 中的文档碎片，可以将多个元素包裹起来，却不会被渲染，用法如下。 Fragment 组件的使用1234567891011import React from 'react';import ReactDOM from 'react-dom';let el = ( &lt;React.Fragment&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;div&gt;world&lt;/div&gt; &lt;/React.Fragment&gt;)ReactDOM.render(el, window.root); 循环动态创建 JSX 结构在 React 中不存在过多的 API，最大的特点就是 JSX 语法可以将 JS 与 HTML 混写，借助原生 JS 的方法实现功能，比如可以使用循环创建 JSX 结构。 循环在 JSX 中的应用12345678910111213import React from 'react';import ReactDOM from 'react-dom';const arr = [1, 2, 3];let el = ( arr.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; ) &#125;))ReactDOM.render(el, window.root); 上面成功的渲染除了一个列表，但是有两点需要注意： 第一点是循环一定要使用具有返回值的方法，如 map、filter 等； 第二点是每一个循环出来的 JSX 元素必须绑定一个 key 属性，可以使用数据的 id（优先），也可以使用数组的索引。 组件在上面所有代码中的 JSX 都很不优雅，如果一个项目非常大，这样的混乱的结构是难以维护的，组件就是为了更好的维护和复用相同的 JSX 结构以及提高工作效率而存在的。 函数组件在 React 中可以通过函数创建组件，函数名称就是组件名，必须大写，必须有返回值，可以为 JSX，也可以为 null，通过单闭合和双闭合两种方式调用组件，可以通过属性传参，并通过函数组件的第一个参数接收，实现代码如下。 函数组件1234567891011121314151617181920import React from 'react';import ReactDOM from 'react-dom';// 创建一个函数组件function Build(props) &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;props.title&#125;&lt;/h1&gt; &lt;div&gt;&#123;props.content&#125;&lt;/div&gt; &lt;/div&gt; )&#125;// 渲染组件ReactDOM.render(( &lt;div&gt; &lt;Build title=\"1\" content=\"1xx\"&gt;&lt;/Build&gt; &#123;/* 双闭合 */&#125; &lt;Build title=\"2\" content=\"2xx\"/&gt; &#123;/* 单闭合 */&#125; &lt;/div&gt;), window.root); 缺点 1：在函数组件内部 this 为 undefined；缺点 2：在函数组件内部没有状态，即只能使用通过属性传递的参数，却没有更改的能力；缺点 3：函数组件没有生命周期，无法使用生命周期 “钩子” 完成一些操作。 由于函数组件的缺陷，所以更适合渲染一些静态的不需要数据变化的结构，如果想要让传入的属性变化可以通过不断执行 React.render 的方式不断更新传入组件参数的值，下面是一个时钟案例，通过函数组件实现时间的变化。 函数组件多次渲染1234567891011121314151617181920import React from 'react';import ReactDOM from 'react-dom';// 创建函数组件function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;当前时间&lt;/h1&gt; &lt;div&gt;&#123;props.time&#125;&lt;/div&gt; &lt;/div&gt; )&#125;// 每秒渲染一次组件setInterval(() =&gt; &#123; ReactDOM.render( &lt;Clock time=&#123;new Date().toLocaleString()&#125;/&gt;, window.root );&#125;, 1000); 类组件类组件解决了函数组件所有的缺陷，是通过类声明的。 类组件12345678910111213141516171819202122232425262728293031323334353637import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 创建类组件class Clock extends Component &#123; // constructor(props) &#123; // super(props); // this.state = &#123; // time: new Date().toLocaleString(); // &#125; // &#125; // 等价于 constructor 的写法，更简洁 state = &#123; time: new Date().toLocaleString() &#125; // 生命周期 componentDidMount() &#123; // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; &#123; this.setState(&#123; time: new Date().toLocaleString() &#125;); &#125;, 1000); &#125; // 渲染这个组件会调用 render 方法 render() &#123; return ( &lt;div&gt; 时间：&lt;span&gt;&#123;this.state.time&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;Clock/&gt;, window.root); 在上面的类组件中，我们同样使用了一个简单的时钟功能，可以看出类组件即有 this，又能创建和更新状态，也可以通过生命周期进行一些操作。 所有的类组件都需要继承 React.Component，这样就可以使用 React.Component 的原型方法 setState 对状态进行更新，每次更新，都会使组件重新渲染，但是只会重新渲染变化的 DOM，这是 ReactDOM 通过 diff 算法所做的优化。 类组件中添加事件在平时开发中每个组件都会有一些对应的功能，这就需要事件的配合，在类组建中绑定事件大概有四种方式，我们还是用上面的时钟案例，给该组件添加一个按钮，在点击时卸载这个组件。 方式 1：使用箭头函数直接绑定事件123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 创建类组件class Clock extends Component &#123; state = &#123; time: new Date().toLocaleString() &#125; // 生命周期 componentDidMount() &#123; // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; &#123; this.setState(&#123; time: new Date().toLocaleString() &#125;); &#125;, 1000); &#125; // 渲染这个组件会调用 render 方法 render() &#123; return ( &lt;div&gt; 时间：&lt;span&gt;&#123;this.state.time&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123; // 卸载组件的方法 ReactDOM.unmountComponentAtNode(window.root); &#125;&#125;&gt;kill&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;Clock/&gt;, window.root); 方式 2：使用 bind 绑定函数1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 创建类组件class Clock extends Component &#123; state = &#123; time: new Date().toLocaleString() &#125; // 生命周期 componentDidMount() &#123; // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; &#123; this.setState(&#123; time: new Date().toLocaleString() &#125;); &#125;, 1000); &#125; // 点击事件 handleClick() &#123; ReactDOM.unmountComponentAtNode(window.root); &#125; // 渲染这个组件会调用 render 方法 render() &#123; return ( &lt;div&gt; 时间：&lt;span&gt;&#123;this.state.time&#125;&lt;/span&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;kill&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;Clock/&gt;, window.root); 上面两种方式都有一个共同的问题，箭头函数的方式在每次执行 render 时都会创建新的箭头函数，而将函数作为原型方法，通过 bind 是为了修正方法内部的 this 指向，但是每次执行 render 时，bind 也会返回一个新的函数。 方式 3：在方式 2 的基础上提前生成函数123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 创建类组件class Clock extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; time: new Date().toLocaleString() &#125;; this.fn = this.handleClick.bind(this); &#125; // 生命周期 componentDidMount() &#123; // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; &#123; this.setState(&#123; time: new Date().toLocaleString() &#125;); &#125;, 1000); &#125; // 点击事件 handleClick() &#123; ReactDOM.unmountComponentAtNode(window.root); &#125; // 渲染这个组件会调用 render 方法 render() &#123; return ( &lt;div&gt; 时间：&lt;span&gt;&#123;this.state.time&#125;&lt;/span&gt; &lt;button onClick=&#123;this.fn&#125;&gt;kill&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;Clock/&gt;, window.root); 这样就解决了上面每次执行 render 就创建新函数的问题，但是这样的写法并不优雅，又产生了新的问题，所有的事件执行函数全都添加到了组件的实例上，而且代码会随着事件的增加而越来越乱。 方式 4：使用 ES7 语法将原型方法使用箭头函数1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 创建类组件class Clock extends Component &#123; state = &#123; time: new Date().toLocaleString() &#125; // 生命周期 componentDidMount() &#123; // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; &#123; this.setState(&#123; time: new Date().toLocaleString() &#125;); &#125;, 1000); &#125; // 点击事件 handleClick = () =&gt; &#123; ReactDOM.unmountComponentAtNode(window.root); &#125; // 渲染这个组件会调用 render 方法 render() &#123; return ( &lt;div&gt; 时间：&lt;span&gt;&#123;this.state.time&#125;&lt;/span&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;kill&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;Clock/&gt;, window.root); 使用 ES7 的新语法，既解决了事件处理函数方法内部 this 指向问题，又解决了每次执行 render 创建新函数的问题。 卸载组件后不能再更新状态还是上面的时钟案例，我们知道卸载一个组件应该使用 ReactDOM.unmountComponentAtNode 方法，参数一个组件，执行后会卸载这个组件内部所有的组件。 当真正点击时钟组件的按钮去卸载组件，组件虽然成功卸载了，但是控制台报错了，报错信息如下。 卸载组件后更新状态报错 这个报错信息的意思是告诉我们在组件卸载后不能再通过 setState 更新状态，所以我们要在组件卸载之前先清空调用 setState 的定时器，代码修改如下。 完整的时钟组件12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 创建类组件class Clock extends Component &#123; state = &#123; time: new Date().toLocaleString() &#125; // 生命周期 componentDidMount() &#123; // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 this.timer = setInterval(() =&gt; &#123; this.setState(&#123; time: new Date().toLocaleString() &#125;); &#125;, 1000); &#125; // 组件将要卸载时清空定时器 componentWillUnmount() &#123; clearInterval(this.timer); &#125; // 点击事件 handleClick = () =&gt; &#123; ReactDOM.unmountComponentAtNode(window.root); &#125; // 渲染这个组件会调用 render 方法 render() &#123; return ( &lt;div&gt; 时间：&lt;span&gt;&#123;this.state.time&#125;&lt;/span&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;kill&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;Clock/&gt;, window.root); 在这个组件中用到了两个生命周期 “钩子”，componentDidMount 钩子在组件挂载后执行，类似于原生 JS 的 window.onload，componentWillUnmount 钩子在组件将要卸载之前执行，后面会涉及更多生命周期钩子，我们会在这个 React 基础篇系列文章中一一说明。 类组件的参数传递类组件传参第一种方式123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';const p = &#123; name: 'panda', age: 28 &#125;;class Person extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.props.name&#125;&lt;/p&gt; &lt;p&gt;&#123;this.props.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;// 分别传入想要的属性ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125;/&gt;, window.root); 类组件传参第二种方式1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';const p = &#123; name: 'panda', age: 28 &#125;;class Person extends Component &#123; render() &#123; const &#123; name, age &#125; = this.props; return ( &lt;div&gt; &lt;p&gt;&#123;name&#125;&lt;/p&gt; &lt;p&gt;&#123;age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;// 传入整个对象ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;, window.root); 上面两种传参方式第一种是将对象中希望传入的属性传递给组件，第二种方式是将整个对象通过解构的方式直接传递给组件，而组件中可以在 constructor 中的第一个参数接收 props，也可以直接使用 this.props，因为 React 在组件创建实例调用 super 之前就已经将 props 作为了实例属性。 组件参数的类型校验在 React 组件传递参数时，是通过 props 取出传入的参数直接使用，传入的值类型并没有做任何的校验，这就可能造成传参时出现错误，在 React 生态中有一个第三方模块 prop-types 可以规定参数的类型，并对传入的参数进行校验，使用前需安装。 npm install prop-types 使用 prop-types 校验传给组件的参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';import PropTypes from 'prop-types';const p = &#123; name: 'panda', age: 28, gender: '男', hobby: ['basketball', 'swim'], pos: &#123; x: 433, y: 822 &#125;, salary: 5000&#125;class Person extends Component &#123; // 定义默认属性，React 自带 static defaultProps = &#123; name: 'shen' &#125; // 定义属性类型 static propTypes = &#123; name: PropTypes.string.isRequired, // 类型必须为字符串，必填项 age: PropTypes.number, // 类型必须为数字 gender: PropTypes.oneOf(['男', '女']), // 性别只能为男或女 hobby: PropTypes.arrayOf(PropTypes.string), // 数组成员类型必须是字符串 pos: PropTypes.shape(&#123; // 限制模型内部类型 x: PropTypes.number.isRequired, y: PropTypes.number.isRequired &#125;), // 第一个参数为原对象，第二个参数为当前属性，第三个参数为类 salary(obj, key, P) &#123; // 自行校验 if (obj[key] &lt; 3000) &#123; throw new Error('工资太低'); &#125; &#125; &#125; render() &#123; const &#123; name, age &#125; = this.props; return ( &lt;div&gt; &lt;p&gt;&#123;name&#125;&lt;/p&gt; &lt;p&gt;&#123;age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;, window.root); 使用 prop-types 必须在类组件上添加一个静态属性 propTypes，在内部定义属性的类型，其中 isRequired 为必填项，如果没有传参会报错，在检测是会优先检测 React 的静态属性 defaultProps，即默认属性，如果 defaultProps 存在则视为已经有该参数。 oneOf 方法参数为一个数组，传给组件对应的参数值必须是传给 oneOf 数组中的其中一项，否则会报错，arrayOf 方法用于限制数组成员的类型，shape 方法用于限属性值为对象的内部属性类型，参数为对象。 在 propTypes 静态属性中以传入的属性名作为方法名，则该方法为自定义校验该属性的函数，参数的前三项为原对象，属性名和所属类，可以在函数内部自行实现校验逻辑。 setState 更新状态在前面的时钟组件中已经简单的使用过 setState，在这里我们会对 setState 的用法通过一个计数器案例来做详细说明。 计数器案例 112345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); this.setState(&#123; num: this.state.num + 1 &#125;); &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root); 在上面的计数器中，当我们点击按钮时会执行 handleClick，而在 handleClick 内部调用了两次 setState 更新状态，但是我们启动项目后发现只有一次是有效的，这也说明了一个问题，setState 是异步执行的，最后一次执行的会覆盖前一次，其实在 setState 方法调用时支持传入一个回调函数，代码如下。 计数器案例 2123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; handleClick = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;, () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125;); &#125; render() &#123; console.log('render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root); setState 传入的回调会在更新状态成功后执行，所以将代码修改后两次 setState 都生效了，render 执行了两次，这样的写法如果调用 setState 次数多了就形成了 “回调地狱”，setState 还有另一种用法如下。 计数器案例 3123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends Component &#123; state = &#123; num: 0 &#125; handleClick = () =&gt; &#123; this.setState(prevState =&gt; (&#123; num: prevState.num + 1 &#125;)); this.setState(prevState =&gt; (&#123; num: prevState.num + 1 &#125;)); &#125; render() &#123; console.log('render'); return ( &lt;div&gt; &#123;this.state.num&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;, window.root); setState 方法可直接传入一个函数，函数的参数为上一次更新的 state，也就是 this.state，此时执行 setState 只更新状态，不重新渲染，当最后一次更新状态后统一渲染一次。 更新组件有两种方式，一种是重新调用 render 并传入新的属性值，一种是通过组件调用 setState 重新设置状态。 受控组件和非受控组件对于组件的分类除了可以按照组件的创建方式分为函数组件和类组件，还有另外一种分类方式，就是受控组件和非受控组件，简单来说 “受控” 和 “非受控” 就是指是否受到状态的控制，这种分类方式多用于表单元素，同时也指对于表单元素数据的不同处理方式。 受控组件下面是一个受控组件的写法，输入框的初始值是通过 value 和 defaultValue 属性绑定的状态的值。 受控组件1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Control extends Component &#123; state = &#123; msg1: 'hello', msg2: 'world' &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.msg1&#125;/&gt; &#123;/* 报错 */&#125; &lt;input type=\"text\" defaultValue=&#123;this.state.msg2&#125;/&gt; &#123;/* 不报错 */&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Control&gt;&lt;/Control&gt;, window.root); 上面的代码中是两种绑定初始值的方式，使用 defaultValue 属性可以正常的将状态中的属性作为初始值绑定到页面的输入框内，但是随着输入的变化并没更新状态的作用，而使用 value 做了同样的绑定后，虽然页面正常显示初始值，但是控制台报错了，报错信息如下。 受控组件赋初始值报错 输入框的值可以通过输入改变，但受控组件要求状态的值要随着输入框内的值改变而更新，而报错信息告诉我们想要达到这样的目的必须要给表单元素绑定一个 onChange 事件，这个功能其实就是输入框与数据的双向绑定，修改后的实现如下。 受控组件 —— 修改后123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Control extends Component &#123; state = &#123; msg: 'hello' &#125; changeHandler = e =&gt; &#123; this.setState(&#123; msg: e.target.value &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.msg&#125; onChange=&#123;this.changeHandler&#125; /&gt; &#123;this.state.msg&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Control&gt;&lt;/Control&gt;, window.root); 上面的代码中在 onChange 事件中调用了 setState 并更新了状态，但是如果有多个输入框，要保证 onChange 事件的复用，实现不同的输入框输入时 onChange 事件时更新不同的状态，实现如下。 受控组件 —— 多个输入框复用 onChange12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Control extends Component &#123; state = &#123; msg1: 'hello', msg2: 'world' &#125; changeHandler = e =&gt; &#123; let val = e.target.name; this.setState(&#123; [val]: e.target.value &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" name=\"msg1\" value=&#123;this.state.msg1&#125; onChange=&#123;this.changeHandler&#125;/&gt; &#123;this.state.msg1&#125; &lt;br/&gt; &lt;input type=\"text\" name=\"msg2\" value=&#123;this.state.msg2&#125; onChange=&#123;this.changeHandler&#125;/&gt; &#123;this.state.msg2&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Control&gt;&lt;/Control&gt;, window.root); 上面通过给 input 标签添加和状态的变量名相同的 name 属性，在触发 onChange 事件时用 name 属性作为更新状态数据的键值。 受控组件的好处是，可以实时对输入框输入的值进行校验，并可以随着输入框的内容更新而更新状态，进而更新视图。 非受控组件非受控组件与受控组件相比就是直接操作 DOM 来操作表单元素，直接操作 DOM 可以在 componentDidMount 生命周期内（DOM 完全挂载），写法如下。 非受控组件 —— 直接操作 DOM（不建议）1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class UnControl extends Component &#123; componentDidMount() &#123; let username = document.getElementById('username'); username.value = 123; console.log(username.value); &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" id=\"username\"/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;UnControl&gt;&lt;/UnControl&gt;, window.root); 当然在 React 中并不会这么写，React 专门给我们提供了操作 DOM 属性 ref，用法如下。 非受控组件 —— ref 常用写法12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class UnControl extends Component &#123; handleClick = () =&gt; &#123; // 打印输入框的值 console.log(this.userDom.value); &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" id=\"username\" ref=&#123;dom =&gt; &#123; this.userDom = dom; &#125;&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;UnControl&gt;&lt;/UnControl&gt;, window.root); 使用 ref 属性的方式通常会在其中传入一个函数，这个函数的参数就是当前表单元素对应的 DOM，通常情况下会使用类组件的一个属性来存储这个 DOM，方便在其他的事件或生命周期 “钩子” 中使用。 在 React 16.3 中推出了操作非受控组件的新的 API React.createRef 方法，返回值是一个对象，将这个对象绑定在表单元素的 ref 上，则可以通过这个对象的 current 属性获取这个表单元素的 DOM 元素。 非受控组件 —— React 16.3 新 API12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class UnControl extends Component &#123; userDom = React.createRef(); handleClick = () =&gt; &#123; // 打印输入框的值 console.log(this.userDom.current.value); &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" id=\"username\" ref=&#123;this.userDom&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;UnControl&gt;&lt;/UnControl&gt;, window.root); 我们其实把 React.createRef 的返回值存储为了类组件的一个属性，并将这个属性传入 ref，这样可以在其他的事件或生命周期 “钩子” 中操作 DOM，如果存在多个这样的表单元素，许多次调用 React.createRef，并分别将存储返回值的类组件属性传入各个表单的 ref 中。 非受控组件的好处是，操作 DOM 方便，可以与更多基于 DOM 操作的第三方库结合。 复合组件复合组件指的就是存在父子关系的组件嵌套，在 React 中有两种形式的父子组件嵌套，第一种是直接将子组件在父组件中引入，并放在父组件 render 方法返回的 JSX 中。 复合组件 —— 第一种方式1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 父组件class Parent extends Component &#123; render() &#123; return ( &lt;div&gt; 这是父组件 &lt;Child/&gt; &lt;/div&gt; ) &#125;&#125;// 子组件class Child extends Component &#123; render() &#123; return &lt;div&gt;这是子组件&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Parent/&gt;, window.root); 我们前面提到过组件可以通过单闭合或者双闭合的方式调用，第二种方式就是利用双闭合的调用方式，在父组件中引入子组件，把父组件中某些 JSX 放在双闭合的子组件标签中，作为参数传递给子组件，在子组件中通过 props 的 children 属性进行接收，并放入对应的位置。 复合组件 —— 第二种方式123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';// 父组件class Parent extends Component &#123; render() &#123; return ( &lt;div&gt; 这是父组件 &lt;Child&gt; &lt;div&gt;父组件传递给子组件的 JSX&lt;/div&gt; &lt;/Child&gt; &lt;/div&gt; ) &#125;&#125;// 子组件class Child extends Component &#123; render() &#123; return ( &lt;div&gt; 这是子组件 &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Parent/&gt;, window.root); 总结这是系列关于 React 基础的文章，本篇是关于 React 的一些基础知识，也包含了一些 React 16 版本的一些新增内容，比较适合不了解 React 框架的同学们从零开始入门，在后面会陆续更新关于复合组件参数传递、生命周期等内容。","tags":[{"name":"数据类型检测","slug":"数据类型检测","permalink":"https://www.pandashen.com/tags/数据类型检测/"},{"name":"ES7","slug":"ES7","permalink":"https://www.pandashen.com/tags/ES7/"},{"name":"React","slug":"React","permalink":"https://www.pandashen.com/tags/React/"},{"name":"脚手架","slug":"脚手架","permalink":"https://www.pandashen.com/tags/脚手架/"}]},{"title":"Koa2 洋葱模型 —— compose 串联中间件的四种实现","date":"2018-09-06T09:08:54.000Z","path":"2018/09/06/20180906170854/","text":"前言Koa 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 Express 支持了异步，所以编码时经常使用 async/await，提高了可读性，使代码变得更优雅，上一篇文章 NodeJS 进阶 —— Koa 源码分析，也对 “洋葱模型” 和实现它的 compose 进行分析，由于个人觉得 compose 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 compose。 洋葱模型案例如果你已经使用 Koa 对 “洋葱模型” 这个词一定不陌生，它就是 Koa 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。 1234567891011121314151617181920212223242526272829const Koa = require(\"koa\");const app = new Koa();app.use(async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(2);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(3); await next(); console.log(4);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(5); await next(); console.log(6);&#125;);app.listen(3000);// 1// 3// 5// 6// 4// 2 上面的写法我们按照官方推荐，使用了 async/await，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 next，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 Koa 源码中，这一功能是靠一个 compose 方法实现的，我们本文四种实现 compose 的方式中实现同步和异步，并附带对应的案例来验证。 准备工作在真正创建 compose 方法之前应该先做些准备工作，比如创建一个 app 对象来顶替 Koa 创建出的实例对象，并添加 use 方法和管理中间件的数组 middlewares。 文件：app.js12345678910111213// 模拟 Koa 创建的实例const app = &#123; middlewares: []&#125;;// 创建 use 方法app.use = function(fn) &#123; app.middlewares.push(fn);&#125;;// app.compose.....module.exports = app; 上面的模块中导出了 app 对象，并创建了存储中间件函数的 middlewares 和添加中间件的 use 方法，因为无论用哪种方式实现 compose 这些都是需要的，只是 compose 逻辑的不同，所以后面的代码块中会只写 compose 方法。 Koa 中 compose 的实现方式首先介绍的是 Koa 源码中的实现方式，在 Koa 源码中其实是通过 koa-compose 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 compose 的原理，所以 ctx 参数就被去掉了，因为我们不会使用它，重点是 next 参数。 同步的实现文件：app.js1234567891011121314app.compose = function() &#123; // 递归函数 function dispatch(index) &#123; // 如果所有中间件都执行完跳出 if (index === app.middlewares.length) return; // 取出第 index 个中间件并执行 const route = app.middlewares[index]; return route(() =&gt; dispatch(++index)); &#125; // 取出第一个中间件函数执行 dispatch(0);&#125; 上面是同步的实现，通过递归函数 dispatch 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 dispatch，传入的参数 +1，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 1 3 5 6 4 2 的情况执行，测试例子如下（同步上、异步下）。 文件：sync-test.js123456789101112131415161718192021222324252627const app = require(\"./app\");app.use(next =&gt; &#123; console.log(1); next(); console.log(2);&#125;);app.use(next =&gt; &#123; console.log(3); next(); console.log(4);&#125;);app.use(next =&gt; &#123; console.log(5); next(); console.log(6);&#125;);app.compose();// 1// 3// 5// 6// 4// 2 文件：async-test.js1234567891011121314151617181920212223242526272829303132const app = require(\"./app\");// 异步函数function fn() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); console.log(\"hello\"); &#125;, 3000); &#125;);&#125;app.use(async next =&gt; &#123; console.log(1); await next(); console.log(2);&#125;);app.use(async next =&gt; &#123; console.log(3); await fn(); // 调用异步函数 await next(); console.log(4);&#125;);app.use(async next =&gt; &#123; console.log(5); await next(); console.log(6);&#125;);app.compose(); 我们发现如果案例中按照 Koa 的推荐写法，即使用 async 函数，都会通过，但是在给 use 传参时可能会传入普通函数或 async 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 Koa 中 compose 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。 注意：后面 compose 的其他实现方式中，都是使用 sync-test.js 和 async-test.js 验证，所以后面就不再重复了。 升级为支持异步文件：app.js12345678910111213141516app.compose = function() &#123; // 递归函数 function dispatch(index) &#123; // 如果所有中间件都执行完跳出，并返回一个 Promise if (index === app.middlewares.length) return Promise.resolve(); // 取出第 index 个中间件并执行 const route = app.middlewares[index]; // 执行后返回成功态的 Promise return Promise.resolve(route(() =&gt; dispatch(++index))); &#125; // 取出第一个中间件函数执行 dispatch(0);&#125; 我们知道 async 函数中 await 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 async-test.js 进行测试，发现结果为 1 3 hello(3s后) 5 6 4 2。 Redux 旧版本 compose 的实现方式同步的实现文件：app.js123app.compose = function() &#123; return app.middlewares.reduceRight((a, b) =&gt; () =&gt; b(a), () =&gt; &#123;&#125;)();&#125; 上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 middlewares 中存储的三个中间件函数分别为 fn1、fn2 和 fn3，由于使用的是 reduceRight 方法，所以是逆序归并，第一次 a 代表初始值（空函数），b 代表 fn3，而执行 fn3 返回了一个函数，这个函数再作为下一次归并的 a，而 fn2 作为 b，依次类推，过程如下。 12345678// 第 1 次 reduceRight 的返回值，下一次将作为 a() =&gt; fn3(() =&gt; &#123;&#125;);// 第 2 次 reduceRight 的返回值，下一次将作为 a() =&gt; fn2(() =&gt; fn3(() =&gt; &#123;&#125;));// 第 3 次 reduceRight 的返回值，下一次将作为 a() =&gt; fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; &#123;&#125;))); 由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 fn1，如果调用 next 则会执行 fn2，如果同样调用 next 则会执行 fn3，fn3 已经是最后一个中间件函数了，再次调 next 会执行我们最初传入的空函数，这也是为什么要将 reduceRight 的初始值设置成一个空函数，就是防止最后一个中间件调用 next 而报错。 经过测试上面的代码不会出现顺序错乱的情况，但是在 compose 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 use 的中间件函数既可以是普通函数，又可以是 async 函数，这就要我们的 compose 完全支持异步。 升级为支持异步文件：app.js12345678app.compose = function() &#123; return Promise.resolve( app.middlewares.reduceRight( (a, b) =&gt; () =&gt; Promise.resolve(b(a)), () =&gt; Promise.resolve() )() );&#125; 参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 next 后又调用了 then），都处理成了 Promise，保证了 reduceRight 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 async 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 compose 就可以调用 then 方法执行后续逻辑。 Redux 新版本 compose 的实现方式同步的实现文件：app.js123app.compose = function() &#123; return app.middlewares.reduce((a, b) =&gt; arg =&gt; a(() =&gt; b(arg)))(() =&gt; &#123;&#125;);&#125; Redux 新版本中将 compose 的逻辑做了些改动，将原本的 reduceRight 换成 reduce，也就是说将逆序归并改为了正序，我们不一定和 Redux 源码完全相同，是根据相同的思路来实现串行中间件的需求。 个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 fn1、fn2 和 fn3，由于 reduce 并没有传入初始值，所以此时 a 为 fn1，b 为 fn2。 1234567891011// 第 1 次 reduce 的返回值，下一次将作为 aarg =&gt; fn1(() =&gt; fn2(arg));// 第 2 次 reduce 的返回值，下一次将作为 aarg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg));// 等价于...arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg)));// 执行最后返回的函数连接中间件，返回值等价于...fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; &#123;&#125;))); 所以在调用 reduce 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 fn3，也就是第三个中间件，这样保证了在最后一个中间件调用 next 时不会报错。 升级为支持异步下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。 文件：app.js1234567app.compose = function() &#123; return Promise.resolve( app.middlewares.reduce((a, b) =&gt; &#123; return arg =&gt; a(() =&gt; Promise.resolve(b(arg))); &#125;)(() =&gt; Promise.resolve()) );&#125; 实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 compose 也返回 Promise。 使用 async 函数实现这个版本是我在之前在学习 Koa 源码时偶然在一位大佬的一篇分析 Koa 原理的文章中看到的（翻了半天实在没找到链接），在这里也拿出来和大家分享一下，由于是利用 async 函数实现的，所以默认就是支持异步的，因为 async 函数会返回一个 Promise。 文件：app.js123456789101112131415161718192021222324app.compose = function() &#123; // 自执行 async 函数返回 Promise return (async function () &#123; // 定义默认的 next，最后一个中间件内执行的 next let next = async () =&gt; Promise.resolve(); // middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next // 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题 function createNext(middleware, oldNext) &#123; return async () =&gt; &#123; await middleware(oldNext); &#125; &#125; // 反向遍历中间件数组，先把 next 传给最后一个中间件函数 // 将新的中间件函数存入 next 变量 // 调用下一个中间件函数，将新生成的 next 传入 for (let i = app.middlewares.length - 1; i &gt;= 0; i--) &#123; next = createNext(app.middlewares[i], next); &#125; await next(); &#125;)();&#125; 上面代码中的 next 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 next，而数组 middlewares 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 createNext 作用是返回一个新的可以执行数组中最后一个中间件的 async 函数，并传入了初始的 next，这个返回的 async 函数作为新的 next，再取到倒数第二个中间件，调用 createNext，又返回了一个 async 函数，函数内依然是倒数第二个中间件的执行，传入的 next 就是上次新生成的 next，这样依次类推到第一个中间件。 因此执行第一个中间件返回的 next 则会执行传入的上一个生成的 next 函数，就会执行第二个中间件，就会执行第二个中间件中的 next，就这样直到执行完最初定义的 next，通过案例的验证，执行结果与洋葱模型完全相同。 至于异步的问题，每次执行的 next 都是 async 函数，执行后返回的都是 Promise，而最外层的自执行 async 函数返回的也是 Promise，也就是说 compose 最后返回的是 Promise，因此完全支持异步。 这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。 总结或许你看完这几种方式会觉得，还是 Koa 对于 compose 的实现方式最容易理解，你也可能和我一样在感慨 Redux 的两种实现方式和 async 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想，写出 compose 这种优雅又高逼格的代码，路漫漫其修远兮，愿你在技术的路上 “一去不复返”。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"async/await","slug":"async-await","permalink":"https://www.pandashen.com/tags/async-await/"},{"name":"Koa","slug":"Koa","permalink":"https://www.pandashen.com/tags/Koa/"}]},{"title":"NodeJS 进阶 —— Koa 源码分析","date":"2018-09-02T06:18:19.000Z","path":"2018/09/02/20180902141819/","text":"前言Koa 2.x 版本是当下最流行的 NodeJS 框架，同时社区涌现出一大批围绕 Koa 2.x 的中间件以及基于 Koa 2.x 封装的企业级框架，如 egg.js，然而 Koa 本身的代码却非常精简，精简到所有文件的代码去掉注释后还不足 2000 行，本篇就围绕着这 2000 行不到的代码抽出核心逻辑进行分析，并压缩成一版只有 200 行不到的简易版 Koa。 Koa 分析过程在下面的内容中，我们将对 Koa 所使用的功能由简入深的分析，首先会给出使用案例，然后根据使用方式，分析实现原理，最后对分析的功能进行封装，封装过程会从零开始并一步一步完善，代码也是从少到多，会完整的看到一个简版 Koa 诞生的过程，再此之前我们打开 Koa 源码地址。 Koa 文件目录 通过上面对 Koa 源码目录的截图，发现只有 4 个核心文件，为了方便理解，封装简版 Koa 的文件目录结构也将严格与源码同步。 搭建基本服务在引入 Koa 时我们需要创建一个 Koa 的实例，而启动服务是通过 listen 监听一个端口号实现的，代码如下。 123456const Koa = require('koa');const app = new Koa();app.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 通过使用我们可以分析出 Koa 导出的应该是一个类，或者构造函数，鉴于 Koa 诞生的时间以及基于 node v7.6.0 以上版本的情况来分析，正是 ES6 开始 “横行霸道” 的时候，所以推测 Koa 导出的应该是一个类，打开源码一看，果然如此，所以我们也通过 class 的方式来实现。 而从启动服务的方式上看，app.listen 的调用方式与原生 http 模块提供的 server.listen 几乎相同，我们分析，listen 方法应该是对原生 http 模块的一个封装，启动服务的本质还是靠 http 模块来实现的。 文件路径：&#126koa/application.js12345678910111213141516const http = require('http');class Koa &#123; handleRequest(req, res) &#123; // 请求回调 &#125; listen(...args) &#123; // 创建服务 let server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); &#125;&#125;module.exports = Koa; 上面的代码初步实现了我们上面分析出的需求，为了防止代码冗余，我们将创建服务的回调抽取成一个 handleRequest 的实例方法，内部的逻辑在后面完善，现在可以创建这个 Koa 类的实例，通过调用实例的 listen 方法启动一个服务器。 上下文对象 ctx 的封装基本使用Koa 还有一个很重要的特性，就是它的 ctx 上下文对象，我们可以调用 ctx 的 request 和 response 属性获取原 req 和 res 的属性和方法，也在 ctx 上增加了一些原生没有的属性和方法，总之 ctx 给我们要操作的属性和方法提供了多种调用方式，使用案例如下。 123456789101112131415161718192021const Koa = require('koa');const app = new Koa();app.use((ctx, next) =&gt; &#123; // 原生的 req 对象的 url 属性 console.log(ctx.req.url); console.log(ctx.request.req.url); console.log(ctx.response.req.url); // Koa 扩展的 url console.log(ctx.url); console.log(ctx.request.req.url); // 设置状态码和响应内容 ctx.response.status = 200; ctx.body = 'Hello World';&#125;);app.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 创建 ctx 的引用关系从上面我们可以看出，ctx 为 use 方法的第一个参数，request 和 response 是 ctx 新增的，而通过这两个属性又都可以获取原生的 req 和 res 属性，ctx 本身也可以获取到原生的 req 和 res，我们可以分析出，ctx 是对这些属性做了一个集成，或者说特殊处理。 源码的文件目录中正好有与 request、response 名字相对应的文件，并且还有 context 名字的文件，我们其实可以分析出这三个文件就是用于封装 ctx 上下文对象使用的，而封装 ctx 中也会用到 req 和 res，所以核心逻辑应该在 handleRequest 中实现。 在使用案例中 ctx 是作为 use 方法中回调函数的参数，所以我们分析应该有一个数组统一管理调用 use 后传入的函数，Koa 应该有一个属性，值为数组，用来存储这些函数，下面是实现代码。 文件路径：&#126koa/application.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const http = require('http');// ***************************** 以下为新增代码 *****************************const context = require('./context');const request = require('./request');const response = require('./response');// ***************************** 以上为新增代码 *****************************class Koa &#123;// ***************************** 以下为新增代码 ***************************** contructor() &#123; // 存储中间件 this.middlewares = []; // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125; use(fn) &#123; // 将传给 use 的函数存入数组中 this.middlewares.push(fn); &#125; createContext(req, res) &#123; // 或取定义的上下文 let ctx = this.context; // 增加 request 和 response ctx.request = this.request; ctx.response = this.response; // 让 ctx、request、response 都具有原生的 req 和 res ctx.req = ctx.request.req = ctx.response.req = req; ctx.res = ctx.response.res = ctx.request.res = res; // 返回上下文对象 return ctx; &#125;// ***************************** 以上为新增代码 ***************************** handleRequest(req, res) &#123; // 创建 ctx 上下文对象 let ctx = this.createContext(req, res); &#125; listen(...args) &#123; // 创建服务 let server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); &#125;&#125;module.exports = Koa; 首先，给实例创建了三个属性 context、request 和 response 分别继承了 context.js、request.js 和 response.js 导出的对象，之所以这么做而不是直接赋值是防止操作实例属性时 “污染” 原对象，而获取原模块导出对象的属性可以通过原型链进行查找，并不影响取值。 其次，给实例挂载了 middlewares 属性，值为数组，为了存储 use 方法调用时传入的函数，在 handleRequest 把创建 ctx 属性及引用的过程单独抽取成了 createContext 方法，并在 handleRequest 中调用，返回值为创建好的 ctx 对象，而在 createContext 中我们根据案例中的规则构建了 ctx 的属性相关的各种引用关系。 实现 request 取值上面构建的属性中，所有通过访问原生 req 或 res 的属性都能获取到，反之则是 undefined，这就需要我们去构建 request.js。 文件路径：&#126koa/request.js12345678910111213const url = require('url');// 给 url 和 path 添加 getterconst request = &#123; get url() &#123; return this.req.url; &#125;, get path() &#123; return url.parse(this.req.url).pathname; &#125;&#125;;module.exports = request; 上面我们只构造了两个属性 url 和 path，我们知道 url 是原生所自带的属性，我们在使用 ctx.request.url 获取是通过 request 对象设置的 getter，将 ctx.request.req.url 的值返回了。 path 是原生 req 所没有的属性，但却是通过原生 req 的 url 属性和 url 模块共同构建出来的，所以我们同样用了给 request 对象设置 getter 的方式获取 req 的 url 属性，并使用 url 模块将转换对象中的 pathname 返回，此时就可以通过 ctx.request.path 来获取访问路径，至于源码中我们没有处理的 req 属性都是通过这样的方式建立的引用关系。 实现 response 的取值和赋值Koa 中 response 对象的真正作用是给客户端进行响应，使用时是通过访问属性获取，并通过重新赋值实现响应，但是现在 response 获取的属性都是 undefined，我们这里先不管响应给浏览器的问题，首先要让 response 下的某个属性有值才行，下面我们来实现 response.js。 文件路径：&#126koa/response.js12345678910111213141516171819// 给 body 和 status 添加 getter 和 setterconst response = &#123; get body() &#123; return this._body; &#125;, set body(val) &#123; // 只要给 body 赋值就代表响应成功 this.status = 200; this._body = val; &#125;, get status() &#123; return this.res.statusCode; &#125;, set status(val) &#123; this.res.statusCode = val; &#125;&#125;;module.exports = response; 这里选择了 Koa 在使用时，response 对象上比较重要的两个属性进行处理，因为这两个属性是服务器响应客户端所必须的，并模仿了 request.js 的方式给 body 和 status 设置了 getter，不同的是响应浏览器所做的其实是赋值操作，所以又给这两个属性添加了 setter，对于 status 来说，直接操作原生 res 对象的 statusCode 属性即可，因为同为赋值操作。 还有一点，响应是通过给 body 赋值实现，我们认为只要触发了 body 的 setter 就成功响应，所以在 body 的 getter 中将响应状态码设置为 200，至于 body 赋值是如何实现响应的，放在后面再说。 ctx 代理 request、response 的属性上面实现了通过 request 和 response 对属性的操作，Koa 虽然给我们提供了多样的属性操作方式，但由于我们程序猿（媛）们都很 “懒”，几乎没有人会在开发的时候愿意多写代码，大部分情况都是通过 ctx 直接操作 request 和 response 上的属性，这就是我们现在的问题所在，这些属性通过 ctx 访问不到。 我们需要给 ctx 对象做一个代理，让 ctx 可以访问到 request 和 response 上的属性，这个场景何曾相识，不正是 Vue 创建实例时，将传入参数对象 options 的 data 属性代理给实例本身的场景吗，既然如此，我们也通过相似的方式实现，还记得上面引入的 context 模块作为实例的 context 属性所继承的对象，而剩下的最后一个核心文件 context.js 正是用来做这件事的，代码如下。 文件路径：&#126koa/context.js123456789101112131415161718192021222324252627const proto = &#123;&#125;;// 将传入对象属性代理给 ctxfunction defineGetter(property, key) &#123; proto.__defineGetter__(key, function () &#123; return this[property][key]; &#125;);&#125;// 设置 ctx 值时直接操作传入对象的属性function defineSetter(property, key) &#123; proto.__defineSetter__(key, function (val) &#123; this[property][key] = val; &#125;);&#125;// 将 request 的 url 和 path 代理给 ctxdefineGetter('request', 'url');defineGetter('request', 'path');// 将 response 的 body 和 status 代理给 ctxdefineGetter('response', 'body');defineSetter('response', 'body');defineGetter('response', 'status');defineSetter('response', 'status');module.exports = proto; 在 Vue 中是使用 Object.defineProperty 来时实现的代理，而在 Koa 源码中借助了 delegate 第三方模块来实现的，并在添加代理时链式调用了 delegate 封装的方法，我们并没有直接使用 delegate 模块，而是将 delegate 内部的核心逻辑抽取出来在 context.js 中直接编写，这样方便大家理解原理，也可以清楚的知道是如何实现代理的。 我们封装了两个方法 defineGetter 和 defineSetter 分别来实现取值和设置值时，将传入的属性（第二个参数）代理给传入的对象（第一个参数），函数内是通过 Object.prototype.__defineGetter__ 和 Object.prototype.__defineSetter__ 实现的，点击方法名可查看官方 API。 洋葱模型 —— 实现中间件的串行现在已经实现了 ctx 上下文对象的创建，但是会发现我们封装 ctx 之前所写的案例 use 回调中的代码并不能执行，也不会报错，根本原因是 use 方法内传入的函数没有调用，在使用 Koa 的过程中会发现，我们往往使用多个 use，并且传入 use 的回调函数除了 ctx 还有第二个参数 next，而这个 next 也是一个函数，调用 next 则执行下一个 use 中的回调函数，否则就会 “卡住”，这种执行机制被取名为 “洋葱模型”，而这些被执行的函数被称为 “中间件”，下面我们就来分析这个 “洋葱模型” 并实现中间件的串行。 洋葱模型执行过程 洋葱模型分析下面来看看表述洋葱模型的一个经典案例，结果似乎让人匪夷所思，一时很难想到原因，不着急先看了再说。 12345678910111213141516171819202122232425262728293031const Koa = require('koa');const app = new Koa();app.use((ctx, next) =&gt; &#123; console.log(1); next(); console.log(2);&#125;);app.use((ctx, next) =&gt; &#123; console.log(3); next(); console.log(4);&#125;);app.use((ctx, next) =&gt; &#123; console.log(5); next(); console.log(6);&#125;);app.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;);// 1// 3// 5// 6// 4// 2 根据上面的执行特性我们不妨来分析以下，我们知道 use 方法执行时其实是把传入的回调函数放入了实例的 middlewares 数组中，而执行结果打印了 1 说明第一个回调函数被执行了，接着又打印了 2 说明第二个回调函数被执行了，根据上面的代码我们可以大胆的猜想，第一个回调函数调用的 next 肯定是一个函数，可能就是下一个回调函数，或者是 next 函数中执行了下一个回调函数，这样根据函数调用栈先进后出的原则，会在 next 执行完毕，即出栈后，继续执行上一个回调函数的代码。 支持异步的中间件串行在实现中间件串行之前需要补充一点，中间件函数内调用 next 时，前面的代码出现异步，则会继续向下执行，等到异步执行结束后要执行的代码插入到同步代码中，这会导致执行顺序错乱，所以在官方推荐中告诉我们任何遇到异步的操作前都需要使用 await 进行等待（包括 next，因为下一个中间件中可能包含异步操作），这也间接的说明了传入 use 的回调函数只要有异步代码需要 await，所以应该是 async 函数，而了解 ES7 特性 async/await 的我们来说，一定能分析出 next 返回的应该是一个 Promise 实例，下面是我们在之前 application.js 基础上的实现。 文件路径：&#126koa/application.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const http = require('http');const context = require('./context');const request = require('./request');const response = require('./response');class Koa &#123; contructor() &#123; // 存储中间件 this.middlewares = []; // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125; use(fn) &#123; // 将传给 use 的函数存入数组中 this.middlewares.push(fn); &#125; createContext(req, res) &#123; // 或取定义的上下文 let ctx = this.context; // 增加 request 和 response ctx.request = this.request; ctx.response = this.response; // 让 ctx、request、response 都具有原生的 req 和 res ctx.req = ctx.request.req = ctx.response.req = req; ctx.res = ctx.response.res = ctx.request.res = res; // 返回上下文对象 return ctx; &#125;// ***************************** 以下为新增代码 ***************************** compose(ctx, middles) &#123; // 创建一个递归函数，参数为存储中间件的索引，从 0 开始 function dispatch(index) &#123; // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况） if (index === middles.length) return Promise.resolve(); // 取出第 index 个中间件函数 const route = middles[index]; // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise return Promise.resolve(route(ctx, () =&gt; dispatch(++index))); &#125; return dispatch(0); // 默认执行一次 &#125;// ***************************** 以上为新增代码 ***************************** handleRequest(req, res) &#123; // 创建 ctx 上下文对象 let ctx = this.createContext(req, res);// ***************************** 以下为新增代码 ***************************** // 执行 compose 将中间件组合在一起 this.compose(ctx, this.middlewares);// ***************************** 以上为新增代码 ***************************** &#125; listen(...args) &#123; // 创建服务 let server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); &#125;&#125;module.exports = Koa; 仔细想想我们其实在利用循环执行每一个 middlewares 中的函数，而且需要把下一个中间件函数的执行作为函数体的代码包装一层成为新的函数，并作为参数 next 传入，那么在上一个中间件函数内部调用 next 就相当于先执行了下一个中间件函数，而下一个中间件函数内部调用 next，又先执行了下一个的下一个中间件函数，依次类推。 直到执行到最后一个中间件函数，调用了 next，但是 middlewares 中已经没有下一个中间件函数了，这也是为什么我们要给下一个中间件函数外包了一层函数而不是直接将中间件函数传入的原因之一（另一个原因是解决传参问题，因为在执行时还要传入下一个中间件函数），但是防止递归 “死循环”，要配合一个终止条件，即指向 middlewares 索引的变量等于了 middlewares 的长度，最后只是相当于执行了一个只有一条判断语句的函数就 return 的函数，而并没有报错。 在这整个过程中如果有任意一个 next 没有被调用，就不会向下执行其他的中间件函数，这样就 “卡住了”，完全符合 Koa 中间件的执行规则，而 await 过后也就是下一个中间件优先执行完成，则会继续执行当前中间件 next 调用下面的代码，这也就是 1、3、5、6、4、2 的由来。 为了实现所描述的执行过程，将所有中间件串行的逻辑抽出了一个 compose 方法，但是我们没有使用普通的循环，而是使用递归实现的，首先在 compose 创建 dispatch 递归函数，参数为当前数组函数的索引，初始值为 0，函数逻辑是先取出第一个函数执行，并传入一个回调函数参数，回调函数参数中递归 dispatch，参数 +1，这样就会将整个中间件串行起来了。 但是上面的串行也只是同步串行，如果某个中间件内部需要等待异步，则调用得 next 函数必须返回一个 Promise，有些中间件没有执行异步，则不需要 async 函数，也不会返回 Promise，而 Koa 规定只要遇到 next 就需要等待，则将取出每一个中间件函数执行后的结果使用 Promise.resolve 强行包装成一个成功态的 Promise，就对异步进行了兼容。 我们最后也希望 compose 返回一个 Promise 方便执行一些只有在中间件都执行后才会执行的逻辑，每次串行最后执行的都是一个只有一条判断逻辑就 return 了的函数（包含一个中间件也没有的情况），此时 compose 返回了 undefined，无法调用 then 方法，为了兼容这种情况也强行的使用相同的 “招数”，在判断条件的 return 关键字后面加上了 Promise.resolve()，直接返回了一个成功态的 Promise。 注意：官方只是推荐我们在调用 next 的时候使用 await 等待，即使执行的 next 真的存在异步，也不是非 await 不可，我们完全可以使用 return 来代替 await，唯一的区别就是 next 调用后，下面的代码不会再执行了，类比 “洋葱模型”，形象地说就是 “下去了就上不来了”，这个完全可以根据我们的使用需要而定，如果 next 后面不再有任何逻辑，完全可以使用 return 替代。 实现真正的响应在对 ctx 实现属性代理后，我们通过 ctx.body 重新赋值其实只是改变了 response.js 导出对象的 _body 属性，而并没有实现真正的响应，看下面这个 Koa 的例子。 123456789101112131415161718192021const Koa = require('koa');const fs = require('fs');const app = new Koa();app.use(async (ctx, next) =&gt; &#123; ctx.body = 'hello'; await next();&#125;);app.use(async (ctx, next) =&gt; &#123; ctx.body = fs.createReadStream('1.txt'); ctx.body = await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('panda'), 3000); &#125;);&#125;);app.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 其实最后响应给客户端的值是 panda，正常在最后一个中间件执行后，由于异步定时器的代码没有执行完，ctx.body 最后的值应该是 1.txt 的可读流，这与客户端接收到的值相违背，通过这个猜想上的差异我们应该知道，compose 在串行执行中间件后为什么要返回一个 Promise 了，因为最后执行的只有判断语句的函数会等待我们例子中最后一个 use 传入的中间件函数执行完毕调用，也就是说在执行 compose 返回值的 then 时，ctx.body 的值已经是 panda 了。 文件路径：&#126koa/application.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const http = require('http');// ***************************** 以下为新增代码 *****************************const Stream = require('stream');// ***************************** 以上为新增代码 *****************************const context = require('./context');const request = require('./request');const response = require('./response');class Koa &#123; contructor() &#123; // 存储中间件 this.middlewares = []; // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125; use(fn) &#123; // 将传给 use 的函数存入数组中 this.middlewares.push(fn); &#125; createContext(req, res) &#123; // 或取定义的上下文 let ctx = this.context; // 增加 request 和 response ctx.request = this.request; ctx.response = this.response; // 让 ctx、request、response 都具有原生的 req 和 res ctx.req = ctx.request.req = ctx.response.req = req; ctx.res = ctx.response.res = ctx.request.res = res; // 返回上下文对象 return ctx; &#125; compose(ctx, middles) &#123; // 创建一个递归函数，参数为存储中间件的索引，从 0 开始 function dispatch(index) &#123; // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况） if (index === middles.length) return Promise.resolve(); // 取出第 index 个中间件函数 const route = middles[index]; // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise return Promise.resolve(route(ctx, () =&gt; dispatch(++index))); &#125; return dispatch(0); // 默认执行一次 &#125; handleRequest(req, res) &#123; // 创建 ctx 上下文对象 let ctx = this.createContext(req, res);// ***************************** 以下为修改代码 ***************************** // 设置默认状态码（Koa 规定），必须在调用中间件之前 ctx.status = 404; // 执行 compose 将中间件组合在一起 this.compose(ctx, this.middlewares).then(() =&gt; &#123; // 获取最后 body 的值 let body = ctx.body; // 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器 if (Buffer.isBuffer(body) || typeof body === 'string') &#123; // 处理 Buffer 类型的数据 res.setHeader('Content-Type', 'text/plain;charset=utf8'); res.end(body); &#125; else if (typeof body === 'object') &#123; // 处理对象类型 res.setHeader('Content-Type', 'application/json;charset=utf8'); res.end(JSON.stringify(body)); &#125; else if (body instanceof Stream) &#123; // 处理流类型的数据 body.pipe(res); &#125; else &#123; res.end('Not Found'); &#125; &#125;);// ***************************** 以上为修改代码 ***************************** &#125; listen(...args) &#123; // 创建服务 let server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); &#125;&#125;module.exports = Koa; 处理 response 时，在 body 的 setter 中将状态码设置为了 200，就是说需要设置 ctx.body 去触发 setter 让响应成功，如果没有给 ctx.body 设置任何值，默认应该是无响应的，在官方文档也有默认状态码为 404 的明确说明，所以在 handleRequest 把状态码设置为了 404，但必须在 compose 执行之前才叫默认状态码，因为中间件中可能会操作 ctx.body，重新设置状态码。 在 comose 的 then 中，也就是在所有中间件执行后，我们取出 ctx.body 的值，即为最后生效的响应值，对该值进行了数据类型验证，如 Buffer、字符串、对象和流，并分别用不同的方式处理了响应，但本质都是调用的原生 res 对象的 end 方法。 中间件错误处理在上面的逻辑当中我们实现了很多 Koa 的核心逻辑，但是只考虑了顺利执行的情况，并没有考虑如果中间件中代码执行出现错误的问题，如下面案例。 12345678910111213141516const Koa = require('koa');const app = new Koa();app.use((ctx, next) =&gt; &#123; // 抛出异常 throw new Error('Error');&#125;);// 添加 error 监听app.on('error', err =&gt; &#123; console.log(err);&#125;);app.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 我们之所以让 compose 方法在执行所有中间件后返回一个 Promise 还有一个更重要的意义，因为在 Promise 链式调用中，只要其中任何一个环节出现代码执行错误或抛出异常，都会直接执行出现错误的 then 方法中错误的回调或者最后的 catch 方法，对于 Koa 中间件的串行而言，最后一个 then 调用 catch 方法就是 compose 的返回值调用 then 后继续调用的 catch，catch 内可以捕获到任意一个中间件执行时出现的错误。 文件路径：&#126koa/application.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const http = require('http');const Stream = require('stream');// ***************************** 以下为新增代码 *****************************const EventEmitter = require('events');const httpServer = require('_http_server');// ***************************** 以上为新增代码 *****************************const context = require('./context');const request = require('./request');const response = require('./response');// ***************************** 以下为修改代码 *****************************// 继承 EventEmitter 后可以用创建的实例 app 添加 error 监听，可以通过 emit 触发监听class Koa extends EventEmitter &#123; contructor() &#123; supper();// ***************************** 以上为修改代码 ***************************** // 存储中间件 this.middlewares = []; // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125; use(fn) &#123; // 将传给 use 的函数存入数组中 this.middlewares.push(fn); &#125; createContext(req, res) &#123; // 或取定义的上下文 let ctx = this.context; // 增加 request 和 response ctx.request = this.request; ctx.response = this.response; // 让 ctx、request、response 都具有原生的 req 和 res ctx.req = ctx.request.req = ctx.response.req = req; ctx.res = ctx.response.res = ctx.request.res = res; // 返回上下文对象 return ctx; &#125; compose(ctx, middles) &#123; // 创建一个递归函数，参数为存储中间件的索引，从 0 开始 function dispatch(index) &#123; // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况） if (index === middles.length) return Promise.resolve(); // 取出第 index 个中间件函数 const route = middles[index]; // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise return Promise.resolve(route(ctx, () =&gt; dispatch(++index))); &#125; return dispatch(0); // 默认执行一次 &#125; handleRequest(req, res) &#123; // 创建 ctx 上下文对象 let ctx = this.createContext(req, res); // 设置默认状态码（Koa 规定），必须在调用中间件之前 ctx.status = 404; // 执行 compose 将中间件组合在一起 this.compose(ctx, this.middlewares).then(() =&gt; &#123; // 获取最后 body 的值 let body = ctx.body; // 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器 if (Buffer.isBuffer(body) || typeof body === 'string') &#123; // 处理 Buffer 类型的数据 res.setHeader('Content-Type', 'text/plain;charset=utf8'); res.end(body); &#125; else if (typeof body === 'object') &#123; // 处理对象类型 res.setHeader('Content-Type', 'application/json;charset=utf8'); res.end(JSON.stringify(body)); &#125; else if (body instanceof Stream) &#123; // 处理流类型的数据 body.pipe(res); &#125; else &#123; res.end('Not Found'); &#125;// ***************************** 以下为修改代码 ***************************** &#125;).catch(err =&gt; &#123; // 执行 error 事件 this.emit('error', err); // 设置 500 状态码 ctx.status = 500; // 返回状态码对应的信息响应浏览器 res.end(httpServer.STATUS_CODES[ctx.status]); &#125;);// ***************************** 以上为修改代码 ***************************** &#125; listen(...args) &#123; // 创建服务 let server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); &#125;&#125;module.exports = Koa; 在使用的案例当中，使用 app（即 Koa 创建的实例）监听了一个 error 事件，当中间件执行错误时会触发该监听的回调，这让我们想起了 NodeJS 中一个重要的核心模块 events，这个模块帮我们提供了一个事件机制，通过 on 方法添加监听，通过 emit 触发监听，所以我们引入了 events，并让 Koa 类继承了 events 导入的 EventEmitter 类，此时 Koa 的实例就可以使用 EventEmitter 原型对象上的 on 和 emit 方法。 在 compose 执行后调用的 catch 中，通过实例调用了 emit，并传入了事件类型 error 和错误对象，这样就是实现了中间件的错误监听，只要中间件执行出错，就会执行案例中错误监听的回调。 让引入的 Koa 直接指向 application.js在上面我们实现了 Koa 大部分常用功能的核心逻辑，但还有一点美中不足，就是我们引入自己的简易版 Koa 时，默认会查找 koa 路径下的 index.js，想要执行我们的 Koa 必须要使用路径找到 application.js，代码如下。 现在的引入方式1const Koa = require('./koa/application'); 希望的引入方式1const Koa = require('./koa'); 我们更希望像直接引入指定 koa 文件夹，就可以找到 application.js 文件并执行，这就需要我们在 koa 文件夹创建 package.json 文件，并在动一点小小的 “手脚” 如下。 文件路径：&#126koa/package.js123456789&#123; . . . \"main\": \"./application.js\", . . .&#125; Koa 原理图在文章最后一节送给大家一张 Koa 执行的原理图，这张图片是准备写这篇文章时在 Google 上发现的，觉得把 Koa 的整个流程表达的非常清楚，所以这里拿来帮助大家理解 Koa 框架的原理和执行过程。 Koa 原理图 之所以没有在文章开篇放上这张图是因为觉得在完全没有了解过 Koa 的原理之前，可能有一部分小伙伴看这张图会懵，会打消学习的积极性，因为本篇的目的就是带着大家从零到有的，一步一步实现简易版 Koa，梳理 Koa 的核心逻辑，如果你已经看到了这里，是不是觉得这张图出现的不早不晚，刚刚好。 总结最后还是在这里做一个总结，在 Koa 中主要的部分有 listen 创建服务器、封装上下文对象 ctx 并代理属性、use 方法添加中间件、compose 串行执行中间、让 Koa 继承 EventEmitter 实现错误监听，而我个人觉得最重要的就是 compose，它是一个事件串行机制，也是实现 “洋葱模型” 的核心，如今 compose 已经不再只是一个方法名，而是一种编程思想，用于将多个程序串行在一起，或同步，或异步，在 Koa 中自不必多说，因为大家已经见识过了，compose 在 React 中也起着串联中间件的作用，如串联 promise、redux-thunk、logger 等，在 Webpack 源码依赖的核心模块 tapable 中也有所应用，在我们的学习过程中，这样优秀的编程思想是应该重点吸收的。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"async/await","slug":"async-await","permalink":"https://www.pandashen.com/tags/async-await/"},{"name":"Koa","slug":"Koa","permalink":"https://www.pandashen.com/tags/Koa/"}]},{"title":"Express 中间件 body-parser 原理分析","date":"2018-08-27T18:21:47.000Z","path":"2018/08/28/20180828022147/","text":"前言Express 是基于 NodeJS 平台的 Web 框架，应用广泛，在 Express 社区中有着大量的开发者通过 Express 中间件的特性，开发了各种功能的中间件，用来处理某些响应以及给请求对象 req、响应对象 res 添加属性或方法，我们接下来就通过分析常用的 body-parser 中间件的原理来了解如何开发 Express 中间件，如果想了解更多 Express 内部封装原理可以看 《Express 源码分析及简易封装》。 body-parser 的基本使用想刨析一个中间件的原理，首先应该从使用入手，在足够了解用法的基础上去分析，现在搭建一个简易的 Express 服务，并使用 body-parser 中间件，使用前需安装。 npm install express body-parser 使用 body-parser 代码如下： 使用 body-parser 中间件1234567891011121314151617181920const express = require('express');const bodyParser = require('body-parser');// 创建服务const app = express();// 使用 body-parser 中间app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(bodyParser.json());// 创建路由app.post('/login', function (req, res) &#123; console.log(req.body); res.send(req.body);&#125;);// 监听服务app.listen(3000, function () &#123; console.log('server start 3000');&#125;); 启动上面的服务器，通过 postman 工具分别通过表单提交和 json 的格式访问 http://localhost:3000/login，查看服务器控制后台的打印结果和 postman 的返回结果。 body-parser 的实现原理分析从上面的使用案例我们可以分析出一下几点： 首先，body-parser 中间件的作用是给 req 添加属性 body，值为对象，以键值对的形式存储请求体中的参数； 其次，body-parser 只处理 POST 请求； 最后，body-parser 模块导出一个对象，上面有两个方法 urlencoded 和 json，分别处理表单提交和 json 格式的请求体参数。 分析 urlencoded、json 公共逻辑在实现之前我们先分析一下两个方法，首先都需要先读取请求体中的内容，数据传输的类型为 Buffer，转换成字符串后会根据提交方式不同而导致请求体中的内容是查询字符串或者是 json 字符串的区别。 当解析失败时都需要做错误处理，当不是 POST 请求时都需要向下执行其他中间件，而最核心的事就是把请求体中的数据转换成对象挂在 req.body 上。 使用的转换数据的方法不同是唯一的区别，能区分两者的就是请求头 Content-Type 的值，因此我们可以把所有的公共逻辑抽取出来用一个 acceptPost 函数来执行。 模块的创建我们下面创建自己的 body-parser 模块，防止命名冲突，我们的模块命名为 my-body-parser，处理参数需要使用 querystring 和 qs 两个模块，其中 qs 是第三方模块，使用前需安装。 npm install qs qs 和 querystring 作用基本相同，就是处理查询字符串格式的参数，但是也有一点小小的区别，querystring 只能处理一级，而 qs 可以处理多级。 文件：my-body-parser.js1234567891011121314151617181920const querystring = require('querystring');const qs = require('qs');// urlencoded 和 json 公共逻辑function acceptPost() &#123; // ...&#125;// 处理表单提交的方法function urlencoded() &#123; // ...&#125;// 处理请求体 json 的方法function json() &#123; // ...&#125;// 导出对象module.exports = &#123; urlencoded, json &#125;; 在把基本模块搭建好后，我们下面就实现 body-parser 模块内的公共逻辑函数 acceptPost。 acceptPost 的实现为了兼容 urlencoded 方法和 json 方法设计了两个参数，一个是区分当前调用方法的 type，一个是针对 urlencoded 方法的 options。 acceptPost 的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// urlencoded 方法和 json 方法的公共逻辑函数function acceptPost(type, options) &#123; // 返回一个中间件函数 return function (req, res, next) &#123; // 获取请求头 const contentType = req.headers['content-type']; // 判断如果不符合两种提交的请求头直接交给其他中间件处理 if ( contentType === 'application/x-www-form-urlencoded' || contentType === 'application/json' ) &#123; // 存储数据的数组 const buffers = []; req.on('data', function (data) &#123; // 接收数据并存入数组中 buffers.push(data); &#125;); req.on('end', function () &#123; // 组合数据并转换成字符串 let result = Buffer.concat(buffers).toString(); // 处理数据并挂载 req.body 属性上 // 如果是表单提交则使用 querystring 或 qs，否则使用 JSON.parse if (type === 'form') &#123; // 如果配置 extended 值为 true 使用 qs，否则使用 querystring req.body = options.extended ? qs.parse(result) : querystring.parse(result); &#125; else if (type === 'json') &#123; req.body = JSON.parse(result); &#125; next(); // 向下执行 &#125;); // 错误处理 req.on('err', function (err) &#123; next(err); &#125;); &#125; else &#123; next(); &#125; &#125;&#125; urlencoded 和 json 方法的实现12345678910111213// 处理表单提交的方法function urlencoded(options) &#123; // 定义 type 值 let type = 'form'; return acceptPost(type, options)&#125;// 处理请求体 json 的方法function json() &#123; // 定义 type 值 let type = 'json'; return acceptPost(type);&#125; 当我们把所有的公共逻辑都抽取出去后发现，urlencoded 和 json 方法内部只需要定义不同的类型就可以执行自己的中间件逻辑。 总结上面分析 body-parse 中间件的原理的目的在于理解 Express 中间件开发的模式，在此总结一下，Express 中间件返回的是一个函数，形参为 req、res 和 next，当功能无法处理某些情况时需要调用 next，当出现错误时调用 next 并传递错误，则交给 Express 内置的错误处理中间件，在中间件内部代码涉及异步操作时，须在异步完成的回调当中调用 next，这是不如 Koa 方便的一点，同时也是两者的区别，因为 Koa 中已经大量使用 async/await，在执行异步代码时可以等待。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"中间件","slug":"中间件","permalink":"https://www.pandashen.com/tags/中间件/"},{"name":"Express","slug":"Express","permalink":"https://www.pandashen.com/tags/Express/"}]},{"title":"Express 源码分析及简易封装","date":"2018-08-25T08:21:29.000Z","path":"2018/08/25/20180825162129/","text":"前言Express 是 NodeJS 的 Web 框架，与 Koa 的轻量相比，功能要更多一些，依然是当前使用最广泛的 NodeJS 框架，本篇参考 Express 的核心逻辑来实现一个简易版，Express 源码较多，逻辑复杂，看一周可能也看不完，如果你已经使用过 Express，又想快速的了解 Express 常用功能的原理，那读这篇文章是一个好的选择，也可以为读真正的源码做铺垫，本篇内容每部分代码较多，因为按照 Express 的封装思想很难拆分，所以建议以星号标注区域为主其他代码为辅。 搭建基本服务下面我们使用 Express 来搭建一个最基本的服务，只有三行代码，只能访问不能响应。 三行代码搭建的最基本服务12345678// 引入 Expressconst express = require('express');// 创建服务const app = express();// 监听服务app.listen(3000); 从上面我们可以分析出，express 模块给我们提供了一个函数，调用后返回了一个函数或对象给上面有 listen 方法给我们创建了一个 http 服务，我们就按照官方的设计返回一个函数 app。 文件：express.js1234567891011121314151617181920const http = require('http');function createApplication() &#123; // 创建 app 函数，身份为总管家，用于将请求分派给别人处理 let app = function(req, res) &#123;&#125; // 启动服务的 listen 方法 app.listen = function() &#123; // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); &#125; // 返回 app return app;&#125;module.exports = createApplication; 我们创建一个模块 express.js，导出了 createApplication 函数并返回在内部创建 app 函数，createApplication 等于我们引入 Express 模块时所调用的那个函数，返回值就是我们接收的 app，在 createApplication 返回的 app 函数上挂载了静态方法 listen，用于帮助我们启动 http 服务。 createApplication 函数内我们使用引入的 http 模块创建了服务，并调用了创建服务 server 的 listen 方法，将 app.listen 的所有参数传递进去，这就等于做了一层封装，将真正创建服务器的过程都包在了 app.listen 内部，我们自己封装的 Express 模块只有在调用导出函数并调用 app.listen 时才会真正的创建服务器和启动服务器，相当于将原生的两步合二为一。 路由的实现在 Express 框架中有多个路由方法，方法名分别对应不同的请求方式，可以帮助我们匹配路径和请求方式，在完全匹配时执行路由内部的回调函数，以、目的是在不同路由不同请求方法的情况下让服务器做出不同的响应，路由的使用方式如下。 路由的使用方式123456789101112131415161718192021// 引入 Expressconst express = require('express');// 创建服务const app = express();// 创建路由app.get('/', function(req, res) &#123; res.end('home');&#125;);app.post('/about', function(req, res) &#123; res.end('about');&#125;);app.all('*', function(req, res) &#123; res.end('Not Found');&#125;);// 监听服务app.listen(3000); 如果启动上面的服务，通过浏览器访问定义的路由时可以匹配到 app.get、app.post 或 app.all 并执行回调，但其实我们可以发现这些方法的名字是与请求类型严格对应的，不仅仅这几个，下面来看看实现路由的核心逻辑（直接找到星号提示新增或修改位置即可）。 文件：express.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const http = require('http');// ***************************** 以下为新增代码 *****************************// methods 模块返回存储所有请求方法名称的数组const methods = require('methods');// ***************************** 以上为新增代码 *****************************function createApplication() &#123; // 创建 app 函数，身份为总管家，用于将请求分派给别人处理 const app = function(req, res) &#123;// ***************************** 以下为新增代码 ***************************** // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 let [reqPath, query = ''] = req.url.split('?'); // 循环匹配路径 for (let i = 0; i &lt; app.routes.lenth; i++) &#123; // 循环取得每一层 const layer = app.routes[i]; // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ( (reqPath === layer.pathname || layer.pathname === '*') &amp;&amp; (method === layer.method || layer.method === 'all') ) &#123; return layer.hanlder(req, res); &#125; &#125; // 如果都没有匹配上，则响应错误信息 res.end(`CANNOT $&#123;req.method&#125; $&#123;reqPath&#125;`);// ***************************** 以上为新增代码 ***************************** &#125;// ***************************** 以下为新增代码 ***************************** // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) &#123; return function(pathname, handler) &#123; const layer = &#123; method, pathname, // 不包含查询字符串 handler &#125;; // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); &#125; &#125; // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function(method) &#123; // 匹配路由的 get 方法 app[method] = createRouteMethod(method); &#125;); // all 方法，通吃所有请求类型 app.all = createRouteMethod('all');// ***************************** 以上为新增代码 ***************************** // 启动服务的 listen 方法 app.listen = function() &#123; // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); &#125; // 返回 app return app;&#125;module.exports = createApplication; 我们的逻辑大体可以分为两个部分，路由方法的创建以及路由的匹配，首先是路由方法的创建阶段，每一个方法的内部所做的事情就是将路由的路径、请求方式和回调函数作为对象的属性，并将对象存入一个数组中统一管理，所以我们创建了 app.routes 数组用来存储这些路由对象。 方法名对应请求类型，请类型有很多，我们不会一一的创建每一个方法，所以选择引入专门存储请求类型名称的 methods 模块，其实路由方法逻辑相同，我们封装了 createRouteMethod 方法用来生成不同路由方法的函数体，之所以这样做是因为有个特殊的路由方法 app.all，导致请求类型有差别，其他的可以从 methods 中取，app.all 我们定义类型为 all 通过 createRouteMethod 函数的参数传入。 接着就是循环 methods 调用 createRouteMethod 函数创建路由方法，并单独创建 app.all 方法。 路由匹配阶段实在函数 app 内完成的，因为启动服务接收到请求时会执行 createServer 中的回调，即执行 app，先通过原生自带的 req.method 取出请求方式并处理成小写，通过 req.path 取出完整路径并分成路由名和查询字符串两个部分。 循环 app.routes 用取到请求的类型和路由名称匹配，两者都相等则执行对应路由对象上的回调函数，在判断条件中，请求方式兼容了我们之前定义的 all，为了所有的请求类型只要路由匹配都可以执行 app.all 的回调，请求路径兼容了 *，因为如果某个路由方法定义的路径为 *，则任意路由都可以执行这个路由对象上的回调。 扩展请求对象属性且在路由内部可以通过 req 访问一些原生没有的属性如 req.path、req.query、req.host 和 req.params，这说明 Express 在实现的过程中对 req 进行了处理。 req 属性的使用123456789101112131415161718192021// 引入 Expressconst express = require('express');// 创建服务const app = express();// 创建路由app.get('/', function(req, res) &#123; console.log(req.path); console.log(req.query); console.log(req.host); res.end('home');&#125;);app.get('/about/:id/:name', function(req, res) &#123; console.log(req.params); res.end('about');&#125;);// 监听服务app.listen(3000); 在上面的使用中我们写了两个路由，分别打印了原生所不具备而 Express 帮我们处理并新增的属性，下面我们就来在之前自己实现的 express.js 的基础上增加这些属性（直接找到星号提示新增或修改位置即可）。 文件：express.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const http = require('http');// methods 模块返回存储所有请求方法名称的数组const methods = require('methods');// ***************************** 以下为新增代码 *****************************const querystring = require('querystring');// ***************************** 以上为新增代码 *****************************function createApplication() &#123; // 创建 app 函数，身份为总管家，用于将请求分派给别人处理 const app = function(req, res) &#123; // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 let [reqPath, query = ''] = req.url.split('?');// *************************** 以下为修改代码 ***************************** // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(':')[0]; // 循环匹配路径 for (let i = 0; i &lt; app.routes.lenth; i++) &#123; // 循环取得每一层 const layer = app.routes[i]; // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) &#123; // 使用路径配置的正则匹配请求路径 const result = pathname.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if (result &amp;&amp; (method === layer.method || layer.method === 'all')) &#123; // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce(function(memo, key, index) &#123; memo[key] = result[index + 1]; return memo; &#125;, &#123;&#125;); // 执行对应的回调 return layer.hanlder(req, res); &#125; &#125; else &#123; // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ( (reqPath === layer.pathname || layer.pathname === '*') &amp;&amp; (method === layer.method || layer.method === 'all') ) &#123; return layer.hanlder(req, res); &#125; &#125;// ***************************** 以上为修改代码 ***************************** &#125; // 如果都没有匹配上，则响应错误信息 res.end(`CANNOT $&#123;req.method&#125; $&#123;reqPath&#125;`); &#125; // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) &#123; return function(pathname, handler) &#123; const layer = &#123; method, pathname, // 不包含查询字符串 handler &#125;;// ***************************** 以下为新增代码 ***************************** // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(':') !== -1) &#123; const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function(matched, attr) &#123; paramNames.push(attr); return '(\\\\w+)'; &#125;); const regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 &#125;// ***************************** 以上为新增代码 ***************************** // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); &#125; &#125; // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function(method) &#123; // 匹配路由的 get 方法 app[method] = createRouteMethod(method); &#125;); // all 方法，通吃所有请求类型 app.all = createRouteMethod('all'); // 启动服务的 listen 方法 app.listen = function() &#123; // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); &#125; // 返回 app return app;&#125;module.exports = createApplication; 上面代码有些长，我们一点一点分析，首先是 req.path，就是我们浏览器地址栏里查询字符串前的路径，值其实就是我们之前从 req.url 中解构出来的 pathname，我们只需要将 pathname 赋值给 req.path 即可。 req.query 是浏览器地址栏的查询字符串传递的参数，就是我们从 req.url 解构出来的查询字符串，借助 querystring 模块将查询字符串处理成对象赋值给 req.query 即可。 req.host 是访问的主机名，请求头中的 host 包含了主机名和端口号，我们只要截取出前半部分赋值给 req.host 即可。 最复杂的是 req.params 的实现，大概分为两个步骤，首先是在路由方法创建时需要检查定义的路由是否含有路由参数，如果有则取出参数的键存入数组 paramNames 中，然后创建一个匹配路由参数的正则，通过 replace 实现正则字符串的创建，再通过 RegExp 构造函数来创建正则，并挂在路由对象上，之所以使用 replace 是因为创建的规则内的分组要和路由参数的个数是相同的，我们将这些逻辑完善进了 createRouteMethod 函数中。 实现响应方法 send 和 sendFile之前的例子中我们都是用原生的 end 方法响应浏览器，我们知道 end 方法只能接收字符串和 Buffer 作为响应的值，非常不方便，其实在 Express 中封装了一个 send 方法挂在 res 对象下，可以接收数组、对象、字符串、Buffer、数字处理后响应给浏览器，在 Express 内部同样封装了一个 sendFile 方法用于读取请求的文件。 send 响应12345678910111213141516171819// 引入 Expressconst express = require('express');const path = require('path');// 创建服务const app = express();// 创建路由app.get('/', function(req, res) &#123; res.send(&#123; name: 'panda', age: 28 &#125;);&#125;);app.get('/test.txt', function(req, res) &#123; // 必须传入绝对路径 res.sendFile(path.join(__dirname, req.path));&#125;);// 监听服务app.listen(3000); 通过我们的分析，封装的 send 方法应该是将 end 不支持的类型数据转换成了字符串，在内部再次调用 end，而 sendFile 方法规定参数必须为绝对路径，内部实现应该是利用可读流读取文件内容相应给浏览器，下面是两个方法的实现（直接找到星号提示新增或修改位置即可）。 文件：express.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153const http = require('http');// methods 模块返回存储所有请求方法名称的数组const methods = require('methods');const querystring = require('querystring');// ***************************** 以下为新增代码 *****************************const util = require('util');const httpServer = require('_http_server'); // 存储 node 服务相关信息const fs = require('fs');// ***************************** 以上为新增代码 *****************************function createApplication() &#123; // 创建 app 函数，身份为总管家，用于将请求分派给别人处理 const app = function(req, res) &#123; // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 let [reqPath, query = ''] = req.url.split('?'); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(':')[0];// ***************************** 以下为新增代码 ***************************** // 响应方法 res.send = function(params) &#123; // 设置响应头 res.setHeader('Content-Type', 'text/plain;charset=utf8'); // 检测传入值得数据类型 switch (typeof params) &#123; case 'object': res.setHeader('Content-Type', 'application/json;charset=utf8'); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case 'number': // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; &#125; // 响应 res.end(params); &#125; // 响应文件方法 res.sendFile = function(pathname) &#123; fs.createReadStream(pathname).pipe(res); &#125;// ***************************** 以上为新增代码 ***************************** // 循环匹配路径 for (let i = 0; i &lt; app.routes.lenth; i++) &#123; // 循环取得每一层 const layer = app.routes[i]; // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) &#123; // 使用路径配置的正则匹配请求路径 const result = reqPath.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if (result &amp;&amp; (method === layer.method || layer.method === 'all')) &#123; // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce(function(memo, key, index) &#123; memo[key] = result[index + 1]; return memo; &#125;, &#123;&#125;); // 执行对应的回调 return layer.hanlder(req, res); &#125; &#125; else &#123; // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ( (reqPath === layer.pathname || layer.pathname === '*') &amp;&amp; (method === layer.method || layer.method === 'all') ) &#123; return layer.hanlder(req, res); &#125; &#125; &#125; // 如果都没有匹配上，则响应错误信息 res.end(`CANNOT $&#123;req.method&#125; $&#123;reqPath&#125;`); &#125; // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) &#123; return function(pathname, handler) &#123; const layer = &#123; method, pathname, // 不包含查询字符串 handler &#125;; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(':') !== -1) &#123; const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function(matched, attr) &#123; paramNames.push(attr); return '(\\\\w+)'; &#125;); let regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 &#125; // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); &#125; &#125; // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function(method) &#123; // 匹配路由的 get 方法 app[method] = createRouteMethod(method); &#125;); // all 方法，通吃所有请求类型 app.all = createRouteMethod('all'); // 启动服务的 listen 方法 app.listen = function() &#123; // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); &#125; // 返回 app return app;&#125;module.exports = createApplication; 有一点需要注意，在 Node 环境中想把任何对象类型转换成字符串应该使用 util.inspect 方法，而当 send 方法输入数字类型时，要返回对应状态码的名称，可通过 _http_server 模块的 STATUS_CODES 对象获取。 内置中间件的实现Express 最大的特点就是中间件机制，中间件就是用来处理请求的函数，用来完成不同场景的请求处理，一个中间件处理完请求后可以再传递给下一个中间件，具有回调函数 next，不执行 next 则会卡在一个位置，调用 next 则继续向下传递。 use 的使用1234567891011121314151617181920// 引入 Expressconst express = require('express');const path = require('path');// 创建服务const app = express();// 创建路由app.use(function(req, res, next) &#123; res.setHeader('Content-Type', 'text/html;charset=utf8'); next();&#125;);// 创建路由app.get('/', function(req, res) &#123; res.send(&#123; name: 'panda', age: 28 &#125;);&#125;);// 监听服务app.listen(3000); 在上面代码中使用 use 方法执行了传入的回调函数，实现公共逻辑，起到了中间件的作用，调用回调参数的 next 方法向下继续执行，下面来实现 use 方法（直接找到星号提示新增或修改位置即可）。 文件：express.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225const http = require('http');// methods 模块返回存储所有请求方法名称的数组const methods = require('methods');const querystring = require('querystring');const util = require('util');const httpServer = require('_http_server'); // 存储 node 服务相关信息const fs = require('fs');function createApplication() &#123; // 创建 app 函数，身份为总管家，用于将请求分派给别人处理 const app = function(req, res) &#123;// ***************************** 以下为修改代码 ***************************** // 循环匹配路径 let index = 0; function next(err) &#123; // 获取第一个回调函数 const layer = app.routes[index++]; if (layer) &#123; // 将当前中间件函数的属性解构出来 let &#123; method, pathname, handler &#125; = layer; if (err) &#123; // 如果存在错误将错误交给错误处理中间件，否则 if (method === 'middle', handle.length === 4) &#123; return hanlder(err, req, res, next); &#125; else &#123; next(err); &#125; &#125; else &#123; // 如果不存在错误则继续向下执行 // 判断是中间件还是路由 if (method === 'middle') &#123; // 匹配路径判断 if ( pathname === '/' || pathname === req.path || req.path.startWidth(pathname) ) &#123; handler(req, res, next); &#125; else &#123; next(); &#125; &#125; else &#123; // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) &#123; // 使用路径配置的正则匹配请求路径 const result = req.path.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if ( result &amp;&amp; ( method === layer.method || layer.method === 'all' ) ) &#123; // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce( function(memo, key, index ) &#123; memo[key] = result[index + 1]; return memo; &#125;, &#123;&#125; ); // 执行对应的回调 return layer.hanlder(req, res); &#125; else &#123; next(); &#125; &#125; else &#123; // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ( (req.path === layer.pathname || layer.pathname === '*') &amp;&amp; (method === layer.method || layer.method === 'all') ) &#123; return layer.hanlder(req, res); &#125; else &#123; next(); &#125; &#125; &#125; &#125; &#125; else &#123; // 如果都没有匹配上，则响应错误信息 res.end(`CANNOT $&#123;req.method&#125; $&#123;req.path&#125;`); &#125; &#125; next();// ***************************** 以上为修改代码 ***************************** &#125;// ***************************** 以下为新增代码 ***************************** function init() &#123; return function(req, res, next) &#123; // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 let [reqPath, query = ''] = req.url.split('?'); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(':')[0]; // 响应方法 res.send = function(params) &#123; // 设置响应头 res.setHeader('Content-Type', 'text/plain;charset=utf8'); // 检测传入值得数据类型 switch (typeof params) &#123; case 'object': res.setHeader('Content-Type', 'application/json;charset=utf8'); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case 'number': // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; &#125; // 响应 res.end(params); &#125; // 响应文件方法 res.sendFile = function(pathname) &#123; fs.createReadStream(pathname).pipe(res); &#125; // 向下执行 next(); &#125; &#125;// ***************************** 以上为新增代码 ***************************** // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) &#123; return function(pathname, handler) &#123; const layer = &#123; method, pathname, // 不包含查询字符串 handler &#125;; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上// ***************************** 以下为修改代码 ***************************** if ( pathname.indexOf(':') !== -1 &amp;&amp; pathname.method !== 'middle' ) &#123;// ***************************** 以上为修改代码 ***************************** const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function(matched, attr) &#123; paramNames.push(attr); return '(\\\\w+)'; &#125;); let regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 &#125; // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); &#125; &#125; // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function(method) &#123; // 匹配路由的 get 方法 app[method] = createRouteMethod(method); &#125;); // all 方法，通吃所有请求类型 app.all = createRouteMethod('all');// ***************************** 以下为新增代码 ***************************** // 添加中间件方法 app.use = function(pathname, handler) &#123; // 处理没有传入路径的情况 if (typeof handler !== 'function') &#123; handler = pathname; pathname = '/'; &#125; // 生成函数并执行 createRouteMethod('middle')(pathname, handler); &#125; // 将初始逻辑作为中间件执行 app.use(init());// ***************************** 以上为新增代码 ***************************** // 启动服务的 listen 方法 app.listen = function() &#123; // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); &#125; // 返回 app return app;&#125;module.exports = createApplication; use 方法第一个参数为路径，与路由相同，不传默认为 /，如果不传所有的路径都会经过该中间件，如果传入指定的值，则匹配后的请求才会通过该中间件。 中间件的执行可能存在异步的情况，但之前匹配路径使用的是 for 循环同步匹配，我们将其修改为异步并把路由匹配的逻辑与中间件路径匹配的逻辑进行了整合，并创建了 use 方法，对是否传了第一个参数做了一个兼容，其他将带有请求方式、路径和回调的逻辑统一使用 createRouteMethod 方法创建，并传入 middle 类型，createRouteMethod 中路由参数匹配的逻辑对 middle 类型做了一个排除。 使用 Express 中间件调用 next 方法时，不传递参数和参数为 null 代表执行成功，如果传入了其他的参数，表示执行出错，会跳过所有正常的中间件和路由，直接交给错误处理中间件处理，并将 next 传入的参数作为错误处理中间件回调函数的第一个参数 err，后面三个参数分别为 req、res 和 next。 代码种创建了 index 变量，默认调用了一次 next 方法，每次然后取出数组 app.routes 中的路由对象的回调函数执行，并在内部执行 handler，而 handler 回调中又调用了 next 方法，就这样将整个中间件和路由的回调串联起来。 我们发现在第一次调用 next 之前的所有逻辑，如给 req 添加属性，给 res 添加方法，都是公共逻辑，是任何中间件和路由在匹配之前都会执行的逻辑，我们既然有了中间件方法 app.user，可以将这些逻辑抽取出来作为一个单独的中间件回调函数执行，所以创建了 init 函数，内部返回了一个函数作为回调函数，形参为 req、res 和 next，并在init 调用返回的函数内部调用 next 向下执行。 内置模板引擎的实现在 Express 框架中内置支持了 ejs、jade 等模板，使用方法 “三部曲” 如下。 模板的使用123456789101112131415161718192021222324// 引入 Expressconst express = require('express');const path = require('path');// 创建服务const app = express();// 1、指定模板引擎，其实就是模板文件的后缀名app.set('view engine', 'ejs');// 2、指定模板的存放根目录app.set('views', path.resolve(__dirname, 'views'));// 3、如果要自定义模板后缀和函数的关系app.engine('.html', require('./ejs').__express);// 创建路由app.get('/user', function(req, res) &#123; //使用指定的模板引擎渲染 user 模板 res.render('user', &#123; title: '用户管理' &#125;);&#125;);// 监听服务app.listen(3000); 上面将模板根目录设置为 views 文件夹，并规定了模板类型为 ejs，可以同时给多种模板设置，并不冲突，如果需要将其他后缀名的模板按照另一种模板的渲染引擎渲染则使用 app.engine 进行设置，下面看一下实现代码（直接找到星号提示新增或修改位置即可）。 文件：express.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266const http = require('http');// methods 模块返回存储所有请求方法名称的数组const methods = require('methods');const querystring = require('querystring');const util = require('util');const httpServer = require('_http_server'); // 存储 node 服务相关信息const fs = require('fs');// ***************************** 以下为新增代码 *****************************const path = require('path');// ***************************** 以上为新增代码 *****************************function createApplication() &#123; // 创建 app 函数，身份为总管家，用于将请求分派给别人处理 const app = function(req, res) &#123; // 循环匹配路径 let index = 0; function next(err) &#123; // 获取第一个回调函数 const layer = app.routes[index++]; if (layer) &#123; // 将当前中间件函数的属性解构出来 let &#123; method, pathname, handler &#125; = layer; if (err) &#123; // 如果存在错误将错误交给错误处理中间件，否则 if (method === 'middle', handle.length === 4) &#123; return hanlder(err, req, res, next); &#125; else &#123; next(err); &#125; &#125; else &#123; // 如果不存在错误则继续向下执行 // 判断是中间件还是路由 if (method === 'middle') &#123; // 匹配路径判断 if ( pathname === '/' || pathname === req.path || req.path.startWidth(pathname) ) &#123; handler(req, res, next); &#125; else &#123; next(); &#125; &#125; else &#123; // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) &#123; // 使用路径配置的正则匹配请求路径 const result = req.path.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if ( result &amp;&amp; ( method === layer.method || layer.method === 'all' ) ) &#123; // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce( function(memo, key, index) &#123; memo[key] = result[index + 1]; return memo; &#125;, &#123;&#125; ); // 执行对应的回调 return layer.hanlder(req, res); &#125; else &#123; next(); &#125; &#125; else &#123; // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ( (req.path === layer.pathname || layer.pathname === '*') &amp;&amp; (method === layer.method || layer.method === 'all') ) &#123; return layer.hanlder(req, res); &#125; else &#123; next(); &#125; &#125; &#125; &#125; &#125; else &#123; // 如果都没有匹配上，则响应错误信息 res.end(`CANNOT $&#123;req.method&#125; $&#123;req.path&#125;`); &#125; &#125; next(); &#125; function init() &#123; return function(req, res, next) &#123; // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 let [reqPath, query = ''] = req.url.split('?'); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(':')[0]; // 响应方法 res.send = function(params) &#123; // 设置响应头 res.setHeader('Content-Type', 'text/plain;charset=utf8'); // 检测传入值得数据类型 switch (typeof params) &#123; case 'object': res.setHeader('Content-Type', 'application/json;charset=utf8'); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case 'number': // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; &#125; // 响应 res.end(params); &#125; // 响应文件方法 res.sendFile = function(pathname) &#123; fs.createReadStream(pathname).pipe(res); &#125;// ***************************** 以下为新增代码 ***************************** // 模板渲染方法 res.render = function(filename, data) &#123; // 将文件名和模板路径拼接 let filepath = path.join(app.get('views'), filename); // 获取扩展名 let extname = path.extname(filename.split(path.sep).pop()); // 如果没有扩展名，则使用默认的扩展名 if (!extname) &#123; extname = `.$&#123;app.get('view engine')&#125;` filepath += extname; &#125; // 读取模板文件并使用渲染引擎相应给浏览器 app.engines[extname](filepath, data, function(err, html) &#123; res.setHeader('Content-Type', 'text/html;charset=utf8'); res.end(html); &#125;); &#125;// ***************************** 以上为新增代码 ***************************** // 向下执行 next(); &#125; &#125; // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) &#123; return function(pathname, handler) &#123;// ***************************** 以下为修改代码 ***************************** // 满足条件说明是取值方法 if (method === 'get' &amp;&amp; arguments.length === 1) &#123; return app.settings[pathname]; &#125;// ***************************** 以上为修改代码 ***************************** const layer = &#123; method, pathname, // 不包含查询字符串 handler &#125;; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(':') !== -1 &amp;&amp; pathname.method !== 'middle') &#123; const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function(matched, attr) &#123; paramNames.push(attr); return '(\\\\w+)'; &#125;); let regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 &#125; // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); &#125; &#125; // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function(method) &#123; // 匹配路由的 get 方法 app[method] = createRouteMethod(method); &#125;); // all 方法，通吃所有请求类型 app.all = createRouteMethod('all'); // 添加中间件方法 app.use = function(pathname, handler) &#123; // 处理没有传入路径的情况 if (typeof handler !== 'function') &#123; handler = pathname; pathname = '/'; &#125; // 生成函数并执行 createRouteMethod('middle')(pathname, handler); &#125; // 将初始逻辑作为中间件执行 app.use(init());// ***************************** 以下为新增代码 ***************************** // 存储设置的对象 app.setting =&#123;&#125;; // 存储模板渲染方法 app.engines = &#123;&#125;; // 添加设置的方法 app.set = function(key, value) &#123; app.use[key] = value; &#125; // 添加渲染引擎的方法 app.engine = function(ext, renderFile) &#123; app.engines[ext] = renderFile; &#125;// ***************************** 以上为新增代码 ***************************** // 启动服务的 listen 方法 app.listen = function() &#123; // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); &#125; // 返回 app return app;&#125;module.exports = createApplication; 在上面新增代码中设置了两个缓存 settings 和 engines，前者用来存储模板相关的设置，如渲染成什么类型的文件、读取模板文件的根目录，后者用来存储渲染引擎，即渲染模板的方法，这所以设置这两个缓存对象是为了实现 Express 多种不同模板共存的功能，可以根据需要进行设置和使用，而设置的方法分别为 app.set 和 app.engine，有设置值的方法就应该有取值的方法，但是 app.get 方法已经被设置为路由方法了，为了语义我们在 app.get 方法逻辑中进行了兼容，当参数为 1 个时，从 settings 中取值并返回，否则执行添加路由方法的逻辑。 之前都是准备工作，在使用时无论是中间件还是路由中都是靠调用 res.render 方法并传入模板路径和渲染数据来真正实现渲染和响应的，render 方法是在 init 函数初始化时就挂在了 res 上，核心逻辑是取出传入的模板文件后缀名，如果存在则使用后缀名，将文件名与默认读取模板的文件夹路径拼接传递给设置的渲染引擎的渲染方法，如果不存在后缀名则默认拼接 .html 当作后缀名，再与默认读取模板路径进行拼接，在渲染函数的回调中将渲染引擎渲染的模板字符串响应给浏览器。 内置静态资源中间件的实现在 Express 内部可以通过路由处理静态文件，但是如果可能请求多个文件不可能一个文件对应一个路由，因此 Express 内部实现了静态文件中间件，使用如下。 静态文件中间件的使用123456789101112// 引入 Expressconst express = require('express');const path = require('path');// 创建服务const app = express();// 使用处理静态文件中间件app.use(express.static(path.resolve(__dirname, 'public')));// 监听服务app.listen(3000); 从上面使用可以看出，express.static 是一个函数，执行的时候传入了一个参数，为默认查找文件的根路径，而添加中间件的 app.use 方法传入的参数正好是回调函数，这说明 express.static 方法需要返回一个函数，形参为 req、res 和 next，通过调用方式我们能看出 static 是静态方法，挂在了模块返回的函数上，实现代码如下（直接找到星号提示新增或修改位置即可）。 文件：express.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280const http = require('http');// methods 模块返回存储所有请求方法名称的数组const methods = require('methods');const querystring = require('querystring');const util = require('util');const httpServer = require('_http_server'); // 存储 node 服务相关信息const fs = require('fs');const path = require('path');// ***************************** 以下为新增代码 *****************************const mime = require('mime');// ***************************** 以上为新增代码 *****************************function createApplication() &#123; // 创建 app 函数，身份为总管家，用于将请求分派给别人处理 const app = function(req, res) &#123; // 循环匹配路径 let index = 0; function next(err) &#123; // 获取第一个回调函数 const layer = app.routes[index++]; if (layer) &#123; // 将当前中间件函数的属性解构出来 let &#123; method, pathname, handler &#125; = layer; if (err) &#123; // 如果存在错误将错误交给错误处理中间件，否则 if (method === 'middle', handle.length === 4) &#123; return hanlder(err, req, res, next); &#125; else &#123; next(err); &#125; &#125; else &#123; // 如果不存在错误则继续向下执行 // 判断是中间件还是路由 if (method === 'middle') &#123; // 匹配路径判断 if ( pathname === '/' || pathname === req.path || req.path.startWidth(pathname) ) &#123; handler(req, res, next); &#125; else &#123; next(); &#125; &#125; else &#123; // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) &#123; // 使用路径配置的正则匹配请求路径 const result = req.path.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if ( result &amp;&amp; ( method === layer.method || layer.method === 'all' ) ) &#123; // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce( function(memo, key, index) &#123; memo[key] = result[index + 1]; return memo; &#125;, &#123;&#125; ); // 执行对应的回调 return layer.hanlder(req, res); &#125; else &#123; next(); &#125; &#125; else &#123; // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ( (req.path === layer.pathname || layer.pathname === '*') &amp;&amp; (method === layer.method || layer.method === 'all') ) &#123; return layer.hanlder(req, res); &#125; else &#123; next(); &#125; &#125; &#125; &#125; &#125; else &#123; // 如果都没有匹配上，则响应错误信息 res.end(`CANNOT $&#123;req.method&#125; $&#123;req.path&#125;`); &#125; &#125; next(); &#125; function init() &#123; return function(req, res, next) &#123; // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 let [reqPath, query = ''] = req.url.split('?'); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(':')[0]; // 响应方法 res.send = function(params) &#123; // 设置响应头 res.setHeader('Content-Type', 'text/plain;charset=utf8'); // 检测传入值得数据类型 switch (typeof params) &#123; case 'object': res.setHeader('Content-Type', 'application/json;charset=utf8'); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case 'number': // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; &#125; // 响应 res.end(params); &#125; // 响应文件方法 res.sendFile = function(pathname) &#123; fs.createReadStream(pathname).pipe(res); &#125; // 模板渲染方法 res.render = function(filename, data) &#123; // 将文件名和模板路径拼接 let filepath = path.join(app.get('views'), filename); // 获取扩展名 let extname = path.extname(filename.split(path.sep).pop()); // 如果没有扩展名，则使用默认的扩展名 if (!extname) &#123; extname = `.$&#123;app.get('view engine')&#125;` filepath += extname; &#125; // 读取模板文件并使用渲染引擎相应给浏览器 app.engines[extname](filepath, data, function(err, html) &#123; res.setHeader('Content-Type', 'text/html;charset=utf8'); res.end(html); &#125;); &#125; // 向下执行 next(); &#125; &#125; // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) &#123; return function(pathname, handler) &#123; // 满足条件说明是取值方法 if (method === 'get' &amp;&amp; arguments.length === 1) &#123; return app.settings[pathname]; &#125; const layer = &#123; method, pathname, // 不包含查询字符串 handler &#125;; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(':') !== -1 &amp;&amp; pathname.method !== 'middle') &#123; const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function(matched, attr) &#123; paramNames.push(attr); return '(\\\\w+)'; &#125;); let regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 &#125; // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); &#125; &#125; // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function(method) &#123; // 匹配路由的 get 方法 app[method] = createRouteMethod(method); &#125;); // all 方法，通吃所有请求类型 app.all = createRouteMethod('all'); // 添加中间件方法 app.use = function(pathname, handler) &#123; // 处理没有传入路径的情况 if (typeof handler !== 'function') &#123; handler = pathname; pathname = '/'; &#125; // 生成函数并执行 createRouteMethod('middle')(pathname, handler); &#125; // 将初始逻辑作为中间件执行 app.use(init()); // 存储设置的对象 app.setting =&#123;&#125;; // 存储模板渲染方法 app.engines = &#123;&#125;; // 添加设置的方法 app.set = function(key, value) &#123; app.use[key] = value; &#125; // 添加渲染引擎的方法 app.engine = function(ext, renderFile) &#123; app.engines[ext] = renderFile; &#125; // 启动服务的 listen 方法 app.listen = function() &#123; // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); &#125; // 返回 app return app;&#125;// ***************************** 以下为新增代码 *****************************createApplication.static = function(staticRoot) &#123; return function(req, res, next) &#123; // 获取文件的完整路径 let filename = path.join(staticRoot, req.path); // 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应 fs.access(filename, function(err) &#123; if (err) &#123; next(); &#125; else &#123; // 设置响应头类型和响应文件内容 res.setHeader('Content-Type', `$&#123;mime.getType()&#125;;charset=utf8`); fs.createReadStream(filename).pipe(res); &#125; &#125;); &#125;&#125;// ***************************** 以上为新增代码 *****************************module.exports = createApplication; 这个方法的核心逻辑是获取文件的路径，检查文件的权限，如果没有权限，则调用 next 交给其他中间件，这里注意的是 err 错误对象不要传递给 next，因为后面的中间件还要执行，如果传递后会直接执行错误处理中间件，有权限的情况下就正常读取文件内容，给 Content-Type 响应头设置文件类型，并将文件的可读流通过 pipe 方法传递给可写流 res，即响应给浏览器。 实现重定向在 Express 中有一个功能在我们匹配到的某一个路由中调用可以直接跳转到另一个路由，即 302 重定向。 使用重定向12345678910111213141516171819// 引入 Expressconst express = require('express');const path = require('path');// 创建服务const app = express();// 创建路由app.get('/user', function(req, res, next) &#123; res.end('user');&#125;);app.get('/detail', function(req, res, next) &#123; // 访问 /detail 重定向到 /user res.redirect('/user');&#125;);// 监听服务app.listen(3000); 看到上面的使用方式，我们根据前面的套路知道是 Express 在 res 对象上给挂载了一个 redirect 方法，参数为状态码（可选）和要跳转路由的路径，并且这个方法应该在 init 函数调用时挂在 res 上的，下面是实现的代码（直接找到星号提示新增或修改位置即可）。 文件：express.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295const http = require('http');// methods 模块返回存储所有请求方法名称的数组const methods = require('methods');const querystring = require('querystring');const util = require('util');const httpServer = require('_http_server'); // 存储 node 服务相关信息const fs = require('fs');const path = require('path');const mime = require('mime');function createApplication() &#123; // 创建 app 函数，身份为总管家，用于将请求分派给别人处理 const app = function(req, res) &#123; // 循环匹配路径 let index = 0; function next(err) &#123; // 获取第一个回调函数 let layer = app.routes[index++]; if (layer) &#123; // 将当前中间件函数的属性解构出来 let &#123; method, pathname, handler &#125; = layer; if (err) &#123; // 如果存在错误将错误交给错误处理中间件，否则 if (method === 'middle', handle.length === 4) &#123; return hanlder(err, req, res, next); &#125; else &#123; next(err); &#125; &#125; else &#123; // 如果不存在错误则继续向下执行 // 判断是中间件还是路由 if (method === 'middle') &#123; // 匹配路径判断 if ( pathname === '/' || pathname === req.path || req.path.startWidth(pathname) ) &#123; handler(req, res, next); &#125; else &#123; next(); &#125; &#125; else &#123; // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) &#123; // 使用路径配置的正则匹配请求路径 const result = req.path.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if ( result &amp;&amp; ( method === layer.method || layer.method === 'all' ) ) &#123; // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce( function(memo, key, index) &#123; memo[key] = result[index + 1]; return memo; &#125;, &#123;&#125; ); // 执行对应的回调 return layer.hanlder(req, res); &#125; else &#123; next(); &#125; &#125; else &#123; // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ( (req.path === layer.pathname || layer.pathname === '*') &amp;&amp; (method === layer.method || layer.method === 'all') ) &#123; return layer.hanlder(req, res); &#125; else &#123; next(); &#125; &#125; &#125; &#125; &#125; else &#123; // 如果都没有匹配上，则响应错误信息 res.end(`CANNOT $&#123;req.method&#125; $&#123;req.path&#125;`); &#125; &#125; next(); &#125; function init() &#123; return function(req, res, next) &#123; // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 let [reqPath, query = ''] = req.url.split('?'); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(':')[0]; // 响应方法 res.send = function(params) &#123; // 设置响应头 res.setHeader('Content-Type', 'text/plain;charset=utf8'); // 检测传入值得数据类型 switch (typeof params) &#123; case 'object': res.setHeader('Content-Type', 'application/json;charset=utf8'); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case 'number': // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; &#125; // 响应 res.end(params); &#125; // 响应文件方法 res.sendFile = function(pathname) &#123; fs.createReadStream(pathname).pipe(res); &#125; // 模板渲染方法 res.render = function(filename, data) &#123; // 将文件名和模板路径拼接 let filepath = path.join(app.get('views'), filename); // 获取扩展名 let extname = path.extname(filename.split(path.sep).pop()); // 如果没有扩展名，则使用默认的扩展名 if (!extname) &#123; extname = `.$&#123;app.get('view engine')&#125;` filepath += extname; &#125; // 读取模板文件并使用渲染引擎相应给浏览器 app.engines[extname](filepath, data, function(err, html) &#123; res.setHeader('Content-Type', 'text/html;charset=utf8'); res.end(html); &#125;); &#125;// ***************************** 以下为新增代码 ***************************** // 重定向方法 res.redirect = function(status, target) &#123; // 如果第一个参数是字符串类型说明没有传状态码 if (typeof status === 'string') &#123; // 将第二个参数（重定向的目标路径）设置给 target target = status; // 再把状态码设置成 302 status = 302; &#125; // 响应状态码，设置重定向响应头 res.statusCode = status; res.setHeader('Location', target); res.end(); &#125;// ***************************** 以上为新增代码 ***************************** // 向下执行 next(); &#125; &#125; // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) &#123; return function(pathname, handler) &#123; // 满足条件说明是取值方法 if (method === 'get' &amp;&amp; arguments.length === 1) &#123; return app.settings[pathname]; &#125; const layer = &#123; method, pathname, // 不包含查询字符串 handler &#125;; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(':') !== -1 &amp;&amp; pathname.method !== 'middle') &#123; const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function(matched, attr) &#123; paramNames.push(attr); return '(\\\\w+)'; &#125;); let regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 &#125; // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); &#125; &#125; // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function(method) &#123; // 匹配路由的 get 方法 app[method] = createRouteMethod(method); &#125;); // all 方法，通吃所有请求类型 app.all = createRouteMethod('all'); // 添加中间件方法 app.use = function(pathname, handler) &#123; // 处理没有传入路径的情况 if (typeof handler !== 'function') &#123; handler = pathname; pathname = '/'; &#125; // 生成函数并执行 createRouteMethod('middle')(pathname, handler); &#125; // 将初始逻辑作为中间件执行 app.use(init()); // 存储设置的对象 app.setting =&#123;&#125;; // 存储模板渲染方法 app.engines = &#123;&#125;; // 添加设置的方法 app.set = function(key, value) &#123; app.use[key] = value; &#125; // 添加渲染引擎的方法 app.engine = function(ext, renderFile) &#123; app.engines[ext] = renderFile; &#125; // 启动服务的 listen 方法 app.listen = function() &#123; // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); &#125; // 返回 app return app;&#125;createApplication.static = function(staticRoot) &#123; return function(req, res, next) &#123; // 获取文件的完整路径 let filename = path.join(staticRoot, req.path); // 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应 fs.access(filename, function(err) &#123; if (err) &#123; next(); &#125; else &#123; // 设置响应头类型和响应文件内容 res.setHeader('Content-Type', `$&#123;mime.getType()&#125;;charset=utf8`); fs.createReadStream(filename).pipe(res); &#125; &#125;); &#125;&#125;module.exports = createApplication; 其实 res.redirect 方法的核心逻辑就是处理参数，如果没有传状态码的时候将参数设置给 target，将状态码设置为 302，并设置重定向响应头 Location。 总结到此为止 Express 的大部分内置功能就都简易的实现了，由于 Express 内部的封装思想，以及代码复杂、紧密的特点，各个功能代码很难单独拆分，总结一下就是很难表述清楚，只能通过大量代码来堆砌，好在每一部分实现我都标记了 “重点”，但看的时候还是要经历 “痛苦”，这已经将 Express 中的逻辑 “阉割” 到了一定的程度，读 Express 的源码一定比读这篇文章更需要耐心，当然如果你已经读到了这里证明困难都被克服了，继续加油。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"中间件","slug":"中间件","permalink":"https://www.pandashen.com/tags/中间件/"},{"name":"Express","slug":"Express","permalink":"https://www.pandashen.com/tags/Express/"}]},{"title":"Koa2 中间件原理解析 —— 看了就会写","date":"2018-08-20T12:03:42.000Z","path":"2018/08/20/20180820200342/","text":"前言Koa 2.x 版本是当下最流行的 NodeJS 框架，Koa 2.0 的源码特别精简，不像 Express 封装的功能那么多，所以大部分的功能都是由 Koa 开发团队（同 Express 是一家出品）和社区贡献者针对 Koa 对 NodeJS 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 Koa 的 use 方法使用在对应的位置，这样就可以通过在内部操作 ctx 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 Koa 中间件供自己和别人使用。 Koa 的洋葱模型介绍我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 API 的使用方式及洋葱模型分析中间件是如何工作的。 洋葱模型特点123456789101112131415161718192021222324252627282930313233// 引入 Koaconst Koa = require('koa');// 创建服务const app = new Koa();app.use(async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(2);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(3); await next(); console.log(4);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(5); await next(); console.log(6);&#125;);// 监听服务app.listen(3000);// 1// 3// 5// 6// 4// 2 我们知道 Koa 的 use 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 next 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 Koa 中都是建议使用 async/await 的，引入的中间件都是在 use 方法中调用，由此我们可以分析出每一个 Koa 的中间件都是返回一个 async 函数的。 koa-bodyparser 中间件模拟想要分析 koa-bodyparser 的原理首先需要知道用法和作用，koa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值，使用前需提前安装。 npm install koa koa-bodyparser koa-bodyparser 具体用法如下： koa-bodyparser 的用法12345678910111213141516const Koa = require('koa');const bodyParser = require('koa-bodyparser');const app = new Koa();// 使用中间件app.use(bodyParser());app.use(async (ctx, next) =&gt; &#123; if (ctx.path === '/' &amp;&amp; ctx.method === 'POST') &#123; // 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据 console.log(ctx.request.body); &#125;&#125;);app.listen(3000); 根据用法我们可以看出 koa-bodyparser 中间件引入的其实是一个函数，我们把它放在了 use 中执行，根据 Koa 的特点，我们推断出 koa-bodyparser 的函数执行后应该给我们返回了一个 async 函数，下面是我们模拟实现的代码。 文件：my-koa-bodyparser.js123456789101112131415161718192021222324252627282930313233343536const querystring = require('querystring');module.exports = function bodyParser() &#123; return async (ctx, next) =&gt; &#123; await new Promise((resolve, reject) =&gt; &#123; // 存储数据的数组 const dataArr = []; // 接收数据 ctx.req.on('data', data =&gt; dataArr.push(data)); // 整合数据并使用 Promise 成功 ctx.req.on('end', () =&gt; &#123; // 获取请求数据的类型 json 或表单 const contentType = ctx.get('Content-Type'); // 获取数据 Buffer 格式 const data = Buffer.concat(dataArr).toString(); if (contentType === 'application/x-www-form-urlencoded') &#123; // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body ctx.request.body = querystring.parse(data); &#125; else if (contentType === 'applaction/json') &#123; // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body ctx.request.body = JSON.parse(data); &#125; // 执行成功的回调 resolve(); &#125;); &#125;); // 继续向下执行 await next(); &#125;&#125; 在上面代码中由几点是需要我们注意的，即 next 的调用以及为什么通过流接收数据、处理数据和将数据挂在 ctx.request.body 要在 Promise 中进行。 首先是 next 的调用，我们知道 Koa 的 next 执行，其实就是在执行下一个中间件的函数，即下一个 use 中的 async 函数，为了保证后面的异步代码执行完毕后再继续执行当前的代码，所以我们需要使用 await 进行等待，其次就是数据从接收到挂在 ctx.request.body 都在 Promise 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 ctx.request.body 上，可以保证我们在下一个 use 的 async 函数中可以在 ctx.request.body 上拿到数据，所以我们使用 await 等待一个 Promise 成功后再执行 next。 koa-better-body 中间件模拟koa-bodyparser 在处理表单提交时还是显得有一点弱，因为不支持文件上传，而 koa-better-body 则弥补了这个不足，但是 koa-better-body 为 Koa 1.x 版本的中间件，Koa 1.x 的中间件都是使用 Generator 函数实现的，我们需要使用 koa-convert 将 koa-better-body 转化成 Koa 2.x 的中间件。 npm install koa koa-better-body koa-convert path uuid koa-better-body 具体用法如下： koa-better-body 的用法123456789101112131415161718192021222324252627const Koa = require('koa');const betterBody = require('koa-better-body');const convert = require('koa-convert'); // 将 koa 1.0 中间转化成 koa 2.0 中间件const path = require('path');const fs = require('fs');const uuid = require('uuid/v1'); // 生成随机串const app = new Koa();// 将 koa-better-body 中间件从 koa 1.0 转化成 koa 2.0，并使用中间件app.use(convert(betterBody(&#123; uploadDir: path.resolve(__dirname, 'upload')&#125;)));app.use(async (ctx, next) =&gt; &#123; if (ctx.path === '/' &amp;&amp; ctx.method === 'POST') &#123; // 使用中间件后 ctx.request.fields 属性自动加上了 post 请求的文件数据 console.log(ctx.request.fields); // 将文件重命名 let imgPath = ctx.request.fields.avatar[0].path; let newPath = path.resolve(__dirname, uuid()); fs.rename(imgPath, newPath); &#125;&#125;);app.listen(3000); 上面代码中 koa-better-body 的主要功能就是将表单上传的文件存入本地指定的文件夹下，并将文件流对象挂在了 ctx.request.fields 属性上，我们接下来就模拟 koa-better-body 的功能实现一版基于 Koa 2.x 处理文件上传的中间件。 文件：my-koa-better-body.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const fs = require('fs');const uuid = require('uuid/v1');const path = require('path');// 给 Buffer 扩展 split 方法预备后面使用Buffer.prototype.split = function (sep) &#123; let len = Buffer.from(sep).length; // 分隔符所占的字节数 let result = []; // 返回的数组 let start = 0; // 查找 Buffer 的起始位置 let offset = 0; // 偏移量 // 循环查找分隔符 while ((offset = this.indexOf(sep, start)) !== -1) &#123; // 将分隔符之前的部分截取出来存入 result.push(this.slice(start, offset)); start = offset + len; &#125; // 处理剩下的部分 result.push(this.slice(start)); // 返回结果 return result;&#125;module.exports = function (options) &#123; return async (ctx, next) =&gt; &#123; await new Promise((resolve, reject) =&gt; &#123; const dataArr = []; // 存储读取的数据 // 读取数据 ctx.req.on('data', data =&gt; dataArr.push(data)); ctx.req.on('end', () =&gt; &#123; // 取到请求体每段的分割线字符串 let bondery = `--$&#123;ctx.get('content-Type').split('=')[1]&#125;`; // 获取不同系统的换行符 let lineBreak = process.platform === 'win32' ? '\\r\\n' : '\\n'; // 非文件类型数据的最终返回结果 let fields = &#123;&#125;; // 分隔的 buffer 去掉没用的头和尾即开头的 '' 和末尾的 '--' dataArr = dataArr.split(bondery).slice(1, -1); // 循环处理 dataArr 中每一段 Buffer 的内容 dataArr.forEach(lines =&gt; &#123; // 对于普通值，信息由包含键名的行 + 两个换行 + 数据值 + 换行组成 // 对于文件，信息由包含 filename 的行 + 两个换行 + 文件内容 + 换行组成 let [head, tail] = lines.split(`$&#123;lineBreak&#125;$&#123;lineBreak&#125;`); // 判断是否是文件，如果是文件则创建文件并写入，如果是普通值则存入 fields 对象中 if (head.includes('filename')) &#123; // 防止文件内容含有换行而被分割，应重新截取内容并去掉最后的换行 let tail = lines.slice( head.length + 2 * lineBreak.length, -lineBreak.length ); // 创建可写流并指定写入的路径： // 绝对路径 + 指定文件夹 + 随机文件名，最后写入文件 fs.createWriteStream( path.join(__dirname, options.uploadDir, uuid()) ).end(tail); &#125; else &#123; // 是普通值取出键名 let key = head.match(/name='(\\w+)'/)[1]; // 将 key 设置给 fields tail 去掉末尾换行后的内容 fields[key] = tail.toString('utf8').slice(0, -lineBreak.length); &#125; &#125;); // 将处理好的 fields 对象挂在 ctx.request.fields 上，并完成 Promise ctx.request.fields = fields; resolve(); &#125;); &#125;); // 向下执行 await next(); &#125;&#125; 上面的内容逻辑可以通过代码注释来理解，就是模拟 koa-better-body 的功能逻辑，我们主要的关心点在于中间件实现的方式，上面功能实现的异步操作依然是读取数据，为了等待数据处理结束仍然在 Promise 中执行，并使用 await 等待，Promise 执行成功调用 next。 koa-views 中间件模拟Node 模板是我们经常使用的工具用来在服务端帮我们渲染页面，模板的种类繁多，因此出现了 koa-view 中间件，帮我们来兼容这些模板，先安装依赖的模块。 npm install koa koa-views ejs 下面是一个 ejs 的模板文件： 文件：index.ejs123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang='en'&gt;&lt;head&gt; &lt;meta charset='UTF-8'&gt; &lt;title&gt;ejs&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%= name %&gt; &lt;%= age %&gt; &lt;% if (name=='panda') &#123; %&gt; panda &lt;% &#125; else &#123; %&gt; shen &lt;% &#125; %&gt; &lt;% arr.forEach(item =&gt; &#123; %&gt; &lt;li&gt;&lt;%=item%&gt;&lt;/li&gt; &lt;% &#125;) %&gt;&lt;/body&gt;&lt;/html&gt; koa-views 具体用法如下： koa-views 的用法12345678910111213141516const Koa = require('koa');const views = require('koa-views');const path = require('path');const app = new Koa();// 使用中间件app.use(views(path.resolve(__dirname, 'views'), &#123; extension: 'ejs'&#125;));app.use(async (ctx, next) =&gt; &#123; await ctx.render('index', &#123; name: 'panda', age: 20, arr: [1, 2, 3] &#125;);&#125;);app.listen(3000); 可以看出我们使用了 koa-views 中间件后，让 ctx 上多了 render 方法帮助我们实现对模板的渲染和响应页面，就和直接使用 ejs 自带的 render 方法一样，并且从用法可以看出 render 方法是异步执行的，所以需要使用 await 进行等待，接下来我们就来模拟实现一版简单的 koa-views 中间件。 文件：my-koa-views.js1234567891011121314151617181920212223242526272829303132const fs = require('fs');const path = require('path');const &#123; promisify &#125; = require('util');// 将读取文件方法转换成 Promiseconst readFile = promisify(fs.radFile);// 到处中间件module.exports = function (dir, options) &#123; return async (ctx, next) =&gt; &#123; // 动态引入模板依赖模块 const view = require(options.extension); ctx.render = async (filename, data) =&gt; &#123; // 异步读取文件内容 let tmpl = await readFile( path.join(dir, `$&#123;filename&#125;.$&#123;options.extension&#125;`), 'utf8' ); // 将模板渲染并返回页面字符串 let pageStr = view.render(tmpl, data); // 设置响应类型并响应页面 ctx.set('Content-Type', 'text/html;charset=utf8'); ctx.body = pageStr; &#125; // 继续向下执行 await next(); &#125;&#125; 挂在 ctx 上的 render 方法之所以是异步执行的是因为内部读取模板文件是异步执行的，需要等待，所以 render 方法为 async 函数，在中间件内部动态引入了我们使的用模板，如 ejs，并在 ctx.render 内部使用对应的 render 方法获取替换数据后的页面字符串，并以 html 的类型响应。 koa-static 中间件模拟下面是 koa-static 中间件的用法，代码使用的依赖如下，使用前需安装。 npm install koa koa-static mime koa-static 具体用法如下： koa-static 的用法12345678910111213const Koa = require('koa');const static = require('koa-static');const path = require('path');const app = new Koa();app.use(static(path.resolve(__dirname, 'public')));app.use(async (ctx, next) =&gt; &#123; ctx.body = 'hello world';&#125;);app.listen(3000); 通过使用和分析，我们知道了 koa-static 中间件的作用是在服务器接到请求时，帮我们处理静态文件，如果我们直接访问文件名的时候，会查找这个文件并直接响应，如果没有这个文件路径会当作文件夹，并查找文件夹下的 index.html，如果存在则直接响应，如果不存在则交给其他中间件处理。 文件：my-koa-static.js12345678910111213141516171819202122232425262728293031323334353637const fs = require('fs');const path = require('path');const mime = require('mime');const &#123; promisify &#125; = require('util');// 将 stat 和 access 转换成 Promiseconst stat = promisify(fs.stat);const access = promisify(fs.access)module.exports = function (dir) &#123; return async (ctx, next) =&gt; &#123; // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 / let realPath = path.join(dir, ctx.path); try &#123; // 获取 stat 对象 let statObj = await stat(realPath); // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html if (statObj.isFile()) &#123; ctx.set('Content-Type', `$&#123;mime.getType()&#125;;charset=utf8`); ctx.body = fs.createReadStream(realPath); &#125; else &#123; let filename = path.join(realPath, 'index.html'); // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理 await access(filename); // 存在设置文件类型并响应内容 ctx.set('Content-Type', 'text/html;charset=utf8'); ctx.body = fs.createReadStream(filename); &#125; &#125; catch (e) &#123; await next(); &#125; &#125;&#125; 上面的逻辑中需要检测路径是否存在，由于我们导出的函数都是 async 函数，所以我们将 stat 和 access 转化成了 Promise，并用 try...catch 进行捕获，在路径不合法时调用 next 交给其他中间件处理。 koa-router 中间件模拟在 Express 框架中，路由是被内置在了框架内部，而 Koa 中没有内置，是使用 koa-router 中间件来实现的，使用前需要安装。 npm install koa koa-router koa-router 功能非常强大，下面我们只是简单的使用，并且根据使用的功能进行模拟。 koa-router 的简单用法12345678910111213141516171819202122const Koa = require('Koa');const Router = require('koa-router');const app = new Koa();const router = new Router();router.get('/panda', (ctx, next) =&gt; &#123; ctx.body = 'panda';&#125;);router.get('/panda', (ctx, next) =&gt; &#123; ctx.body = 'pandashen';&#125;);router.get('/shen', (ctx, next) =&gt; &#123; ctx.body = 'shen';&#125;)// 调用路由中间件app.use(router.routes());app.listen(3000); 从上面看出 koa-router 导出的是一个类，使用时需要创建一个实例，并且调用实例的 routes 方法将该方法返回的 async 函数进行连接，但是在匹配路由的时候，会根据路由 get 方法中的路径进行匹配，并串行执行内部的回调函数，当所有回调函数执行完毕之后会执行整个 Koa 串行的 next，原理同其他中间件，我下面来针对上面使用的功能简易实现。 文件：my-koa-router.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 控制每一个路由层的类class Layer &#123; constructor(path, cb) &#123; this.path = path; this.cb = cb; &#125; match(path) &#123; // 地址的路由和当前配置路由相等返回 true，否则返回 false return path === this.path; &#125;&#125;// 路由的类class Router &#123; constructor() &#123; // 存放每个路由对象的数组，&#123; path: /xxx, fn: cb &#125; this.layers = []; &#125; get(path, cb) &#123; // 将路由对象存入数组中 this.layers.push(new Layer(path, cb)); &#125; compose(ctx, next, handlers) &#123; // 将匹配的路由函数串联执行 function dispatch(index) &#123; // 如果当前 index 个数大于了存储路由对象的长度，则执行 Koa 的 next 方法 if (index &gt;= handlers.length) return next(); // 否则调用取出的路由对象的回调执行 // 并传入一个函数，在传入的函数中递归 dispatch(index + 1) // 目的是为了执行下一个路由对象上的回调函数 handlers[index].cb(ctx, () =&gt; dispatch(index + 1)); &#125; // 第一次执行路由对象的回调函数 dispatch(0); &#125; routes() &#123; return async (ctx, next) &#123; // 当前 next 是 Koa 自己的 next，即 Koa 其他的中间件 // 筛选出路径相同的路由 let handlers = this.layers.filter(layer =&gt; layer.match(ctx.path)); this.compose(ctx, next, handlers); &#125; &#125;&#125; 在上面我们创建了一个 Router 类，定义了 get 方法，当然还有 post 等，我们只实现 get 意思一下，get 内为逻辑为将调用 get 方法的参数函数和路由字符串共同构建成对象存入了数组 layers，所以我们创建了专门构造路由对象的类 Layer，方便扩展，在路由匹配时我们可以根据 ctx.path 拿到路由字符串，并通过该路由过滤调数组中与路由不匹配的路由对象，调用 compose 方法将过滤后的数组作为参数 handlers 传入，串行执行路由对象上的回调函数。 compose 这个方法的实现思想非常的重要，在 Koa 源码中用于串联中间件，在 React 源码中用于串联 redux 的 promise、thunk 和 logger 等模块，我们的实现是一个简版，并没有兼容异步，主要思想是递归 dispatch 函数，每次取出数组中下一个路由对象的回调函数执行，直到所有匹配的路由的回调函数都执行完，执行 Koa 的下一个中间件 next，注意此处的 next 不同于数组中回调函数的参数 next，数组中路由对象回调函数的 next 代表下一个匹配路由的回调。 总结上面我们分析和模拟了一些中间件，其实我们会理解 Koa 和 Express 相比较的优势是没有那么繁重，开发使用方便，需要的功能都可以用对应的中间件来实现，使用中间件可以给我们带来一些好处，比如能将我们处理好的数据和新方法挂载在 ctx 上，方便后面 use 传入的回调函数中使用，也可以帮我们处理一些公共逻辑，不至于在每一个 use 的回调中都去处理，大大减少了冗余代码，由此看来其实给 Koa 使用中间件的过程就是一个典型的 “装饰器” 模式，在通过上面的分析之后相信大家也了解了 Koa 的 “洋葱模型” 和异步特点，知道该如何开发自己的中间件了。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"async/await","slug":"async-await","permalink":"https://www.pandashen.com/tags/async-await/"},{"name":"Koa","slug":"Koa","permalink":"https://www.pandashen.com/tags/Koa/"},{"name":"中间件","slug":"中间件","permalink":"https://www.pandashen.com/tags/中间件/"}]},{"title":"NodeJS 使用 cookie 和 session","date":"2018-08-17T07:36:35.000Z","path":"2018/08/17/20180817153635/","text":"前言由于浏览器无状态的特性，cookie 技术应运而生，cookie 是一个会话级的存储，大小 4KB 左右，用于浏览器将服务器设置的信息重新带给服务器进行验证，不支持跨域，在浏览器清空缓存或超过有效期后失效，不能存放敏感信息，session 是专门用于存储最初设置给浏览器 cookie 数据的地方，我们本篇就来讨论一下 cookie 和 session 在 NodeJS 中的使用方式。 cookie 的基本使用NodeJS 原生操作 cookie下面是 cookie 在 Node 原生中的读取和写入方法。 原生中操作 cookie1234567891011121314151617181920const http = require('http');// 创建服务http.createServer((req, res) =&gt; &#123; if (req.url === '/read') &#123; // 读取 cookie console.log(req.headers.cookie); res.end(req.headers.cookie); &#125; else if (req.url === '/write') &#123; // 设置 cookie res.setHeader('Set-Cookie', [ 'name=panda; domain=panda.com; path=/write; httpOnly=true', `age=28; Expires=$&#123;new Date(Date.now() + 1000 * 10).toGMTString()&#125;`, `address=$&#123;encodeURIComponent('回龙观')&#125;; max-age=10` ]); res.end('Write ok'); &#125; else &#123; res.end('Not Found'); &#125;&#125;).listen(3000); 上面代码创建了一个 http 服务器，可以通过读取 cookie 请求头的值来获取浏览器发来的 cookie，服务器可以通过给浏览器设置响应头 Set-Cookie 实现对浏览器 cookie 的设置，多个 cookie 参数为数组，在数组内可以规定每一条 cookie 的规则，中间使用一个分号和一个空格隔开。 domain 用来设置允许访问 cookie 的域； path 用来设置允许访问 cookie 的路径； httpOnly 用来设置是否允许浏览器中修改 cookie，如果通过浏览器修改设置过 httpOnly=true 的 cookie，则会增加一条同名 cookie，原来的 cookie 不会被修改； Expires 用来设置过期时间，绝对时间，值为一个 GMT 或 UTC 格式的时间； max-age 同样用来设置过期时间，相对时间，值为一个正整数，单位 s。 cookie 默认不支持存储中文，如果存储中文需先使用 encodeURIComponent 方法进行转译，将转译后的结果存入 cookie，在浏览器获取 cookie 需使用 decodeURIComponent 方法转回中文。 Koa 中操作 cookieKoa 是当下流行的 NodeJS 框架，是对原生 Node 的一个轻量的封装，但是内部实现了快捷操作 cookie 的方法，下面是原生中对 cookie 的操作在 Koa 中的写法。 Koa 中操作 cookie1234567891011121314151617181920212223242526const Koa = require('koa');const Router = require('koa-router');// 创建服务和路由const app = new Koa();const router = new Router();// 签名需要设置 keyapp.keys = ['shen'];router.get('/read', (ctx, next) =&gt; &#123; // 获取 cookie let name = ctx.cookies.get(name) || 'No name'; let name = ctx.cookies.get(age) || 'No age'; ctx.body = `$&#123;name&#125;-$&#123;age&#125;`;&#125;);router.get('/write', (ctx, next) =&gt; &#123; // 设置 cookie ctx.cookies.set('name', 'panda', &#123; domain: 'panda.com' &#125;); ctx.cookies.set('age', 28, &#123; maxAge: 10 * 1000, signed: true &#125;);&#125;);// 使用路由app.use(router.routes());app.listen(3000); 在 Koa 中将获取和设置 cookie 的方法都挂在了 ctx 上下文对象的 cookies 属性上，分别为 get 和 set。 cookies.get 的参数为获取 cookie 的键名，返回值为键对应的值，cookies.set 的第一个参数同样为 cookie 的键名，第二个参数为键对应的值，第三个参数为一个对象，用来配置该条 cookie 的规则，如 domain、path 和过期时间等，这里 maxAge 值为毫秒数。 注意：Koa 中设置的 cookie 默认不允许浏览器端通过 document.cookie 获取，但是服务器也可以被欺骗，比如使用 postman 发送一个带 Cookie 请求头的请求，服务器可以通过设置签名来预防，即添加 signed 选项并将值设置为 true。 Koa 操作 cookie 方法的原理cookies 对象都是挂在 ctx 上来实现的，使用过 Koa 都知道如果要操作 ctx 就会用到中间件的思想，我们这就看看这两个方法使用原生封装的过程。 Koa 中 ctx.cookies 对象 get 和 set 方法的原理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const Koa = require('koa');const querystring = require('querystring');const app = new Koa();app.use(async (ctx, next) =&gt; &#123; // 获取 cookie const get = key =&gt; &#123; const cookies = ctx.get('cookie') || ''; return querystring.parse(result, '; ')[key]; &#125;; // 设置 cookie，存储所有的 cookie，等于 setHeader 中的第二个参数 const cookies = []; const set = (key, val, options = &#123;&#125;) =&gt; &#123; // 用于构造单条 cookie 和权限等设置的数组，默认存放这条 cookie 的键和值 let single = [`$&#123;key&#125;=$&#123;encodeURIComponent(val)&#125;`]; // 下面是配置 if (options.domain) &#123; arr.push(`domain=$&#123;options.domain&#125;`); &#125; if (options.maxAge) &#123; arr.push(`Max-Age=$&#123;options.maxAge&#125;`); &#125; if (options.path) &#123; arr.push(`path=$&#123;options.path&#125;`); &#125; if (options.httpOnly) &#123; arr.push(`HttpOnly=true`); &#125; // 将配置组合到 single 中后转为字符串存入 cookies cookies.push(single.join('; ')); // 设置给浏览器 ctx.set('Set-Cookie', cookies); &#125; // 将获取和设置 cookie 的方法挂在 cookies 对象上 ctx.cookies = &#123; get, set &#125;; await next();&#125;); 在 get 方法内部获取 cookie 请求头的值并根据传入的 key 获取值，set 方法内，将传入的键值和选项拼接成符合 cookie 的字符串，通过 Set-Cookie 响应头设置给浏览器。 session 的基本使用NodeJS 原生使用 session正常 session 是存放在数据库中的，我们这里为了方便就用一个名为 session 的对象来代替。 原生中使用 session123456789101112131415161718192021222324252627282930313233343536const http = require('http');const uuid = require('uuid/v1'); // 生成随字符串const querystring = require('querystring');// 存放 sessionconst session = &#123;&#125;;// 创建服务http.createServer((req, res) =&gt; &#123; if (req.url === '/user') &#123; // 取出 cookie 存储的用户 ID let userId = querystring.parse(req.headers['cookie'], '; ')['study']; if (userId) &#123; if (session[userId].studyCount === 0) res.end('您的学习次数已用完'); session[userId].studyCount--; &#125; else &#123; // 生成 userId userId = uuid(); // 将用户信息存入 session session[userId] = &#123; studyCount: 30 &#125;; // 设置 cookie req.setHeader('Set-Cookie', [`study=$&#123;userId&#125;`]); &#125; // 响应信息 res.end(` 您的用户 ID 为 $&#123;userId&#125;， 剩余学习次数为：$&#123;session[userId].studyCount&#125; `); &#125; else &#123; res.end('Not Found'); &#125;&#125;).listen(3000); 上面写的案例是一个网校的场景，一个新用户默认有 30 次学习机会，以后每次访问服务器学习次数减 1，如果 studyCount 值为 0，则提示学习次数用完，否则提示当前用户的 ID 和剩余学习次数，session 中存储的是每一个用户 ID 对应的剩余学习次数，这样就不会轻易的被修改学习剩余次数，因为服务器只认用户 ID，再通过 ID 去更改对应的剩余次数（当然忽略了别人冒充这个 ID 的情况，只能减，不能加），这样就不会因为篡改 cookie 而篡改用户存在 session 中的数据，除非连整个数据库都拖走。 Koa 中使用 session我们接下来使用 Koa 实现和上面一摸一样的场景，在 Koa 的社区中提供了专门操作 session 的中间件 koa-session，使用前需安装。 Koa 中使用 session12345678910111213141516171819202122232425262728293031323334353637383940414243444546const Koa = require('koa');const Router = require('koa-router');const session = requier('koa-session');const uuid = require('uuid/v1');// 创建服务和路由const app = new Koa();const router = new Router();// cookie 的签名app.keys = ['panda'];// 使用 koa-session 中间件app.use(session(&#123; key: 'shen', maxAge: 10 * 1000&#125;, app));router.get('/user', (ctx, next) =&gt; &#123; // 取出 cookie 存储的用户 ID let userId = ctx.cookie('study'); if (ctx.session.userId) &#123; if (ctx.session[userId].studyCount === 0) res.end('您的学习次数已用完'); ctx.session[userId].studyCount--; &#125; else &#123; // 生成 userId userId = uuid(); // 将用户信息存入 session ctx.session[userId] = &#123; studyCount: 30 &#125;; // 设置 cookie ctx.cookies.set('study', userId); &#125; // 响应信息 ctx.body = ` 您的用户 ID 为 $&#123;userId&#125;， 剩余学习次数为：$&#123;session[userId].studyCount&#125; `;&#125;);// 使用路由app.use(router.routes());app.listen(3000); 使用 Koa 的 koa-session 以后，不再需要我们创建 session 对象进行存储，并且 cookie-session 中间件帮我们封装了 API 可以直接操作 mongo 和 MySQL 数据库，上面代码中与用原生相比还增加了 cookie 和 session 的签名和过期时间，比原生写起来要方便很多。 总结本篇内容更偏向于 cookie 和 session 在 NodeJS 中的使用，没有过多的叙述理论性的内容，cookie 和 session 是相互依存的，也就是说共同使用的，现在已经有 JWT 的方案来替代，因为相比较下有很多优点，但某些项目和特殊场景还在使用 cookie 和 session，所以还是写了这一篇，如果对 JWT 感兴趣可以看 通过一个案例理解 JWT。","tags":[{"name":"cookie/session","slug":"cookie-session","permalink":"https://www.pandashen.com/tags/cookie-session/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"Koa","slug":"Koa","permalink":"https://www.pandashen.com/tags/Koa/"}]},{"title":"通过一个案例理解 JWT","date":"2018-08-16T06:11:46.000Z","path":"2018/08/16/20180816141146/","text":"JWT 简述JWT（json web token）是为了在网络应用环境之间传递声明而基于 json 的开放标准，JWT 的声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便于从资源服务器获取资源。 JWT 的应用场景JWT 一般用于用户登录上，身份认证在这种场景下，一旦用户登录完成，在接下来的每个涉及用户权限的请求中都包含 JWT，可以对用户身份、路由、服务和资源的访问权限进行验证。 举一个例子，假如一个电商网站，在用户登录以后，需要验证用户的地方其实有很多，比如购物车，订单页，个人中心等等，访问这些页面正常的逻辑是先验证用户权限和登录状态，如果验证通过，则进入访问的页面，否则重定向到登录页。 而在 JWT 之前，这样的验证我们大多都是通过 cookie 和 session 去实现的，我们接下来就来对比以下这两种方式的不同。 JWT 对比 cookie/sessioncookie/session 的过程： 由于浏览器的请求是无状态的，cookie 的存在就是为了带给服务器一些状态信息，服务器在接收到请求时会对其进行验证（其实是在登录时，服务器发给浏览器的），如果验证通过则正常返回结果，如果验证不通过则重定向到登录页，而服务器是根据 session 中存储的结果和收到的信息进行对比决定是否验证通过，当然这里只是简述过程。 cookie/session 的问题： 从上面可以看出服务器种植 cookie 后每次请求都会带上 cookie，浪费带宽，而且 cookie 不支持跨域，不方便与其他的系统之间进行跨域访问，而服务器会用 session 来存储这些用户验证的信息，这样浪费了服务器的内存，当多个服务器想要共享 session 需要都拷贝过去。 JWT 的过程： 当用户发送请求，将用户信息带给服务器的时候，服务器不再像过去一样存储在 session 中，而是将浏览器发来的内容通过内部的密钥加上这些信息，使用 sha256 和 RSA 等加密算法生成一个 token 令牌和用户信息一起返回给浏览器，当涉及验证用户的所有请求只需要将这个 token 和用户信息发送给服务器，而服务器将用户信息和自己的密钥通过既定好的算法进行签名，然后将发来的签名和生成的签名比较，严格相等则说明用户信息没被篡改和伪造，验证通过。 JWT 的过程中，服务器不再需要额外的内存存储用户信息，和多个服务器之间只需要共享密钥就可以让多个服务器都有验证能力，同时也解决了 cookie 不能跨域的问题。 JWT 的结构JWT 之所以能被作为一种声明传递的标准是因为它有自己的结构，并不是随便的发个 token 就可以的，JWT 用于生成 token 的结构有三个部分，使用 . 隔开。 HeaderHeader 头部中主要包含两部分，token 类型和加密算法，如 {typ: &#39;jwt&#39;, alg: &#39;HS256&#39;}，HS256 就是指 sha256 算法，会将这个对象转成 base64。 PayloadPayload 负载就是存放有效信息的地方，有效信息被分为标准中注册的声明、公共的声明和私有的声明。 标准中注册的声明下面是标准中注册的声明，建议但不强制使用。 iss：jwt 签发者； sub：jwt 所面向的用户； aud：接收 jwt 的一方； exp：jwt 的过期时间，这个过期时间必须要大于签发时间，这是一个秒数； nbf：定义在什么时间之前，该 jwt 都是不可用的； iat：jwt 的签发时间。 上面的标准中注册的声明中常用的有 exp 和 nbf。 公共声明公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密，如 {&#39;id&#39;, username: &#39;panda&#39;, adress: &#39;Beijing&#39;}，会将这个对象转成 base64。 私有声明私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。 SignatureSignature 这一部分指将 Header 和 Payload 通过密钥 secret 和加盐算法进行加密后生成的签名，secret，密钥保存在服务端，不会发送给任何人，所以 JWT 的传输方式是很安全的。 最后将三部分使用 . 连接成字符串，就是要返回给浏览器的 token 浏览器一般会将这个 token 存储在 localStorge 以备其他需要验证用户的请求使用。 经过上面对 JWT 的叙述可能还是没有完全的理解什么是 JWT，具体怎么操作的，我们接下来实现一个小的案例，为了方便，服务端使用 express 框架，数据库使用 mongo 来存储用户信息，前端使用 Vue 来实现，做一个登录页登录后进入订单页验证 token 的功能。 文件目录jwt-apply |- jwt-client | |- src | | |- views | | | |- Login.vue | | | |- Order.vue | | |- App.vue | | |- axios.js | | |- main.js | | |- router.js | |- .gitignore | |- babel.config | |- package.json |- jwt-server | |- model | | |- user.js | |- app.js | |- config.js | |- jwt-simple.js | |- package.json 服务端的实现在搭建服务端之前需要安装我们使用的依赖，这里我们使用 yarn 来安装，命令如下。 yarn add express body-parse mongoose jwt-simple 配置文件文件位置：&#126;jwt-apply/jwt-server/config.js1234module.exports = &#123; 'db_url': 'mongodb://localhost:27017/jwt', // 操作 mongo 自动生成这个数据库 'secret': 'pandashen' // 密钥&#125;; 上面配置文件中，db_url 存储的是 mango 数据库的地址，操作数据库自动创建，secret 是用来生成 token 的密钥。 创建数据库模型文件位置：&#126;jwt-apply/jwt-server/model/user.js1234567891011121314151617// 操作数据库的逻辑const mongoose = require('mongoose');let &#123; db_url &#125; = require('../config');// 连接数据库，端口默认 27017mongoose.connect(db_url, &#123; useNewUrlParser: true // 去掉警告&#125;);// 创建一个骨架 Schema，数据会按照这个骨架格式存储let UserSchema = new mongoose.Schema(&#123; username: String, password: String&#125;);// 创建一个模型module.exports = mongoose.model('User', UserSchema); 我们将连接数据库、定义数据库字段和值类型以及创建数据模型的代码统一放在了 model 文件夹下的 user.js 当中，将数据模型导出方便在服务器的代码中进行查找操作。 实现基本服务文件位置：&#126;jwt-apply/jwt-server/app.js123456789101112131415161718192021222324252627const express = require('express');const bodyParser = require('body-parser');const jwt = require('jwt-simple');const User = require('./model/user');let &#123; secret &#125; = require('./config');// 创建服务器const app = express();/*** 设置中间件*//*** 注册接口*//*** 登录接口*//*** 验证 token 接口*/// 监听端口号app.listen(3000); 上面是一个基本的服务器，引入了相关的依赖，能保证启动，接下来添加处理 post 请求的中间件和实现 cors 跨域的中间件。 添加中间件文件位置：&#126;jwt-apply/jwt-server/app.js1234567891011121314151617// 设置跨域中间件app.use((req, res, next) =&gt; &#123; // 允许跨域的头 res.setHeader('Access-Control-Allow-Origin', '*'); // 允许浏览器发送的头 res.setHeader('Access-Control-Allow-Headers', 'Content-Type,Authorization'); // 允许哪些请求方法 res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS'); // 如果当前请求是 OPTIONS 直接结束，否则继续执行 req.method === 'OPTIONS' ? res.end() : next();&#125;);// 设置处理 post 请求参数的中间件app.use(bodyParser.json()); 之所以设置处理 post 请求参数中间件是因为注册和登录都需要使用 post 请求，之所以设置跨域中间件是因为我们项目虽小也是前后端分离的，需要用前端的 8080 端口访问服务器的 3000 端口，所以需要服务端使用 cors 处理跨域问题。 注册接口的实现文件位置：&#126;jwt-apply/jwt-server/app.js12345678910111213141516171819202122232425// 注册接口的实现app.post('/reg', async (req, res, next) =&gt; &#123; // 获取 post 请求的数据 let user = req.body; // 错误验证 try &#123; // 存入数据库，添加成功后返回的就是添加后的结果 user = await User.create(user); // 返回注册成功的信息 res.json(&#123; code: 0, data: &#123; user: &#123; id: user._id, username: user.username &#125; &#125; &#125;); &#125; catch (e) &#123; // 返回注册失败的信息 res.json(&#123; code: 1, data: '注册失败' &#125;); &#125;&#125;); 上面将用户注册的信息存入了 mongo 数据库，返回值为存入的数据，如果存入成功，则返回注册成功的信息，否则返回注册失败的信息。 登录接口的实现文件位置：&#126;jwt-apply/jwt-server/app.js1234567891011121314151617181920212223242526// 用户能登录app.post('/login', async (req, res, next) =&gt; &#123; let user = req.body; try &#123; // 查找用户是否存在 user = await User.findOne(user); if (user) &#123; // 生成 token let token = jwt.encode(&#123; id: user._id, username: user.username, exp: Date.now() + 1000 * 10 &#125;, secret); res.json(&#123; code: 0, data: &#123; token &#125; &#125;); &#125; else &#123; res.json(&#123; code: 1, data: '用户不存在' &#125;); &#125; &#125; catch (e) &#123; res.json(&#123; code: 1, data: '登录失败' &#125;); &#125;&#125;); 登录的过程中会先拿用户的账号和密码进数据库中进行严重和查找，如果存在，则登录成功并返回 token，如果不存在则登录失败。 token 校验接口文件位置：&#126;jwt-apply/jwt-server/app.js12345678910111213141516171819202122232425262728// 只针对 token 校验接口的中间件const auth = (req, res, next) =&gt; &#123; // 获取请求头 authorization const authorization = req.headers['authorization']; // 如果存在，则获取 token if (authorization) &#123; const token = authorization.split(' ')[1]; try &#123; // 对 token 进行校验 req.user = jwt.decode(token, secret); next(); &#125; catch (e) &#123; res.status(401).send('Not Allowed'); &#125; &#125; else &#123; res.status(401).send('Not Allowed'); &#125;&#125;// 用户可以校验是否登录过，通过请求头 authorization: Bearer tokenapp.get('/order', auth, (req, res, next) =&gt; &#123; res.json(&#123; code: 0, data: &#123; user: req.user &#125; &#125;);&#125;); 在校验过程中，每次浏览器都会将 token 通过请求头 authorization 带给服务器，请求头的值为 Bearer token，这是 JWT 规定的，服务器取出 token 使用 decode 方法进行解码，并使用 try...catch 进行捕获，如果解码失败则会触发 try...catch，说明 token 过期、被篡改、或被伪造，返回 401 响应。 前端的实现我们使用 3.0 版本的 vue-cli 脚手架生成 Vue 项目，并安装 axios 发送请求。 yarn add global @vue/cli yarn add axios 入口文件文件位置：&#126;jwt-apply/jwt-client/src/main.js1234567891011import Vue from 'vue'import App from './App.vue'import router from './router'// 是否为生产模式Vue.config.productionTip = falsenew Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount('#app'); 上面这个文件是 vue-cli 自动生成的，我们并没有做改动，但是为了方便查看我们会将主要文件的代码一一贴出来。 主组件 App文件位置：&#126;jwt-apply/jwt-client/src/App.vue123456789&lt;template&gt; &lt;div id='app'&gt; &lt;div id='nav'&gt; &lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt; | &lt;router-link to=\"/order\"&gt;订单&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 在主组件中我们将 router-link 分别对应了 /login 和 /order 两个路由。 3、路由配置文件位置：&#126;jwt-apply/jwt-client/src/router.js1234567891011121314151617181920212223import Vue from 'vue'import Router from 'vue-router'import Login from './views/Login.vue'import Order from './views/Order.vue'Vue.use(Router);export default new Router(&#123; mode: 'history', base: process.env.BASE_URL, routes: [ &#123; path: '/login', name: 'login', component: Login &#125;, &#123; path: '/order', name: 'order', component: Order &#125; ]&#125;); 我们定义了两个路由，一个对应登录页，一个对应订单页，并引入了组件 Login 和 Order，前端并没有写注册模块，可以使用 postman 发送注册请求生成一个账户以备后面验证使用。 登录组件 Login文件位置：&#126;jwt-apply/jwt-client/src/views/Login.vue123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=\"login\"&gt; 用户名 &lt;input type=\"text\" v-model=\"user.username\"&gt; 密码 &lt;input type=\"text\" v-model=\"user.password\"&gt; &lt;button @click=\"login\"&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from '../axios'export default &#123; data() &#123; return &#123; user: &#123; username: '', password: '' &#125; &#125; &#125;, methods: &#123; login() &#123; // 发送请求访问服务器的登录接口 axios.post('/login', this.user).then(res =&gt; &#123; // 将返回的 token 存入 localStorage，并跳转订单页 localStorage.setItem('token', res.data.token); this.$router.push('/order'); &#125;).catch(err =&gt; &#123; // 弹出错误 alert(err.data); &#125;); &#125; &#125;&#125;&lt;/script&gt; Login 组件中将两个输入框的值同步到 data 中，用来存放账号和密码，当点击提交按钮时，触发点击事件 login 发送请求，请求成功后将返回的 token 存入 localStorage，并跳转路由到订单页，请求错误时弹出错误信息。 订单组件 Order文件位置：&#126;jwt-apply/jwt-client/src/views/Order.vue1234567891011121314151617181920212223&lt;template&gt; &lt;div class=\"order\"&gt; &#123;&#123;username&#125;&#125; 的订单 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from '../axios'export default &#123; data() &#123; return &#123; username: '' &#125; &#125;, mounted() &#123; axios.get('/order').then(res =&gt;&#123; this.username = res.data.user.username; &#125;).catch(err =&gt; &#123; alert(err); &#125;); &#125;&#125;&lt;/script&gt; Order 页面显示的内容是 “XXX 的订单”，在加载 Order 组件被挂载时发送请求获取用户名，即访问服务器的验证 token 接口，因为订单页就是一个涉及到验证用户的页面，当请求成功时，将用户名同步到 data，否则弹出错误信息。 在 Login 和 Order 两个组件中对请求的回调内似乎写的太简单了，其实是因为 axios 的返回值会在服务器返回的返回值外面包了一层，存放一些 http 响应的相关信息，两个接口访问时请求地址也是同一个服务器，而且在服务器响应时的错误处理都是对状态吗 401 的处理，在涉及验证用户信息的请求中需要设置请求头 Authorization 发送 token。 这些逻辑我们似乎在组件请求相关的代码中都没有看到，是因为我们使用 axios 的 API 设置了 baseURL 请求拦截和响应拦截，细心可以发现其实引入的 axios 并不是直接从 node_modules 引入，而是引入了我们自己的导出的 axios。 axios 配置文件位置：&#126;jwt-apply/jwt-client/src/axios.js1234567891011121314151617181920212223242526272829303132import axios from 'axios';import router from './router';// 设置默认访问地址axios.defaults.baseURL = 'http://localhost:3000';// 响应拦截axios.interceptors.response.use(res =&gt; &#123; // 报错执行 axios then 方法错误的回调，成功返回正确的数据 return res.data.code !== 0 ? Promise.reject(res.data) : res.data;&#125;, res =&gt; &#123; // 如果 token 验证失败则跳回登陆页，并执行 axios then 方法错误的回调 if (res.response.status === 401) &#123; router.history.push('/login'); &#125; return Promise.reject('Not Allowed');&#125;);// 请求拦截，用于将请求统一带上 tokenaxios.interceptors.request.use(config =&gt; &#123; // 在 localStorage 获取 token const token = localStorage.getItem('token'); // 如果存在则设置请求头 if (token) &#123; config.headers.Authorization = `Bearer $&#123;token&#125;`; &#125; return config;&#125;);export default axios; 访问服务器时会将 axios 中的第一个参数拼接在 axios.defaults.baseURL 的后面作为请求地址。 axios.interceptors.response.use 为响应拦截，axios 发送请求后所有的响应都会先执行这个方法内部的逻辑，返回值为数据，作为参数传递给 axios 返回值的 then 方法。 axios.interceptors.request.use 为请求拦截，axios 发送的所有请求都会先执行这个方法的逻辑，然后发送给服务器，一般用来设置请求头。 jwt-simple 模块的实现原理相信通过上面的过程已经非常清楚 JWT 如何生成的，token 的格式是怎样的，如何跟前端交互去验证 token，我们在这些基础上再深入的研究一下 token 的整个生成过程和验证过程，我们使用的 jwt-simple 模块的 encode 方法如何生成 token，使用 decode 方法如何验证 token，下面就看看一看 jwt-simple 的实现原理。 创建模块文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js1234567891011const crypto = require('crypto');/*** 其他方法*/// 创建对象module.exports = &#123; encode, decode&#125;; 我们知道 jwt-simple 我们使用的有两个方法 encode 和 decode，所以最后导出的对象上有这两个方法，使用加盐算法进行签名需要使用 crypto，所以我们提前引入。 字符串和 Base64 互相转换文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js123456789// 将子子符串转换成 Base64function stringToBase64(str) &#123; return Buffer.from(str).toString('base64');&#125;// 将 Base64 转换成字符串function base64ToString(base64) &#123; return Buffer.from(base64, 'base64').toString('utf8');&#125; 从方法的名字相信很容易看出用途和参数，所以就一起放在这了，其实本质是在两种编码之间进行转换，所以转换之前都应该先转换成 Buffer。 生成签名的方法文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js1234function createSign(str, secret) &#123; // 使用加盐算法进行加密 return crypto.createHmac('sha256', secret).update(str).digest('base64');&#125; 这一步就是通过加盐算法使用 sha256 和密钥 secret 进行生成签名，但是为了方便我们把使用的加密算法给写死了，正常情况下是应该根据 Header 中 alg 字段的值去检索 alg 的值与加密算法名称对应的 map，去使用设置的算法生成签名。 encode文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js12345678910111213141516function encode(payload, secret) &#123; // 头部 const = stringToBase64(JSON.stringify(&#123; typ: 'JWT', alg: 'HS256' &#125;)); // 负载 const content = stringToBase64(JSON.stringify(payload)); // 签名 const sign = createSign([header, content].join('.'), secret); // 生成签名 return [header, content, sign].join('.');&#125; 在 encode 中将 Header、Payload 转换成 base64，通过 . 连接在一起，然后使用 secret 密钥生成签名，最后将 Header 和 Payload 的 base64 通过 . 和生成的签名连接在一起，这就形成了 “明文” + “明文” + “暗文” 三段格式的 token。 decode文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js123456789101112131415161718function decode(token, secret) &#123; let [header, content, sign] = token.split('.'); // 将接收到的 token 的前两部分（base64）重新签名并验证，验证不通过抛出错误 if (sign !== createSign([header, content].join('.'), secret)) &#123; throw new Error('Not Allow'); &#125; // 将 content 转成对象 content = JSON.parse(base64ToString(content)); // 检测过期时间，如果过去抛出错误 if (content.exp &amp;&amp; content.exp &lt; Date.now()) &#123; throw new Error('Not Allow'); &#125; return content;&#125; 在验证方法 decode 中，首先将 token 的三段分别取出，并用前两段重新生成签名，并与第三段 sign 对比，相同通过验证，不同说明篡改过并抛出错误，将 Payload 的内容重新转换成对象，也就是将 content 转换成对象，取出 exp 字段与当前时间对比来验证是否过期，如果过期抛出错误。 总结在 JWT 生成的 token 中，前两段明文可解，这样别人拦截后知道了我们的加密算法和规则，也知道我们传输的信息，也可以使用 jwt-simple 加密一段暗文拼接成 token 的格式给服务器去验证，为什么 JWT 还这么安全呢，这就说到了最最重点的地方，无论别人知道多少我们在传输的信息，篡改和伪造后都不能通过服务器的验证，是因为无法获取服务器的密钥 secret，真正能保证安全的就是 secret，同时证明了 Header 和 Payload 并不安全，可以被破解，所以不能存放敏感信息。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"cookie/session","slug":"cookie-session","permalink":"https://www.pandashen.com/tags/cookie-session/"},{"name":"Vue","slug":"Vue","permalink":"https://www.pandashen.com/tags/Vue/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"JWT","slug":"JWT","permalink":"https://www.pandashen.com/tags/JWT/"}]},{"title":"MySQL —— 简单聊一聊数据库设计","date":"2018-08-14T05:12:41.000Z","path":"2018/08/14/20180814131241/","text":"前言这是关于 MySQL 系列文章的第三篇，在前两篇文章 《MySQL —— 数据库基础》 和 《MySQL —— SQL 语句总结》 中，主要介绍了一些数据库的基础概念、创建表的方式以及 SQL 语句的使用，本篇在使用的基础上做一个小小的升华，来简单聊一聊数据库的设计，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。 为什么设计数据库说到为什么要设计数据库，就要说到数据的完整性，我们要在设计数据库时保证域的完整性和实体的完整性，同时从性能出发，我们要保证最大限度的节省存储空间，比如一张成绩表，上面没必要存储学生的姓名、年龄等信息，只需要存储成绩，如果一个数据库设计的合理，最后的结果就是方便我们对数据库的开发和扩展。 如果是一个 “糟糕” 的数据库设计会造成一系列的不良反应，比如数据冗余，存储空间浪费，内存浪费，有时甚至会造成数据插入和更新的异常，比如学生表存了学生信息，而成绩表也存了，这样在修改时没有全部修改就会出现错误。 软件项目开发中数据库设计的生命周期软件项目开发中数据库设计的生命周期可大概分为以下几个阶段： 需求分析阶段，分析客户的业务和数据处理需求； 概要设计阶段，设计数据库 E-R 模型图，确认需求的正确和完整性； 详细设计阶段，应用三大范式审核数据库； 代码编写阶段，物理实现数据库，编码实现应用； 软件测试阶段； 安装部署阶段。 上面数据库的设计经历了从 “现实世界” 到 “信息世界” 到 “数据库模型” 再到 “数据库” 产生的一个完整过程。 设计数据库的步骤收集信息：收集信息其实就是与相关人员进行交流、访谈、调研，充分了解用户需求，理解整个项目的完整流程，并理解数据库需要完成的任务，这部分工作大部分由需求人员完成，并根技术人员进行对接。 标识实体和实体属性：开发人员在明确需求和流程之后，标识数据库的实体，比如学生信息表，每一条实体中应该由哪些字段组成，成绩表中实体由哪些字段组成等等。 标识实体之间的关系：其实就是通过表之间的某字段对表进行关联，对表的实体之间建立对应关系，如学生表的 id 字段会关联成绩表的 student_id 字段，用来查找某个学生的成绩。 数据库 E-R 图E-R 图基本概念E-R 图也叫做实体关系图，是指用实体、关系、属性三个基本概念概括数据的基本结构，从而描述静态数据的概念模型。 E-R 图的实体：即数据模型中的数据对象，每一张表就是一个 E-R 图的实体。 E-R 图的属性：即数据对象中所具有的属性，例如学生表的学生、姓名、年龄等，属性又分为唯一属性和非唯一属性，唯一属性如经过唯一约束和主键约束的属性，不可重复，其他的都是非唯一属性。 E-R 图的关系：用来表示每一个数据对象与数据对象之间的联系，即每一个实体之间的联系，例如学生表和成绩表之间的联系，因为每个学生都有自己的成绩。 E-R 图的关联关系1 对 1 （1 : 1）1 对 1 关系是指对于实体集 A 和 实体集 B，A 中的每一个实体最多与 B 中的一个实体有关系，反之在实体集 B 中的每一个实体之多与实体集 A 中的一个实体有关系。 1 对 1 关系图 1 对多（1 : N）1 对多关系是指实体集 A 与实体集 B 中至少有 N (N &gt; 0) 个实体有关系，并且实体集 B 中最多与实体集 A 中的一个实体有关系。 1 对多关系图 多对多（M : N）多对多关系是指实体集 A 中的每一个实体与实体集 B 中至少有 M (M &gt; 0) 个实体有关系，并且实体集 B 中的每一个实体与实体集 A 中至少有 N (N &gt; 0) 个实体有关系。 多对多关系图 数据库设计的三大范式确保每列的原子性如果每列都是不可再分的最小单元信息，则满足第一范式，比如下图中，地址是由国家和城市组成的，显然可以继续在拆分成两个列，国家和城市，是不满足第一范式的，需要将地址列差分成国家和城市两个列。 原子性事例 举一个简单的例子，我们平时在淘宝购物的时候需要添加地址，在填写新地址时，都是让我们选择国家、省、城市、区、街道、小区这样的方式，而不是让我们自己将这些地址写在一起，其原因就是因为淘宝的数据库设计严格遵循每列的原子性，这样的提交可以方便后端获取每一个列的信息在数据库中进行存储。 每个表只能描述一件事情如下图中所示，在左侧的表中，描述了学生信息和课程信息，这明显是两件事情，假设再有一张成绩表，也要描述学生信息，课程信息和成绩等多件事情，就会造成数据的重复、冗余，也可能会导致更新、插入、删除数据异常的现象。 每个表描述一件 所以正确的做法是应该将左侧表差分成两张表分别为学生表和课程表，并使用学生编号与课程编号进行关联。 其他列都不传递依赖于主键列其他列都不传递依赖于主键列的意思是表中各列必须都与主键直接相关，不能间接相关，从下图左表可以看出，学生编号为主键，年级 ID 也应该为主键，正常应该通过学生编号找到年级 ID，再找到年级名称，这样年级名称与学生编号之间就形成了一个传递并且依赖于主键年级 ID，即年级 ID 做为主键在中间隔了一层，这样就使年级名称与主键学生编号间接相关，如果在同一张表中，所有的字段都是应该直接依赖于主键，而不是再通过其他的主键传递。 其他列都不传递依赖于主键列 如果一个表中表述了多件事情并有多个作为主键的列，与上一条的处理方式相同，应该拆成多张表，并且每张表只有一个主键列。 RBAC 基于角色的访问控制RBAC 的含义RBAC（Role-Based Access Control）基于角色的访问控制，就是用户通过角色与权限进行关联，简单的说，一个用户拥若干个角色，每个角色拥有若干个权限，这样就构造成了 “用户 → 角色 → 权限 → 资源” 的授权模型，在这个模型中，用户与角色之间，角色与权限之间，权限与资源之间，一般都是多对多的关系，在 RBAC 中最重要的概念主要有四部分，就是用户（User）、角色（Role）、权限（Permission）和资源（Resource）。 RBAC 的安全原则 最小权限原则：最小权限原则之所以被 RBAC 所支持，是因为 RBAC 可以将其角色配置成完成任务所需要的最小的权限集； 责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一个帐目； 数据抽象原则：数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限。 RBAC 的 E-R 图之前说 RBAC 最重要的概念由四部分，其实体现在数据库的表中有主要三部分，因为角色和用户是重叠的，那么主要有三张表分别为用户表、权限表和资源表，其中用户表与权限表之间有一张关联表，权限表与资源表之间有一张关联表，E-R 图如下。 RBAC 的 E-R 图 事务为什么需要事务？在生活中我们经常使用银行转账或者支付宝和微信支付，这种操作每一次至少影响两个用户的数据信息，比如一方给另一方转钱，如果成功则转钱方余额减去转出金额，而收钱方余额增加收到的金额，这应该是一个请求操作了数据表中的俩个实体，如果在两个操作数据的环节任意一个失败了，都会影响两个人数据的正确性，这种时候需要两个操作同时失败或同时成功，就是说有一个操作出现失败的情况，即使另一个成功了也需要进行回滚操作，这就是事务的由来。 什么是事务事务是作为单个逻辑工作单元执行的一系列操作，多个操作作为一个整体向系统提交，要么都执行，要么都不执行，是一个不可分割的工作逻辑单元。 转账过程就是一个整体，它需要两条 UPDATE 语句，如果任何一个出错，则整个转账业务取消，两个账户的余额都恢复到原来的数据（回滚），确保总余额不变。 这里再举一个例子，有一个上传文件的功能，后端接收到文件流时是需要先写入的，当写入成功后，会将上传成功的结果返回给客户端，如果文件很大，写入的时间就会长，如果在此期间突然写入失败，则会删除之前写入的内容，将整个操作回滚到写入之前，这里面主要两步操作，创建一个新文件并写入，写入成功删除旧文件，如果写入失败，两个操作将会同时失败，即不会删除旧文件，这也是一个事务的例子，只是没有转账那么明显。 事务的特性 ACID事务具有以下特性，被简称为 ACID： 原子性（Atomicity）：事务是一个完整的操作，事务各个部分是不可分的，要么都执行，要么都不执行； 一致性（Consistency）：当事务完成后，数据必须处理完整的状态； 隔离性（Isolation）：并发事务彼此隔离、独立，它不应该以任何方式依赖于其它事务； 持久性（Durability）：事务完成后，它对数据库的修改被永久保持。 如何创建事务创建表创建表 account，id 列为主键列，name 列为姓名，balance 为余额。 123456CREATE TABLE `account` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(64) NOT NULL, `balance` INT(11) DEFAULT 0 PRIMARY KEY (`id`)); 添加数据将表 account 添加两条数据，分别为 “张三” 和 “李四”，余额都为 100。 12INSERT INTO `student` (`name`, `balance`) VALUES (\"张三\", 100);INSERT INTO `student` (`name`, `balance`) VALUES (\"李四\", 100); 使用 NodeJS 实现事务一个非常简单的事务123456789101112131415161718192021222324252627282930313233const mysql = require('mysql');// 创建数据库连接const connection = mysql.createConnection(&#123; host: 'localhost', // 主机名 port: '3306', // 数据库服务端口号 username: 'root', // 数据库名称 pwd: '123456', // 数据库密码 database: 'school' // 连接的数据库名称&#125;);connection.connect();// 开启事务connection.beginTransaction(err =&gt; &#123; // 回调参数为错误对象，返回结果，返回字段描述 connection.query( 'UPDATE account SET balance - 50 WHERE id = 1', (err, result, fields) =&gt; &#123; if (err) &#123; connection.rollback(); // 如果失败直接回归 &#125; else &#123; connection.query( 'UPDATE account SET balance - 50 WHERE id = 1', (err, result, fields) =&gt; &#123; // 如果失败直接回归，如果两个都成功了则提交事务 err ? connection.rollback() : connection.commit(); &#125; ); &#125; &#125; );&#125;); 总结到此关于 MySQL 的系列文章就告一段落了，希望前端的同学们在看了这几篇文章后对你们入门 MySQL 有一些帮助，那这几篇的文章就达到目的了，也欢迎后端的小伙伴来指出文章中的错误和不足。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.pandashen.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://www.pandashen.com/tags/数据库/"}]},{"title":"MySQL —— SQL 语句总结","date":"2018-08-09T03:52:45.000Z","path":"2018/08/09/20180809115245/","text":"前言这是关于 MySQL 系列文章的第二篇，在上一篇 《MySQL —— 数据库基础》 中，主要介绍了一些数据库的基础概念、创建表的方式以及使用 DDL 数据定义语言对表的操作，本篇的主要内容是在开发中使用 SQL 语句对数据库的增、删、改、查，函数、聚合函数的应用以及表连接，本篇大部分内容都贴近开发中的实际操作，不会像上一篇那么枯燥，也可当作一个小小的查询文档，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。 准备数据还记得在上一篇的最后我们使用 DDL 创建了完整的表关系，student、score 和 course 三张表如下图。 完整表关系图 其中 score 是外键表，创建外键约束关联了两张主键表 scudent 和 cource，接下来的 SQL 语句都是基于这几张表来进行的。 SQL 的组成DDLDDL（data definition language）是数据定义语言，主要命令有 CREATE、ALTER、DROP 等，DDL 主要用在定义或改变数据表（TABLE）的结构、数据类型、表之间的链接和约束等初始化工作上，大多数在建立表时使用，在上一篇中 DDL 操作表的部分着重做了介绍并创建数据表，也可以将存储 DDL 语句的文件存储在 .sql 后缀名结尾的文件当中，在 DBMS 数据管理系统中导入，直接创建数据库。 DMLDML（data manipulation language）是数据操做语言，通过 DML 语句对数据库数据表中的实体进行增、删、改、查，数据量非常大时，我们不可能使用 DBMS 一条一条的操作数据，所以都是通过代码完成操作，DML 是在学习 MySQL 数据库中最最重要的内容，也是本篇的重点，后面会非常详细的说明。 DCLDCL（data control language）是数据库控制语言，用来设置或更改数据库用户或角色权限的语句，包括 grant、revoke 等，grant 是授权命令，revoke 是收回权限命令。 SQL 运算符SQL 元算符分为算术运算符、逻辑运算符和比较运算符，是用来完成列之间或者变量之间的比较和运算的。 算术运算符运算符说明+加运算，求两个数或表达式相加的和，如 1 + 1-减运算，求两个数或表达式相减的差，如 4 - 1*乘运算，求两个数或表达式相乘的积，如 2 * 2\\除运算，求两个数或表达式相除的商，如 6 / 4%取模运算，求两个数或表达式相除的余数，如 6 % 4 逻辑运算符运算符说明AND当且仅当两个布尔表达式都为 true 时，返回 trueOR当且仅当两个布尔表达式都为 false 时，返回 falseNOT布尔表达式的值取反 比较运算符运算符说明=等于>大于&lt;小于&gt;=大于等于&lt;=小于等于&lt;&gt;不等于!=不等于&lt;=&gt;安全不等于 SQL 语句之数据增、删、改插入数据行语法： 1INSERT [INTO] 表名 [(列名)] VALUES (值列表) 给上面的 student 表插入一条数据，姓名为张三，卡号为 100，年龄为 20，城市默认为北京。 12INSERT INTO `student` (`name`, `idcard`, `age`, `city`)VALUES (\"张三\", \"100\", 20, NULL); 注意事项： 每次插入一行数据，不能只插入一部分数据，即不能只插入了一个实体的某几列，插入的数据是否有效将严格按照实体的完整性要求来检验； 每个数据值的数据类型、精度、位数必须要与对应的列名精确匹配，严格按照域的完整性要求来检验； 不能为标识符指定值（规定），例如作为主键自增的标识列； 如果某字段设置非空约束，则该列必须插入不为 null 的数据； 插入数据时还要符合检查性约束的要求，如非空约束、唯一约束等； 设置了默认值的列，有缺省值时，可以使用 DEFAULT 关键字来代替插入的实际值。 更新数据行语法： 1UPDATE 表名 SET 列名 = 更新值 [WHERE &lt;更新条件&gt;] 将 student 表中 id 为 1 的实体的 idcard 列值改为 200，age 列值改为 24。 123UPDATE `student`SET `idcard` = \"200\", `age` = 24WHERE `id` = 1 AND `name` = \"张三\"; 将 student 表中 city 列为空的实体 city 列的值设置为 “上海”。 123UPDATE `student`SET `city` = \"上海\"WHERE `city` IS NULL; 注意事项： 更新多列时，列赋值语句之间使用逗号分隔，一定要加更新条件，否则会更新所有的行； 多个联合条件根据逻辑关系使用 AND 或 OR 连接。 删除数据行语法： 1DELETE [FROM] 表名 [WHERE &lt;删除条件&gt;] 删除 student 表中 age 列值为 24 或者 idcard 列值为 200 的实体。 12DELETE FROM `student`WHERE `age` = 24 OR `idcard` = 200; 注意事项： 删除的是一整行的数据，所以不需要提供列名； 如果要删除主表数据，则要先删除外键连接对应的子表数据。 SQL 语句之数据查询在 SQL 语句的增、删、改、查中，最繁琐和复杂的就是查询语句，在实际开发中七分查询三分增、删、改的说法一点也不为过，查询语句是在业务中使用最多的语句，所以我们将查询语句与增、删、改分离出来，用这单独的一节来叙述。 查询简介查询就是从客户端发出查询，请求数据库服务器，并从数据库返回查询结果的过程，每次执行查询只是从数据表中提取数据，并按照表的方式呈现出来，查询产生的虚拟表并不会保存。 查询语法12345SELECT &lt;列名&gt;FROM &lt;表名&gt;[WHERE &lt;查询条件表达式&gt;][ORDER BY &lt;排序的列名&gt; [ASC 或 DESC]]LIMIT &lt;起始索引&gt;, &lt;查询条数&gt;; 我们继续操作之前的三张表，查询 “北京” 的学生并按 id 的正序排序。 1234SELECT *FROM `student`WHERE `city` = \"北京\"ORDER BY `id` ASC; 上面 SQL 语句中的 * 代表查询表中所有的列，如果查找某些列，列名之间用 , 分隔。 别名在查询数据表的某个列的时候可以通过别名改变查询到虚拟表列的名称，在列的后面使用 AS 关键字加上别名，AS 可以省略。 1234SELECT `name`, `age`, `city` AS `城市`FROM `student`WHERE `city` = \"北京\"ORDER BY `id` DESC; 查询空行假设表中的某一列值为 null，我们可以通过 IS 关键字查询这一列值为空的数据。 1234SELECT `name`, `age`, `city`FROM `student`WHERE `city` IS NULLORDER BY `id` DESC; 常量列查询一个数据表中没有的列，我们可以在查询时将这一列增加为常量列，如 city 的值都是中国的，我们可以增加一个常量列值都为 “中国”，列名为 country。 12SELECT `name`, `age`, `city`, \"中国\" AS `country`FROM `student`; 查询列的不重复数据假设查询 student 表中同学们来自那些城市，正常按照 city 列查询，有多个条数据的 city 列都来自同一个城市，我们可以使用 DISTINCT 关键字，只保留一个。 12SELECT DISTINCT `city`FROM `student`; 限制查询条数LIMIT 关键字用来限制查询返回的条数，后面的值为数字，下面查询 student 表，只返回 3 条数据。 123SELECT *FROM `student`LIMIT 3; 当 LIMIT 参数大于一个时，第一个参数代表起始的索引（跳过的条数），第二个参数代表返回的条数，中间用 , 隔开，还是查询 student 表，返回第 4 到 6 条数据。 123SELECT *FROM `student`LIMIT 3, 3; 运算符在查询中的使用1234SELECT 1 + 1; -- 2SELECT 1 + \"1\"; -- 2SELECT 1 + \"panda\"; -- 1SELECT 1 + NULL; -- NULL 通过上面的例子可以看出在 SQL 语句中，使用算术运算符相加无法起到字符串拼接的作用，会将值转化为数字进行计算，字符串转为数字 0，数字与 null 相加结果为 null，没意义。 查询语句练习案例首先我们将上面的三张表 student，cource 和 score 三张表插入数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- 给 student 表插入数据INSERT INTO `student`VALUES ( \"1\", \"郭靖\", \"1\", \"40\", \"济南\", \"山东省\", \"1978-09-03\", 1, \"1@qq.com\" );INSERT INTO `student`VALUES ( \"2\", \"黄蓉\", \"2\", \"36\", \"济南\", \"山东省\", \"1982-09-03\", 0, \"2@qq.com\");INSERT INTO `student`VALUES ( \"3\", \"杨过\", \"3\", \"22\", \"终南山\", \"陕西省\", \"1996-09-03\", 1, \"3@qq.com\");INSERT INTO `student`VALUES ( \"4\", \"小龙女\", \"4\", \"28\", \"终南山\", \"陕西省\", \"1990-09-03\", 0, \"4@qq.com\");INSERT INTO `student`VALUES ( \"5\", \"欧阳锋\", \"5\", \"70\", \"白驼山\", \"新疆\", \"1948-09-03\", 1, \"5@qq.com\");-- 给 cource 表插入数据INSERT INTO `course` VALUES (\"1\", \"语文\");INSERT INTO `course` VALUES (\"2\", \"数学\");INSERT INTO `course` VALUES (\"3\", \"英语\");-- 给 score 表插入数据INSERT INTO `score` VALUES (\"1\", \"1\", \"100\");INSERT INTO `score` VALUES (\"1\", \"2\", \"90\");INSERT INTO `score` VALUES (\"1\", \"3\", \"70\");INSERT INTO `score` VALUES (\"2\", \"1\", \"100\");INSERT INTO `score` VALUES (\"2\", \"2\", \"40\");INSERT INTO `score` VALUES (\"2\", \"3\", \"80\");INSERT INTO `score` VALUES (\"3\", \"1\", \"100\");INSERT INTO `score` VALUES (\"3\", \"2\", \"60\");INSERT INTO `score` VALUES (\"3\", \"3\", \"80\"); 添加数据后的三张表如下图： 表的具体数据 查询山东省学生的全部信息： 123SELECT *FROM `student`WHERE `province` = \"山东\"; 查询山东省男学生的全部信息： 123SELECT *FROM `student`WHERE `province` = \"山东\" AND `gender` = 1; 查询没填写电子邮箱学生的姓名和身份证号： 123SELECT `name`, `idcard`FROM `student`WHERE `email` IS NULL; 把学生的成绩按升序排列： 123SELECT *FROM `score`ORDER BY `grade` ASC; 课程编号升序排列，成绩降序排列： 123SELECT *FROM `score`ORDER BY `course_id` ASC, `grade` DESC; SQL 语句之模糊查询在上一节中我们所使用的查询叫 “完整查询” 或 “精准查询”，而本节的 “模糊查询” 是指查询条件不明确，可以尽量多的匹配满足查询条件的数据。 通配符“通配符” 用于代替一个或多个真正的字符，与 LIKE 关键字一起使用，通配符的解释、示例如下表。 通配符解释示例符合条件的值_一个任意字符LIKE “a_”as、ad 等%任意长度的字符串LIKE “c%”code、cat 等[ ]括号中所指定范围内的一个字符LIKE “1[35]5”135 或 155[^]不再括号中所指定范围内的一个字符LIKE “1[^1-2]5”135 或 155 等 查询 student 表中 email 列是 qq 邮箱的学生信息。 123SELECT *FROM `student`WHERE `emai` LIKE `%qq%`; 查询 student 表中姓杨的名字为两个字的所有学生信息。 12SELECT * FROM `student`WHERE `name` LIKE \"杨_\"; BETWEEN…AND…BETWEEN...AND... 用于查询某一列在指定范围内的记录，包括两个边界。 查询 score 表中成绩在 80 到 90 范围内的所有学生信息。 123456789-- 精准查询SELECT *FROM `score`WHERE `grade` &gt;= 80 AND `grade` &lt;= 90;-- 模糊查询SELECT *FROM `score`WHERE `grade` BETWEEN 80 AND 90; IN查询某一列中的值在列出的内容列表中。 查询 student 表中 city 列为 “北京” 或 “上海” 或 “杭州” 所有学生的信息。 123456789-- 精准查询SELECT *FROM `student`WHERE `city` = \"北京\" OR `city` = \"上海\" OR `city` = \"杭州\";-- 模糊查询SELECT *FROM `student`WHERE `city` IN (\"北京\", \"上海\", \"杭州\"); 截断表作为主键的标识列，值是会随着数据的增加，自动递增的，且具有 “断号保留” 的特性，随着表中数据的增删，标识列的值会非常混乱，我们可以通过截断表来解决该问题，截断表有两个作用如下。 使表中数据的标识列的值重新从 1 开始计数； 清空表中数据； 使用截断表时，表的列和约束不会改动，使用的前提是表与表之间不能存在外键约束，表之间如果通过外键进行关联，无法清空主表中数据，即无法截断表。 语法： 1TRUNCATE TABLE 表名 截断 student 表： 1TRUNCATE TABLE `student`; 截断表操作轻易不要使用，因为普通的 SQL 操作会记录日志，并且可以还原，而 TRUNCATE 操作不会记录日志，并且不可还原，万一删错，彻底完蛋。 函数在 MySQL 中有很多内置的函数帮我们实现一些功能，函数大类可分为普通函数和聚合函数，我们本节主要介绍普通函数，常用的普通函数大概可分为字符函数、数字函数、日期函数和流程控制函数等，还有一些与数据库相关的辅助函数以及自定义函数，都会在本节一一介绍。 字符函数LENGTHLENGTH 函数的作用是返回输入字符串的长度。 12SELECT LENGTH(\"panda\"); -- 5SELECT LENGTH(\"你好啊\"); -- 9 CONCAT 和 CONCAT_WSCONCAT 函数用于将多个字符串拼接成一个字符串，CONCAT_WS 函数用于使用分隔符将多个字符串拼接成一个字符串，第一个参数为分隔符。 12SELECT CONCAT(\"Panda\", \"Shen\"); -- PandaShenSELECT CONCAT_WS(\"-\", \"Hello\", \"Panda\", \"Shen\"); -- Hello-Panda-Shen UPPER 和 LOWERUPPER 函数用于将字符串转换为大写，LOWER 函数用于将字符串转换为小写。 12SELECT UPPER(\"panda\"); -- PANDASELECT LOWER(\"PANDA\"); -- panda SUBSTRSUBSTR 函数用于截取字符串，第一个参数为源字符串，第二个参数为起始的索引（从 1 开始），第三个参数为截取的长度，不传默认截取后面全部字符串。 12SELECT SUBSTR(\"panda\", 3); -- ndaSELECT SUBSTR(\"panda\", 3, 2); -- nd LEFT 和 RIGHTLEFT 函数和 RIGHT 函数分别代表在字符串取左边或右边的规定位数，第一个参数为源字符串，第二个参数为规定的位数。 12SELECT LEFT(\"panda12345\", 5); -- pandaSELECT RIGHT(\"panda12345\", 5); -- 12345 INSTRINSTR 函数用于查找某个字符串在一个源字符串中的起始（第一个匹配到的）索引，第一个参数为源字符串，第二个参数为查询字符串，查询不到返回 0。 12SELECT INSTR(\"panda\", \"a\"); -- 2SELECT INSTR(\"panda\", \"x\"); -- 0 LTRIM、RTRIM 和 TRIMLTRIM 函数用于去掉字符串左侧空格，RTRIM 用于去掉字符串右侧空格，TRIM 用于去掉字符串两侧的空格，如果 TRIM 的参数将两个字符串使用 FROM 连接，则代表去掉右侧字符串左右两侧的左侧字符串（说的有点绕，看例子）。 1234SELECT LTRIM(\" panda\"); -- pandaSELECT RTRIM(\"panda \"); -- pandaSELECT TRIM(\" panda \"); -- pandaSELECT TRIM(\"@\" FROM \"@@panda@@\"); -- panda LPAD 和 RPADLPAD 函数和 RPAD 函数分别用于向源字符串的左、右按照规定字符串的长度填充定义的字符。 12SELECT LPAD(\"panda\", 10, \"@\"); -- @@@@@pandaSELECT RPAD(\"panda\", 10, \"@\"); -- panda@@@@@ REPLACEREPLACE 函数用于替换某字符串的部分字符，第一个参数为源字符串，第二个参数为被替换字符，第三个参数为替换字符。 1SELECT REPLACE(\"panda\", \"a\", \"e\"); -- pende 综合练习查询 id 为 3 学生的邮箱域名。 12345SELECT SUBSTR(`email`, INSTR(`email`, \"@\") + 1)FROM `student`WHERE `id` = 3;-- qq.com 将 student 表中的邮箱地址全部由小写改成大写。 12UPDATE `student`SET `email` = UPPER(`email`); 给 student 表新增一列 level，类型为 varchar，值为 1-1、1-2、1-3、2-1、2-2 等，按照 level 列值中 - 的前半段正序排列，后半段逆序排列。 1234567SELECT `level`,SUBSTR(`level`, 1, INSTR(`level`, \"-\") - 1),SUBSTR(`level`, INSTR(`level`, \"-\") + 1)FROM `student`ORDER BYSUBSTR(`level`, 1, INSTR(`level`, \"-\") - 1) ASC,SUBSTR(`level`, INSTR(`level`, \"-\") + 1) DESC; 将 pandashen 转换成 Panda_Shen，将两个单词拆开，并实现首字母大写，其他字符小写，然后用 _ 拼接。 1234567891011121314SELECTCONCAT( CONCAT( UPPER(SUBSTR(SUBSTR(\"pandashen\", 1, 5), 1, 1)), SUBSTR(SUBSTR(\"pandashen\", 1, 5), 2) ), \"_\", CONCAT( UPPER(SUBSTR(SUBSTR(\"pandashen\", 6), 1, 1)), SUBSTR(SUBSTR(\"pandashen\", 6), 2) ));-- Panda_Shen 数学函数FORMATFORMAT 函数用于将数字格式化，第一个参数为要格式化的数字，第二个参数为保留的小数位数，返回值为字符串，整数部分每三位使用 , 分隔。 1234SELECT FORMAT(100000, 2); -- 100,000.00SELECT FORMAT(100.31111, 3); -- 100.311SELECT FORMAT(100.31111, 0); -- 100SELECT FORMAT(423423234.65534453, 2); -- 423,423,234.66 CEIL 和 FLOORCEIL 函数为向上取整，FLOOR 函数为向下取整。 12SELECT CEIL(2.4); -- 3SELECT FLOOR(2.4); -- 2 ROUND 和 TRUNCATEROUND 函数为四舍五入，TRUNCATE 函数为小数截断，第一个参数为截断的数字，第二个参数为保留的小数位数。 123456SELECT ROUND(2.1); -- 2SELECT ROUND(2.5); -- 3SELECT TRUNCATE(1.66, 0); -- 1SELECT TRUNCATE(1.66, 1); -- 1.6SELECT TRUNCATE(1.66, 2); -- 1.66SELECT TRUNCATE(1.66, 3); -- 1.66 POWERPOWER 函数用于幂运算，第一个参数为底数，第二个参数为指数。 1SELECT POWER(2, 3); -- 8 MODMOD 函数用于取余运算，第一个参数为被除数，第二个参数为除数。 1SElECT MOD(10, 3); -- 1 日期函数NOW、CURDATE 和 CURTIMENOW 函数用于获取当前的时间，格式为 yyyy-mm-dd hh:mm:ss，CURDATE 函数用于获取当前日期，格式为 yyyy-mm-dd hh:mm:ss，CURTIME 函数用于获取当前时间，格式为 hh:mm:ss，返回类型均为日期格式。 123SELECT NOW(); -- 2018-08-09 19:23:18SELECT CURDATE(); -- 2018-08-09SELECT CURTIME(); -- 19:25:31 DATE_ADDDATE_ADD 函数用于增加时间，即将时间求和，第一个参数为 yyyy-mm-dd hh:mm:ss 格式的时间，第二个参数为时间间隔，INTERVAL 关键字代表时间间隔，后面跟上数字，单位为 DAY、MONTH、YEAR 等，返回类型为字符串。 123SELECT DATE_ADD(NOW(), INTERVAL 365 DAY); -- 2019-08-09 19:30:15SELECT DATE_ADD(NOW(), INTERVAL 1 MONTH); -- 2018-09-09 19:30:15SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR); -- 2019-08-09 19:30:15 STR_TO_DATESTR_TO_DATE 函数可以将一个日期格式的字符串转换成日期，第一个参数为日期格式的字符串，第二个参数为日期的格式描述，如 %Y-%m-%d，传入的日期字符串的格式与日期格式描述必须保持一致。 123SELECT STR_TO_DATE(\"2018-08-09\", \"%Y-%m-%d\"); -- 2018-08-09SELECT STR_TO_DATE(\"2018/08/09\", \"%Y/%m/%d\"); -- 2018-08-09SELECT STR_TO_DATE(\"2018.08.09\", \"%Y.%m.%d\"); -- 2018-08-09 从 student 表中查询一个生日（列名为 birthday）为 1982 年 9 月 3 的学生信息。 12345SELECT *FROM `student`WHERE `birthday` = STR_TO_DATE('09-03 1982','%m-%d %Y');-- 结果查到了黄蓉的信息 格式描述参考下表： 序号格式符功能1%Y4 位的年份2%y2 位的年份3%m月份（01，02）4%c月份（1，2）5%d日（01，02）6%H小时（24 小时制）7%h小时（12 小时制）8%i分钟（00，01）9%s秒（00，01） DATE_FORMATDATE_FORMAT 函数与 STR_TO_DATE 作用正好相反，是将一个日期类型按照格式描述转换成日期字符串，第一个参数为日期对象，第二个参数为日期的格式描述。 123SELECT DATE_FORMAT(STR_TO_DATE(\"2018-08-09\", \"%Y-%m-%d\"), \"%Y年%m月%d日\");-- 2018年08月09日 DATEDIFFDATEDIFF 函数用于计算时间间隔，两个参数均为日期对象，得到的结果为第一个与第二个的差值，单位为 “天”。 1SELECT DATEDIFF(NOW(), STR_TO_DATE(\"2018-08-08\", \"%Y-%m-%d\")); -- 1 通过查询 student 的 birthday 列计算每个人的年龄（周岁）。 12SELECT FLOOR(DATEDIFF(NOW(), `birthday`) / 365)FROM `student`; 返回日期中指定的部分下面方法传入参数均为日期对象，返回的时间中对应的部分均为字符串。 YEAR：返回年； MONTH：返回月； DAY：返回日； HOUR：返回小时； MINUTE：返回分钟； SECOND：返回秒； MONTHNAME：返回月份名称（英文）。 1234567SELECT YEAR(NOW()); -- 2018SELECT MONTH(NOW()); -- 8SELECT DAY(NOW()); -- 9SELECT HOUR(NOW()); -- 19SELECT MINUTE(NOW()); -- 48SELECT SECOND(NOW()); -- 53SELECT MONTHNAME(NOW()); -- August 综合练习查询 student 表中出生月份是 9 月的学生。 123SELECT *FROM `student`WHERE MONTH(`birthday`) = 9; 查询 student 表中生日是今天的学生。 123SELECT *FROM `student`WHERE MONTH(NOW()) = MONTH(`birthday`) AND DAY(NOW()) = DAY(`birthday`); 在 student 表中查询年龄超过 18 岁的男同学。 1234-- 写法 1：求生日与现在时间的差值转换成年与年龄比较SELECT *FROM `student`WHERE DATEDIFF(NOW(), `birthday`) / 365 &gt; 18; 1234-- 写法 2：给生日加上 18 年看看是否大于今天的时间SELECT *FROM `student`WHERE DATE_ADD(`birthday`, INTERVAL 18 YEAR) &lt; NOW(); 1234-- 写法 3：获取今天时间的年份和生日的年份做差，看是否大于 18SELECT *FROM `student`WHERE YEAR(NOW()) - YEAR(`birthday`) &gt; 18; 数据库辅助函数CONNECTION_ID连接每个数据库都会分配对应的连接号，我们称为连接 ID，CONNECTION_ID 函数可以帮我们获取连接 ID。 1SELECT CONNECTION_ID(); -- 10 DATABASEDATABASE 函数用于查看当前的连接的数据库，返回数据库名称。 1SELECT DATABASE(); -- school VERSIONVERSION 函数用来查看当前 MySQL 数据库的版本号。 1SELECT VERSION(); -- 5.5.61 LAST_INSERT_IDLAST_INSERT_ID 可以获取上次向表中（任意表）插入数据时，插入数据的 id 号。 1select LAST_INSERT_ID(); -- 0 USER 和 PASSWORDUSER 用于查询当前数据库登录的用户。 1SELECT USER(); -- root@ 在 MySQL 数据库中存在一张表存放着 MySQL 当前所有的用户，可以通过下面命令查询。 1SELECT * FROM mysql.user; 通过查询结果可以看出密码的位置存储的是密文，如果要修改密码需要将设置的密码转换成密文进行存储，PASSWORD 函数就是来做这件事的，修改密码命令如下。 12UPDATE FROM mysql.userSET `password` = PASSWORD(\"123456\"); MD5MD5 可以将传入的字符串进行一个 MD5 散列算法的转换并输出。 1SELECT MD5(\"panda\"); -- ce61649168c4550c2f7acab92354dc6e 流程控制函数IFIF 函数可以根据传入的判断条件在两个结果中进行选择输出。 1SELECT IF(1 &gt; 2, \"yes\", \"no\"); -- no CASE、WHEN、THEN、ELSE 和 ENDCASE、WHEN、THEN、ELSE 和 END 共同组成了一个流程控制函数，可以代替多个 IF，CASE 为条件判断起始关键字，WHEN 为判断条件关键字（可以有多个），THEN 为输出结果关键字，ELSE 为默认输出关键字，END 为流程结束关键字。 123456789SELECT `grade`,CASEWHEN `grade` &gt; 90 THEN \"优\"WHEN `grade` &gt; 80 THEN \"良\"WHEN `grade` &gt; 70 THEN \"中\"WHEN `grade` &gt; 60 THEN \"及格\"ELSE \"不及格\"ENDFROM `score`; 自定义函数规则 自定义函数是对 MySQL 的扩展，使用方式和内置函数相同； 函数必须要有参数和返回值，函数可以接收任意类型的值和参数，返回值只能有一个； 函数体由合法的 SQL 语句组成，可以包含声明、循环和流程控制，也可以是 SELECT 或 INSERT 语句，如果函数体是复合结构（多条语句）要用 BEGIN...END。 语法123CREATE FUNCTION FUNC_NAME RETURNS &#123;String|Integer&#125;BODYRETURN VALUE CREATE FUNCTION 为创建函数关键字，FUNC_NAME 为函数的名字，RETURNS 为返回类型关键字，“&#123; &#125;” 中的内容为返回值类型，如 varchar 等，BODY 代表函数体，RETURN VALUE 代表返回值。 实例写一个自定义函数用于获取中文格式的当前时间。 123456-- 函数 ZHNOWCREATE FUNCTION ZHNOW() RETURNS VARCHAR(64)RETURN DATE_FORMAT(NOW(), \"%Y年%m月%d日\");-- 使用 ZHNOWSELECT ZHNOW(); -- 2018年08月10日 实现一个自定义函数对两个数字进行相乘运算并将结果返回。 123456-- 函数 MYPRODUCT，参数为两个数字CREATE FUNCTION MYPRODUCT(n INT, m INT) RETURNS INTRETURN n * m;-- 使用 MYPRODUCTSELECT MYPRODUCT(2, 5); -- 10 针对上面的 course 学科表，写一个自定义函数用来增加学科并返回增加数据的 id 值。 12345678910-- 函数 ADD_COURSE，参数为添加课程的名称CREATE FUNCTION ADD_COURSE(name VARCHAR(32)) RETURNS INTBEGININSERT INTO `course` (`name`)VALUES (name);RETURN LAST_INSERT_ID();END-- 使用 ADD_COURSESELECT ADD_COURSE(\"体育\"); -- 4 聚合函数上一节中的函数都是普通函数，多用于操作表达式后返回结果，而聚合函数更多是对一组值进行计算，并返回计算后的值，一般用来统计数据，使用难度要大于普通函数。 SUMSUM 函数用于累加所有行的值。 还是以上面的 score 表为例，我们取出 student_id 值为 1 的学生全部科目的总成绩。 123SELECT SUM(`grade`)FROM `score`WHERE `student_id` = 1; -- 260 其实上面的操作是分为两部分进行，首先先查出 student_id 为 1 的所有学科的成绩，在对这些成绩进行求和计算后返回。 AVGAVG 函数用于计算所有行的平均值。 在 score 表中查询 student_id 值为 3 的学生全部科目成绩的平均值。 123SELECT AVG(`grade`)FROM `score`WHERE `student_id` = 3; -- 80 MAX 和 MINMAX 和 MIN 分别用于计算所有行的最大值和最小值。 在 score 表中查询 student_id 值为 2 的学生全部科目成绩的最大值和最小值。 123SELECT MAX(`grade`), MIN(`grade`)FROM `score`WHERE `student_id` = 2; -- 100 40 COUNTCOUNT 按照某一列统计所有行的总条数，如果参照的列值为 null 则不统计在内。 在 score 表中查询 student_id 值为 1 的学生成绩总数。 123SELECT COUNT(`grade`)FROM `score`WHERE `student_id` = 1; -- 3 SQL 语句之分组聚合分组分组查询就是按某一列或某几列的值进行分组，相同的值分为一组，然后可以对组内使用聚合函数分别进行统计。 以 score 表为例，分组表示图如下： 成绩表分组数据 语法： 123SELECT 列名, 查询表达式FROM &lt;表名&gt;GROUP BY &lt;分组字段&gt; GROUP BY 关键字用于对筛选后的结果进行分组。 例子： 统计 score 表中每位同学的平均成绩（单列分组，对 student_id 进行分组）。 123SELECT `student_id`, AVG(`grade`)FROM `score`GROUP BY `student_id`; 统计 score 表中每门课程的最高分（单列分组，对 course_id 进行分组），并按照分数从低到高排序。 1234SELECT `course_id`, MAX(`grade`)FROM `score`GROUP BY `course_id`ORDER BY `grade` ASC; 统计 student 表中各省男女同学人数（多列分组，按照 province 和 gender 进行分组）。 123SELECT `province`, `gender`, COUNT(*)FROM `student`GROUP BY `province`, `gender`; COUNT 中的 * 代表任意一列。 分组筛选语法： 1234567SELECT 列名, 查询表达式FROM &lt;表名&gt;WHERE &lt;条件&gt;GROUP BY &lt;分组字段&gt;HAVING 分组后的过滤条件ORDER BY 列名 [ASC, DESC]LIMIT 偏移量, 条数 WHERE 用于过滤掉不符合条件的记录，HAVING 用于过滤分组后的记录。 注意：上面查询的关键字不一定每条查询语句都要有，但是如果有其中的某些关键字，一定要按照上面的顺序进行。 例子： 统计 student 表中学生人数多于一个的省份。 1234SELECT `province`, COUNT(*)FROM `student`GROUP BY `province`HAVING COUNT(*) &gt; 1; 统计 score 表中不及格次数大于 1 的学生按逆序排列并取前 3 条。 1234567SELECT `student_id`, COUNT(*)FROM `score`WHERE `grade` &lt; 60GROUP BY `student_id`HAVING COUNT(`grade`) &gt; 1ORDER BY COUNT(`grade`) DESCLIMIT 0, 3; SQL 语句之子查询子查询的注意点： 子查询是出现在其他 SQL 语句中的 SELECT 语句； 子查询嵌套在查询内部，且必须写在圆括号中，外层可以是 SELECT、INSERT、UPDATE、SET 等； 子查询可以包含多个关键字或条件； 子查询可以返回常量、一行数据、一列数据或其它子查询（返回多行数据需使用其他关键字处理）。 比较运算符连接子查询在查询通过 WHERE 进行条件筛选时，可以使用比较运算符连接子查询。 查询年龄大于平均年龄的学生。 123456SELECT *FROM `student`WHERE YEAR(NOW()) - YEAR(`birthday`) &gt; ( SELECT AVG(YEAR(NOW()) - YEAR(`birthday`)) FROM `student`); IN 和 NOT IN当查询一张表的数据需要另一张表中的数据作为筛选条件时，可以在查询时通过 IN 和 NOT IN 关键字连接子查询。 查询 student 有不及格成绩的学生信息。 123456789SELECT *FROM `student`WHERE `id` IN ( SELECT DISTINCT `student_id` FROM `score` WHERE `grade` &lt; 60);-- 结果查到了黄蓉 上面例子查到了 “黄蓉” 同学的信息，如果将 IN 修改为 NOT IN 则会查询到除 “黄蓉” 以外其他同学的信息。 查询 student 表中在 score 表中有成绩的学生信息。 123456SELECT *FROM `student`WHERE student.id IN ( SELECT DISTINCT `student_id` FROM `score`); EXISTS 和 NOT EXISTSEXISTS 和 NOT EXISTS 关键字用于连接子查询，代表 “存在” 或 “不存在” 的意思，接收的子查询返回为数据为布尔值。 拿上面查询 student 表在 score 表中有成绩学生信息的例子，使用 EXISTS 实现查询。 1234567SELECT *FROM `student`WHERE EXISTS ( SELECT `student_id` FROM `score` WHERE score.student_id = student.id); IN、NOT IN 与 EXISTS、NOT EXISTS 比较，后者的性能更高，查询速度更快，因为判断是在子查询内部，EXISTS、NOT EXISTS 只需要判断布尔值就可以了，IN、NOT IN 在子查询返回数据的基础上还要再次过滤。 ALL、SOME 和 ANY当子查询返回了多条数据的时候，可以使用 ALL、SOME 和 ANY 关键字作为比较运算符和子查询之间的连接。 ALL 关键字代表全部，即查询的数据筛选条件要去和所有子查询返回的比较并都满足； SOME 关键字代表某些，查询数据筛选条件只要满足子查询返回数据的某些条即可； ANY 关键字代表任何一个，查询数据的筛选条件只要满足子查询返回数据的任意一条即可。 查询 student 表中年龄大于等于所有人的学生信息。 12345678SELECT *FROM `student`WHERE `age` &gt;= ALL ( SELECT `age` FROM `student`);-- 结果查到了欧阳锋 查询 student 表中年龄大于某些人的学生信息。 12345678SELECT *FROM `student`WHERE `age` &gt; SOME ( SELECT `age` FROM `student`);-- 结果查到除杨过以外的所有人（因为杨过年龄最小） 查询 student 表中年龄大于任意一个人的学生信息。 12345678SELECT *FROM `student`WHERE `age` &gt; ANY ( SELECT `age` FROM `student`);-- 返回结果同 SOME 没区别 表连接连接类型在 MySQL 中的表连接类型： INNER JOIN：内连接，代表取两张关联表的交集，可以用 JOIN 关键字代替； LEFT：左外连接，代表取两张表的交集后再和左侧表求并集，即包含左侧表全部数据； RIGHT：右外连接，代表取两张表的交际后再和右侧表求并集，即包含右侧表全部数据。 三种连接类型表示如下图： 表连接类型韦恩图 连接条件 ONON 关键字用来设定表的连接条件，也可以使用 WHERE 对结果进行过滤的方式来代替。 内连接对 student 和 score 两张表使用内连接。 123SELECT *FROM `student`INNER JOIN `score` ON student.id = score.student_id; 查询结果如下： 内连接查询结果 左外连接对 student 和 score 两张表使用左外连接。 123SELECT *FROM `student`LEFT JOIN `score` ON student.id = score.student_id; 查询结果如下： 左外连接查询结果 右外连接对 student 和 score 两张表使用右外连接。 123SELECT *FROM `student`RIGHT JOIN `score` ON student.id = score.student_id; 查询结果如下： 右外连接查询结果 多表连接案例连接 student、score 和 course 三张表，分别查询学生姓名、学科和分数。 1234SELECT student.name, course.name, score.gradeFROM `score`INNER JOIN `student` ON student.id = score.student_idINNER JOIN `course` ON course.id = score.course_id; 总结到此 MySQL 系列文章的第二篇就结束了，本篇的大部分都是和操作数据库的 SQl 语句相关的知识点，里面涵盖了基本的增、删、改、查以及函数、聚合函数的应用等，如果记不住的话（当然我也记不住，只是负责替大家和我自己整理）建议收藏，在使用时随时查阅，这一篇的内容对于前端而言，可以说基本够用了，如果你对数据库还有兴趣，想了解关于表的设计的相关思想，期待我的下一篇 《MySQL —— 简单聊一聊数据库设计》 更新吧。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.pandashen.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://www.pandashen.com/tags/数据库/"}]},{"title":"MySQL —— 数据库基础","date":"2018-08-07T17:23:03.000Z","path":"2018/08/08/20180808012303/","text":"前言MySQL 是目前使用最广泛的关系型数据库，是在软件开发中所必备的技能之一，这是关于 MySQL 的系列文章，将从 MySQL 的基本概念、基本使用、SQL 语句、函数、聚合函数、表连接以及表设计等多方面对 MySQL 进行总结，而本篇是数据库基础部分，大多都是一些概念性的内容和表的创建，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，当然这也是我的学习笔记，希望可以帮助大家。 MySQL 的基本概念MySQL 的特点：开源免费、性能高、安装使用简单。 MySQL 的作用： 存储大量数据，方便检索和访问； 保持数据信息的一致、完整； 实现数据的共享和安全； 通过组合分析产生新的有用信息。 实体：只要是客观存在，能够被描述出来的都是实体，每一条数据都是一个实体。 DB：是数据库的意思，就是存储数据的仓库，可以存放结构化的数据。 DBMS：代表数据管理系统，是一种系统软件，提供操作数据库的环境，如 Navicat for MySQL，可以通过数据库管理系统对数据进行增、删、改、查。 SQL：结构化查询语言，专门用来和数据库进行交流的语言，几乎所有的 DBMS 都支持 SQL。 数据表： 表是数据库中包含所有数据的数据库对象，也是其他对象的基础； 表定义是一个集合，数据在表中是按行和列的格式组织的，用来存放数据； 行被称为记录，用来存放一个实体，列称为字段用来描述实体的某一个属性。 MySQL 的配置和命令MySQL 配置在 MySQL 的默认安装目录中 my.ini 文件是专门用来配置的，常用配置项如下： port：端口号； basedir：安装目录； datadir：数据存放目录 charcter-set-server：字符集； default-storage-engine：存储引擎； sql-mode：语法模式； max-connections：最大连接数。 MySQL 命令MySQL 服务启动和停止： 12net start MySQLnet stop MySQL 连接和退出数据库： 12mysql -h 127.0.0.1 -P 3306 -uroot -p123456exit -h 代表主机名，-p 代表端口号，-u 和 -p 分别代表当前 MySQL 服务的账号和密码。 查看当前 MySQL 中的数据库： 12show dbs;show database; 切换数据库： 1use dataname; 查看数据库的表： 12show tables;show tables from mysql; 查看当前所在的数据库： 1select database(); 查询表结构： 1desc tablename; 数据完整性数据完整性是指，数据库种所有数据值均为正确状态，如果数据存储有不正确的的数据值，则该数据库丧失数据完整性，为了实现数据完整性，需要检验数据库表中每行每列的数据是否符合要求，在创建表时，应该保证以后输入的数据都是正确的，错误的数据不允许输入。 域（列）完整性域完整性是对数据表中字段属性的约束，通常指数据的有效性，它包括字段的值域、字段的类型及字段的有效规则等约束，它是由确定关系结构时所定义的字段的属性决定的，如关于年龄的字段，数据类型应为 int，关于普通的字符串值得类型应该为 varchar 等等，并在规定值类型时相应得规定值的长度，即所占的字节数。 数据类型图如下： 数据类型图 数值类型整数型： tinyint：存储所占 1 字节，无符号可以存储 0 ~ 255，有符号可以存储 -128 ~ 127； smallint：存储所占 2 字节，无符号可以存储 0 ~ 65535，有符号可以存储 -32768 ~ 32767； mediumint：存储所占 3 字节，无符号可以存储 0 ~ 16777215，有符号可以存储 -8388608 ~ 8388607； int：存储所占 4 字节，无符号可以存储 0 ~ 4294967295，有符号可以存储 -2147483648 ~ 2147483647； bigint：存储所占 8 字节，无符号可以存储 0 ~ 18446744073709551615，有符号可以存储 -9223372036854775808 ~ 9223372036854775807。 上面的整数型用来规定字段存储的数据必须为整数，从上到下需要占用的空间越来越多，能表示的数字也越来越大，定义字段时选择满足需求的数字范围即可。 数值类型小数型： float：单精度浮点型，存储所占 4 字节，数值范围为 -3.4E38 ~ 3.4E38，7 个有效位； double：双精度浮点型，存储所占 8 字节，数值范围为 -1.7E308~1.7E308，15 个有效位； decimal：定点型，存储所占 16 字节，28 个有效位，不存在精度损失，常用于银行账目计算。 数值存储范围越小，精度越高，范围越大，精度越不准确，既要求精度，又固定小数点位数的数值存储，建议使用 decimal，优点在于可以自定义小数点位数，精度高，特殊情况，数值范围巨大，只能使用 float 类型，该类型一般不建议使用。 字符串类型： set：存储字符串对象，最多包含 64 个元素，并且可以取到集合中任意元素； enum：存储字符串对象，最多包含 65536 个元素，只能取到集合中一个元素； blob：用于存储二进制字符串，有子类型； text：用于存储大文本，有子类型； char：定长，最大 255 字节，存储空间未满，会在数据右侧填充空格； varchar：不定长，最大 65536 字节，当长度小于 4 时，会自动转换成 char。 上面类型中最常用的为 varchar 可以根据字段内容的自定义长度。 时间类型： year：yyyy 格式表示的年份值； timestamp：yyyymmddhhmmss 格式表示的时间戳； time：hh:mm:ss 格式表示的时间值； date：yyyy-mm-dd 格式表示的日期值； datetime：yyyy-mm-dd hh:mm:ss 格式表示的日期和时间。 默认值：默认值是指如果某个字段没有指定值的情况下，会为该字段指定一个预先设定的值。 非空约束：我们可以指定某个字段不能不输入，必须提供一个非空的值，即不能为 null。 实体（行）完整性实体完整性是对关系中的记录唯一性，也就是主键的约束，准确地说，实体完整性是指关系中的主属性值不能为 null 且不能有相同值，定义表中的所有行唯一的标识，一般用主键。 主键：表中一列或者几列组合的值能用来唯一标识表中的每一行，这样的列或者列组合称为表的主键，主键表的数据不能重复，如果两列或者多列组合起来唯一标识表中的每一行，则该主键又称为 “组合主键”。 主键的选择标准： 最少性：尽量选择单个键作为主键； 稳定性：由于主键是用来在两个表之间建立关联的，不能经常更新或者说一般不更新，所以最好选择无意义的列作为主键，如各种 id 值。 引用完整性引用完整性意思是对关系型数据库中建立关联关系的数据表之间数据参照引用的约束，也就是对外键的约束，准确地说，是指关系中的外键必须是另一个关系的主键有效值，或者是 null，参考完整性，维护表间数据的有效性，完整性，通常通过建立外部键联系另一张关联表的主键实现。 外键：用于连接两张表的字段称为外键，属于外键表，通常要关联的主键表的字段作为外键，保证了引用完整性。 外键约束：外键表的外键必须引用主键表的主键，主表没有记录。 如果一个表的外键引用了一个表的主键会有以下限制： 在外键表里不能添加主键表里没有的数据，外键表的数据与主键表的数据必须通过外键一一对应； 要想删除主键表的数据必须删除所有外键表的数据。 唯一约束：唯一约束是指某个字段值是唯一的，在所有的记录中不能有重复的值，如某个人的身份证号，需将外键的索引类型设置为 Unique。 标识列：当表中没有适合做主键的列时，此时创建作为主键的无意义列称为标识列，标识列的值是自动生成的，不能输入修改，且是自增的，可以设置每次的增量，具有 “断号保留” 的特性，当某一个实体被删除时，该标识列的值是永久保存的，其他新增实体会在这个标识列的基础上继续自增。 DDL 数据定义语言的使用我们可以通过两种方式创建表，可以使用 DDL（data defintion language）数据定义语言来创建，也可以使用 DBMS 数据管理系统来创建，使用 DBMS 还是很方便的，而且也是最常用的方式，但 DDL 创建方式我们不得不说，就是通过代码的方式来实现表的创建和操作，因为这是最原始的方式，即使图形化的操作会更方便，我们也应该了解。 SQL 规范SQL 语句的规范如下： SQL 语句不区分大小写，建议 SQL 关键字大写，表名和列表小写； 命令用分号结尾； 命令可以缩进和换行，一种类型的关键字放在一行； 可以写单行和多行注释 , # 和 -- 是单行注释， /*/ 是多行注释。 使用 DDL 操作表在 DBMS 中的查询编辑器可以代替命令行实现命令的编写，为了视觉效果，我们都使用 Navicat for MySQL 的查询编辑器，操作界面如下图。 Navicat For MySQL 操作界面 创建表创建表 student，创建一个标识列 id 不为空，设为主键并自增，创建 name 列，varchar 类型，64 位，不为空，创建 age 列，int 类型，不为空，创建 city 列，varchar 类型，32 位，默认值为 “北京”。 1234567CREATE TABLE `student`( `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(64) NOT NULL, `age` INT NOT NULL, `city` VARCHAR(32) DEFAULT \"北京\"); 操作表的列给上面的表 student 增加 idcard 列，值为空，将 idcard 列类型大小修改为 32 位，添加 province 列，插入到 city 列前面，查询表结构，删除 idcard 列，删除表 student。 123456ALTER TABLE `student` ADD COLUMN `idcard` VARCHAR(18) NULL;ALTER TABLE `student` MODIFY COLUMN `idcard` VARCHAR(32) NULL;ALTER TABLE `student` ADD COLUMN `province` VARCHAR(32) AFTER `age`;DESC `student`;ALTER TABLE `student` DROP COLUMN `idcard`;DROP TABLE `student`; 添加主键约束重新创建上面的 student 表，city 不设置默认值，不添加主键约束和标识列，再通过命令添加主键约束。 12345678CREATE TABLE `student`( `id` INT NOT NULL, `name` VARCHAR(64) NOT NULL, `age` INT NOT NULL, `city` VARCHAR(32));ALTER TABLE `student` ADD PRIMARY KEY(id); 添加唯一约束将上面我们 student 表中的 idcard 列再加回来，给 idcard 列添加唯一约束，外键名为 uq_idcard。 12ALTER TABLE `student` ADD COLUMN `idcard` VARCHAR(18) NULL;ALTER TABLE `student` ADD UNIQUE INDEX uq_idcard(`idcard`); 添加默认约束将 student 表 city 列的默认值设置为 “北京”。 1ALTER TABLE `student` MODIFY COLUMN `city` VARCHAR(64) DEFAULT \"北京\"; 添加外键约束创建一个子表 score，添加 student_id 列，添加外键 fk_student_id，将 student_id 与 student 表的主键 id 相关联，此时 student 为主表（主键表），score 为子表（外键表）。 1234567CREATE TABLE `score`( `student_id` INT);ALTER TABLE `score` ADD CONSTRAINT `fk_student_id`FOREIGN KEY (`student_id`)REFERENCES `student` (`id`); 注意：在项目中一般不会添加这个约束，因为在开发时会频繁操作表和修改数据，会经常报错，非常麻烦，不添加这个约束并不影响数据的检索和修改。 删除约束删除 score 表与 student 表的外键约束，即删除外键 fk_student_id。 1ALTER TABLE `score` DROP FOREIGN KEY `fk_student_id`; 使用 DDL 创建一个完整的表关系完整的表关系图如下： 完整表关系图 DDL 命令如下： 1234567891011121314151617181920212223242526272829-- 创建表 studentCREATE TABLE `student` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(50) NOT NULL, `idcard` VARCHAR(18) DEFAULT NULL, `age` INT(11) DEFAULT NULL, `city` VARCHAR(50) DEFAULT \"北京\", PRIMARY KEY (`id`));-- 创建表 courseCREATE TABLE `course` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(50) DEFAULT NULL, PRIMARY KEY (`id`));-- 创建表 score，并添加外键约束CREATE TABLE `score` ( `student_id` INT(11) NOT NULL DEFAULT \"0\", `course_id` INT(11) NOT NULL DEFAULT \"0\", `grade` FLOAT DEFAULT NULL, PRIMARY KEY (`student_id`, `course_id`), KEY `fk_courseid` (`course_id`), CONSTRAINT `fk_courseid` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`), CONSTRAINT `fk_student_id` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 在实际开发当中使用 DDL 对表的编辑并不多，因为命令繁琐，在效率上，使用 DBMS 效率更高，但是 DDL 是学习 MySQL 数据库的根本之一，应该会写。 总结到此 MySQL 系列文章的第一篇就结束了，里面大部分内容都是关于 MySQL 数据库的概念以及表的创建，非常枯燥，但又是初学 MySQL 所必须要懂的知识点，相信大家通过本节已经对 MySQL 有了一定的认识，那么下一篇将是重中之重，是在开发中经常使用的 DML 数据库操作语言，也就是我们平时所说的 SQL 语句，在此期待我们的下一篇 《MySQL —— SQL 语句总结》。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.pandashen.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://www.pandashen.com/tags/数据库/"}]},{"title":"Webpack 核心模块 tapable 解析","date":"2018-08-06T10:44:12.000Z","path":"2018/08/06/20180806184412/","text":"前言Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，是对前端项目实现自动化和优化必不可少的工具，Webpack 的 loader（加载器）和 plugin（插件）是由 Webpack 开发者和社区开发者共同贡献的，而目前又没有比较系统的开发文档，想写加载器和插件必须要懂 Webpack 的原理，即看懂 Webpack 的源码，tapable 则是 Webpack 依赖的核心库，可以说不懂 tapable 就看不懂 Webpack 源码，所以本篇会对 tapable 提供的类进行解析和模拟。 tapable 介绍Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 tapable，Webpack 中最核心的，负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 tapable 构造函数的实例。 打开 Webpack 4.0 的源码中一定会看到下面这些以 Sync、Async 开头，以 Hook 结尾的方法，这些都是 tapable 核心库的类，为我们提供不同的事件流执行机制，我们称为 “钩子”。 引入 tapable 如下1234567891011const &#123; SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook &#125; = require('tapable'); 上面的实现事件流机制的 “钩子” 大方向可以分为两个类别，“同步” 和 “异步”，“异步” 又分为两个类别，“并行” 和 “串行”，而 “同步” 的钩子都是串行的。 Sync 类型的钩子SyncHookSyncHook 为串行同步执行，不关心事件处理函数的返回值，在触发事件之后，会按照事件注册的先后顺序执行所有的事件处理函数。 SyncHook 钩子的使用12345678910111213141516const &#123; SyncHook &#125; = require('tapable');// 创建实例const syncHook = new SyncHook(['name', 'age']);// 注册事件syncHook.tap('1', (name, age) =&gt; console.log('1', name, age));syncHook.tap('2', (name, age) =&gt; console.log('2', name, age));syncHook.tap('3', (name, age) =&gt; console.log('3', name, age));// 触发事件，让监听函数执行syncHook.call('panda', 18);// 1 panda 18// 2 panda 18// 3 panda 18 在 tapable 解构的 SyncHook 是一个类，注册事件需先创建实例，创建实例时支持传入一个数组，数组内存储事件触发时传入的参数，实例的 tap 方法用于注册事件，支持传入两个参数，第一个参数为事件名称，在 Webpack 中一般用于存储事件对应的插件名称（名字随意，只是起到注释作用）， 第二个参数为事件处理函数，函数参数为执行 call 方法触发事件时所传入的参数的形参。 模拟 SyncHook 类12345678910111213141516171819class SyncHook &#123; constructor(args) &#123; this.args = args; this.tasks = []; &#125; tap(name, task) &#123; this.tasks.push(task); &#125; call(...args) &#123; // 也可在参数不足时抛出异常 if (args.length &lt; this.args.length) throw new Error('参数不足'); // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 依次执行事件处理函数 this.tasks.forEach(task =&gt; task(...args)); &#125;&#125; tasks 数组用于存储事件处理函数，call 方法调用时传入参数超过创建 SyncHook 实例传入的数组长度时，多余参数可处理为 undefined，也可在参数不足时抛出异常，不灵活，后面的例子中就不再这样写了。 SyncBailHookSyncBailHook 同样为串行同步执行，如果事件处理函数执行时有一个返回值不为空（即返回值为 undefined），则跳过剩下未执行的事件处理函数（如类的名字，意义在于保险）。 SyncBailHook 钩子的使用1234567891011121314151617181920const &#123; SyncBailHook &#125; = require('tapable');// 创建实例const syncBailHook = new SyncBailHook(['name', 'age']);// 注册事件syncBailHook.tap('1', (name, age) =&gt; console.log('1', name, age));syncBailHook.tap('2', (name, age) =&gt; &#123; console.log('2', name, age); return '2';&#125;);syncBailHook.tap('3', (name, age) =&gt; console.log('3', name, age));// 触发事件，让监听函数执行syncBailHook.call('panda', 18);// 1 panda 18// 2 panda 18 通过上面的用法可以看出，SyncHook 和 SyncBailHook 在逻辑上只是 call 方法不同，导致事件的执行机制不同，对于后面其他的 “钩子”，也是 call 的区别，接下来实现 SyncBailHook 类。 模拟 SyncBailHook 类12345678910111213141516171819class SyncBailHook &#123; constructor(args) &#123; this.args = args; this.tasks = []; &#125; tap(name, task) &#123; this.tasks.push(task); &#125; call(...args) &#123; // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 依次执行事件处理函数，如果返回值不为空，则停止向下执行 let i = 0, ret; do &#123; ret = this.tasks[i++](...args); &#125; while (!ret); &#125;&#125; 在上面代码的 call 方法中，我们设置返回值为 ret，第一次执行后没有返回值则继续循环执行，如果有返回值则立即停止循环，即实现 “保险” 的功能。 SyncWaterfallHookSyncWaterfallHook 为串行同步执行，上一个事件处理函数的返回值作为参数传递给下一个事件处理函数，依次类推，正因如此，只有第一个事件处理函数的参数可以通过 call 传递，而 call 的返回值为最后一个事件处理函数的返回值。 SyncWaterfallHook 钩子的使用1234567891011121314151617181920212223242526272829const &#123; SyncWaterfallHook &#125; = require('tapable');// 创建实例const syncWaterfallHook = new SyncWaterfallHook(['name', 'age']);// 注册事件syncWaterfallHook.tap('1', (name, age) =&gt; &#123; console.log('1', name, age); return '1';&#125;);syncWaterfallHook.tap('2', data =&gt; &#123; console.log('2', data); return '2';&#125;);syncWaterfallHook.tap('3', data =&gt; &#123; console.log('3', data); return '3'&#125;);// 触发事件，让监听函数执行let ret = syncWaterfallHook.call('panda', 18);console.log('call', ret);// 1 panda 18// 2 1// 3 2// call 3 SyncWaterfallHook 名称中含有 “瀑布”，通过上面代码可以看出 “瀑布” 形象生动的描绘了事件处理函数执行的特点，与 SyncHook 和 SyncBailHook 的区别就在于事件处理函数返回结果的流动性，接下来看一下 SyncWaterfallHook 类的实现。 模拟 SyncWaterfallHook 类1234567891011121314151617class SyncWaterfallHook &#123; constructor(args) &#123; this.args = args; this.tasks = []; &#125; tap(name, task) &#123; this.tasks.push(task); &#125; call(...args) &#123; // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 依次执行事件处理函数，事件处理函数的返回值作为下一个事件处理函数的参数 const [first, ...others] = this.tasks; return others.reduce((ret, task) =&gt; task(ret), first(...args)); &#125;&#125; 上面代码中 call 的逻辑是将存储事件处理函数的 tasks 拆成两部分，分别为第一个事件处理函数，和存储其余事件处理函数的数组，使用 reduce 进行归并，将第一个事件处理函数执行后的返回值作为归并的初始值，依次调用其余事件处理函数并传递上一次归并的返回值。 SyncLoopHookSyncLoopHook 为串行同步执行，事件处理函数返回 true 表示继续循环，即循环执行当前事件处理函数，返回 undefined 表示结束循环，SyncLoopHook 与 SyncBailHook 的循环不同，SyncBailHook 只决定是否继续向下执行后面的事件处理函数，而 SyncLoopHook 的循环是指循环执行每一个事件处理函数，直到返回 undefined 为止，才会继续向下执行其他事件处理函数，执行机制同理。 SyncLoopHook 钩子的使用1234567891011121314151617181920212223242526272829303132const &#123; SyncLoopHook &#125; = require('tapable');// 创建实例const syncLoopHook = new SyncLoopHook(['name', 'age']);// 定义辅助变量let total1 = 0;let total2 = 0;// 注册事件syncLoopHook.tap('1', (name, age) =&gt; &#123; console.log('1', name, age, total1); return total1++ &lt; 2 ? true : undefined;&#125;);syncLoopHook.tap('2', (name, age) =&gt; &#123; console.log('2', name, age, total2); return total2++ &lt; 2 ? true : undefined;&#125;);syncLoopHook.tap('3', (name, age) =&gt; console.log('3', name, age));// 触发事件，让监听函数执行syncLoopHook.call('panda', 18);// 1 panda 18 0// 1 panda 18 1// 1 panda 18 2// 2 panda 18 0// 2 panda 18 1// 2 panda 18 2// 3 panda 18 通过上面的执行结果可以清楚的看到 SyncLoopHook 的执行机制，但有一点需要注意，返回值必须严格是 true 才会触发循环，多次执行当前事件处理函数，必须严格返回 undefined，才会结束循环，去执行后面的事件处理函数，如果事件处理函数的返回值不是 true 也不是 undefined，则会死循环。 在了解 SyncLoopHook 的执行机制以后，我们接下来看看 SyncLoopHook 的 call 方法是如何实现的。 模拟 SyncLoopHook 类12345678910111213141516171819202122class SyncLoopHook &#123; constructor(args) &#123; this.args = args; this.tasks = []; &#125; tap(name, task) &#123; this.tasks.push(task); &#125; call(...args) &#123; // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 依次执行事件处理函数，如果返回值为 true，则继续执行当前事件处理函数 // 直到返回 undefined，则继续向下执行其他事件处理函数 this.tasks.forEach(task =&gt; &#123; let ret; do &#123; ret = this.task(...args); &#125; while (ret === true || !(ret === undefined)); &#125;); &#125;&#125; 在上面代码中可以看到 SyncLoopHook 类 call 方法的实现更像是 SyncHook 和 SyncBailHook 的 call 方法的结合版，外层循环整个 tasks 事件处理函数队列，内层通过返回值进行循环，控制每一个事件处理函数的执行次数。 注意：在 Sync 类型 “钩子” 下执行的插件都是顺序执行的，只能使用 tab 注册。 Async 类型的钩子Async 类型可以使用 tap、tapAsync 和 tapPromise 注册不同类型的插件 “钩子”，分别通过 call、callAsync 和 promise 方法调用，我们下面会针对 AsyncParallelHook 和 AsyncSeriesHook 的 async 和 promise 两种方式分别介绍和模拟。 AsyncParallelHookAsyncParallelHook 为异步并行执行，通过 tapAsync 注册的事件，通过 callAsync 触发，通过 tapPromise 注册的事件，通过 promise 触发（返回值可以调用 then 方法）。 tapAsync/callAsynccallAsync 的最后一个参数为回调函数，在所有事件处理函数执行完毕后执行。 AsyncParallelHook 钩子：tapAsync/callAsync 的使用123456789101112131415161718192021222324252627282930313233343536373839const &#123; AsyncParallelHook &#125; = require('tapable');// 创建实例const asyncParallelHook = new AsyncParallelHook(['name', 'age']);// 注册事件console.time('time');asyncParallelHook.tapAsync('1', (name, age, done) =&gt; &#123; settimeout(() =&gt; &#123; console.log('1', name, age, new Date()); done(); &#125;, 1000);&#125;);asyncParallelHook.tapAsync('2', (name, age, done) =&gt; &#123; settimeout(() =&gt; &#123; console.log('2', name, age, new Date()); done(); &#125;, 2000);&#125;);asyncParallelHook.tapAsync('3', (name, age, done) =&gt; &#123; settimeout(() =&gt; &#123; console.log('3', name, age, new Date()); done(); console.timeEnd('time'); &#125;, 3000);&#125;);// 触发事件，让监听函数执行asyncParallelHook.callAsync('panda', 18, () =&gt; &#123; console.log('complete');&#125;);// 1 panda 18 2018-08-07T10:38:32.675Z// 2 panda 18 2018-08-07T10:38:33.674Z// 3 panda 18 2018-08-07T10:38:34.674Z// complete// time: 3005.060ms 异步并行是指，事件处理函数内三个定时器的异步操作最长时间为 3s，而三个事件处理函数执行完成总共用时接近 3s，所以三个事件处理函数是几乎同时执行的，不需等待。 所有 tabAsync 注册的事件处理函数最后一个参数都为一个回调函数 done，每个事件处理函数在异步代码执行完毕后调用 done 函数，则可以保证 callAsync 会在所有异步函数都执行完毕后执行，接下来看一看 callAsync 是如何实现的。 模拟 AsyncParallelHook 类：tapAsync/callAsync12345678910111213141516171819202122232425262728class AsyncParallelHook &#123; constructor(args) &#123; this.args = args; this.tasks = []; &#125; tabAsync(name, task) &#123; this.tasks.push(task); &#125; callAsync(...args) &#123; // 先取出最后传入的回调函数 const finalCallback = args.pop(); // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 定义一个 i 变量和 done 函数 // 每次执行检测 i 值和队列长度，决定是否执行 callAsync 的回调函数 let i = 0; const done = () =&gt; &#123; if (++i === this.tasks.length) &#123; finalCallback(); &#125; &#125;; // 依次执行事件处理函数 this.tasks.forEach(task =&gt; task(...args, done)); &#125;&#125; 在 callAsync 中，将最后一个参数（所有事件处理函数执行完毕后执行的回调）取出，并定义 done 函数，通过比较 i 和存储事件处理函数的数组 tasks 的 length 来确定回调是否执行，循环执行每一个事件处理函数并将 done 作为最后一个参数传入，所以每个事件处理函数内部的异步操作完成时，执行 done 就是为了检测是不是该执行 callAsync 的回调，当所有事件处理函数均执行完毕满足 done 函数内部 i 和 length 相等的条件时，则调用 callAsync 的回调。 tapPromise/promise要使用 tapPromise 注册事件，对事件处理函数有一个要求，必须返回一个 Promise 实例，而 promise 方法也返回一个 Promise 实例，callAsync 的回调函数在 promise 方法中用 then 的方式代替。 AsyncParallelHook 钩子：tapPromise/promise 的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445const &#123; AsyncParallelHook &#125; = require('tapable');// 创建实例const asyncParallelHook = new AsyncParallelHook(['name', 'age']);// 注册事件console.time('time');asyncParallelHook.tapPromise('1', (name, age) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; settimeout(() =&gt; &#123; console.log('1', name, age, new Date()); resolve('1'); &#125;, 1000); &#125;);&#125;);asyncParallelHook.tapPromise('2', (name, age) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; settimeout(() =&gt; &#123; console.log('2', name, age, new Date()); resolve('2'); &#125;, 2000); &#125;);&#125;);asyncParallelHook.tapPromise('3', (name, age) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; settimeout(() =&gt; &#123; console.log('3', name, age, new Date()); resolve('3'); console.timeEnd('time'); &#125;, 3000); &#125;);&#125;);// 触发事件，让监听函数执行asyncParallelHook.promise('panda', 18).then(ret =&gt; &#123; console.log(ret);&#125;);// 1 panda 18 2018-08-07T12:17:21.741Z// 2 panda 18 2018-08-07T12:17:22.736Z// 3 panda 18 2018-08-07T12:17:23.739Z// time: 3006.542ms// [ '1', '2', '3' ] 上面每一个 tapPromise 注册事件的事件处理函数都返回一个 Promise 实例，并将返回值传入 resolve 方法，调用 promise 方法触发事件时，如果所有事件处理函数返回的 Promise 实例结果都成功，会将结果存储在数组中，并作为参数传递给 promise 的 then 方法中成功的回调，如果有一个失败就是将失败的结果返回作为参数传递给失败的回调。 模拟 AsyncParallelHook 类 tapPromise/promise12345678910111213141516class AsyncParallelHook &#123; constructor(args) &#123; this.args = args; this.tasks = []; &#125; tapPromise(name, task) &#123; this.tasks.push(task); &#125; promise(...args) &#123; // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 将所有事件处理函数转换成 Promise 实例，并发执行所有的 Promise return Promise.all(this.tasks.map(task =&gt; task(...args))); &#125;&#125; 其实根据上面对于 tapPromise 和 promise 使用的描述就可以猜到，promise 方法的逻辑是通过 Promise.all 来实现的。 AsyncSeriesHookAsyncSeriesHook 为异步串行执行，与 AsyncParallelHook 相同，通过 tapAsync 注册的事件，通过 callAsync 触发，通过 tapPromise 注册的事件，通过 promise 触发，可以调用 then 方法。 tapAsync/callAsync与 AsyncParallelHook 的 callAsync 方法类似，AsyncSeriesHook 的 callAsync 方法也是通过传入回调函数的方式，在所有事件处理函数执行完毕后执行 callAsync 的回调函数。 AsyncSeriesHook 钩子：tapAsync/callAsync 的使用123456789101112131415161718192021222324252627282930313233343536373839const &#123; AsyncSeriesHook &#125; = require('tapable');// 创建实例const asyncSeriesHook = new AsyncSeriesHook(['name', 'age']);// 注册事件console.time('time');asyncSeriesHook.tapAsync('1', (name, age, next) =&gt; &#123; settimeout(() =&gt; &#123; console.log('1', name, age, new Date()); next(); &#125;, 1000);&#125;);asyncSeriesHook.tapAsync('2', (name, age, next) =&gt; &#123; settimeout(() =&gt; &#123; console.log('2', name, age, new Date()); next(); &#125;, 2000);&#125;);asyncSeriesHook.tapAsync('3', (name, age, next) =&gt; &#123; settimeout(() =&gt; &#123; console.log('3', name, age, new Date()); next(); console.timeEnd('time'); &#125;, 3000);&#125;);// 触发事件，让监听函数执行asyncSeriesHook.callAsync('panda', 18, () =&gt; &#123; console.log('complete');&#125;);// 1 panda 18 2018-08-07T14:40:52.896Z// 2 panda 18 2018-08-07T14:40:54.901Z// 3 panda 18 2018-08-07T14:40:57.901Z// complete// time: 6008.790ms 异步串行是指，事件处理函数内三个定时器的异步执行时间分别为 1s、2s 和 3s，而三个事件处理函数执行完总共用时接近 6s，所以三个事件处理函数执行是需要排队的，必须一个一个执行，当前事件处理函数执行完才能执行下一个。 AsyncSeriesHook 类的 tabAsync 方法注册的事件处理函数参数中的 next 可以与 AsyncParallelHook 类中 tabAsync 方法参数的 done 进行类比，同为回调函数，不同点在于 AsyncSeriesHook 与 AsyncParallelHook 的 callAsync 方法的 “并行” 和 “串行” 的实现方式。 模拟 AsyncSeriesHook 类：tapAsync/callAsync1234567891011121314151617181920212223242526class AsyncSeriesHook &#123; constructor(args) &#123; this.args = args; this.tasks = []; &#125; tabAsync(name, task) &#123; this.tasks.push(task); &#125; callAsync(...args) &#123; // 先取出最后传入的回调函数 const finalCallback = args.pop(); // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 定义一个 i 变量和 next 函数，每次取出一个事件处理函数执行，并维护 i 的值 // 直到所有事件处理函数都执行完，调用 callAsync 的回调 // 如果事件处理函数中没有调用 next，则无法继续 let i = 0; const next = () =&gt; &#123; const task = this.tasks[i++]; task ? task(...args, next) : finalCallback(); &#125;; next(); &#125;&#125; AsyncParallelHook 是通过循环依次执行了所有的事件处理函数，done 方法只为了检测是否已经满足条件执行 callAsync 的回调，如果中间某个事件处理函数没有调用 done，只是不会调用 callAsync 的回调，但是所有的事件处理函数都执行了。 而 AsyncSeriesHook 的 next 执行机制更像 Express 和 Koa 中的中间件，在注册事件的回调中如果不调用 next，则在触发事件时会在没有调用 next 的事件处理函数的位置 “卡死”，即不会继续执行后面的事件处理函数，只有都调用 next 才能继续，而最后一个事件处理函数中调用 next 决定是否调用 callAsync 的回调。 tapPromise/promise与 AsyncParallelHook 类似，tapPromise 注册事件的事件处理函数需要返回一个 Promise 实例，promise 方法最后也返回一个 Promise 实例。 AsyncSeriesHook 钩子：tapPromise/promise 的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445const &#123; AsyncSeriesHook &#125; = require('tapable');// 创建实例let asyncSeriesHook = new AsyncSeriesHook(['name', 'age']);// 注册事件console.time('time');asyncSeriesHook.tapPromise('1', (name, age) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; settimeout(() =&gt; &#123; console.log('1', name, age, new Date()); resolve('1'); &#125;, 1000); &#125;);&#125;);asyncSeriesHook.tapPromise('2', (name, age) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; settimeout(() =&gt; &#123; console.log('2', name, age, new Date()); resolve('2'); &#125;, 2000); &#125;);&#125;);asyncParallelHook.tapPromise('3', (name, age) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; settimeout(() =&gt; &#123; console.log('3', name, age, new Date()); resolve('3'); console.timeEnd('time'); &#125;, 3000); &#125;);&#125;);// 触发事件，让监听函数执行asyncSeriesHook.promise('panda', 18).then(ret =&gt; &#123; console.log(ret);&#125;);// 1 panda 18 2018-08-07T14:45:52.896Z// 2 panda 18 2018-08-07T14:45:54.901Z// 3 panda 18 2018-08-07T14:45:57.901Z// time: 6014.291ms// [ '1', '2', '3' ] 分析上面的执行过程，所有的事件处理函数都返回了 Promise 的实例，如果想实现 “串行”，则需要让每一个返回的 Promise 实例都调用 then，并在 then 中执行下一个事件处理函数，这样就保证了只有上一个事件处理函数执行完后才会执行下一个。 模拟 AsyncSeriesHook 类 tapPromise/promise1234567891011121314151617181920class AsyncSeriesHook &#123; constructor(args) &#123; this.args = args; this.tasks = []; &#125; tapPromise(name, task) &#123; this.tasks.push(task); &#125; promise(...args) &#123; // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 将每个事件处理函数执行并调用返回 Promise 实例的 then 方法 // 让下一个事件处理函数在 then 方法成功的回调中执行 const [first, ...others] = this.tasks; return others.reduce((promise, task) =&gt; &#123; return promise.then(() =&gt; task(...args)); &#125;, first(...args)); &#125;&#125; 上面代码中的 “串行” 是使用 reduce 归并来实现的，首先将存储所有事件处理函数的数组 tasks 解构成两部分，第一个事件处理函数和存储其他事件处理函数的数组 others，对 others 进行归并，将第一个事件处理函数执行后返回的 Promise 实例作为归并的初始值，这样在归并的过程中上一个值始终是上一个事件处理函数返回的 Promise 实例，可以直接调用 then 方法，并在 then 的回调中执行下一个事件处理函数，直到归并完成，将 reduce 最后返回的 Promise 实例作为 promise 方法的返回值，则实现 promise 方法执行后继续调用 then 来实现后续逻辑。 对其他异步钩子补充在上面 Async 异步类型的 “钩子中”，我们只着重介绍了 “串行” 和 “并行”（AsyncParallelHook 和 AsyncSeriesHook）以及回调和 Promise 的两种注册和触发事件的方式，还有一些其他的具有一定特点的异步 “钩子” 我们并没有进行分析，因为他们的机制与同步对应的 “钩子” 非常的相似。 AsyncParallelBailHook 和 AsyncSeriesBailHook 分别为异步 “并行” 和 “串行” 执行的 “钩子”，返回值不为 undefined，即有返回值，则立即停止向下执行其他事件处理函数，实现逻辑可结合 AsyncParallelHook 、AsyncSeriesHook 和 SyncBailHook。 AsyncSeriesWaterfallHook 为异步 “串行” 执行的 “钩子”，上一个事件处理函数的返回值作为参数传递给下一个事件处理函数，实现逻辑可结合 AsyncSeriesHook 和 SyncWaterfallHook。 总结在 tapable 源码中，注册事件的方法 tab、tapAsync、tapPromise 和触发事件的方法 call、callAsync、promise 都是通过 compile 方法快速编译出来的，我们本文中这些方法的实现只是遵照了 tapable 库这些 “钩子” 的事件处理机制进行了模拟，以方便我们了解 tapable，为学习 Webpack 原理做了一个铺垫，在 Webpack 中，这些 “钩子” 的真正作用就是将通过配置文件读取的插件与插件、加载器与加载器之间进行连接，“并行” 或 “串行” 执行，相信在我们对 tapable 中这些 “钩子” 的事件机制有所了解之后，再重新学习 Webpack 的源码应该会有所头绪。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.pandashen.com/tags/Webpack/"},{"name":"tapable","slug":"tapable","permalink":"https://www.pandashen.com/tags/tapable/"}]},{"title":"NodeJS 多进程和集群","date":"2018-07-27T06:02:33.000Z","path":"2018/07/27/20180727140233/","text":"进程和线程“进程” 是计算机系统进行资源分配和调度的基本单位，我们可以理解为计算机每开启一个任务就会创建至少一个进程来处理，有时会创建多个，如 Chrome 浏览器的选项卡，其目的是为了防止一个进程挂掉而应用停止工作，而 “线程” 是程序执行流的最小单元，NodeJS 默认是单进程、单线程的，我们将这个进程称为主进程，也可以通过 child_process 模块创建子进程实现多进程，我们称这些子进程为 “工作进程”，并且归主进程管理，进程之间默认是不能通信的，且所有子进程执行任务都是异步的。 spawn 实现多进程spawn 创建子进程在 NodeJS 中执行一个 JS 文件，如果想在这个文件中再同时（异步）执行另一个 JS 文件，可以使用 child_process 模块中的 spawn 来实现，spawn 可以帮助我们创建一个子进程，用法如下。 文件：process.js12345678910111213141516171819const &#123; spawn &#125; = require('child_process');const path = require('path');// 创建子进程const child = spawn('node', ['sub_process.js', '--port', '3000'], &#123; cwd: path.join(__dirname, 'test') // 指定子进程的当前工作目录&#125;);// 出现错误触发child.on('error', err =&gt; console.log(err));// 子进程退出触发child.on('exit', () =&gt; console.log('exit'));// 子进程关闭触发child.on('close', () =&gt; console.log('close'));// exit// close spawn 方法可以帮助我们创建一个子进程，这个子进程就是方法的返回值，spawn 接收以下几个参数： command：要运行的命令； args：类型为数组，数组内第一项为文件名，后面项依次为执行文件的命令参数和值； options：选项，类型为对象，用于指定子进程的当前工作目录和主进程、子进程的通信规则等，具体可查看 官方文档。 error 事件在子进程出错时触发，exit 事件在子进程退出时触发，close 事件在子进程关闭后触发，在子进程任务结束后 exit 一定会触发，close 不一定触发。 文件：&#126;test/sub_process.js12// 打印子进程执行 sub_process.js 文件的参数console.log(process.argv); 通过上面代码打印了子进程执行时的参数，但是我们发现主进程窗口并没有打印，我们希望的是子进程的信息可以反馈给主进程，要实现通信需要在创建子进程时在第三个参数 options 中配置 stdio 属性定义。 spawn 定义输入、输出文件：process.js1234567891011const &#123; spawn &#125; = require('child_process');const path = require('path');// 创建子进程const child = spawn('node', ['sub_process.js', '--port', '3000'], &#123; cwd: path.join(__dirname, 'test') // 指定子进程的当前工作目录 // stdin: [process.stdin, process.stdout, process.stderr] stdio: [0, 1, 2] // 配置标准输入、标准输出、错误输出&#125;);// C:\\Program Files\\nodejs\\node.exe,g:\\process\\test\\sub_process.js,--port,3000 文件：&#126;test/sub_process.js12// 使用主进程的标准输出，输出 sub_process.js 文件执行的参数process.stdout.write(process.argv.toString()); 通过上面配置 options 的 stdio 值为数组，上面的两种写法作用相同，都表示子进程和主进程共用了主进程的标准输入、标准输出、和错误输出，实际上并没有实现主进程与子进程的通信，其中 0 和 stdin 代表标准输入，1 和 stdout 代表标准输出，2 和 stderr 代表错误输出。 上面这样的方式只要子进程执行 sub_process.js 就会在窗口输出，如果我们希望是否输出在主进程里面控制，即实现子进程与主进程的通信，看下面用法。 文件：process.js123456789101112const &#123; spawn &#125; = require('child_process');const path = require('path');// 创建子进程const child = spawn('node', ['sub_process.js'], &#123; cwd: path.join(__dirname, 'test'), stdio: ['pipe']&#125;);child.stdout.on('data', data =&gt; console.log(data.toString()));// hello world 文件：&#126;test/sub_process.js12// 子进程执行 sub_process.jsprocess.stdout.write('hello world'); 上面将 stdio 内数组的值配置为 pipe（默认不写就是 pipe），则通过流的方式实现主进程和子进程的通信，通过子进程的标准输出（可写流）写入，在主进程通过子进程的标准输出通过 data 事件读取的流在输出到窗口（这种写法很少用），上面都只在主进程中开启了一个子进程，下面举一个开启多个进程的例子。 例子的场景是主进程开启两个子进程，先运行子进程 1 传递一些参数，子进程 1 将参数取出返还给主进程，主进程再把参数传递给子进程 2，通过子进程 2 将参数写入到文件 param.txt 中，这个过程不代表真实应用场景，主要目的是体会主进程和子进程的通信过程。 文件：process.js123456789101112131415const &#123; spawn &#125; = require('child_process');const path = require('path');// 创建子进程const child1 = spawn('node', ['sub_process_1.js', '--port', '3000'], &#123; cwd: path.join(__dirname, 'test'),&#125;);const child2 = spawn('node', ['sub_process_2.js'], &#123; cwd: path.join(__dirname, 'test'),&#125;);// 读取子进程 1 写入的内容，写入子进程 2child1.stdout.on('data', data =&gt; child2.stdout.write(data.toString)); 文件：&#126;test/sub_process_1.js12// 获取 --port 和 3000process.argv.slice(2).forEach(item =&gt; process.stdout.write(item)); 文件：&#126;test/sub_process_2.js12345678const fs = require('fs');// 读取主进程传递的参数并写入文件process.stdout.on('data', data =&gt; &#123; fs.writeFile('param.txt', data, () =&gt; &#123; process.exit(); &#125;);&#125;); 有一点需要注意，在子进程 2 写入文件的时候，由于主进程不知道子进程 2 什么时候写完，所以主进程会卡住，需要子进程在写入完成后调用 process.exit 方法退出子进程，子进程退出并关闭后，主进程会随之关闭。 在我们给 options 配置 stdio 时，数组内其实可以对标准输入、标准输出和错误输出分开配置，默认数组内为 pipe 时代表三者都为 pipe，分别配置看下面案例。 文件：process.js12345678910const &#123; spawn &#125; = require('spawn');const path = require('path');// 创建子进程const child = spawn('node', ['sub_process.js'], &#123; cwd: path.join(__dirname, 'test'), stdio: [0, 'pipe', 2]&#125;);// world 文件：&#126;test/sub_process.js12console.log('hello');console.error('world'); 上面代码中对 stderr 实现了默认打印而不通信，对标准输入实现了通信，还有一种情况，如果希望子进程只是默默的执行任务，而在主进程命令窗口什么类型的输出都禁止，可以在数组中对应位置给定值 ignore，将上面案例修改如下。 文件：process.js12345678const &#123; spawn &#125; = require('spawn');const path = require('path');// 创建子进程const child = spawn('node', ['sub_process.js'], &#123; cwd: path.join(__dirname, 'test'), stdio: [0, 'pipe', 'ignore']&#125;); 文件：&#126;test/sub_process.js12console.log('hello');console.error('world'); 这次我们发现无论标准输出和错误输出都没有生效，上面这些方式其实是不太方便的，因为输出有 stdout 和 stderr，在写法上没办法统一，可以通过下面的方式来统一。 标准进程通信文件：process.js1234567891011121314151617181920const &#123; spawn &#125; = require('spawn');const path = require('path');// 创建子进程const child = spawn('node', ['sub_process.js'], &#123; cwd: path.join(__dirname, 'test'), stdio: [0, 'pipe', 'ignore', 'ipc']&#125;);child.on('message', data =&gt; &#123; console.log(data); // 回复消息给子进程 child.send('world'); // 杀死子进程 // process.kill(child.pid);&#125;);// hello 文件：&#126;test/sub_process.js123456789101112// 给主进程发送消息process.send('hello');// 接收主进程回复的消息process.on('message', data =&gt; &#123; console.log(data); // 退出子进程 process.exit();&#125;);// world 这种方式被称为标准进程通信，通过给 options 的 stdio 数组配置 ipc，只要数组中存在 ipc 即可，一般放在数组开头或结尾，配置 ipc 后子进程通过调用自己的 send 方法发送消息给主进程，主进程中用子进程的 message 事件进行接收，也可以在主进程中接收消息的 message 事件的回调当中，通过子进程的 send 回复消息，并在子进程中用 message 事件进行接收，这样的编程方式比较统一，更贴近于开发者的意愿。 退出和杀死子进程上面代码中子进程在接收到主进程的消息时直接退出，也可以在子进程发送给消息给主进程时，主进程接收到消息直接杀死子进程，代码如下。 文件：process.js1234567891011121314151617const &#123; spawn &#125; = require('spawn');const path = require('path');// 创建子进程const child = spawn('node', ['sub_process.js'], &#123; cwd: path.join(__dirname, 'test'), stdio: [0, 'pipe', 'ignore', 'ipc']&#125;);child.on('message', data =&gt; &#123; console.log(data); // 杀死子进程 process.kill(child.pid);&#125;);// hello world 文件：&#126;test/sub_process.js12// 给主进程发送消息process.send('hello'); 从上面代码我们可以看出，杀死子进程的方法为 process.kill，由于一个主进程可能有多个子进程，所以指定要杀死的子进程需要传入子进程的 pid 属性作为 process.kill 的参数。 注意：退出子进程 process.exit 方法是在子进程中操作的，此时 process 代表子进程，杀死子进程 process.kill 是在主进程中操作的，此时 process 代表主进程。 独立子进程我们前面说过，child_process 模块创建的子进程是被主进程统一管理的，如果主进程挂了，所有的子进程也会受到影响一起挂掉，但其实使用多进程一方面为了提高处理任务的效率，另一方面也是为了当一个进程挂掉时还有其他进程可以继续工作，不至于整个应用挂掉，这样的例子非常多，比如 Chrome 浏览器的选项卡，比如 VSCode 编辑器运行时都会同时开启多个进程同时处理任务，其实在 spawn 创建子进程时，也可以实现子进程的独立，即子进程不再受主进程的控制和影响。 文件：process.js123456789101112const &#123; spawn &#125; = require('spawn');const path = require('path');// 创建子进程const child = spawn('node', ['sub_process.js'], &#123; cwd: path.join(__dirname, 'test'), stdio: 'ignore', detached: true&#125;);// 与主进程断绝关系child.unref(); 文件：&#126;test/sub_process.js12345const fs = require('fs');setInterval(() =&gt; &#123; fs.appendFileSync('test.txt', 'hello');&#125;); 要想创建的子进程独立，需要在创建子进程时配置 detached 参数为 true，表示该子进程不受控制，还需调用子进程的 unref 方法与主进程断绝关系，但是仅仅这样子进程可能还是会受主进程的影响，要想子进程完全独立需要保证子进程一定不能和主进程共用标准输入、标准输出和错误输出，也就是 stdio 必须设置为 ignore，这也就代表着独立的子进程是不能和主进程进行标准进程通信，即不能设置 ipc。 fork 实现多进程fork 的使用fork 也是 child_process 模块的一个方法，与 spawn 类似，是在 spawn 的基础上又做了一层封装，我们看一个 fork 使用的例子。 文件：process.js12345678910const fork = require('child_process');const path = require('path');// 创建子进程const child = fork('sub_process.js', ['--port', '3000'], &#123; cwd: path.join(__dirname, 'test'), silent: true&#125;);child.send('hello world'); 文件：&#126;test/sub_process.js12// 接收主进程发来的消息process.on('message', data =&gt; console.log(data)); fork 的用法与 spawn 相比有所改变，第一个参数是子进程执行文件的名称，第二个参数为数组，存储执行时的参数和值，第三个参数为 options，其中使用 slilent 属性替代了 spawn 的 stdio，当 silent 为 true 时，此时主进程与子进程的所有非标准通信的操作都不会生效，包括标准输入、标准输出和错误输出，当设为 false 时可正常输出，返回值依然为一个子进程。 fork 创建的子进程可以直接通过 send 方法和监听 message 事件与主进程进行通信。 fork 的原理其实 fork 的原理非常简单，只是在子进程模块 child_process 上挂了一个 fork 方法，而在该方法内调用 spawn 并将 spawn 返回的子进程作为返回值返回，下面进行简易实现。 文件：fork.js1234567891011121314151617181920const childProcess = require('child_process');const path = require('path');// 封装原理childProcess.fork = function(modulePath, args, options) &#123; let stdio = options.silent ? ['ignore', 'ignore', 'ignore', 'ipc'] : [0, 1, 2, 'ipc']; return childProcess.spawn('node', [modulePath, ...args], &#123; ...options, stdio &#125;);&#125;// 创建子进程const child = fork('sub_process.js', ['--port', '3000'], &#123; cwd: path.join(__dirname, 'test'), silent: false&#125;);// 向子进程发送消息child.send('hello world'); 文件：&#126;test/sub_process.js1234// 接收主进程发来的消息process.on('message', data =&gt; console.log(data));// hello world spawn 中的有一些 fork 没有传的参数（如使用 node 执行文件），都在内部调用 spawn 时传递默认值或将默认参数与 fork 传入的参数进行整合，着重处理了 spawn 没有的参数 silent，其实就是处理成了 spawn 的 stdio 参数两种极端的情况（默认使用 ipc 通信），封装 fork 就是让我们能更方便的创建子进程，可以更少的传参。 execFile 和 exec 实现多进程execFile 和 exec 是 child_process 模块的两个方法，execFile 是基于 spawn 封装的，而 exec 是基于 execFile 封装的，这两个方法用法大同小异，execFile 可以直接创建子进程进行文件操作，而 exec 可以直接开启子进程执行命令，常见的应用场景如 http-server 以及 weboack-dev-server 等命令行工具在启动本地服务时自动打开浏览器。 execFile 和 exec12345678910111213const &#123; execFile, exec &#125; = require('child_process');const execFileChild = execFile('node', ['--version'], (err, stdout, stderr) =&gt; &#123; if (error) throw error; console.log(stdout); console.log(stderr);&#125;);const execChild = exec('node --version', (err, stdout, stderr) =&gt; &#123; if (err) throw err; console.log(stdout); console.log(stderr);&#125;); exec 与 execFile 的区别在于传参，execFile 第一个参数为文件的可执行路径或命令，第二个参数为命令的参数集合（数组），第三个参数为 options，最后一个参数为回调函数，回调函数的形参为错误、标准输出和错误输出。 exec 在传参上将 execFile 的前两个参数进行了整合，也就是命令与命令参数拼接成字符串作为第一参数，后面的参数都与 execFile 相同。 cluster 集群开启进程需要消耗内存，所以开启进程的数量要适合，合理运用多进程可以大大提高效率，如 Webpack 对资源进行打包，就开启了多个进程同时进行，大大提高了打包速度，集群也是多进程重要的应用之一，用多个进程同时监听同一个服务，一般开启进程的数量跟 CPU 核数相同为好，此时多个进程监听的服务会根据请求压力分流处理，也可以通过设置每个子进程处理请求的数量来实现 “负载均衡”。 使用 ipc 实现集群ipc 标准进程通信使用 send 方法发送消息时第二个参数支持传入一个服务，必须是 http 服务或者 tcp 服务，子进程通过 message 事件进行接收，回调的参数分别对应发送的参数，即第一个参数为消息，第二个参数为服务，我们就可以在子进程创建服务并对主进程的服务进行监听和操作（listen 除了可以监听端口号也可以监听服务），便实现了集群，代码如下。 文件：server.js12345678910111213141516const os = require('os'); // os 模块用于获取系统信息const http = require('http');const path = require('path');const &#123; fork &#125; = rquire('child_process');// 创建服务const server = createServer((res, req) =&gt; &#123; res.end('hello');&#125;).listen(3000);// 根据 CPU 个数创建子进程os.cpus().forEach(() =&gt; &#123; fork('child_server.js', &#123; cwd: path.join(__dirname); &#125;).send('server', server);&#125;); 文件：child_server.js12345678const http = require('http');// 接收来自主进程发来的服务process.on('message', (data, server) =&gt; &#123; http.createServer((req, res) =&gt; &#123; res.end(`child$&#123;process.pid&#125;`); &#125;).listen(server); // 子进程共用主进程的服务&#125;); 上面代码中由主进程处理的请求会返回 hello，由子进程处理的请求会返回 child 加进程的 pid 组成的字符串。 使用 cluster 实现集群cluster 模块是 NodeJS 提供的用来实现集群的，他将 child_process 创建子进程的方法集成进去，实现方式要比使用 ipc 更简洁。 文件：cluster.js1234567891011121314const cluster = require('cluster');const http = require('http');const os = require('os');// 判断当前执行的进程是否为主进程，为主进程则创建子进程，否则用子进程监听服务if (cluster.isMaster) &#123; // 创建子进程 os.cpus().forEach(() =&gt; cluster.fork());&#125; else &#123; // 创建并监听服务 http.createServer((req, res) =&gt; &#123; res.end(`child$&#123;process.pid&#125;`); &#125;).listen(3000);&#125; 上面代码既会执行 if 又会执行 else，这看似很奇怪，但其实不是在同一次执行的，主进程执行时会通过 cluster.fork 创建子进程，当子进程被创建会将该文件再次执行，此时则会执行 else 中对服务的监听，还有另一种用法将主进程和子进程执行的代码拆分开，逻辑更清晰，用法如下。 文件：cluster.js1234567891011const cluster = require('cluster');const path = require('path');const os = require('os');// 设置子进程读取文件的路径cluster.setupMaster(&#123; exec: path.join(__dirname, 'cluster-server.js')&#125;);// 创建子进程os.cpus().forEach(() =&gt; cluster.fork()); 文件：cluster-server.js123456const http = require('http');// 创建并监听服务http.createServer((req, res) =&gt; &#123; res.end(`child$&#123;process.pid&#125;`);&#125;).listen(3000); 通过 cluster.setupMaster 设置子进程执行文件以后，就可以将主进程和子进程的逻辑拆分开，在实际的开发中这样的方式也是最常用的，耦合度低，可读性好，更符合开发的原则。 总结本篇着重的介绍了 NodeJS 多进程的实现方式以及集群的使用，之所以在开头长篇大论的介绍 spawn，是因为其他的所有跟多进程相关的方法包括 fork、exec 等，以及模块 cluster 都是基于 spawn 的封装，如果对 spawn 足够了解，其他的也不在话下，希望大家通过这篇可以在 NodeJS 多进程相关的开发中起到一个 “路标” 的作用。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"process","slug":"process","permalink":"https://www.pandashen.com/tags/process/"},{"name":"Cluster","slug":"Cluster","permalink":"https://www.pandashen.com/tags/Cluster/"}]},{"title":"Webpack —— tree-staking 解析","date":"2018-07-26T04:21:46.000Z","path":"2018/07/26/20180726122146/","text":"tree-sharking 简介tree-sharking 是 Webpack 2 后续版本的优化功能，顾名思义，就是将多余的代码给 “摇晃” 掉，在开发中我们经常使用一些第三方库，而这些第三方库只使用了这个库的一部门功能或代码，未使用的代码也要被打包进来，这样出口文件会非常大，tree-sharking 帮我们解决了这个问题，它可以将各个模块中没有使用的方法过滤掉，只对有效代码进行打包。 AST 语法树分析假设我们现在使用了 ElementUI 库的两个组件，通常会使用解构赋值来引入。 优化前1import &#123; Button, Alert &#125; from 'element-ui'; 这样引用资源， Webpack 在打包的时候会找到 element-ui 并把里面所有的代码全部打包到出口文件，我们只使用了两个组件，全部打包不是我们所希望的，tree-sharking 是通过在 Webpack 中配置 babel-plugin-import 插件来实现的，它可以将解构的代码转换成下面的形式。 优化后12import Button from 'element-ui/lib/button';import Alert from 'element-ui/lib/Alert'; 转化后会去 node_modules 中的 element-ui 模块找到 Button 和 Alert 两个组件对应的文件，并打包到出口文件中。 通过上面的转换可以看出，其实 tree-sharking 的实现原理是通过改变 AST 语法树的结构来实现的，如果不了解抽象语法树可以参考 AST 抽象语法树，我们可以通过在线转换网站 http://esprima.org/demo/parse.html 将 JS 代码装换成 AST 语法树。 优化前的 AST 语法树1234567891011121314151617181920212223242526272829303132333435363738&#123; \"type\": \"Program\", \"body\": [ &#123; \"type\": \"ImportDeclaration\", \"specifiers\": [ &#123; \"type\": \"ImportSpecifier\", \"local\": &#123; \"type\": \"Identifier\", \"name\": \"Button\" &#125;, \"imported\": &#123; \"type\": \"Identifier\", \"name\": \"Button\" &#125; &#125;, &#123; \"type\": \"ImportSpecifier\", \"local\": &#123; \"type\": \"Identifier\", \"name\": \"Alert\" &#125;, \"imported\": &#123; \"type\": \"Identifier\", \"name\": \"Alert\" &#125; &#125; ], \"source\": &#123; \"type\": \"Literal\", \"value\": \"element-ui\", \"raw\": \"\\\"element-ui\\\"\" &#125; &#125; ], \"sourceType\": \"module\"&#125; 优化后的 AST 语法树12345678910111213141516171819202122232425262728293031323334353637383940&#123; \"type\": \"Program\", \"body\": [ &#123; \"type\": \"ImportDeclaration\", \"specifiers\": [ &#123; \"type\": \"ImportDefaultSpecifier\", \"local\": &#123; \"type\": \"Identifier\", \"name\": \"Button\" &#125; &#125; ], \"source\": &#123; \"type\": \"Literal\", \"value\": \"element-ui/lib/button\", \"raw\": \"\\\"element-ui/lib/button\\\"\" &#125; &#125;, &#123; \"type\": \"ImportDeclaration\", \"specifiers\": [ &#123; \"type\": \"ImportDefaultSpecifier\", \"local\": &#123; \"type\": \"Identifier\", \"name\": \"Alert\" &#125; &#125; ], \"source\": &#123; \"type\": \"Literal\", \"value\": \"element-ui/lib/Alert\", \"raw\": \"\\\"element-ui/lib/Alert\\\"\" &#125; &#125; ], \"sourceType\": \"module\"&#125; 从上面的语法树对比，可以看出在优化前 body 里面只有一个对象，使用的组件信息存在 specifiers 里，source 指向了 element-ui，而在优化后，将两个组件分别拆成了两个对象存在 body 中，每个对象的的 specifiers 只存储一个组件，并在 source 里面指向了当前组件对应的路径。 模拟 tree-staking既然我们已经清楚要修改语法树的位置，下面就使用 AST 来模拟 tree-sharking 功能，对语法树的操作是依赖于 babel-core 和 babel-types 两个核心模块的，下面先安装依赖。 npm install babel-core babel-types 文件：babel-plugin-my-import.js12345678910111213141516171819202122232425262728293031323334353637383940const babel = require('babel-core');const types = require('babel-types');let code = `import &#123; Button, Alert &#125; from 'element-ui'`;const importPlugin = &#123; visitor: &#123; ImportDeclaration(path) &#123; let node = path.node; let source = node.source.value; let specifiers = node.specifiers; // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出 if (!types.isImportDefaultSpecifier(specifiers[0])) &#123; // 如果不是默认导出，则需要转换 specifiers = specifiers.map(specifier =&gt; &#123; // 数组内容：当前默认导出的标识、从哪里导入 return types.importDeclaration( [types.importDefaultSpecifier(specifier.local)], types.stringLiteral( `$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;` ) ); &#125;); // 替换树结构 path.replaceWithMultiple(specifiers); &#125; &#125; &#125;&#125;;let result = babel.transform(code, &#123; plugins: [importPlugin]&#125;);console.log(result.code);// import Button from 'element-ui/lib/button';// import Alert from 'element-ui/lib/alert'; 通过上面的代码可以发现我们使用 babel-core 和 babel-types 两个模块的核心方法对语法书进行了遍历、修改和替换，更详细的 API 可以查看 https://github.com/babel/babel/tree/6.x/packages/babel-types。 结合 Webpack 使用插件前面只是验证了 tree-sharking 中 JS 语法的转换过程，接下来将上面的代码转换成插件配合 Webpack 使用，来彻底感受 tree-sharking 的工作过程。 文件：&#126;node_modules/babel-plugin-my-import.js12345678910111213141516171819202122232425262728293031const babel = require('babel-core');const types = require('babel-types');const importPlugin = &#123; visitor: &#123; ImportDeclaration(path) &#123; let node = path.node; let source = node.source.value; let specifiers = node.specifiers; // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出 if (!types.isImportDefaultSpecifier(specifiers[0])) &#123; // 如果不是默认导出，则需要转换 specifiers = specifiers.map(specifier =&gt; &#123; // 数组内容：当前默认导出的标识、从哪里导入 return types.importDeclaration( [types.importDefaultSpecifier(specifier.local)], types.stringLiteral( `$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;` ) ); &#125;); // 替换树解构 path.replaceWithMultiple(specifiers); &#125; &#125; &#125;&#125;;module.exports = importPlugin; 上面删掉了多余的测试代码，将模块中的 importPlugin 插件导出，并把 babel-plugin-my-import.js 移入了 node_modules 当中。 接下来安装需要的依赖： npm install webpack webpack-cli babel-loader babel-presets-env npm install vue element-ui --save 安装完依赖，写一个要编译的文件，使用 Webpack 进行打包，查看使用插件前和使用插件后出口文件的大小。 文件：import.js12import Vue from 'vue';import &#123; Button, Alert &#125; from 'element-ui'; 下面来写一个简单的 Webpack 配置文件。 文件：webpcak.config.js1234567891011121314151617181920212223242526module.exports = &#123; mode: 'development', entry: 'import.js', output: &#123; filename: 'bundle.js', path: __dirname &#125;, module: &#123; rules: [&#123; test: /\\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ 'env', ], plugins: [ // 插件：不使用插件打包注释掉该行即可 ['my-import', &#123; libararyName: 'element-ui' &#125;] ] &#125; &#125;, exclude: /node_modules/ &#125;] &#125;&#125;; 为了防止 babel 相关的依赖升级 7.0 后出现一些问题导致 Webpack 无法启动，再此贴出 package.json 文件，按照对应版本下载依赖保证上面 Webpack 配置生效。 文件：package.json123456789101112131415161718192021222324252627&#123; \"name\": \"ast-lesson\", \"version\": \"1.0.0\", \"description\": \"tree-staking\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-preset-env\": \"^1.7.0\", \"babel-types\": \"^6.26.0\", \"escodegen\": \"^1.10.0\", \"esprima\": \"^4.0.0\", \"estraverse\": \"^4.2.0\", \"webpack\": \"^4.16.0\", \"webpack-cli\": \"^3.0.8\" &#125;, \"devDependencies\": &#123; \"vue\": \"^2.5.17\", \"element-ui\": \"^2.4.6\" &#125;&#125; 对比使用插件前后的出口文件接下来分别在使用插件和不使用插件时执行打包命令，查看出口文件 bondle.js 的大小。 npx webpack 使用 babel-plugin-my-import 前： 使用 tree-staking 之前 使用 babel-plugin-my-import 后： 使用 tree-staking 之后 通过对比，可以看到使用 tree-sharking 即我们自己实现的 babel-plugin-my-import 插件后，打包的出口文件大大减小，其原因是将引入第三方库没有使用的代码全都过滤掉了，只打包了有效代码。 总结上面对 Webpack 的 tree-sharking 进行了分析，并模拟 babel-plugin-import 简易的实现了一版 tree-sharking 的优化插件，这个过程中相信大家已经了解了 tree-sharking 的原理以及实现类似插件的思路，并已经具备了开发类似插件的基本条件，最后还有一点需要补充，tree-sharking 优化的方式是根据 ES6 语法 import “静态” 引入的特性实现的，如果要说 tree-sharking 很强大，还不如说 ES6 模块化规范 “静态” 引入的特性强大，正由于是基于 “静态” 引入，所以目前 tree-sharking 只支持遍历一层 import 关键字。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"Babel","slug":"Babel","permalink":"https://www.pandashen.com/tags/Babel/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.pandashen.com/tags/Webpack/"},{"name":"AST","slug":"AST","permalink":"https://www.pandashen.com/tags/AST/"},{"name":"tree-staking","slug":"tree-staking","permalink":"https://www.pandashen.com/tags/tree-staking/"}]},{"title":"AST 抽象语法树","date":"2018-07-25T05:02:33.000Z","path":"2018/07/25/20180725130233/","text":"AST 抽象语法树简介AST（Abstract Syntax Tree）是源代码的抽象语法结构树状表现形式，Webpack、ESLint、JSX、TypeScript 的编译和模块化规则之间的转化都是通过 AST 来实现对代码的检查、分析以及编译等操作。 JavaScript 语法的 AST 语法树JavaScript 中想要使用 AST 进行开发，要知道抽象成语法树之后的结构是什么，里面的字段名称都代表什么含义以及遍历的规则，可以通过 http://esprima.org/demo/parse.html 来实现 JavaScript 语法的在线转换。 通过在线编译工具，可以将 function fn(a, b) {} 编译为下面的结构。 123456789101112131415161718192021222324252627282930&#123; \"type\": \"Program\", \"body\": [ &#123; \"type\": \"FunctionDeclaration\", \"id\": &#123; \"type\": \"Identifier\", \"name\": \"fn\" &#125;, \"params\": [ &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, &#123; \"type\": \"Identifier\", \"name\": \"b\" &#125; ], \"body\": &#123; \"type\": \"BlockStatement\", \"body\": [] &#125;, \"generator\": false, \"expression\": false, \"async\": false &#125; ], \"sourceType\": \"script\"&#125; 将 JavaScript 语法编译成抽象语法树后，需要对它进行遍历、修该并重新编译，遍历树结构的过程为 “先序深度优先”。 esprima、estraverse 和 escodegenesprima、estraverse 和 escodegen 模块是操作 AST 的三个重要模块，也是实现 babel 的核心依赖，下面是分别介绍三个模块的作用。 esprima 将 JS 转换成 ASTesprima 模块的用法如下： 文件：esprima-test.js123456789101112131415161718192021const esprima = require('esprima');let code = 'function fn() &#123;&#125;';// 生成语法树let tree = esprima.parseScript(code);console.log(tree);// Script &#123;// type: 'Program',// body:// [ FunctionDeclaration &#123;// type: 'FunctionDeclaration',// id: [Identifier],// params: [],// body: [BlockStatement],// generator: false,// expression: false,// async: false &#125; ],// sourceType: 'script' &#125; 通过上面的案例可以看出，通过 esprima 模块的 parseScript 方法将 JS 代码块转换成语法树，代码块需要转换成字符串，也可以通过 parseModule 方法转换一个模块。 estraverse 遍历和修改 AST查看遍历过程： 文件：estraverse-test.js1234567891011121314151617181920212223const esprima = require('esprima');const estraverse = require('estraverse');let code = 'function fn() &#123;&#125;';// 遍历语法树estraverse.traverse(esprima.parseScript(code), &#123; enter(node) &#123; console.log('enter', node.type); &#125;, leave() &#123; console.log('leave', node.type); &#125;&#125;);// enter Program// enter FunctionDeclaration// enter Identifier// leave Identifier// enter BlockStatement// leave BlockStatement// leave FunctionDeclaration// leave Program 上面代码通过 estraverse 模块的 traverse 方法将 esprima 模块转换的 AST 进行了遍历，并打印了所有的 type 属性并打印，每含有一个 type 属性的对象被叫做一个节点，修改是获取对应的类型并修改该节点中的属性即可。 其实深度遍历 AST 就是在遍历每一层的 type 属性，所以遍历会分为两个阶段，进入阶段和离开阶段，在 estraverse 的 traverse 方法中分别用参数指定的 entry 和 leave 两个函数监听，但是我们一般只使用 entry。 escodegen 将 AST 转换成 JS下面的案例是一个段 JS 代码块被转换成 AST，并将遍历、修改后的 AST 重新转换成 JS 的全过程。 文件：escodegen-test.js1234567891011121314151617181920212223242526const esprima = require('esprima');const estraverse = require('estraverse');const escodegen = require('escodegen');let code = 'function fn() &#123;&#125;';// 生成语法树let tree = esprima.parseScript(code);// 遍历语法树estraverse.traverse(tree, &#123; enter(node) &#123; // 修改函数名 if (node.type === 'FunctionDeclaration') &#123; node.id.name = 'ast'; &#125; &#125;&#125;);// 编译语法树let result = escodegen.generate(tree);console.log(result);// function ast() &#123;// &#125; 在遍历 AST 的过程中 params 值为数组，没有 type 属性。 实现 Babel 语法转换插件实现语法转换插件需要借助 babel-core 和 babel-types 两个模块，其实这两个模块就是依赖 esprima、estraverse 和 escodegen 的。 使用这两个模块需要安装，命令如下： npm install babel-core babel-types plugin-transform-arrow-functionsplugin-transform-arrow-functions 是 Babel 家族成员之一，用于将箭头函数转换 ES5 语法的函数表达式。 文件：plugin-transform-arrow-functions.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const babel = require('babel-core');const types = require('babel-types');// 箭头函数代码块let sumCode = `const sum = (a, b) =&gt; &#123; return a + b;&#125;`;let minusCode = `const minus = (a, b) =&gt; a - b;`;// 转化 ES5 插件const ArrowPlugin = &#123; // 访问者（访问者模式） visitor: &#123; // path 是树的路径 ArrowFunctionExpression(path) &#123; // 获取树节点 let node = path.node; // 获取参数和函数体 let params = node.params; let body = node.body; // 判断函数体是否是代码块，不是代码块则添加 return 和 &#123;&#125; if (!types.isBlockStatement(body)) &#123; let returnStatement = types.returnStatement(body); body = types.blockStatement([returnStatement]); &#125; // 生成一个函数表达式树结构 let func = types.functionExpression(null, params, body, false, false); // 用新的树结构替换掉旧的树结构 types.replaceWith(func); &#125; &#125;&#125;;// 生成转换后的代码块let sumResult = babel.transform(sumCode, &#123; plugins: [ArrowPlugin]&#125;);let minusResult = babel.transform(minusCode, &#123; plugins: [ArrowPlugin]&#125;);console.log(sumResult.code);console.log(minusResult.code);// let sum = function(a, b) &#123;// return a + b;// &#125;;// let minus = function(a, b) &#123;// return a - b;// &#125;; 我们主要使用 babel-core 的 transform 方法将 AST 转化成代码块，第一个参数为转换前的代码块（字符串），第二个参数为配置项，其中 plugins 值为数组，存储修改 babal-core 转换的 AST 的插件（对象），使用 transform 方法将旧的 AST 处理成新的代码块后，返回值为一个对象，对象的 code 属性为转换后的代码块（字符串）。 内部修改通过 babel-types 模块提供的方法实现，API 可以到 https://github.com/babel/babel/tree/6.x/packages/babel-types 中查看。 ArrowPlugin 就是传入 transform 方法的插件，必须含有 visitor 属性（固定），值同为对象，用于存储修改语法树的方法，方法名要严格按照 API，对应的方法会修改 AST 对应的节点。 在 types.functionExpression 方法中参数分别代表，函数名（匿名函数为 null）、函数参数（必填）、函数体（必填）、是否为 generator 函数（默认 false）、是否为 async 函数（默认 false），返回值为修改后的 AST，types.replaceWith 方法用于替换 AST，参数为新的 AST。 plugin-transform-classesplugin-transform-classes 也是 Babel 家族中的成员之一，用于将 ES6 的 class 类转换成 ES5 的构造函数。 文件：plugin-transform-classes.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111const babel = require('babel-core');const types = require('babel-types');// 类let code = `class Person &#123; constructor(name) &#123; this.name = name; &#125; getName () &#123; return this.name; &#125;&#125;`;// 将类转化 ES5 构造函数插件const ClassPlugin = &#123; visitor: &#123; ClassDeclaration(path) &#123; let node = path.node; let classList = node.body.body; // 将取到的类名转换成标识符 &#123; type: 'Identifier', name: 'Person' &#125; let className = types.identifier(node.id.name); let body = types.blockStatement([]); let func = types.functionDeclaration( className, [], body, false, false ); path.replaceWith(func); // 用于存储多个原型方法 let es5Func = []; // 获取 class 中的代码体 classList.forEach((item, index) =&gt; &#123; // 函数的代码体 let body = classList[index].body; // 获取参数 let params = item.params.length ? item.params.map(val =&gt; val.name) : []; // 转化参数为标识符 params = types.identifier(params); // 判断是否是 constructor，如果构造函数那就生成新的函数替换 if (item.kind === 'constructor') &#123; // 生成一个构造函数树结构 func = types.functionDeclaration( className, [params], body, false, false ); &#125; else &#123; // 其他情况是原型方法 let proto = types.memberExpression( className, types.identifier('prototype') ); // 左侧层层定义标识符 Person.prototype.getName let left = types.memberExpression( proto, types.identifier(item.key.name) ); // 右侧定义匿名函数 let right = types.functionExpression( null, [params], body, false, false ); // 将左侧和右侧进行合并并存入数组 es5Func.push(types.assignmentExpression('=', left, right)); &#125; &#125;); // 如果没有原型方法，直接替换 if (es5Func.length === 0) &#123; path.replaceWith(func); &#125; else &#123; es5Func.push(func); // 替换 n 个节点 path.replaceWithMultiple(es5Func); &#125; &#125; &#125;&#125;;// 生成转换后的代码块result = babel.transform(code, &#123; plugins: [ClassPlugin]&#125;);console.log(result.code);// Person.prototype.getName = function() &#123;// return this.name;// &#125;// function Person(name) &#123;// this.name = name;// &#125; 上面这个插件的实现要比 plugin-transform-arrow-functions 复杂一些，归根结底还是将要互相转换的 ES6 和 ES5 语法树做对比，找到他们的不同，并使用 babel-types 提供的 API 对语法树对应的节点属性进行修改并替换语法树，值得注意的是 path.replaceWithMultiple 与 path.replaceWith 不同，参数为一个数组，数组支持多个语法树结构，可根据具体修改语法树的场景选择使用，也可根据不同情况使用不同的替换方法。 总结通过本节我们了解了什么是 AST 抽象语法树、抽象语法树在 JavaScript 中的体现以及在 NodeJS 中用于生成、遍历和修改 AST 抽象语法树的核心依赖，并通过使用 babel-core 和 babel-types 两个模块简易模拟了 ES6 新特性转换为 ES5 语法的过程，希望可以为后面自己实现一些编译插件提供了思路。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"Babel","slug":"Babel","permalink":"https://www.pandashen.com/tags/Babel/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.pandashen.com/tags/Webpack/"},{"name":"AST","slug":"AST","permalink":"https://www.pandashen.com/tags/AST/"}]},{"title":"命令行工具 —— 手写类似 http-server 的静态服务器","date":"2018-07-22T03:01:47.000Z","path":"2018/07/22/20180722110147/","text":"前言npm 里有个 http-server 的模块，是一个简单的、零配置的 HTTP 服务，它非常强大，同时非常简单，可以方便的帮助我们开启本地服务器，以及局域网共享，可以用来做测试，开发，学习时的环境配置，我们本节就模拟 http-server 实现一个自己的启动本地服务的命令行工具。 http-server 使用http-server 服务器通过命令行启动，使用时需要安装，安装命令如下： npm install http-server -g 启动本地服务器时在根目录下执行下面命令即可： http-server [path] [option] path 默认情况下是 ./public，否则是 ./，启动后可以通过 http://localhost:8080 来访问服务器，options 为其他参数， npm 官方文档 https://www.npmjs.com/package/http-server 有详细说明。 当通过浏览器访问 http://localhost:8080 以后，会将我们服务器根目录的目录结构显示在浏览器页面上，当点击文件夹时，可以继续显示内部的文件和文件夹，当点击文件时会直接通过服务器访问文件，并将文件内容显示在浏览器页面上。 实现命令行工具依赖的模块chalk 模块chalk 模块是用来控制命令行输出的文字颜色的第三方模块，使用前需要安装，安装命令如下： npm install chalk chalk 模块的用法如下，模块支持的颜色和更多的 API 可以在 npm 官方文档 https://www.npmjs.com/package/chalk 中查看。 文件位置：&#126;static/tests/staticchalk-test.js12345const chalk = require('chalk');// 在命令行打印绿色和红色的 helloconsole.log(chalk.green('hello'));console.log(chalk.red('hello')); 在命令行窗口输入 node chalk-test.js 查看命令行打印 hello 的颜色。 debug 模块debug 模块可以匹配当前环境变量 DEBUG 的值并输出相关信息，作用在于命令行工具可以根据不同情况输出的信息进行调试，是第三方模块，使用前需安装，命令如下。 npm install debug debug 的简单使用如下，如果想了解更详细的 API 可以在 npm 官方文档 https://www.npmjs.com/package/debug 中查看。 文件位置：&#126;static/tests/debug-test1.js —— 用法 1123const debug = require('debug')('hello');debug('hi panda'); 当我们在命令行中执行 node debug-test1.js 时发现命令窗口什么也没有打印，那是因为当前根目录的环境变量 DEBUG 的值必须和我们设置的 hello 相匹配才会打印相关信息。 设置环境变量，Window 可以通过 set DEBUG=hello 设置，Mac 可以通过 export DEBUG=hello 设置，设置环境变量后再次执行 node debug-test.js，我们会发现命令行打印出了下面内容。 hello hi panda +0ms 其中 hello 为我们设置 DEBUG 环境变量的值，hi panda 为调试方法 debug 方法打印的信息，+0ms 为距离上次执行的间隔时间。 文件位置：&#126;static/tests/debug-test2.js —— 用法 212345const debugA = require('debug')('hello:a');const debugB = require('debug')('hello:b');debugA('hi panda');debugB('hello panda'); 上面的代码目的是可以让我们不同的 debug 方法可以匹配不同的环境变量，所以需要重新将环境变量的值设置为 hello:*，这样再次执行 node debug-test2.js 发现命令窗口打印了如下内容。 hello:a hi panda +0mshello:b hello panda +0ms 使用 debug 的好处就是可以在开发的时候打印一些调试用的信息，在开发完成后因为匹配不到环境变量，这些信息就会被隐藏。 commander 模块commander 是著名的 Node 大神 TJ 的 “作品”，是一个开发命令行工具的解决方案，提供了用户命令行输入和参数解析的强大功能，commander 是第三方模块，使用时需要安装，命令如下。 npm install commander 基本用法如下： 文件位置：&#126;static/tests/commander-test1.js1234const commander = require('commander');// 解析 Node 进程执行时的参数commander.version('1.0.0').parse(process.argv); 上面文件中 version 方法代表当前执行文件模块的版本，parse 为解析参数为当前命令行进程参数的方法，process.argv 为参数集合（数组），第一个参数为执行的 node.exe 文件的绝对路径，第二个参数为当前执行文件的绝对路径，后面为通过命令行传入的参数，如 --host、--port 等。 在命令行执行 node commander-test.js --help 时默认会在命令行输出如下信息： Usage: [options]Options:&emsp;&emsp; -V, --version output the version number&emsp;&emsp; -h, --help output usage information 当然在我们的命令行工具中，参数不只 --version 和 --help 两个，我们更希望更多的参数更多的功能，并且可定制的描述信息，使用案例如下。 文件位置：&#126;static/tests/commander-test2.js1234567891011121314const commander = require('commander');// 解析 Node 进程执行时的参数commander .version('1.0.0') .usage('[options]') .option('-p, --port &lt;n&gt;', 'server port') .option('-o, --host &lt;n&gt;', 'server host') .option('-d, --dir &lt;n&gt;', 'server dir') .parse(process.argv);console.log(commander.port); // 3000console.log(commander.host); // localhostconsole.log(commander.dir); // public 在执行命令 node commander-test2.js --help 后会在命令窗口输出如下信息： Usage: yourname-http-server [options]Options:&emsp;&emsp; -V, --version output the version number&emsp;&emsp; -p, --port server port&emsp;&emsp; -o, --host server host&emsp;&emsp; -d, --dir server dir&emsp;&emsp; -h, --help output usage information usage 方法可以让我们详细的定制参数的类型和描述，option 方法可以让我们添加执行 --help 指令时打印的命令以及对应的描述信息。 执行下面命令： node commander-test2.js --port 3000 --host localhost --dir public 执行命令后我们发现其实给我们的参数挂在了 commander 对象上，方便我们取值。 在我们使用别人的命令行工具时会发现在上面输出信息的时候经常会在下面输出 How to use 的列表，更详细的描述了每条命令的作用及用法。 文件位置：&#126;static/tests/commander-test3.js123456789101112131415161718let commander = require('commander');// 必须写到 parse 方法的前面commander.on('--help', function() &#123; console.log('\\r\\n How to use:') console.log(' yourname-http-server --port &lt;val&gt;'); console.log(' yourname-http-server --host &lt;val&gt;'); console.log(' yourname-http-server --dir &lt;val&gt;');&#125;);// 解析 Node 进程执行时的参数commander .version('1.0.0') .usage('[options]') .option('-p, --port &lt;n&gt;', 'server port') .option('-o, --host &lt;n&gt;', 'server host') .option('-d, --dir &lt;n&gt;', 'server dir') .parse(process.argv); 再次执行命令 node commander-test2.js --help 后会在命令窗口输出如下信息： Usage: yourname-http-server [options]Options:&emsp;&emsp; -V, --version output the version number&emsp;&emsp; -p, --port server port&emsp;&emsp; -o, --host server host&emsp;&emsp; -d, --dir server dir&emsp;&emsp; -h, --help output usage informationHow to use:&emsp;&emsp; yourname-http-server --port &emsp;&emsp; yourname-http-server --host &emsp;&emsp; yourname-http-server --dir 以上是 commander 模块的基本用法，如想了解更详细的 API 和使用案例可以到 npm 官方文档查看，地址如下 https://www.npmjs.com/package/commander 。 实现静态服务的功能文件目录static |- bin | |- yourname-http-server.js |- public | |- css | | |- style.css | |- index.html | |- 1.txt |- tests | |- chalk-test.js | |- commander-test1.js | |- commander-test2.js | |- commander-test3.js | |- debug-test1.js | |- debug-test2.js |- config.js |- index.html |- index.js |- package-lock.json |- package.json 配置文件在启动静态服务的时候，我们希望可以通过命令行传参的形式来定义当前启动服务的主机名端口号，以及默认检索的文件根目录，所以需要配置文件来实现灵活传参。 文件位置：&#126;static/config.js12345module.exports = &#123; port: 3000, host: 'localhost', dir: process.cwd()&#125; 在上面的配置中，默认端口号为 3000，默认主机名为 localhost，我们设置默认检索文件的根目录为通过命令行启动服务器的目录，而 process.cwd() 的值就是我们启动命令行执行命令的目录的绝对路径。 创建服务器 Server 类因为我们的命令行工具启动本地服务可能是在系统的任意位置，或者指定启动服务访问的域，提高可配置性，并且要更方便给服务器扩展更多的方法处理不同的逻辑，所以需要创建一个 Server 类。 文件位置：&#126;static/index.js —— Server 类的创建1234567891011121314151617181920212223// 引入依赖const http = require('http');const url = require('url');const path = require('path');const fs = require('mz/fs');const mime = require('mime');const zlib = require('zlib');const chalk = require('chalk');const ejs = require('ejs');const debug = require('debug')('http:a');// 引入配置文件const config = require('./config');// 读取模板文件const templateStr = fs.readFileSync(path.join(__dirname, 'index.html'), 'utf8');class Server &#123; constructor() &#123; this.config = config; // 配置 this.template = templateStr; // 模板 &#125;&#125; 我们在上面代码中引入了 config.js 配置文件，读取了用于启动服务后展示页面 index.html 的内容，并都挂在了 Server 类的实例上，目的是方便内部的方法使用以及达到不轻易操作全局变量的目的。 启动服务器的 start 方法后面为了方便代码的拆分，我们将原型上的方法统一使用 Server.prototype.xxx 的方式来书写，实际的案例都是写在 Server 类里面的。 文件位置：&#126;static/index.js —— start 方法123456789101112Server.prototype.start = function() &#123; // 创建服务 const server = http.createServer(this.handleRequest.bind(this)); // 从配置中解构端口号和主机名 let &#123; port, host &#125; = this.config; // 启动服务 server.listen(port, host, () =&gt; &#123; debug(`server start http://$&#123;host&#125;:$&#123;chalk.green(port)&#125;`); &#125;);&#125; 在 start 方法中创建了服务，在启动服务时只需要创建 Server 的实例并调用 start 方法，由于服务的回调中会处理很多请求响应的逻辑，会导致 start 方法的臃肿，所以将服务的回调函数抽取成 Server 类的一个实例方法 handleRequest，需要注意的是 handleRequest 内部的 this 指向需要我们修正。 在启动服务时我们根据配置可以灵活的设置服务的地址，当设置 host 后，服务将只能通过 host 的值作为主机名的地址访问静态服务器，启动服务的提示我们通过匹配环境变量 DEBUG 的 debug 方法来打印，并将端口号设置成绿色。 服务回调 handleRequest 方法在实现 handleRequest 之前我们应该了解要实现的功能，在 http-server 中，如果访问的服务地址路径后面指定具体要访问的文件，并且当前启动服务根目录按照访问路径可以查找到文件，将文件内容读取后响应给客户端，如果没指定文件，应该检索当前启动服务根目录或默认设置的目录结构，并将文件的结构通过模板渲染成超链接后将页面响应给客户端，再次点击页面的上的链接，如果是文件，直接读取并响应文件内容，如果是文件夹，则继续检索内部结构通过模板渲染成页面。 文件位置：&#126;static/index.js —— handleRequest 方法12345678910111213141516171819202122232425Server.prototype.handleRequest = async function(req, res) &#123; // 获取访问的路径，默认为 / this.pathname = url.parse(req.url, true).pathname; // 将访问的路径名转换成绝对路径，取到的 dir 就是绝对路径 this.realPath = path.join(this.config.dir, this.pathname); debug(realPath); // 打印当前访问的绝对路径，用于调试 try &#123; // 获取 statObj 对象，如果 await 同步使用 try...catch 捕获非法路径 let statObj = await fs.stat(this.realPath); if (statObj.isFile()) &#123; // 如果是文件，直接返回文件内容 this.sendFile(req, res, statObj); &#125; else &#123; // 如果是文件夹则检索文件夹通过模板渲染后返回页面 this.sendDirDetails(req, res, statObj); &#125; &#125; catch (e) &#123; // 如果路径非法，发送错误响应 this.sendError(req, res, e); &#125;&#125; handleRequest 由于内部需要使用异步操作获取 statObj 对象，所以我们使用了 async 函数，为了函数内部可以使用 await 避免异步回调嵌套，由于 await 会等待到异步执行完毕后继续向下执行，我们可以使用 try...catch... 捕获非法的访问路径，并做出错误响应。 如果路径合法，我们需要检测访问路径对应的是文件还是文件夹，如果是文件则执行响应内容的逻辑，是文件夹执行检索文件夹渲染内部文件列表返回页面的逻辑。 所以我们将错误处理逻辑、响应文件内容逻辑和返回文件夹详情页面的逻辑分别抽离成 Server 类的三个实例方法 sendError、sendFile 和 sendDirDetails，使得 handleRequest 方法逻辑清晰且不那么臃肿。 错误响应 sendError 方法在服务器处理不同的请求和响应时可能需要处理不同的错误，这些错误的不同就是捕获错误对象的不同，所以我们的 sendError 方法为了更方便的或取请求参数、处理响应以及更好的复用，将参数设置为请求对象、响应对象和错误对象。 文件位置：&#126;static/index.js —— sendError 方法12345678Server.prototype.sendError = function(req, res, err) &#123; // 打印错误对象，方便调试 console.log(chalk.red(err)); // 设置错误状态码并响应 Not Found res.statusCode = 404; res.end('Not Found');&#125; 渲染目录 sendDirDetails 方法在渲染文件夹详情之前我们首先要做的就是异步读取文件目录，所以我们同样使用 async 函数来实现，NodeJS 中有很多渲染页面的模板，我们本次使用 ejs，语法简单，比较常用，ejs 为第三方模块，使用前需安装，更详细的用法可参照 npm 官方文档 https://www.npmjs.com/package/ejs。 npm install ejs sendDirDetails 的参数为请求对象、响应对象和 statObj。 文件位置：&#126;static/index.js —— sendDirDetails 方法1234567891011121314151617Server.prototype.sendDirDetails = async function(req, res, statObj) &#123; // 读取当前文件夹 let dirs = await fs.readdir(this.realPath); // 构造模板需要的数据 dirs = dirs.map(dir =&gt; (&#123; name: dir, path: path.join(this.pathname, dir) &#125;)); // 渲染模板 let pageStr = ejs.render(this.template, &#123; dirs &#125;); // 响应客户端 res.setHeader('Content-Type', 'text/html;charset=utf8'); res.end(pageStr);&#125; 还记得 Server 类的实例属性 template 存储的就是我们的模板（字符串），里面写的就是 ejs 的语法，我们使用 ejs 模块渲染的 render 方法可以将模板中的 JS 执行，并用传给该方法的参数的值替换掉模板中的变量，返回新的字符串，我们直接将字符串响应给客户端即可。 注意：在构建模板数据的时候 path 为超链接标签要跳转的路径，如果直接使用 dir 的值，多级访问还是会在根目录去查找，所以路径非法会返回 Not Found，我们需要在每次访问的时候都将上一次访问的路径与当前访问的文件夹或文件名进行拼接，保证路径的正确性。 ejs 模板 index.html上面已经知道了该怎样使用 ejs 对模板进行渲染，也对模板构造了数据，接下来就是使用 ejs 的语法编写我们的模板内容。 文件位置：&#126;static/index.html —— 模板1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Server&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%dirs.forEach(function(item) &#123;%&gt; &lt;li&gt;&lt;a href=\"&lt;%=item.path%&gt;\"&gt;&lt;%=item.name%&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;)%&gt;&lt;/body&gt;&lt;/html&gt; 模板中 JS 逻辑使用 &lt;% %&gt; 包裹，使用 &lt;%= %&gt; 输出变量。 返回文件内容 sendFile 方法由于都是根据路径查找或操作文件目录并做出响应，sendFile 方法与 sendDirDetails 方法的参数相同，分别为 req、res 和 statObj。 文件位置：&#126;static/index.js —— sendFile 方法1234567891011121314151617181920212223242526Server.prototype.sendFile = function(req, res, statObj) &#123; // 设置和处理缓存 if (this.cache(req, res, statObj)) &#123; res.statusCode = 304; return res.end(); &#125; // 创建可读流 let rs = fs.createReadStream(this.realPath); // 响应文件类型 res.setHeader( 'Content-Type', `$&#123;mime.getType(this.realPath)&#125;;charset=utf8` ); // 压缩 let zip = this.compress(req, res, statObj); if (zip) return rs.pipe(zip).pipe(res); // 处理范围请求 if (this.range(req, res, statObj)) return; // 响应文件内容 rs.pipe(res);&#125; 其实上面的方法通过在根目录执行 node index.js 启动服务后，通过我们默认配置的地址访问服务器，表面上就已经实现了 http-server 的功能，但是我们为了服务器的性能和功能更强大，又在这基础上实现了缓存策略、服务器压缩和处理范围请求的逻辑。 如果对缓存策略、服务器压缩和范围请求不了解可以看下面三篇文章： HTTP 缓存的那些事儿 NodeJS 服务器实现 gzip 压缩 NodeJS 使用 Range 请求实现下载功能 我们将上面的三个功能分别抽离成了 Server 类的三个原型方法，cache、compress 和 range，并且这三个方法的参数都为 req、res 和 statObj。 缓存策略 cache 方法我们本次的缓存兼容 HTTP 1.0 和 HTTP 1.1 版本，并且同时使用强制缓存和协商缓存共同存在的策略。 文件位置：&#126;static/index.js —— cache 方法12345678910111213141516171819202122232425Server.prototype.cache = function(req, res, statObj) &#123; // 创建协商缓存标识 let etag = statObj.ctime.toGMTString() + statObj.size; let lastModified = statObj.ctime.toGMTString(); // 设置强制缓存 res.setHeader('Cache-Control', 'max-age=30'); res.setHeader('Expires', new Date(Date.now() + 30 * 1000).toUTCString()); // 设置协商缓存 res.setHeader('Etag', etag); res.setHeader('Last-Modified', lastModified); // 获取协商缓存请求头 let &#123; 'if-none-match': ifNodeMatch, 'if-modified-since': ifModifiedSince &#125; = req.headers; if (etag !== ifNodeMatch &amp;&amp; lastModified !== ifModifiedSince) &#123; return false; &#125; else &#123; return true; &#125;&#125; 我们使用的缓存策略为同时设置强制缓存和协商缓存，当强制缓存有效期内再次请求不会访问服务器，待强制缓存过期再次请求执行协商缓存策略，带标识访问服务器进行确认，确认的同时重新设置强制缓存和协商缓存的响应头信息，如果协商缓存任然生效，则直接返回 304 状态码，如果协商缓存失效则读取文件内容返回浏览器。 服务器压缩 compress 方法为了减少文件数据在传输过程中消耗的流量和时间，我们在浏览器支持解压的情况下使用服务器压缩功能，浏览器会在请求时默认发送请求头 Accept-Encoding 通知我们的服务器当前支持的压缩格式，我们要做的就是按照压缩格式的优先级进行匹配，按照最高优先级的压缩格式进行压缩，将压缩后的数据返回，并通过响应头 Content-Encoding 通知浏览器当前的压缩格式（压缩流的本质为转化流）。 文件位置：&#126;static/index.js —— compress 方法123456789101112131415Server.prototype.compress = function(req, res, statObj) &#123; // 获取浏览器支持的压缩格式 let encoding = req.headers['accept-encoding']; // 支持 gzip 使用 gzip 压缩，支持 deflate 使用 deflate 压缩 if (encoding &amp;&amp; encoding.match(/\\bgzip\\b/)) &#123; res.setHeader('Content-Encoding', 'gzip'); return zlib.createGzip(); &#125; else if (encoding &amp;&amp; encoding.match(/\\bdeflate\\b/)) &#123; res.setHeader('Content-Encoding', 'deflate'); return zlib.createDeflate(); &#125; else &#123; return false; // 不支持压缩返回 false &#125;&#125; 当浏览器支持压缩时，compress 方法返回的为优先级最高压缩格式的压缩流，不支持返回 false，存在压缩流，则将数据压缩并响应浏览器，与不压缩响应不同的是，需要使用压缩流将可读流转化为可写流写入响应 res 中，所以可读流执行了两次 pipe 方法。 处理范围请求 range 方法range 方法处理的场景为客户端发送请求只想获取文件的某个范围的数据，此时通过 range 方法读取文件范围对应的内容响应给客户端，通过响应头 Accept-Ranges 通知浏览器当前响应范围请求，通过响应头 Content-Range 通知客户端响应的范围以及文件的总字节数。 文件位置：&#126;static/index.js —— range 方法1234567891011121314151617181920212223Server.prototype.range = function(req, res, statObj) &#123; // 获取 range 请求头 let range = req.headers['range']; if (range) &#123; // 获取范围请求的开始和结束位置 let [, start, end] = range.match(/(\\d*)-(\\d*)/); // 处理请求头中范围参数不传的问题 start = start ? ParseInt(start) : 0; end = end ? ParseInt(end) : statObj.size - 1; // 设置范围请求响应 res.statusCode = 206; res.setHeader('Accept-Ranges', 'bytes'); res.setHeader('Content-Range', `bytes $&#123;start&#125;-$&#123;end&#125;/$&#123;statObj.size&#125;`); fs.createReadStream(this.realPath, &#123; start, end &#125;).pipe(res); return true; &#125; else &#123; return false; &#125;&#125; range 方法默认返回值为布尔值，当不是范围请求时返回值为 false，则直接向下执行 sendFile 中的代码，正常读取文件全部内容并响应给浏览器，如果是范围请求则会处理范围请求后在直接结束后返回 true，会在 sendFile 中直接 return，不再向下执行。 将静态服务器关联到命令行命令行启动服务器http-server 实际上是通过命令行启动、并传参的，我们需要将我们的程序与命令行关联，关联命令行只需以下几个步骤。 首先，在根目录 package.json 文件中加入 bin 字段，值为对象，对象内属性为命令名称，值为对应执行文件的路径。 文件位置：&#126;static/package.json1234567891011121314151617181920212223&#123; \"name\": \"yourname-http-server\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"dependencies\": &#123; \"chalk\": \"^2.4.1\", \"commander\": \"^2.17.1\", \"debug\": \"^3.1.0\", \"ejs\": \"^2.6.1\", \"mime\": \"^2.3.1\", \"mz\": \"^2.7.0\" &#125;, \"bin\": &#123; \"yourname-http-server\": \"bin/yourname-http-server.js\" &#125;, \"devDependencies\": &#123;&#125;, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 其次，在 yourname-http-server.js 文件中首行加入注释 #! /usr/bin/env node，在命令行执行命令时，默认会以 Node 执行 yourname-http-server.js 文件。 最后，想要使用我们的命令启动 yourname-http-server.js 文件，则需要将这条命令连接到全局（与 -g 安装效果相同），在当前根目录下执行以下命令。 npm link 当在命令行执行 yourname-http-server 时，Node 会默认执行 yourname-http-server.js 文件。 命令行的参数传递我们现在知道在命令行执行命令后用 Node 启动的文件为 yourname-http-server.js，在启动文件时我们应该启动我们的服务器，并结合 commander 模块的参数解析，则需要用命令行传递的参数替换掉 config.js 中的默认参数。 文件位置：&#126;static/bin/yourname-http-server.js —— 命令行执行文件12345678910111213141516171819202122232425const commander = require('commander');const Server = require('../index');// 增加 How to usecommander.on('--help', function() &#123; console.log('\\r\\n How to use: \\r\\n') console.log(' yourname-http-server --port &lt;val&gt;'); console.log(' yourname-http-server --host &lt;val&gt;'); console.log(' yourname-http-server --dir &lt;val&gt;');&#125;);// 解析 Node 进程执行时的参数commander .version('1.0.0') .usage('[options]') .option('-p, --port &lt;n&gt;', 'server port') .option('-o, --host &lt;n&gt;', 'server host') .option('-d, --dir &lt;n&gt;', 'server dir') .parse(process.argv);// 创建 Server 实例传入命令行解析的参数const server = new Server(commander);// 启动服务器server.start(); 我们之前把 config.js 的配置直接挂在了 Server 实例的 config 属性上，创建服务使用的参数也是直接从该属性上获取的，因此我们要用 commander 对象对应的参数覆盖实例上 config 的参数，所以在创建 Server 实例时传入了 commander 对象，下面稍微修改 Server 类的部分代码。 文件位置：&#126;static/index.js —— Server 类1234567class Server &#123; constructor(options) &#123; // 通过解构赋值将 options 的参数覆盖 config 的参数 this.config = &#123; ...config, ...options &#125;; // 配置 this.template = templateStr; // 模板 &#125;&#125; 执行下面命令，并通过浏览器访问 http://127.0.0.1:4000 来测试服务器功能。 yourname-http-server --port 4000 --host 127.0.0.1 在启动服务时自动打开浏览器由于 JS 是单线程的，在命令行输入命令启动服务的同时不能去做其他的事，此时要靠多进程来帮助我们打开浏览器，在 JS 中开启一个子进程来打开浏览器。 文件位置：&#126;static/bin/yourname-http-server.js —— 命令行执行文件123456789101112131415161718192021222324252627282930313233const commander = require('commander');const Server = require('../index');// 增加 How to usecommander.on('--help', function() &#123; console.log('\\r\\n How to use: \\r\\n') console.log(' yourname-http-server --port &lt;val&gt;'); console.log(' yourname-http-server --host &lt;val&gt;'); console.log(' yourname-http-server --dir &lt;val&gt;');&#125;);// 解析 Node 进程执行时的参数commander .version('1.0.0') .usage('[options]') .option('-p, --port &lt;n&gt;', 'server port') .option('-o, --host &lt;n&gt;', 'server host') .option('-d, --dir &lt;n&gt;', 'server dir') .parse(process.argv);// 创建 Server 实例传入命令行解析的参数const server = new Server(commander);// 启动服务器server.start();// ********** 以下为新增代码 **********let &#123; exec &#125; = require('child_process');// 判断系统执行不同的命令打开浏览器let systemOrder = process.platform === 'win32' ? 'start' : 'open';exec(`$&#123;systemOrder&#125; http://$&#123;commander.localhost&#125;:$&#123;commander.port&#125;`);// ********** 以上为新增代码 ********** 发布命令行工具到 npm在发布我们自己实现的 npm 模块之前需要先做一件事，就是解除当前模块与全局环境的 link，我们可以通过两种方式，第一种方式是直接到系统存储命令文件的文件夹删除模块对应命令的 yourname-http-server.cmd 文件，第二种方式是在模块根目录启动命令行并输入如下命令。 npm unlink 输入下面命令进行登录： npm login 登录成功后执行下面命令进行发布： npm publish 发布成功后再次使用自己的模块需要通过 npm 下载并全局安装，命令如下： npm install yourname-http-server -g 任意文件夹内打开命令行，并执行命令启动服务验证。 在发布模块之前如果使用 nrm 切换过其他的源，必须切换回 npm，再进行登录和发布操作。 总结其实我们实现的静态服务器核心还在于处理请求和响应的逻辑上，只是不再手动输入 node 命令启动，而是借助一些第三方模块关联到了命令行并通过命令启动，开发其他类型的命令行工具也需要借助这些第三方模块，静态服务器只是其中之一，其实类似这种命令行工具在开发的角度来讲属于 “造轮子” 系列，可以独立开发命令行工具是一个成为前端架构的必备技能，希望通过本篇文章可以了解命令行工具的开发流程，在未来 “造轮子” 的道路上提供帮助。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"命令行","slug":"命令行","permalink":"https://www.pandashen.com/tags/命令行/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"http-server","slug":"http-server","permalink":"https://www.pandashen.com/tags/http-server/"},{"name":"npm","slug":"npm","permalink":"https://www.pandashen.com/tags/npm/"}]},{"title":"HTTP 缓存的那些事儿","date":"2018-07-20T03:06:47.000Z","path":"2018/07/20/20180720110647/","text":"前言HTTP 缓存机制作为 Web 应用性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系的基础环节，也是想要成为前端架构的必备技能。 缓存的作用我们为什么使用缓存，是因为缓存可以给我们的 Web 项目带来以下好处，以提高性能和用户体验。 加快了浏览器加载网页的速度； 减少了冗余的数据传输，节省网络流量和带宽； 减少服务器的负担，大大提高了网站的性能。 由于从本地缓存读取静态资源，加快浏览器的网页加载速度是一定的，也确实的减少了数据传输，就提高网站性能来说，可能一两个用户的访问对于减小服务器的负担没有明显效果，但如果这个网站在高并发的情况下，使用缓存对于减小服务器压力和整个网站的性能都会发生质的变化。 缓存规则简介为了方便理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息（实际上静态资源是被缓存到了内存和磁盘中），在浏览器第一次请求数据时，此时缓存数据库没有对应的缓存数据，则需要请求服务器，服务器会将缓存规则和数据返回，浏览器将缓存规则和数据存储进缓存数据库。 缓存流程图 当浏览器地址栏输入地址后请求的 index.html 是不会被缓存的，但 index.html 内部请求的其他资源会遵循缓存策略，HTTP 缓存有多种规则，根据是否需要向服务器发送请求主要分为两大类，强制缓存和协商缓存。 强制缓存强制缓存流程强制缓存是第一次访问服务器获取数据后，在有效时间内不会再请求服务器，而是直接使用缓存数据，强制缓存的流程如下。 强制缓存流程图 强制缓存判断到期时间那么如何判断缓存是否到期呢？其实还是根据第一次访问时服务器的响应头来实现的，在 HTTP 1.0 版本和 HTTP 1.1 版本有所不同。 在 HTTP 1.0 版本，服务器使用的响应头字段为 Expires，值为未来的绝对时间（时间戳），浏览器请求时的当前时间超过了 Expires 设置的时间，代表缓存失效，需要再次向服务器发送请求，否则都会直接从缓存数据库中获取数据。 在 HTTP 1.1 版本，服务器使用的响应头字段为 Cache-Control，有多个值，意义各不相同。 private：客户端可以缓存； public：客户端和代理服务器都可以缓存（对于前端而言，可以认为与 private 效果相同）； max-age=xxx：缓存的内容将在 xxx 秒后过期（相对时间，秒为单位）； no-cache：需要使用协商缓存（后面介绍）来验证数据是否过期； no-store：所有内容都不会缓存，强制缓存和协商缓存都不会触发。 Cache-Control 的值中最常用的为 max-age=xxx，缓存本身就是为了数据传输的优化和性能而存在的，所以 no-store 几乎不会使用。 注意：在 HTTP 1.0 版本中，Expires 字段的绝对时间是从服务器获取的，由于请求需要时间，所以浏览器的请求时间与服务器接收到请求所获取的时间是存在误差的，这也导致了缓存命中的误差，在 HTTP 1.1 版本中，因为 Cache-Control 的值 max-age=xxx 中的 xxx 是以秒为单位的相对时间，所以在浏览器接收到资源后开始倒计时，规避了 HTTP 1.0 中缓存命中存在误差的缺点，为了兼容低版本 HTTP 协议，正常开发中两种响应头会同时使用，HTTP 1.1 版本的实现优先级高于 HTTP 1.0。 通过 Network 查看强制缓存我们通过 Chrome 浏览器的开发者工具，打开 NetWork 查看强制缓存的相关信息。 缓存响应头 上面是百度网站 Logo 图片的响应，我们可以清楚的看到，其中兼容了 HTTP 1.0 和 HTTP 1.1 版本，并使用强制缓存存储了 10 年。 下面看一看通过缓存取出的数据在 Network 中与其他资源的区别。 命中缓存 其实缓存的储存是内存和磁盘两个位置，由当前浏览器本身的策略决定，比较随机，从内存的缓存中取出的数据会显示 (from memory cache)，从磁盘的缓存中取出的数据会显示 (from disk cache)。 NodeJS 服务器实现强制缓存强制缓存12345678910111213141516171819202122232425262728293031const http = require('http');const url = require('url');const path = require('path');const mime = require('mime');const fs = require('fs');const server = http.createServer((req, res) =&gt; &#123; let &#123; pathname &#125; = url.parse(req.url, true); pathname = pathname !== '/' ? pathname : '/index.html'; // 获取读取文件的绝对路径 let p = path.join(__dirname, pathname); // 查看路径是否合法 fs.access(p, err =&gt; &#123; // 路径不合法则直接中断连接 if (err) return res.end('Not Found'); // 设置强制缓存 res.setHeader('Expires', new Date(Date.now() + 30000).toGMTString()); res.setHeader('Cache-Control', 'max-age=30'); // 设置文件类型并响应给浏览器 res.setHeader('Content-Type', `$&#123;mime.getType(p)&#125;;charset=utf8`); fs.createReadStream(p).pipe(res); &#125;);&#125;);server.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 上面 mime 模块的 getType 方法可以成功返回传入路径下文件对应的文件类型，如 text/html 和 application/javascript 等，是第三方模块，使用之前需要安装。 npm install mime 协商缓存协商缓存流程协商缓存又叫对比缓存，设置协商缓存后，第一次访问服务器获取数据时，服务器会将数据和缓存标识一起返回给浏览器，客户端会将数据和标识存入缓存数据库中，下一次请求时，会先去缓存中取出缓存标识发送给服务器进行询问，当服务器数据更改时会更新标识，所以服务器拿到浏览器发来的标识进行对比，相同代表数据未更改，响应浏览器通知数据未更改，浏览器会去缓存中获取数据，如果标识不同，代表服务器更改过数据，所以会将新的数据和新的标识返回浏览器，浏览器会将新的数据和标识存入缓存中，协商缓存的流程如下。 协商缓存流程图 协商缓存和强制缓存不同的是，协商缓存每次请求都需要跟服务器通信，而且命中缓存服务器返回状态码不再是 200，而是 304。 协商缓存判断标识强制缓存是通过过期时间来控制是否访问服务器，而协商缓存每次都要与服务器交互对比缓存标识，同样的，对于协商缓存的实现在 HTTP 1.0 版本和 HTTP 1.1 版本也有所不同。 在 HTTP 1.0 版本中，服务器通过 Last-Modified 响应头来设置缓存标识，通常取请求数据的最后修改时间（绝对时间）作为值，而浏览器将接收到返回的数据和标识存入缓存，再次请求会自动发送 If-Modified-Since 请求头，值为之前返回的最后修改时间（标识），服务器取出 If-Modified-Since 的值与数据的上次修改时间对比，如果上次修改时间大于了 If-Modified-Since 的值，说明被修改过，则通过 Last-Modified 响应头返回新的最后修改时间和新的数据，否则未被修改，返回状态码 304 通知浏览器命中缓存。 在 HTTP 1.1 版本中，服务器通过 Etag 响应头来设置缓存标识（唯一标识，像一个指纹一样，生成规则由服务器来决定），浏览器接收到数据和唯一标识后存入缓存，下次请求时，通过 If-None-Match 请求头将唯一标识带给服务器，服务器取出唯一标识与之前的标识对比，不同，说明修改过，返回新标识和数据，相同，则返回状态码 304 通知浏览器命中缓存。 HTTP 协商缓存策略流程图如下： 缓存策略流程图 注意：使用协商缓存时 HTTP 1.0 版本还是不太靠谱，假设一个文件增加了一个字符后又删除了，文件相当于没更改，但是最后修改时间变了，会被当作修改处理，本应该命中缓存，服务器却重新发送了数据，因此 HTTP 1.1 中使用的 Etag 唯一标识是根据文件内容或摘要生成的，保证了只要文件内容不变，则一定会命中缓存，为了兼容低版本 HTTP 协议，开发中两种响应头也会同时使用，同样 HTTP 1.1 版本的实现优先级高于 HTTP 1.0。 通过 Network 查看协商缓存我们同样通过 Chrome 浏览器的开发者工具，打开 NetWork 查看协商缓存的相关信息。 再次请求服务器的请求头信息： 再次请求服务器的请求头信息 命中协商缓存的响应头信息： 命中协商缓存的响应头信息 下面看一看通过协商缓存取出的数据在 Network 中与第一次加载的区别。 第一次请求： 第一次请求 缓存后请求： 缓存后请求 通过两图的对比，我们可以发现，协商缓存生效时的状态码为 304，并且报文大小和请求时间大大减少，原因是服务端在进行标识比对后只返回了 header 部分，通过状态码来通知浏览器使用缓存，不再需要将报文主体部分一起返回给浏览器。 NodeJS 服务器实现协商缓存协商缓存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const http = require('http');const url = require('url');const path = require('path');const mime = require('mime');const fs = require('fs');0const crytpo = require('crytpo');const server = http.createServer((req, res) =&gt; &#123; let &#123; pathname &#125; = url.parse(req.url, true); pathname = pathname !== '/' ? pathname : '/index.html'; // 获取读取文件的绝对路径 let p = path.join(__dirname, pathname); // 查看路径是否合法 fs.stat(p, (err, statObj) =&gt; &#123; // 路径不合法则直接中断连接 if (err) return res.end('Not Found'); let md5 = crypto.createHash('md5'); // 创建加密的转换流 let rs = fs.createReadStream(p); // 创建可读流 // 读取文件内容并加密 rs.on('data', data =&gt; md5.update(data)); rs.on('end', () =&gt; &#123; let ctime = statObj.ctime.toGMTString(); // 获取文件最后修改时间 let flag = md5.digest('hex'); // 获取加密后的唯一标识 // 获取协商缓存的请求头 let ifModifiedSince = req.headers['if-modified-since']; let ifNoneMatch = req.headers['if-none-match']; if (ifModifiedSince === ctime || ifNoneMatch === flag) &#123; res.statusCode = 304; res.end(); &#125; else &#123; // 设置协商缓存 res.setHeader('Last-Modified', ctime); res.setHeader('Etag', flag); // 设置文件类型并响应给浏览器 res.setHeader('Content-Type', `$&#123;mime.getType(p)&#125;;charset=utf8`); rs.pipe(res); &#125; &#125;); &#125;);&#125;);server.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 在上面的代码中是通过可读流读取文件内容，并通过 crypto 模块进行了 md5 加密后的结果作为了唯一标识，这样就能保证只要文件内容不变，就会命中缓存，其中兼容了 HTTP 1.0 和 HTTP 1.1 两个版本，只要满足一个则直接返回 304 通知浏览器命中缓存。 注意：其实读取文件内容加密这种做法并不可取，假如读取的是大文件，在读取文件内容和进行 md5 加密这个过程会非常消耗时间，所以在开发中要针对业务的实际情况选择可以保证服务器性能的方式生成唯一标识，比如根据文件的摘要。 总结为了使缓存策略更加健壮、灵活，HTTP 1.0 版本 和 HTTP 1.1 版本的缓存策略会同时使用，甚至强制缓存和协商缓存也会同时使用，对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，超出有效时间，执行协商缓存策略，对于协商缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求头 If-None-Match 和 If-Modified-Since 发送给服务器，由服务器校验同时设置新的强制缓存，校验通过并返回 304 状态码时，浏览器直接使用缓存，如果协商缓存也未命中，则服务器重新设置协商缓存的标识。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://www.pandashen.com/tags/性能优化/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"}]},{"title":"NodeJS 加密 —— crypto 模块","date":"2018-07-19T11:05:51.000Z","path":"2018/07/19/20180719190551/","text":"加密简介加密是以某种算法改变原有的信息数据，使得未授权用户即使获得了已加密信息，因不知解密的方法，无法得知信息真正的含义，通过这种方式提高网络数据传输的安全性，加密算法常见的有哈希算法、HMAC 算法、签名、对称性加密算法和非对称性加密算法，加密算法也分为可逆和不可逆，比如 md5 就是不可逆加密，只能暴力破解（撞库），我们在 NodeJS 开发中就是直接使用这些加密算法，crypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装，核心模块，使用时不需安装。 哈希算法哈希算法也叫散列算法，用来把任意长度的输入变换成固定长度的输出，常见的有 md5、sha1 等，这类算法实现对原数据的转化过程是否能被称为加密备受争议，为了后面叙述方便我们姑且先叫做加密。 查看哈希加密算法的种类12345678910111213141516171819const crypto = require('crypto');// getHashes 方法用于查看支持的加密算法console.log(crypto.getHashes());// [ 'DSA', 'DSA-SHA', 'DSA-SHA1', 'DSA-cSHA1-old',// 'RSA-MD4', 'RSA-MD5', 'RSA-MDC2', 'RSA-RIPEMD160',// 'RSA-SHA', 'RSA-SHA1', 'RSA-SHA1-2', 'RSA-SHA224',// 'RSA-SHA256', 'RSA-SHA384', 'RSA-SHA512',// 'dsaEncryption', 'dsaWithSHA', 'dsaWithSHA1', 'dss1',// 'ecdsa-with-SHA1', 'md4', 'md4WithRSAEncryption',// 'md5', 'md5WithRSAEncryption', 'mdc2', 'mdc2WithRSA',// 'ripemd', 'ripemd160', 'ripemd160WithRSA', 'rmd160',// 'sha', 'sha1', 'sha1WithRSAEncryption', 'sha224',// 'sha224WithRSAEncryption', 'sha256',// 'sha256WithRSAEncryption', 'sha384',// 'sha384WithRSAEncryption', 'sha512',// 'sha512WithRSAEncryption', 'shaWithRSAEncryption',// 'ssl2-md5', 'ssl3-md5', 'ssl3-sha1', 'whirlpool' ] md5 是开发中经常使用的算法之一，官方称为摘要算法，具有以下几个特点： 不可逆； 不管加密的内容多长，最后输出的结果长度都是相等的； 内容不同输出的结果完全不同，内容相同输出的结果完全相同。 由于相同的输入经过 md5 加密后返回的结果完全相同，所以破解时通过 “撞库” 进行暴力破解，当连续被 md5 加密 3 次以上时就很难被破解了，所以使用 md5 一般会进行多次加密。 md5 加密 —— 返回 Buffer12345678const crytpo = require('crytpo');let md5 = crytpo.createHash('md5'); // 创建 md5let md5Sum = md5.update('hello'); // update 加密let result = md5Sum.digest(); // 获取加密后结果console.log(result);// &lt;Buffer 5d 41 40 2a bc 4b 2a 76 b9 71 9d 91 10 17 c5 92&gt; digest 方法参数用于指定加密后的返回值的格式，不传参默认返回加密后的 Buffer，常用的参数有 hex 和 Base64，hex 代表十六进制，加密后长度为 32，Base64 的结果长度为 24，以 == 结尾。 md5 加密 —— 返回十六进制1234567const crypto = require('crypto');let md5 = crypto.createHash('md5');let md5Sum = md5.update('hello');let result = md5Sum.digest('hex');console.log(result); // 5d41402abc4b2a76b9719d911017c592 md5 加密 —— 返回 Base641234567const crypto = require('crypto');let md5 = crypto.createHash('md5');let md5Sum = md5.update('hello');let result = md5Sum.digest('Base64');console.log(result); // XUFAKrxLKna5cZ2REBfFkg== update 方法的返回值就是 this，即当前实例，所以支持链式调用，较长的信息也可以多次调用 update 方法进行分段加密，调用 digest 方法同样会返回整个加密后的值。 链式调用和分段加密123456789const crypto = require('crypto');let result = crypto .createHash('md5') .update('he') .update('llo') .digest('hex');console.log(result); // 5d41402abc4b2a76b9719d911017c592 由于可以使用 update 进行分段加密，就可以结合流来使用，其实 crypto 的本质是创建 Transform 类型的转化流，可以将可读流转化成可写流。 对可读流读取的数据进行 md5 加密123456789101112131415const crypto = require('crypto');const fs = require('fs');let md5 = crypto.createHash('md5');let rs = fs.createReadSteam('./readme.txt', &#123; highWaterMark: 3&#125;);// 读取数据并加密rs.on('data', data =&gt; md5.update(data));rs.on('end', () =&gt; &#123; let result = md5.digest('hex'); console.log(result);&#125;); 使用场景 1：经常被使用在数据的校验，比如服务器与服务器之间进行通信发送的明文摘要加 md5 加密摘要后的暗文，接收端拿到数据以后将明文摘要按照相同的 md5 算法加密后与暗文摘要对比验证，目的是防止数据传输过程中被劫持并篡改。使用场景 2：在浏览器缓存策略中，可以通过对静态资源的信息摘要使用 md5 加密，每次向服务器发送加密后的密钥进行比对就可以了，不至于对整个文件内容进行比较。 缺点：由于规定使用 md5 的哈希算法加密，别人可以使用同样的算法对信息进行伪造，安全性不高。 Hmac 算法Hmac 算法的使用Hmac 算法又称加盐算法，是将哈希算法与一个密钥结合在一起，用来阻止对签名完整性的破坏，同样具备 md5 加密的几个特点。 使用加盐算法加密123456const crytpo = require('crytpo');let hmac = crytpo.createHmac('sha1', 'panda');let result = hmac.update('hello').digest('Base64');console.log(result); // 7spMLxN8WJdcEtQ8Hm/LR9pUE3YsIGag9Dcai7lwioo= crytpo.createHmac 第一个参数同 crytpo.createHash，为加密的算法，常用 sha1 和 sha256，第二个参数为密钥。 digest 方法生成的加密结果长度要大于 md5，hex 生成的结果长度为 64，Base64 生成的结果长度为 44，以 = 结尾。 安全性高于 md5，通过密钥来加密，不知道密钥无法破解，缺点是密钥传输的过程容易被劫持，可以通过一些生成随机密钥的方式避免。 创建密钥的方法可以安装 openSSH 客户端，并通过命令行生成存储密钥的文件，命令如下。 openssl genrsa -out rsa_private.key 1024 openssl genrsa 代表生成密钥，-out 代表输出文件，rsa_private.key 代表文件名，1024 代表输出密钥的大小。 直接读取密钥文件配合加盐算法加密12345678910const fs = require('fs');const crytpo = require('crytpo');const path = require('path');let key = fs.readFileSync(path.join(__dirname, '/rsa_private.key'));let hmac = crytpo.createHmac('sha256', key);let result = hmac.update('hello').digest('Base64');console.log(result); // bmi2N+6kwgwt5b+U+zSgjL/NFs+GsUnZmcieqLKBy4M= 对称性加密对称性加密是发送数据时使用密钥和加密算法进行加密，接收数据时需要使用相同的密钥和加密算法的逆算法（解密算法）进行解密，也就是说对称性加密的过程是可逆的，crytpo 中使用的算法为 blowfish。 对称性加密1234567891011121314151617181920const fs = require('fs');const crypto = require('crypto');const path = require('path');let key = fs.readFileSync(path.join(__dirname, '/rsa_private.key'));// 加密let cipher = crypto.createCipher('blowfish', key);cipher.update('hello');// final 方法不能链式调用let result = cipher.final('hex');console.log(result); // 3eb9943113c7aa1e// 解密let decipher = crypto.createDecipher('blowfish', key);decipher.update(result, 'hex');let data = decipher.final('utf8');console.log(data); // hello 加密使用 crypto.createCipher 方法，解密使用 crypto.createDecipher 方法，但是使用的算法和密钥必须相同，需要注意的是解密过程中 update 中需要在第二个参数中指定加密时的格式，如 hex，在 final 还原数据时需要指定加密字符的编码格式，如 utf8。 注意：使用对称性加密的字符串有长度限制，不得超过 7 个字符，否则虽然可以加密成功，但是无法解密。 缺点：密钥在传输过程中容易被截获，存在安全风险。 非对称性加密非对称性加密相也是可逆的，较于对称性加密要更安全，消息传输方和接收方都会在本地创建一对密钥，公钥和私钥，互相将自己的公钥发送给对方，每次消息传递时使用对方的公钥加密，对方接收消息后使用他的的私钥解密，这样在公钥传递的过程中被截获也无法解密，因为公钥加密的消息只有配对的私钥可以解密。 接下来我们使用 openSSH 对之前生成的私钥 rsa_private.key 产生一个对应的公钥，命令如下。 openssl rsa -in rsa_private.key -pubout -out rsa_public.key 上面的命令意思根据一个私钥生成对应的公钥，-pubout -out 代表公钥输出，rsa_public.key 为公钥的文件名。 非对称性加密123456789101112131415const fs = require('fs');const crypto = require('crypto');const path = require('path');// 获取公钥和私钥let publicKey = fs.readFileSync(path.join(__dirname, '/rsa_public.key'));let privateKey = fs.readFileSync(path.join(__dirname, '/rsa_private.key'));// 加密let secret = crytpo.publicEncrypt(publicKey, Buffer.from('hello'));// 解密let result = crytpo.provateDecrypt(privateKey, secret);console.log(result); // hello 使用公钥加密的方法是 crytpo.publicEncrypt，第一个参数为公钥，第二个参数为加密信息（必须是 Buffer），使用私钥解密的方法是 crytpo.provateDecrypt，第一个参数为私钥，第二个参数为解密的信息。 签名签名与非对称性加密非常类似，同样有公钥和私钥，不同的是使用私钥加密，对方使用公钥进行解密验证，以确保这段数据是私钥的拥有者所发出的原始数据，且在网络中的传输过程中未被修改。 签名 我们还使用 rsa_public.key 和 rsa_private.key 作为公钥和私钥，crypto 实现签名代码如下。 签名1234567891011121314151617181920212223242526const fs = require('fs');const crypto = require('crypto');const path = require('path');// 获取公钥和私钥let publicKey = fs.readFileSync( path.join(__dirname, 'rsa_public.key'), 'ascii');let privateKey = fs.readFileSync( path.join(__dirname, 'rsa_private.key'), 'ascii');// 生成签名let sign = crypto.createSign('RSA-SHA256');sign.update('panda');let signed = sign.sign(privateKey, 'hex');// 验证签名let verify = crypto.createVerify('RSA-SHA256');verify.update('panda');let verifyResult = verify.verify(publicKey, signed, 'hex');console.log(verifyResult); // true 生成签名的 sign 方法有两个参数，第一个参数为私钥，第二个参数为生成签名的格式，最后返回的 signed 为生成的签名（字符串）。 验证签名的 verify 方法有三个参数，第一个参数为公钥，第二个参数为被验证的签名，第三个参数为生成签名时的格式，返回为布尔值，即是否通过验证。 使用场景：经常用于对 cookie 签名返回浏览器，当浏览器访问同域服务器将 cookie 带过来时再进行验证，防止 cookie 被篡改和 CSRF 跨站请求伪造。 总结各种项目在数据传输时根据信息的敏感度以及用途进行不同的加密算法和加密方式，在 NodeJS 中，crypto 的 API 完全可以实现我们的加密需求，也可以将上面的加密方案组合使用实现更复杂的加密方案。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"加密","slug":"加密","permalink":"https://www.pandashen.com/tags/加密/"},{"name":"crypto","slug":"crypto","permalink":"https://www.pandashen.com/tags/crypto/"}]},{"title":"NodeJS 服务器实现 gzip 压缩","date":"2018-07-18T10:18:23.000Z","path":"2018/07/18/20180718181823/","text":"概述在浏览器向服务器请求静态资源时，服务器为了减小在网络传输过程中消耗的流量和时间，都是将静态资源经过压缩后返回给服务器的，实现压缩的算法有 deflate 和 gzip 等，最常用的是 gzip 压缩。 gzip 简介在浏览器和服务器之间通过 gzip 压缩流实现传输的过程可以用下图表示。 gzip 压缩工作原理 当浏览器向服务器请求静态资源，服务器会将静态资源经过处理转换为压缩流，大大减小文件体积，然后将压缩流返回给浏览器，浏览器通过压缩的类型重新将压缩流解析成静态文件。 zlib 模块的使用压缩在 NodeJS 中通过 zlib 模块帮助我们实现不同类型的压缩，其实压缩的过程就是创建流的过程，创建的压缩流是 Transform 类型（转化流），读取文件的内容经过转化流创建一个新类型的文件。 文件：gzip.js123456789101112131415161718192021222324const zlib = require('zlib');const fs = require('fs');const path = require('path');// 压缩function gzip(source) &#123; // 处理输入和输出的文件路径 let sourcePath = path.join(__dirname, source); let gzipPath = `$&#123;sourcePath&#125;.gz`; // 创建转化流 let gzip = zlib.createGzip(); // 创建可读流 let rs = fs.createReadStream(sourcePath); // 创建可写流 let ws = fs.createWriteStream(gzipPath); // 实现转化 rs.pipe(gzip).pipe(ws);&#125;gzip('index.html'); 执行上面代码查看根目路是否出现 index.gz 压缩包。 解压压缩的过程是可逆的，可以压缩就可以解压，无论是在浏览器还是在服务器，我们下面实现解压的方法。 文件：gunzip.js123456789101112131415161718192021222324const zlib = require('zlib');const fs = require('fs');const path = require('path');// 解压function gunzip(source) &#123; // 处理输入和输出的文件路径 let sourcePath = path.join(__dirname, source); let filePath = path.join(__dirname, path.basename(source, '.gz')); // 创建转化流 let unzip = zlib.createGunzip(); // 创建可读流 let rs = createReadStream(sourcePath); // 创建可写流 let ws = createWriteStream(filePath); // 实现转化 rs.pipe(unzip).pipe(ws);&#125;gunzip('index.html.gz'); 删除原来 index.html，执行解压代码，查看文件根目录是否生成 index.html。 服务器的实现在浏览器与服务器的交互中，浏览器其实会通过请求头 Accept-Encoding 告诉服务器当前支持解压的压缩格式，值为 gzip, deflate, br，多个压缩格式用 , 隔开，服务器在接收到浏览器请求后，会按照请求头的格式压缩资源，将压缩后的资源返回，并通过响应头 Content-Encoding 告诉浏览器当前服务器压缩的格式。 文件：server.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 引入依赖const http = require('http');const url = require('url');const path = require('path');const fs = require('fs');const zlib = require('zlib');// 创建服务器const server = http.createServer((req, res) =&gt; &#123; // 处理 pathname，'/' 时默认读取 '/index.html' let &#123; pathname &#125; = url.parse(req.url, true); pathname = pathname !== '/' ? pathname : '/index.html'; // 获取读取文件的绝对路径 let p = path.join(__dirname, pathname); // 查看路径是否合法 fs.access(p, err =&gt; &#123; // 路径不合法则直接中断连接 if (err) return res.end('Not Found'); // 获取浏览器支持的压缩格式 let encoding = req.headers['accept-encoding']; // 创建可读流 let rs = fs.createReadStream(p); // 支持 gzip 使用 gzip 压缩，支持 deflate 使用 deflate 压缩 if (encoding &amp;&amp; encoding.match(/\\bgzip\\b/)) &#123; let compress = zlib.createGzip(); let compressType = 'gzip'; &#125; else if (encoding &amp;&amp; encoding.match(/\\bdeflate\\b/)) &#123; let compress = zlib.createDeflate(); let compressType = 'deflate'; &#125; else &#123; // 否则直接返回可读流 return rs.pipe(res); &#125; // 将压缩流返回并设置响应头 res.setHeader('Content-Encoding', compressType); rs.pipe(compress).pipe(res); &#125;);&#125;);server.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 在上面服务器中如果不通过响应头通知浏览器当前资源的压缩格式，浏览器会不知道该如何解压，默认会当成文件下载，如 Chrome，所以在返回压缩流时必须通过 Content-Encoding 响应头通知浏览器当前的压缩格式。 测试服务器压缩我们在文件根目录创建一个 index.html 文件，代码如下。 文件：index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;gzip&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Hello GZIP!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动服务器 server.js，然后通过浏览器访问 localhost:3000，查看页面能否正确返回，并查看开发者工具 Network 中的响应头 Content-Encoding 的值是否正确。 总结服务器压缩其实是客户端与服务器在网络传输时的一种优化手段，可以大大减小流量的消耗和响应时间，而 gzip 只是目前最常用的一种压缩格式，即压缩算法。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.pandashen.com/tags/http-headers/"},{"name":"gzip","slug":"gzip","permalink":"https://www.pandashen.com/tags/gzip/"}]},{"title":"NodeJS 实现多语言","date":"2018-07-17T03:18:07.000Z","path":"2018/07/17/20180717111807/","text":"什么是多语言？我们平时访问一些文档类型的网站时，经常可以看到页面右上角有一个下拉框用来选择当前页面支持的语言，并在选中后将整个网页的内容切换为选中的语言，这就是项目中的多语言，多语言可以根据浏览器请求发送的语言类型在服务器进行设置，也可以在请求服务器时返回多种语言，并根据权重和浏览器的支持情况进行选择和渲染。 功能描述在本文中我们通过客户端向服务器发送请求告诉服务器客户端所支持的语言及权重，服务器检索语言包并根据客户端发送的语言类型和权重返回对应语言的内容。 在这个过程中客户端向服务器发送请求需要使用请求头 Accept-Language，值中设置语言类型和权重，语言与语言之间使用 , 隔开，语言与权重之间使用 ; 隔开，权重用 q 表示，与值用 = 隔开，如果权重值为 1 则可省略（最大值），值的格式为 zh-CN, zh;q=0.7, en;q=0.8, fr;q=0.1。 服务器响应时，应通过响应头告诉浏览器返回的内容为何种语言，响应头为 Content-Language, 值的格式为 zh-CN, en，多个语言之间使用 , 隔开。 服务器的实现文件：server.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const http = require('http');const querystring = require('querystring');// 语言包const languagesPackage = &#123; 'zh-CN': '你好', 'en': 'Hello', 'fr': 'Bonjour'&#125;;// 默认语言为英语languagesPackage.defaultLanguage = 'en';// 创建服务器const server = http.createServer((req, res) =&gt; &#123; // 获取请求头中的语言和权重 let languages = req.headers['accept-language']; // 如果客户端设置了语言 if (languages) &#123; // 解析语言为 [&#123; name: 'zh-CN', q: 1 &#125;, &#123; name: 'en', q: '0.8' &#125;] 格式 let lans = languages.split(',').map(lang =&gt; &#123; let [name, q = 1] = Object.keys( querystring.parse(lang.tirm(), ';q=' )); return &#123; name, q &#125;; &#125;).sort((a, b) =&gt; b.q - a.q); // 并按照权重逆序排序 // 循环检测 languagesPackage 是否存在客户端的语言 for (let i = 0; i &lt; lans.length; i++) &#123; let &#123; name &#125; = lans[i]; let content = languagesPackage[name]; // 如果存在直接设置响应头并返回内容 if (content) &#123; res.setHeader('Content-Type', name); return res.end(content); &#125; &#125; &#125; // 如果客户端没设置语言活语言找不到时返回服务器设置的默认语言 res.setHeader('Content-Type', languagesPackage.defaultLanguage); res.end(languagesPackage[languagesPackage.defaultLanguage]);&#125;);server.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 其实上面服务器和客户端配合实现多语言的思路就是客户端向服务器发送 Accept-Language 告诉服务器需要的语言和权重，服务器解析后根据权重从大到小排序，然后循环判断语言包中是否含有客户端需要的语言，如果有，则中断循环直接设置响应头和返回对应内容，如果不存在客户端的需要的语言或者客户端没有向后台发送 Accept-Language 则返回服务器默认设置的语言类型和内容。 验证多语言为了方便我们使用 curl 模拟客户端向服务器发送请求查看返回内容是否正确，之所以使用 curl 是因为只发送验证的请求，方便设置 Accept-Language 请求头，更灵活的控制多语言的类型和权重。 启动服务器 server.js，打开命令行窗口，输入下面的命令执行，查看返回命令行响应体中的内容和设置的语言是否对应。 curl -v --header “Accept-Language: zh-CN, zh;q=0.7, en;q=0.8, fr;q=0.1” http://localhost:3000 总结这样我们就实现了一个简单的多语言，其实真正的多语言在服务器是需要做繁琐的解析和性能优化的（只解析界面有的单词返回，保证响应体中的内容最小），在前端可以通过 JavaScript 的库 il8n（国际化语言包）来实现。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.pandashen.com/tags/http-headers/"},{"name":"multi-language","slug":"multi-language","permalink":"https://www.pandashen.com/tags/multi-language/"}]},{"title":"NodeJS 服务器数据处理（表单、json 字符串和普通字符串）","date":"2018-07-16T07:59:48.000Z","path":"2018/07/16/20180716155948/","text":"前言从浏览器向服务器提交数据时，常见有表单提交，JSON 字符串提交和普通字符串提交，不同情况需要附带不同的请求头信息，告诉服务器客户端可以直接解析的数据格式，如果发送的数据为 json 字符串，后两种类型都可以成功发送到服务器，只是加上请求头信息服务器更容易判断该以什么格式返回数据。 querystring 模块解析请求体在 get 请求中，我们可以通过 url 模块的 parse 方法来解析，如果是带有请求体的请求类型，如 post、put 我们应该使用 querystring 模块的 parse 方法将请求体中的数据解析成对象，在这个方法中有三个参数。 str：要解析的查询字符串； sep：查询字符串中键值对之间的分隔符，默认为 &amp;； eq：查询字符串中的键与值的分隔符，默认为 =。 文件：querystring-test.js12345678910const querystring = require('querystring');let str1 = 'name=pandashen&amp;age=27';let str1 = 'name*pandashen!&amp;age*27';let obj1 = querystring.parse(str1);let obj2 = querystring.parse(str2, '!&amp;', '*');console.log(obj1); // &#123; name: 'pandashen', age: '27'&#125;console.log(obj2); // &#123; name: 'pandashen', age: '27'&#125; querystring 也是很常用的模块，就在这里多说几句关于原理相关的内容，模拟 querystring 模块常用方法 parse 的代码如下。 文件：my-querystring.js12345678910111213141516exports.parse = (str, sep = '&amp;', eq = '=') =&gt; &#123; // 存储解析出键值的对象 const query = &#123;&#125;; // 先将查询字符串切割成 [k=v, k=b] 的形式 const fields = str.split(sep); // 循环将每一项切割成 k 和 v 并存入 queryObj 中 fields.forEach(field =&gt; &#123; let [key, value] = field.split(eq); query[key] = value; &#125;); // 返回 query 对象 return query;&#125;; 服务器的实现向服务器发送请求的请求头为 Content-Type，表单提交、json 和字符串作为请求体时，在 Content-Type 中对应的值分别为 application/x-www-form-urlencoded、application/json 和 text/plain。 其中 text/plain 为 Ajax 的默认提交方式，我们在服务器中针对上面这几种类型的请求头和 get 请求做处理，将发来的数据再次返回客户端。 文件：server.js1234567891011121314151617181920212223242526272829303132333435363738394041const http = require('http');const url = require('url');const querystring = require('querystring');const server = http.createServer((req, res) =&gt; &#123; // 获取 get 请求参数 let &#123; query &#125; = url.parse(req.url, true); // 获取数据类型请求头 let type = req.headers['content-type']; // 接收数据 const buffers = []; res.on('data', data =&gt; buffers.push(data)); res.on('end', () =&gt; &#123; // 合并数据并设置默认响应头和返回数据 let data = Buffer.concat(buffers).toString(); let contentType = 'application/json'; // 判断是否为 get 请求，是则直接返回解析后的数据，不是则判断请求类型 if (req.method.toLowerCase() === 'get') &#123; data = JSON.stringify(query); &#125; else &#123; // 判断请求数据类型并做相应处理 if (type === 'application/x-www-form-urlencoded') &#123; data = JSON.stringify(querystring.parse(str)); &#125; else if (type === 'application/json') &#123; data = JSON.stringify(JSON.parse(str)); &#125; else &#123; contentType = 'text/plain'; &#125; &#125; // 设置响应头并返回数据 res.setHeader('Content-Type', contentType); res.end(data); &#125;);&#125;);server.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125; 当请求类型为 get，将 URL 的查询字符串通过 url 模块解析后再处理成字符串返回客户端。 当请求类型为 post，设置默认响应头为 application/json，如果是表单提交，请求体中的内容为查询字符串格式，使用 querystring 解析后再使用 JSON.stringify 处理成字符串返回，如果是 json，则使用 JSON.parse 解析，并使用 JSON.stringify 处理成字符串返回，如果是默认值 text/plain，则设置响应头的值为 text/plain 并将读取的结果直接返回。 使用客户端进行测试在这里我们为了方便就不用浏览器访问了，因为上面的服务器代码比较简单，只处理了数据，并没有处理静态文件请求，所以我们通过 NodeJS 来实现客户端。 get 请求文件：get.js123456789101112131415161718const http = require('http');const config = &#123; host: 'localhost', port: 3000, path: '/?name=pandashen&amp;age=27'&#125;;// 发送 get 请求http.get(config, res =&gt; &#123; // 接收服务器返回的数据 const buffers = []; res.on('data', data =&gt; buffers.push(data)); res.on('end', () =&gt; &#123; let data = Buffer.concat(buffers).toString(); console.log(data); &#125;);&#125;); 启动服务器 server.js，通过命令行执行 node get.js 查看命令窗口中输出的结果。 post 请求表单提交文件：post-from.js1234567891011121314151617181920const http = require('http');const config = &#123; host: 'localhost', port: 3000, method: 'post' headers: &#123; 'Content-type': 'application/x-www-form-urlencoded' &#125;&#125;;http.request(config, res =&gt; &#123; // 接收服务器返回的数据 const buffers = []; res.on('data', data =&gt; buffers.push(data)); res.on('end', () =&gt; &#123; let data = Buffer.concat(buffers).toString(); console.log(data); &#125;);&#125;).end('name=pandashen&amp;age=27'); 启动服务器 server.js，通过命令行执行 node post-form.js 查看命令窗口中输出的结果。 post 请求 json 字符串数据文件：post-json.js1234567891011121314151617181920const http = require('http');const config = &#123; host: 'localhost', port: 3000, method: 'post', headers: &#123; 'Content-Type': 'application/json' &#125;&#125;;http.request(config, res =&gt; &#123; // 接收服务器返回的数据 const buffers = []; res.on('data', data =&gt; buffers.push(data)); res.on('end', () =&gt; &#123; let data = Buffer.concat(buffers).toString(); console.log(data); &#125;);&#125;).end('&#123; name: pandashen, age: 27 &#125;'); 启动服务器 server.js，通过命令行执行 node post-json.js 查看命令窗口中输出的结果。 post 请求普通字符串数据文件：post-string.js1234567891011121314151617181920const http = require('http');const config = &#123; host: 'localhost', port: 3000, method: 'post', headers: &#123; 'Content-Type': 'text/plain' &#125;&#125;;http.request(config, res =&gt; &#123; // 接收服务器返回的数据 const buffers = []; res.on('data', data =&gt; buffers.push(data)); res.on('end', () =&gt; &#123; let data = Buffer.concat(buffers).toString(); console.log(data); &#125;);&#125;).end('pandashen27'); 启动服务器 server.js，通过命令行执行 node post-string.js 查看命令窗口中输出的结果。 总结通过本篇的内容可以了解 HTTP 在数据传输中的类型，即请求头类型，服务端通过请求头类型可以返回客户端可以直接解析的数据，上面的几种类型只是向服务器提交数据的最常见类型，涵盖表单提交和 Ajax 等，在上传文件时还存在二进制传输等等。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.pandashen.com/tags/http-headers/"}]},{"title":"NodeJS 服务器实现资源防盗链","date":"2018-07-14T07:00:09.000Z","path":"2018/07/14/20180714150009/","text":"什么是 “盗链”？“盗链” 说白了就是利用别人网站的资源链接放在自己的站点，在未经允许的情况下去获取别人网站里面的图片或者视频等资源，导致资源所有者的网站的流量费用增加或收入减少，为了防止资源链接随意被人盗用的手段被称为 “防盗链”。 模拟 “盗链” 场景我们先来模拟一下 “盗链” 场景，在本地启动服务运行 hotlinking.html 文件，并在文件中盗用百度视频的图片资源，看看效果。 文件：hotlinking.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;盗链&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"http://c.hiphotos.baidu.com/c9f1faaf51f2de66ad.jpg\"&gt;&lt;/body&gt;&lt;/html&gt; 我们通过 http-server 来启动服务器访问 hotlinking.html，使用 http-server 需全局安装。 http-server install -g 在服务中打开 hotlinking.html 后我们发现图片并不是我们盗用链接的资源，而是变成了下面这张图片。 百度盗链返回图片 这张图用来提醒我们盗用了别人资源，是因为百度的服务器做了防盗链处理，如果所有盗用别人的资源都变成这样，盗用也就没有实际意义了，我们本篇就通过 NodeJS 来实现防盗链处理，用来保护自己站点的资源。 注意：具备防盗链处理的网站的资源链接可以直接通过浏览器地址栏访问，也可以在文件域（file 协议）访问，限制的是在未经允许的情况下其他服务器的访问。 NodeJS 服务器实现防盗链模拟两个域名在本地的 hosts 文件中加入两个域名： 127.0.0.1 panda.com127.0.0.1 shen.com 准备图片资源在根目录创建文件夹 public 并存入两张图片，success.png 是正常请求的图片资源，error.png 是经过防盗链处理后返回的图片资源，两张图片如下。 正常返回的图片资源 success.png： 正常返回资源 防盗链处理后返回的图片资源 error.png： 盗链返回资源 页面 index.html在页面当中通过 img 标签分别访问 shen.com、panda.com 和 localhost 域下的 success.png 文件。 文件：index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;盗链&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"http://panda.com:3000/success.png\"&gt; &lt;img src=\"http://shen.com:3000/success.png\"&gt; &lt;img src=\"http://localhost:3000/success.png\"&gt;&lt;/body&gt;&lt;/html&gt; 服务端 server.js在写服务端代码之前需要介绍两个重要的请求头： host：资源所在的域 referer：请求来源的域 其实资源防盗就是设置白名单，通过检测 referer 是否在白名单中，如果在则正常返回资源，不存在则返回经过防盗链处理的资源。 注意：referer 请求头在地址栏输入地址时发送的请求是不存在的（如请求 index.html 页面），在旧版本的 HTTP 协议中 referer 的写法为 referered，所以为了兼容旧版本协议应该做兼容处理。 文件：server.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 引入依赖const http = require('http');const url = require('url');const path = require('path');const fs = require('mz/fs');const server = http.createServer(responseImages); // 创建服务器let static = path.resolve(__dirname, 'public'); // 静态资源目录let whiteList = ['shen.com']; // 白名单async function responseImages(req, res) &#123; // 解析 url 中的文件目录处理成绝对路径 let p = path.join(static, url.parse(req.url).pathname); // 检测文件路径是否合法，不合法直接返回 Not Found let isExist = await fs.exists(p); if (isExist) &#123; // 获取 referer let refer = req.headers['referer'] || req.headers['referered']; // 存在 referer 继续检测 if (refer) &#123; // 请求资源存在 referer，做防盗链处理 let referHost = url.parse(refer).hostname; let host = req.headers['host'].split(':')[0]; // 当访问源的域和资源所在的域不是同一个域，做防盗链处理 if (referHost !== host) &#123; let isInWhiteList = whiteList.includes(refer); p = isInWhiteList ? p : path.join(static, 'error.png'); &#125; &#125; // 第一次访问请求页面 index.html，不存在 referer，将静态资源返回 // 第二次访问请求图片资源，如果 referer 和资源所本就是同一个域，直接将资源返回 fs.createReadStream(p).pipe(res); &#125; else &#123; res.statusCode = 404; res.end('Not Found'); &#125;&#125;server.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 其实上面的服务器是 shen.com、panda.com 和 localhost 所共用的，只是通过不同的域名访问。 启动服务器，然后通过 localhost:3000 访问，此时由于与 shen.com 和 panda.com 为不同域，所以只有第三张图片返回 success.png。 通过 shen.com:3000 访问，由于存在白名单中，所以三张图片都返回 success.png。 通过 panda.com:3000 访问，由于 shen.com 在不同域，所以没有返回 success.png。 无论通过 shen.com 还是 panda.com 访问 localhost 的资源都是在同域的，所以都能获取到。 总结在上面我们利用本地服务实现了一个最基本的防盗链，思路就是 referer 与资源同域，正常返回，不同域检测白名单，在真实的开发场景可能会更细化，更复杂一些，其实整个防盗链实现的核心就是利用 HTTP 的 referer 和 host 请求头做检测，希望通过本篇的学习，大家可以对资源防盗链有所了解，并在后面开发类似功能时提供思路。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.pandashen.com/tags/http-headers/"},{"name":"资源防盗链","slug":"资源防盗链","permalink":"https://www.pandashen.com/tags/资源防盗链/"}]},{"title":"NodeJS 使用 Range 请求实现下载功能","date":"2018-07-13T05:08:08.000Z","path":"2018/07/13/20180713130808/","text":"前言本篇使用 NodeJS 的 HTTP 服务创建客户端，使用 Range 请求实现下载功能，并通过本篇的 Demo 扩展在业务中实现断点续传等功能的思路。 服务端的实现我们通过 http 模块创建服务器处理 Range 请求，在服务器代码中我们为了减少回调嵌套使用 async 函数，所以需要将异步的操作方法转换成 Promise，以往我们使用 util 的 promisify 来一个一个转换异步方法，比较麻烦，我们这次使用第三方模块 mz 并直接引入转换好的替代模块。 使用 mz 之前需要先安装： npm install mz 服务端代码如下： 文件：server.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const http = require('http');const path = require('path');const url = require('url');// 引入 mz 模块转换成 Promise 的 fs 模块const fs = require('mz/fs');// 请求处理函数async function listener(req, res) &#123; // 获取 range 请求头，格式为 Range:bytes=0-5 let range = req.headers['range']; // 下载文件路径 let p = path.resovle(__dirname, url.parse(url, true).pathname); // 存在 range 请求头将返回范围请求的数据 if (range) &#123; // 获取范围请求的开始和结束位置 let [, start, end] = range.match(/(\\d*)-(\\d*)/); // 错误处理 try &#123; let statObj = await fs.stat(p); &#125; catch (e) &#123; res.end('Not Found'); &#125; // 文件总字节数 let total = statObj.size; // 处理请求头中范围参数不传的问题 start = start ? ParseInt(start) : 0; end = end ? ParseInt(end) : total - 1; // 响应客户端 res.statusCode = 206; res.setHeader('Accept-Ranges', 'bytes'); res.setHeader('Content-Range', `bytes $&#123;start&#125;-$&#123;end&#125;/$&#123;total&#125;`); fs.createReadStream(p, &#123; start, end &#125;).pipe(res); &#125; else &#123; // 没有 range 请求头时将整个文件内容返回给客户端 fs.createReadStream(p).pipe(res); &#125;&#125;// 创建服务器const server = http.createServer(listener);// 监听端口server.listen(3000, () =&gt; &#123; console.log('server start 3000');&#125;); 在上面服务端的代码中，需要兼容 Range 请求和普通请求，两种请求的区别是，如果客户端发送的是 Range 请求，会携带 Range:bytes=0-5 格式的请求头，我们可以通过 req 的 headers 属性获取，在获取请求头时，原本大写字母开头 NodeJS 统一处理成小写，所以获取时应小写。 如果是 Range 请求则通过可读流读取对应的内容返回客户端，如果不是，则通过可读流读取整个文件返回客户端，在响应 Range 请求的过程中需要设置响应状态为 206，需要设置响应头 Accept-Ranges 值为 bytes，需要设置响应头 Content-Range 值为 byte 0-5/100 的格式，0 为返回数据开始的索引，5 为结束的索引（包含），100 为文件的总字节数。 在通过 url 和 path 模块解析和拼接下载文件路径时，应该进行错误检测，如果文件不存在则直接返回客户端 Not Found。 我们可以使用 curl 命令来检测我们的服务端代码，在命令行工具中输入下面命令，在命令窗口查看返回值是否正确。 curl -v --header “Range:bytes=0-5” http://localhost:3000 客户端的实现在上面使用 curl 命令来访问我们的服务器时，只能请求固定范围的数据，而不是类似于下载功能，每次都下载一个范围的数据，但是想要多次下载并自动维护 Range 的范围需要借助我们自己实现的客户端逻辑。 为了简便，我们的下载客户端是在命令行窗口运行的，通过指令来模拟实际项目中的开始下载、暂停和恢复按钮，当在窗口中输入 s 指令时开始下载，输入 p 指令时暂停下载，输入 r 指令时恢复下载。 文件：client.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const http = require('http');const fs = require('fs');const path = require('path');// 请求配置const config = &#123; host: 'localhost', port: 3000, path: '/download.txt'&#125;;let start = 0; // 请求初始值let step = 5; // 每次请求字符个数let pause = false; // 暂停状态let total; // 文件总长度// 创建可写流let ws = fs.createWriteStream(path.resolve(__dirname, config.path.slice(1)));// 下载函数function download() &#123; // 配置，每次范围请求 step 个字节 config.headers = &#123; 'Range': `bytes=$&#123;start&#125;-$&#123;start + step - 1&#125;`; &#125;; // 维护下次 start 的值 start += step; // 发送请求 http.request(config, res =&gt; &#123; // 获取文件总长度 if (typeof total !== 'number') &#123; total = res.headers['content-ranges'].match(/\\/(\\d*)/)[1]; &#125; // 读取返回数据 const buffers = []; res.on('data', data =&gt; buffers.push(data)); res.on('end', () =&gt; &#123; // 合并数据并写入文件 let buf = Buffer.concat(buffers); ws.write(buf); // 递归进行下一次请求 if (!pause &amp;&amp; start &lt; total) &#123; download(); &#125; &#125;); &#125;).end();&#125;// 监控输入process.stdin.on('data', data =&gt; &#123; // 获取指令 let ins = data.toString().match(/(\\w*)\\/r/)[1]; switch (ins) &#123; case 's': case 'r': pause = false; download(); break; case 'p': pause = true; break; &#125;&#125;); 在上面代码中下载的文件通过 config 中的 path 属性配置，每次调用 download 函数下载时都会重新计算当前范围请求的初始位置和结束位置，并设置 Range 请求头，下一次请求靠递归 download 来实现。 在执行时需先启动我们的服务器，在通过命令行输入 node client.js 来启动客户端，在命令窗口输入对应的指令进行开始下载、暂停下载和恢复下载操作。 总结相信现在已经了解什么是范围请求，范围请求客户端和服务端需要做些什么，其实说白了就是对应的请求头和响应头的使用，需要注意的是范围请求的响应状态码为 206，这样的需求在一些上传、下载资源的网站也很常见，其目的就是为了让我们实现断点续传，不至于一次没有上传或下载完成的资源文件，在下一次的做同样操作时需要重新来过，可以接着上次的位置继续，范围请求在视频网站上也广泛应用，边请求边观看，不至于一次加载整个视频资源，节省流量，节省时间。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"范围请求","slug":"范围请求","permalink":"https://www.pandashen.com/tags/范围请求/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.pandashen.com/tags/http-headers/"}]},{"title":"NodeJS 搭建 HTTP 服务器","date":"2018-07-12T11:55:14.000Z","path":"2018/07/12/20180712195514/","text":"前言在 NodeJS 中用来创建服务的模块是 http 核心模块，本篇就来介绍关于使用 http 模块搭建 HTTP 服务器和客户端的方法，以及模块的基本 API。 HTTP 服务器创建 HTTP 服务器在 NodeJS 中，创建 HTTP 服务器可以与 net 模块创建 TCP 服务器对比，创建服务器有也两种方式。 方式 1： 1234567const http = require('http');const server = http.createServer(function(req, res) &#123; // ......&#125;);server.listen(3000); 方式 2： 123456789const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; // ......&#125;);server.listen(3000); 在 createServer 的回调和 request 事件的回调函数中有两个参数，req（请求）、res（响应），基于 socket，这两个对象都是 Duplex 类型的可读可写流。 http 模块是基于 net 模块实现的，所以 net 模块原有的事件在 http 中依然存在。 12345678910const http = require('http');const server = http.createServer();// net 模块事件server.on('connection', function(socket) &#123; console.log('连接成功');&#125;);server.listen(3000); 获取请求信息在请求对象 req 中存在请求的方法、请求的 url（包含参数，即查询字符串）、当前的 HTTP 协议版本和请求头等信息。 12345678910111213141516171819202122232425const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; console.log(req.method); // 获取请求方法 console.log(req.url); // 获取请求路径（包含查询字符串） console.log(req.httpVersion); // 获取 HTTP 协议版本 console.log(req.headers); // 获取请求头（对象） // 获取请求体的内容 const arr = []; req.on('data', function(data) &#123; arr.push(data); &#125;); req.on('end', function() &#123; console.log(Buffer.concat(arr).toString()); &#125;);&#125;);server.listen(3000, function() &#123; console.log('server start 3000');&#125;); 通过 req 对应的属性可以拿到请求行和请求首部的信息，请求体内的内容通过流操作来获取，其中 url 中存在多个有用的参数，我们自己处理会很麻烦，可以通过 NodeJS 的核心模块 url 进行解析。 123456789101112131415161718192021222324const url = require('url');let str = 'http://user:pass@www.pandashen.com:8080/src/index.html?a=1&amp;b=2#hash';// parse 方法帮助我们解析 url 路径let obj = url.parse(str, true);console.log(obj);// &#123;// protocol: 'http:',// slashes: true,// auth: 'user:pas',// host: 'www.pandashen.com:8080',// port: '8080',// hostname: 'www.pandashen.com',// hash: '#hash',// search: '?a=1&amp;b=2',// query: '&#123; a: '1', b: '2' &#125;',// pathname: '/src/index.html'// path: '/src/index.html?a=1&amp;b=2',// href: `http://user:pass@www.pandashen.com:8080// /src/index.html?a=1&amp;b=2#hash`// &#125; 在被解析路径返回的对象中有几个属性被经常使用： host：主机（域名 + 端口号）； hostname：主机名； query：请求参数（查询字符串或参数对象）； pathname：资源路径（根据不同的路径返回不同的资源）。 我们使用 url 的 parse 方法来帮我们解析请求路径，在真实的服务器中传入的第一个参数为 req.url，第二个参数不传时，query 会被解析成 a=1&amp;b=2 的形式，第二个参数传入 true，query 属性的查询字符串会被解析成对象的形式。 url 模块中，将查询字符串 a=1&amp;b=2 转换为对象 { a: &#39;1&#39;, b: &#39;2&#39; } 的实现方式其实是使用正则替换实现的。 模拟查询字符串转换对象的核心逻辑： 12345678let str = 'a=1&amp;b=2&amp;c=3';const obj = &#123;&#125;;str.replace(/([^=&amp;]+)=([^=&amp;]+)/g, function() &#123; obj[arguments[1]] = arguments[2];&#125;);console.log(obj); // &#123; a: '1', b: '2', c: '3' &#125; 在上面代码的 replace 方法的回调函数中参数集合的第一项为匹配到的字符串，第二项为第一个分组的值，第三项为第二个分组的值，依次类推，倒数第二项为分组匹配的索引，最后一项为原字符串。 设置响应信息我们可以通过 req 来获取请求信息，自然也可以通过 res 来设置响应信息返回给客户端。 12345678910111213141516171819202122232425const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; // 设置响应头（过去的用法），不能多次调用，见到要认识 res.writeHead(200, &#123; 'Content-Type': 'text', a: 'hello world' &#125;); // 设置响应头（现在的用法，常用），可以多次调用，每次设置一个响应头 res.setHeader('Content-Type', 'text'); // 设置状态码，不设置默认为 200 res.statusCode = 200; // 不发送 Date（日期）响应头 res.sendDate = false; // 返回内容 res.write('hello world'); // 不会关闭连接 res.end('hello world'); // 将内容返回后关闭连接&#125;);server.listen(3000, function() &#123; console.log('server start 3000');&#125;); 返回给客户端的信息主要分为两部分，分别为响应头和返回给浏览器的内容，在不设置响应头的情况下，默认会设置响应头 Content-Length 和 Date ，代表当前返回给客户端的内容长度和日期。 返回给浏览器的内容可以通过 res 的 write 方法和 end 方法进行发送，write 方法不会断开连接（通常在响应后需要断开与客户端的连接），end 方法会断开连接，在 end 方法存在参数时，会在内部调用 write 将参数内容返回给客户端，并断开连接。 HTTP 客户端在 net 模块中可以通过 net.createConnection 来创建客户端，并发送请求到服务端，在 http 模块同样可以创建客户端，并向 http 服务器发送请求。 客户端：client.js12345678910111213141516171819202122232425262728const http = require('http');// 发送请求的配置const config = &#123; host: 'localhost', port: 3000, method: 'get', headers: &#123; a: 1 &#125;&#125;;// 创建客户端const client = http.request(config, function(res) &#123; // 接收服务端返回的数据 const arr = []; res.on('data', function(data) &#123; arr.push(data); &#125;); res.on('end', function() &#123; console.log(Buffer.concat(arr).toString()); &#125;);&#125;);// 发送请求client.end(); 在 http 模块中通过 request 方法创建客户端，该方法第一个参数为发送请求的配置，包含请求地址、端口号、请求方法以及请求头等，第二个参数为回调函数，在请求被响应后执行，回调函数的参数为服务器的响应对象 res，创建的客户端通过 end 方法将请求发出与服务端进行通信。 使用 NodeJS 实现的 “爬虫” 其实就可以通过 http 模块创建的客户端来实现，客户端帮我们向我们要抓取数据的地址发送请求，并拿到响应的数据进行解析。 同时使用 HTTP 客户端和服务器我们使用自己创建的客户端访问自己的服务端，并体会请求响应的过程，就是用上面 client.js 作为客户端，启动 server.js 后再启动 client.js 查看效果。 服务器：server.js1234567891011121314const http = require('http');http.createServer(function(req, res) &#123; console.log('The request came'); // 获取客户端请求信息 console.log(req.method); console.log(req.headers); // 返回数据 res.write('hello world');&#125;).listen(3000, function() &#123; console.log('server start 3000');&#125;); 简易爬虫我们结合 http 模块创建的服务端和客户端实现一个简易版的 “爬虫” 去抓取百度新闻页所有 li 标签内的文章标题。 简易爬虫：crawl.js123456789101112131415161718192021222324252627282930313233343536373839const http = require('http');// 创建服务器const server = http.createServer();// 监听请求server.on('request', function(req, res) &#123; const client = http.request( &#123; host: 'news.baidu.com', method: 'get', port: 80 &#125;, function(r) &#123; // 接收百度新闻返回的数据 const arr = []; r.on('data', function(data) &#123; arr.push(data); &#125;); r.on('end', function() &#123; // 处理数据 let result = Buffer.concat(arr).toString(); let matches = result.match(/&lt;li class='bold-item'&gt;([\\s\\S*?])&lt;\\/li&gt;/gm); // 设置返回给浏览器的文档类型和编码格式 res.setHeader('Content-Type', 'text/html;charset=utf8'); // 响应浏览器 res.end(matches.join('')); &#125;); &#125; ); client.end();&#125;);server.listen(3000); 上面的正则匹配中 ([\\s\\S*?]) 代表匹配 &lt;li class=&#39;bold-item&#39;&gt; 到 &lt;\\/li&gt; 之间所有内容（多个字符、非贪婪模式），gm 代表全局并多行匹配。 上面爬取百度新闻数据的过程中，我们自己的 Node 服务器扮演了一个 “中间层” 的角色，我们通过浏览器访问自己的服务器 localhost:3000 触发 request 事件，执行了回调，在回调中创建客户端向 news.baidu.com 发送了请求，并在客户端的回调中处理了响应（百度新闻页返回的数据），将处理后的内容通过我们自己 Node 服务器的 res 对象返回给了浏览器。 总结相信在读过本篇文章之后对搭建一个 Node 服务应该已经有了思路，为未来通过 Node 服务实现复杂的业务场景及数据的处理打下了一个基础，希望初学 Node 的小伙伴在看了这篇文章后能有所收获。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"}]},{"title":"HTTP 基础","date":"2018-07-09T10:51:49.000Z","path":"2018/07/09/20180709185149/","text":"HTTP 和 TCP 的关系HTTP 是在 TCP 传输协议上层的应用层协议，主要解决如何包装数据的问题，关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP 协议，但是如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议，Web 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上”。 HTTP 协议和 TCP 协议HTTP 访问到服务器的过程从在浏览器中输入一个网址直到请求到达服务器的过程中如下图。 HTTP 协议访问服务器流程 长连接在 HTTP1.0 版本中，每一个请求都需要在 TCP 协议中经历 “三次握手四次挥手”，在 HTTP1.1 中有了长连接，这个问题得到了改善，可以通过创建的一次 TCP 连接，进行多次请求响应，并在结束后关闭 TCP 连接。 HTTP1.0 版本： HTTP1.0 版本 HTTP1.1 长连接版本： HTTP1.1 版本 管线化在不同的浏览器中对于访问同一个域名，都有一个最大的请求数限制，数量大小因浏览器而异，如果请求数量大于最大请求数限制，则需要排队等待其他请求结束。 管线化技术，在超出最大请求数限制，客户端继续发送请求到服务端，而不需要其他请求得到响应的时候才能进行，实现并行发送请求，CDN 是比较典型的解决方式，将静态资源分发到不同 ip 下的服务器，请求资源是通过不同的代理服务器去同时获取，可以提高页面初始化响应的速度。 HTTP 管线化 URI 和 URLURI：是统一资源标识符，在某个规则下能把这个资源独一无二标示出来，类似人的身份证号；URL：统一资源定位符，表示资源的地点，URL 是使用浏览器访问 Web 页面时需要输入的网页地址。 URL 的组成： http://username:password@www.pandashen.com:80/2018/07/09/index.html?uid=1&amp;name=panda#ch1 http：协议类型； username:password：登录信息（如 Github，不安全）； www.pandashen.com：服务器地址（与前面用 @ 连接）； 80：服务器端口号（与前面用 : 连接）； /2018/07/09/index.html：带层次的文件路径； uid=1&amp;name=panda：查询字符串（与前面用 ? 连接）； ch1：片段标识符（hash 值，与前面使用 # 连接）。 HTTP 的组成请求的一方叫客户端，响应的一方叫服务器端，通过请求和响应达成通信，HTTP 是一种无状态的协议。 请求报文请求报文包含请求行、请求首部和请求体三个部分。 请求报文 请求行由三个部分组成，并写在同一行，分别为请求方法、请求路径（域名和端口号后面的部分）和协议/版本号。 请求方法： GET：获取资源 POST：向服务器端发送数据，传输实体主体 PUT：传输文件 HEAD：获取报文首部 DELETE：删除文件 OPTIONS：询问支持的方法 TRACE：追踪路径 追踪路径方式如下图： TRACE 追踪路径 请求体内的内容为向服务端发送的数据，首部分为通用首部、请求首部、响应首部和实体首部四种，在后面详细说明。 响应报文响应报文同样包含三个部分，响应行、响应首部和响应体。 响应报文 响应行由三个部分组成，并写在同一行，分别为协议/版本号、状态码和状态码原因短语。 注意：在请求首部与请求体之间、在响应首部与响应体之间都应该空一个空行。 HTTP 响应状态码状态码负责表示客户端请求的返回结果、标记服务器端是否正常、通知出现的错误。 状态码类别类别原因短语1XXInformational（信息性状态码）2XXSuccess（成功状态码）3XXRedirection（重定向）4XXClient Error（客户端错误状态码）5XXServer Error（服务器错误状态吗） 常见状态码成功状态码原因短语原因解释200OK客户端发过来的数据被正常处理204Not Content正常响应，没有实体206Partial Content范围请求，返回部分数据，响应报文中由 Content-Range 指定实体内容 重定向状态码原因短语原因解释301Moved Permanently永久重定向302Found临时重定向，规范要求方法名不变，但是都会改变成 GET303See Other和 302 类似，但必须用 GET 方法304Not Modified状态未改变，配合（If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since）307Temporary Redirect临时重定向，不该改变请求方法 客户端错误状态码原因短语原因解释400Bad Request请求报文语法错误401Unauthorized需要认证403Forbidden服务器拒绝访问对应的资源404Not Found服务器上无法找到资源 服务器错误状态码原因短语原因解释500Internal Server Error服务器故障503Service Unavailable服务器处于超负载或正在停机维护 HTTP 首部HTTP 首部字段是 HTTP 报文首部的重要部分，在客户端和服务器进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。 HTTP 首部主要分为通用首部、请求首部、响应首部和实体首部四种： 通用首部字段：请求和响应报文两方都会使用的首部字段； 请求首部字段：从客户端向服务器发送请求报文时使用的首部字段，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息； 响应首部字段：从服务器向客户端返回响应报文时使用的首部字段；补充了响应的附加内容，也会要求客户端附加额外的内容信息； 实体首部字段：针对请求报文和响应报文的实体部分使用的首部，补充了资源内容的更新时间等与实体有关的信息。 通用首部字段首部字段名说明Cache-Control控制缓存行为Connection链接的管理Date报文日期Pragma报文指令Trailer报文尾部的首部Trasfer-Encoding指定报文主体的传输编码方式Upgrade升级为其他协议Via代理服务器信息Warning错误通知 请求首部字段首部字段名说明Accept用户代理可处理的媒体类型Accept-Charset优先的字符集Accept-Encoding优先的编码Accept-Langulage优先的语言AuthorizationWeb 认证信息Expect期待服务器的特定行为From用户的电子邮箱地址Host请求资源所在的服务器If-Match比较实体标记If-Modified-Since比较资源的更新时间If-None-Match比较实体标记If-Range资源未更新时发送实体 Byte 的范围请求If-Unmodified-Since比较资源的更新时间（ 与 If-Modified-Since相反 ）Max-Forwards最大传输跳数Proxy-Authorization代理服务器需要客户端认证Range实体字节范围请求Referer请求中的URI的原始获取方TE传输编码的优先级User-AgentHTTP 客户端程序的信息 响应首部字段首部字段名说明Accept-Ranges是否接受字节范围Age资源的创建时间ETag资源的匹配信息Location客户端重定向至指定的 URIProxy-Authenticate代理服务器对客户端的认证信息Retry-After再次发送请求的时机Server服务器的信息Vary代理服务器缓存的管理信息www-Authenticate服务器对客户端的认证 实体首部字段首部字段名说明Allow资源可支持的 HTTP 方法Content-Encoding实体的编码方式Content-Language实体的自然语言Content-Length实体的内容大小（字节为单位）Content-Location替代对应资源的 URIContent-MD5实体的报文摘要Content-Range实体的位置范围Content-Type实体主体的媒体类型Expires实体过期时间Last-Modified资源的最后修改时间 总结本篇重点介绍关于 HTTP 协议的一点基础知识，关于请求、响应以及报文对应的信息及内容，也可以用作查询使用。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"TCP","slug":"TCP","permalink":"https://www.pandashen.com/tags/TCP/"}]},{"title":"基于 TCP 实现简易聊天室","date":"2018-07-08T04:03:57.000Z","path":"2018/07/08/20180708120357/","text":"前言TCP 为传输层协议，在 NodeJS 中，基于 TCP 的核心模块为 net，http 和 https 模块都是基于 net 实现的，我们先简单介绍 net 的用法，再根据 net 实现一个简易的聊天室。 net 模块的基本用法使用 net 创建一个网络服务方式 1： 12345678const net = require('net');// 创建 TCP 服务const server = net.createServer(function(socket) &#123; // ......&#125;);server.listen(3000); 方式 2： 1234567891011const net = require('net');// 创建 TCP 服务const server = net.createServer();// 监听连接server.on('connection', function(socket) &#123; // ......&#125;);server.listen(3000); 上面两种创建网络服务的方式第二种更常用，回调函数的参数都为 socket（套接字），在产生连接时执行，每产生一个连接就会产生一个 socket，我们也可以将 socket 理解为客户端。 如果现在使用浏览器连接这个服务可以成功接收到请求，但浏览器是 http 协议，不识别，所以不会有任何响应。 使用 TCP 模拟 http1234567891011121314151617181920212223242526272829303132const net = require('net');// 创建 TCP 服务const server = net.createServer();// 监听连接server.on('connection', function(socket) &#123; // 设置编码 socket.setEncoding('utf8'); // 读取请求报文 socket.on('data', function(data) &#123; console.log(data); &#125;); // 给浏览器返回响应报文 socket.write(`HTTP/1.1 200 okContent-Length: 5hello `);&#125;);server.listen(3000);// GET /favicon.ico HTTP/1.1// Host: localhost:3000// Connection: keep-alive// Pragma: no-cache// Cache-Control: no-cache// ...... 后面省略 soket 是一个可读可写流 Duplex（双工流），所以既可以读取来自浏览器的请求信息，又可以写入响应信息，在模拟 http 时需遵循 http 协议规则，每行前面不允许有空格或制表符，响应头与响应正文之间需空一行。 此时启动服务，使用浏览器访问 localhost:3000 可以在控制台打印请求报文，并在浏览器中显示 hello。 http 的头部信息可以通过命令窗口中使用 curl 发送请求进行查看，输入命令为 curl -v http://.....，默认命令行窗口是不支持 curl 命令的，请在 curl 官网 下载系统对应的版本，在 Windows 系统中，下载后的压缩包解压后将 curl.exe 和 ca-bundle.crt 拷贝至 C:\\Windows\\System32 或将所在文件夹添加至系统环境变量。 server、socket 的属性和方法在 TCP 创建的服务 server 和连接中的 socket 本身具有一些属性、方法和事件，我们通过下面这个例子来介绍。 123456789101112131415161718192021222324252627282930313233343536373839404142const net = require('net');// 创建 TCP 服务器const server = net.createServer();server.on('connection', function(socket) &#123; // 客户端的 ip + 端口号 let key = socket.remoteAddress + socket.remotePort; server.getConnetions(function(err, count) &#123; socket.write(`当前有$&#123;count&#125;人，总人数为$&#123;server.maxConnections&#125;人。`); &#125;); socket.on('data', function(data) &#123; // 设置编码 socket.setEncoding('utf8'); // 关闭客户端 // socket.end(); // 关闭服务器 // server.close(); server.unref(); &#125;);&#125;);// 最大连接数server.maxConnections = 3;server.on('close', function() &#123; console.log('服务端关闭');&#125;);server.on('error', function(err) &#123; if (err.code === 'EADDRINUSE') &#123; server.listen(err.port + 1); &#125;&#125;);server.listen(3000, function() &#123; console.log('server start 3000');&#125;); socket.remoteAddress 属性，获取客户端的 IP 地址。 socket.remotePort 属性，获取客户端的端口号。 socket.setEncoding 方法，设置编码格式。 socket.write 方法，向客户端写入内容，写入内容的值只能为字符串或 Buffer。 socket.end 方法，断开对应客户端的连接，并返回信息，返回内容的值只能为字符串或 Buffer，soket 可以监听 end 事件，当关闭客户端时触发并执行回调。 socket.destroy 方法，用于销毁当前客户端对应的 socket 对象。 server.maxConnections 属性，是当前服务器允许的最大连接数，数值类型，当连接数超过设定值时，新的客户端将无法连接服务器。 server.getConnetions 方法，获取当前的连接数，参数为回调函数，回调函数有两个参数 err（错误）和 count（当前连接数），异步执行。 server.close 方法，关闭服务器，并没有真的关闭服务器，而是不允许新的连接，直到所有连接都断开后自动关闭服务器。 server.unref 方法，关闭服务器的另一种形式，不阻止新的连接，当所有连接都断开时自动关闭服务器。 server.listen 方法，监听端口号，支持传入回调，在启动服务后执行。 server 的 close 事件，参数为回调函数，异步执行，当服务器关闭时触发。 server 的 error 事件，参数为回调函数，回调函数的参数为 err（错误对象），异步执行，当启动服务器或服务器运行时出现错误触发。 在 Webpack 中如果启动 webpack-dev-server 在端口号被占用时，端口号会自动 +1，我们可以利用 err 错误对象来模拟，在 err 事件对象上有很多属性，其中的 code 属性值为 EADDRINUSE 时代表端口号被占用，所以在判断 code 值后，重新调用了 server.listen 并传入重新计算后的端口号。 想看一看上面代码的效果需要客户端的支持，本文中模拟客户端访问服务器有三种方式，使用一种即可。 创建客户端验证我们自己实现的 TCP 服务器需要客户端访问，在本文的主题简易聊天室当中也需要用户和客户端，所以介绍一下创建客户端的方式。 可以使用 net 模块创建客户端，并启访问服务器； Mac 中可以直接在命令窗口执行 brew install telnet 安装 telnet，安装后输入 telnet localhost 3000 即可以访问上面的服务器； Windows 中 telnet 接收到的服务器响应会变成乱码，所以可以使用 Xshell 和 PuTTY 等客户端工具。 使用 net 创建客户端代码如下： 客户端：client.js1234567const net = require('net');// 创建客户端const client = net.createConnection(&#123; port: 3000 &#125;);// 给服务器发送消息client.write('s:username:message'); 为了方便本文中使用 PuTTY 工具，Windows 系统在使用之前需打开 Telnet 服务端和客户端，通过控制面板 → 打开或关闭 Windows 功能 → 勾选 Telnet 服务端和客户端。 PuTTY 界面如下，在 Connection type（连接类型）中默认为 SSH，我们之所以使用 Raw 而不使用其他类型是因为其他的方式在连接服务器时会发送窗口信息，我们不需要这些数据。 PuTTY 界面 点击界面下面的 Open 按钮就可以创建一个客户端连接，客户端窗口如下，可以通过输入并回车确定的方式向服务端发送消息。 PuTTY 客户端窗口 目前所有的准备工作已经就绪，下面就是我们的正题，用 net 模块实现一个 TCP 服务，并使用 PuTTY 作为客户端，实现一个简易的聊天室。 实现简易聊天室定义聊天室规则聊天室主要有四个功能，都需要输入对应的命令。 显示在线用户：命令为 l； 改名：聊天室默认用户名为匿名，重命名的命令为 r:newname； 私聊：私聊的参数为聊天对象的名字和消息内容，命令为 s:username:message； 广播：发送的消息除自己以外的所有人都能接收到，命令为 b:message。 在存储所有的客户端时，都使用客户端的 ip + port 作为用户的唯一标识。 服务搭建服务器：server.js123456789101112131415161718192021222324252627282930313233343536373839404142434445const net = require('net');// 处理输入命令模块const processInstructs = require('./process-instructs');const server = net.createServer(); // 创建服务const client = &#123;&#125;; // 客户端const port = 3000; // 端口号// 监听连接server.on('connection', socket =&gt; &#123; // 客户端的 ip + 端口号 作为存储客户端的唯一标识 let key = socket.remoteAddress + socket.remotePort; // 将客户端添加到 client 存储中 client[key] = &#123; username: '匿名', socket &#125;; // 欢迎功能 server.getConnections((err, count) =&gt; &#123; socket.write(`欢迎加入！目前有 $&#123;count&#125; 人。\\r\\n`); &#125;); // 设置编码 socket.setEncoding('utf8'); // 监听用户输入 socket.on('data', data =&gt; &#123; // 由于输入消息按回车键确认，所以需处理消息中的回车 data = data.replace(/\\r\\n/, ''); // 处理输入并做出响应 processInstructs(client, key, data); &#125;); // 客户端主动关闭后在服务器客户端存储中清除客户端，并销毁对应的 socket socket.on('end', () =&gt; &#123; socket.destroy(); delete client[key]; &#125;);&#125;);// 监听端口号server.listen(port, () =&gt; &#123; console.log(`server start $&#123;port&#125;`);&#125;); 在上面的服务搭建当中，创建了 client 对象，专门存储聊天室内的客户端及信息，客户端使用 ip + port 作为存储的唯一标识，用户名默认为 “匿名”，设置了欢迎功能，并显示当前在线人数，监听用户的输入，并处理了消息中的回车，引入 process-instructs 对指令进行处理，最后处理了离开的用户，目的是防止有离开后，其他的人使用了私聊或广播功能通知这个人，因为找不到对应的 socket 而出现错误。 处理指令模块 process-instructs文件：process-instructs.js123456789101112131415161718192021222324// 引入处理不同指令的功能函数const &#123; list, rename, private, broadcast &#125; = require('./instructs');module.exports = function(client, key, data) &#123; const dataArr = data.split(':'); // 针对不同的指令调用不同的处理方法 switch (dataArr[0]) &#123; case 'l': list(client, key); break; case 'r': rename(client, key, dataArr); break; case 's': private(client, key, dataArr); break; case 'b': broadcast(client, key, dataArr); break; default: socket.write('命令有误\\r\\n'); &#125;&#125;; 在上面对指令的处理中针对不同的指令引入了 instructs 模块对应的处理方法。 指令处理方法模块 instructs文件：instructs.js1234567891011121314151617181920212223242526272829303132333435363738// 处理 l 指令，显示在线用户exports.list = function(client, key) &#123; // 获取当前 socket let socket = client[key].socket; // 写入信息 soket.write('当前用户列表:\\r\\n'); Object.values(client).forEach(p =&gt; &#123; socket.write(`$&#123;p.username&#125;\\r\\n`); &#125;);&#125;;// 处理 r 指令，用户重命名exports.rename = function(client, key, dataArr) &#123; let newName = dataArr[1]; // 更新对应 socket 的新用户名并通知 client[key].username = newName; client[key].socket.write(`新用户名是: $&#123;newName&#125;\\r\\n`);&#125;;// 处理 s 指令，私聊exports.private = function() &#123; Object.keys(client).forEach(c =&gt; &#123; if (client[c].username === dataArr[1]) &#123; client[c].socket.write(`$&#123;client[key].username&#125;: $&#123;dataArr[2]&#125;\\r\\n`); &#125; &#125;);&#125;;// 处理 b 指令，广播exports.broadcast = function() &#123; Object.keys(client).forEach(c =&gt; &#123; if (c !== key) &#123; client[c].socket.write(`$&#123;client[key].username&#125;: $&#123;dataArr[1]&#125;\\r\\n`); &#125; &#125;);&#125;; 显示在线用户功能的思路是将 client 内部所有在线用户的用户名循环写入到当前 socket 中，重命名功能的思路是获取输入的新用户名替换掉 client 中对应的 username 并将当前新用户名设置成功的消息返回当前 socket，私聊功能的思路是循环 client 内的所有客户端，当 username 和发送的用户名相同时，将消息写入这个用户名对应的 socket，广播功能思路是循环 client，将消息写入给出自己以外的所有客户端。 总结本文重点在于理解多人聊天功能的开发思路，及 NodeJS 中关于 TCP 传输对应的 net 模块的使用，实际上本文中聊天室的代码在用户重名的情况下并没有做任何处理，正常情况应该使用 id 作为唯一标识，而不是指定用户名，在 NodeJS 开发中其实很少直接使用 net 大多情况下使用 http 和 https 来替代，但是我们应该知道他们都是基于 net 封装的，了解 net 会在使用 http 和 https 时更得心应手。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"TCP","slug":"TCP","permalink":"https://www.pandashen.com/tags/TCP/"}]},{"title":"使用 NodeJS 可读流实现 “行读取器”","date":"2018-07-06T04:04:28.000Z","path":"2018/07/06/20180706120428/","text":"前言本文是对于 NodeJS 核心模块 fs 可读流 createReadeStream 的应用，实现 “行读取器”，功能为读取一个文档的内容，每读完一行触发一次监听的事件，并对这一行数据进行处理。 LineReader 类的创建实现 “行读取器” 的整体思路是创建一个类的实例，然后在这个实例上监听一个事件，并开始读取文件，每次读完一行触发，我们这里将这个类命名为 LineReader，因为类需要监听事件，所以需要继承 EventEmitter。 行读取器 LineReader 类1234567891011121314151617181920// 引入依赖const EventEmitter = require('events');const fs = require('fs');// 行读取器的类，参数为读取文件的路径class LineReader extends EventEmitter &#123; contructor(path) &#123; super(); this.path = path; // 文件路径 this._rs = fs.createReadStream(this.path); // 创建可读流 this.current = null; // 存储每次读到的单个字节 this.arr = []; // 存放文件每一行单个字节 Buffer 的数组 this.system = null; // 默认的系统（windows 或 mac） this.RETURN = 13; // \\r 的十六进制数 this.Line = 10; // \\n 的十六进制数 // 监听 newListener this.on('newListener', readLineCallback.bind(this)); &#125;&#125; 在 LineReader 实例上定义了 system（当前系统）、current（每次读取的单个字节）、RETURN（\\r 十六进制编码）和 Line（\\n 十六进制编码）等属性方便后面使用。 我们希望在监听的事件触发之前，就执行读取文件一行内容的逻辑，就说明我们需要一个在监听事件时就能执行的函数，那就需要在创建实例之前先监听 newListener 事件，把 newListener 的回调来作为这个函数执行，并能顺带在参数中获取事件类型。 我们把读取文件的核心逻辑放在了 newListener 事件的回调函数中，将这个回调函数命名为 readLineCallback，为了保证执行时 readLineCallback 内部使用的 this 是 LineReader 的实例，使用 bind 进行修正。 行读取器核心逻辑 readLineCall 函数如果需要默认就开始读取，并且每次读取一个字节后还可以进行下一次循环读取，这种场景最符合可读流的暂停模式 readable 事件默认触发一次，“容器” 内读走了一个字节，就会自动 “续杯” 的特点。 行读取器的核心逻辑123456789101112131415161718192021222324252627function readLineCallback(type) &#123; // 使用暂停模式进行读取 this.on('readable', () =&gt; &#123; if (type === 'newLine') &#123; // 为了与 \\r 和 \\n 对比，每次只读一个字节 while ((this.current = this._rs.read(1))) &#123; // 结果为 Buffer，所以使用索引取出对比 switch (this.current[0]) &#123; case RETURN: // 针对 Windows this.system = 'windows'; this.disposeLine(); // 处理换行逻辑 break; case LINE: // 针对 Mac this.system = 'mac'; this.disposeLine(); // 处理换行逻辑 break; default: // 每读到换行的字符存入数组中 this.arr.push(current); &#125; &#125; &#125; &#125;); // 防止最后一行丢失 this.on('end', this.disposeLine.bind(this));&#125; 在上面代码中监听了 readable 事件并验证了事件类型是否为 newLine，然后循环读取文件内容，为了与换行的十六进制码进行对比，每次只读取一个字节，当遇到换行符时，明确当前系统并调用换行符处理函数 disposeLine 进行处理。 注意：在最后一次的时候文件最后一行可能没有换行，所以不满足 switch 内语句的条件，即没使用 disposeLine 进行处理，所以监听可读流的 end 事件，并在 end 触发时让 disposeLine 作为回调函数执行，注意使用 bind 修正 this 为当前实例。 兼容 Windows 和 Mac 的换行符处理函数在换行符处理函数中，Windows 与其他系统（Mac、Linux）系统唯一的区别就是 Window 系统的换行符为 \\r\\n，比 Mac 和 Linux 的 \\n 多了一个字节，而在读取下一行时，这个字节是无用的，需要忽略。 换行符处理函数12345678910LineReader.prototype.disposeLine = function() &#123; // 将这一行的内容发射出来并清空数组 this.emit('newLine', Buffer.concat(this.arr).toString()); this.arr = []; // 如果是 window 系统，下一个是 \\n，就往下多读一个字节不存入组即可 if (this.system === 'windows') &#123; this._rs.read(1); &#125;&#125;; 验证 LineReader 行读取器创建一个 “行读取器” 需要创建 LineReader 类的实例，并传入被读取文件的路径，由于在源码中执行的是 newListener 的回调函数，所以只需添加 newLine 事件监听就可以了，然后会在 readable 默认触发时在内部循环读取，并把每行读到的内容重新整合后发送，实现 newLine 事件的连续触发，直到文件读完。 使用行读取器12345678910// 创建文件 1.txt 每次内容为 1~9 9个数字，每 3 个字符为一行const lineReader = new LineReader('1.txt');lineReader.on('newLine', data =&gt; &#123; console.log(`------ $&#123;data&#125; ------`);&#125;);// ------ 123 ------// ------ 456 ------// ------ 789 ------ “行读取器” lineReader 对读取到每一行的数据进行处理的逻辑主要在 newLine 事件的回调函数中，比如上面例子，在每一行的前、后添加了 ------ 并打印。 总结在 NodeJS 中，流的应用非常广泛，“行读取器” 只是其中的一种表现，可以根据流的不同模式的不同特性实现更复杂的功能，所以流在 NodeJS 中还是非常重要的。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"Stream","slug":"Stream","permalink":"https://www.pandashen.com/tags/Stream/"},{"name":"LineReader","slug":"LineReader","permalink":"https://www.pandashen.com/tags/LineReader/"}]},{"title":"NodeJS —— 自定义流的实现","date":"2018-07-05T04:55:01.000Z","path":"2018/07/05/20180705125501/","text":"概述常见的自定义流有四种，Readable（可读流）、Writable（可写流）、Duplex（双工流）和 Transform（转换流），常见的自定义流应用有 HTTP 请求、响应，crypto 加密，进程 stdin 通信等等。 stream 模块介绍在 NodeJS 中要想实现自定义流，需要依赖模块 stream，直接引入，不需下载，所有种类的流都是继承这个模块内部提供的对应不同种类的类来实现的。 实现一个自定义可读流 Readable创建自定义可读流的类 MyRead实现自定义可读流需创建一个类为 MyRead，并继承 stream 中的 Readable 类，重写 _read 方法，这是所有自定义流的固定套路。 创建自定义可读流12345678910111213141516171819const &#123; Readable &#125; = require('stream');// 创建自定义可读流的类class MyRead extends Readable &#123; constructor() &#123; super(); this.index = 0; &#125; // 重写自定义的可读流的 _read 方法 _read() &#123; this.index++; this.push(this.index + ''); if (this.index === 3) &#123; this.push(null); &#125; &#125;&#125; 我们自己写的 _read 方法会先查找并执行，在读取时使用 push 方法将数据读取出来，直到 push 的值为 null 才会停止，否则会认为没有读取完成，会继续调用 _read。 2、验证自定义可读流验证自定义可读流1234567891011121314const myRead = new MyRead();myRead.on('data', data =&gt; &#123; console.log(data);&#125;);myRead.on('end', function() &#123; console.log('读取完成');&#125;);// &lt;Buffer 31&gt;// &lt;Buffer 32&gt;// &lt;Buffer 33&gt;// 读取完成 实现一个自定义可写流 Writable创建自定义可写流的类 MyWrite创建一个类名为 MyWrite，并继承 stream 中的 Writable 类，重写 _write 方法。 创建自定义可写流123456789const &#123; Writable &#125; = require('stream');// 创建自定义可写流的类class MyWrite extends Writable &#123; // 重写自定义的可写流的 _write 方法 _write(chunk, encoding, callback)) &#123; callback(); // 将缓存区写入文件 &#125;&#125; 写入内容时默认第一次写入直接写入文件，后面的写入都写入缓存区，如果不调用 callback 只能默认第一次写入文件，调用 callback 会将缓存区清空并写入文件。 2、验证自定义可写流验证自定义可写流123456789101112const myWrite = new MyWrite();myWrite.write('hello', 'utf8', () =&gt; &#123; console.log('hello ok');&#125;);myWrite.write('world', 'utf8', () =&gt; &#123; console.log('world ok');&#125;);// hello ok// world ok 实现一个自定义双工流 Duplex创建自定义可双工流的类 MyDuplex双工流的可以理解为即可读又可写的流，创建一个类名为 MyDuplex，并继承 stream 中的 Duplex 类，由于双工流即可读又可写，需重写 _read 和 _write 方法。 创建自定双工流123456789101112131415const &#123; Duplex &#125; = require('stream');// 创建自定义双工流的类class MyDuplex extends Duplex &#123; // 重写自定义的双工流的 _read 方法 _read() &#123; this.push('123'); this.push(null); &#125; // 重写自定义的双工流的 _write 方法 _write(chunk, encoding, callback)) &#123; callback(); &#125;&#125; 双工流分别具备 Readable 和 Writable 的功能，但是读和写互不影响，互不关联。 验证自定义双工流验证自定义双工流12345678910111213141516const myDuplex = new MyDuplex();myDuplex.on('readable', () =&gt; &#123; console.log(myDuplex.read(1), '----');&#125;);setTimeout(() =&gt; &#123; myDuplex.on('data', data =&gt; &#123; console.log(data, 'xxxx'); &#125;);&#125;, 3000);// &lt;Buffer 31&gt; ----// &lt;Buffer 32&gt; xxxx// &lt;Buffer 32&gt; ----// &lt;Buffer 33&gt; xxxx 如果 readable 和 data 两种读取方式都使用默认先通过 data 事件读取，所以一般只选择一个，不要同时使用，可读流的特点是读取数据被消耗掉后就丢失了（缓存区被清空），如果非要两个都用可以加一个定时器（绝对不要这样写）。 实现一个自定义转化流 Transform创建自定义可转化流的类 MyTransform转化流的意思是即可以当作可读流，又可以当作可写流，创建一个类名为 MyTransform，并继承 stream 中的 Transform 类，重写 _transform 方法，该方法的参数和 _write 相同。 创建自定义转化流1234567891011const &#123; Transform &#125; = require('stream');// 创建自定义转化流的类class MyTransform extends Transform &#123; // 重写自定义的转化流的 _transform 方法 _transform(chunk, encoding, callback)) &#123; console.log(chunck.toString.toUpperCase()); callback(); this.push('123'); &#125;&#125; 在自定义转化流的 _transform 方法中，读取数据的 push 方法和 写入数据的 callback 都可以使用。 由此可以看出，Transform 类型可以将可读流转化为可写流，也可以将可写流转化成可读流，他的主要目的不是像其他类型的流一样负责数据的读写，而是既作为可读流又作为可写流，实现流的转化，即实现对数据的特殊处理，如 zib 模块实现的压缩流，cropo 模块实现的加密流，本质都是转化流，将转化流作为可写流，将存储文件内容的可写流通过 pipe 方法写入转化流，再将转化流作为可读流通过 pipe 方法将处理后的数据响应给浏览器。 验证自定义转化流验证自定义转化流1234const myTransForm = new MyTransform();// 使用标准输入process.stdin.pipe(myTransForm).pipe(process.stdin); 打开命令行窗口执行 node demo.js，然后输入 abc，会在命令窗口输出 ABC 和 123，其实转换流先作为一个可写流被写入到标准输入中，而此时 stdin 的作用是读流，即读取用户的输入，读取后转换流作为一个可读流调用 pipe，将用户输入的信息通过标准输出写到命令行窗口，此时 stdout 的作用是写流。 总结自定义流最常见的种类在上面都已经涵盖了，真正的在开发中用到的不多，如果需要写一个自定义流应该比上面的复杂很多，本文主要目的是认识什么是自定义流，并了解写一个自定义流的基本套路。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"Stream","slug":"Stream","permalink":"https://www.pandashen.com/tags/Stream/"}]},{"title":"NodeJS —— 流的原理分析与简易实现","date":"2018-07-04T09:52:17.000Z","path":"2018/07/04/20180704175217/","text":"前言在之前的博客中已经了解了流的基本用法，这篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 ReadStream，流的基本用法请看这里 NodeJS —— Stream 的基本使用。 可读流的实现（流动模式）ReadStream 类创建在使用 fs 的 createReadStream 创建可读流时，返回了 ReadStream 对象，上面存在着一些事件和方法，其实我们在创建这个可读流的时候创建了某一个类的实例，这个实例可以调用类原型上的方法，我们这里将这个类命名为 ReadStream。 在类原型上的方法内部可能会创建一些事件，在 NodeJS 中，事件是依赖 events 模块的，即 EventEmitter 类，同时类的方法可能会操作文件，会用到 fs 模块，所以也提前引入 fs。 创建 ReadStream 类12345678910111213141516171819202122232425262728293031323334353637383940414243// 引入依赖模块const EventEmitter = require('events');const fs = require('fs');// 创建 ReadStream 类class ReadStream extends EventEmitter &#123; constructor(path, options = &#123;&#125;) &#123; super(); // 创建可读流参数传入的属性 this.path = path; // 读取文件的路径 this.flags = options.flags || 'r'; // 文件标识位 this.encoding = options.encoding || null; // 字符编码 this.fd = options.fd || null; // 文件描述符 this.mode = options.mode || 0o666; // 权限位 this.autoClose = options.autoClose || true; // 是否自动关闭 this.start = options.start || 0; // 读取文件的起始位置 this.end = options.end || null; // 读取文件的结束位置（包含） // 每次读取文件的字节数 this.highWaterMark = options.highWaterMark || 64 * 1024; this.flowing = false; // 控制当前是否是流动状态，默认为暂停状态 // 存储读取内容的 Buffer this.buffer = Buffer.alloc(this.highWaterMark); this.pos = this.start; // 下次读取文件的位置（变化的） // 创建可读流要打开文件 this.open(); // 如果监听了 data 事件，切换为流动状态 this.on('newListener', type =&gt; &#123; if (type === 'data') &#123; this.flowing = true; // 开始读取文件 this.read(); &#125; &#125;); &#125;&#125;// 导出模块module.exports = ReadStream; 使用 fs.createReadStream 时传入了两个参数，读取文件的路径和一个 options 选项，options 上有八个参数，我们在创建 ReadStream 类的时候将这些参数初始化到了 this 上。 创建可读流的时候有两种状态，流动状态和暂停状态，默认创建可读流是暂停状态，只有在触发 data 事件时才会变为流动状态，所以在 this 上挂载了 flowing 存储当前的状态是否为流动状态，值默认为 false。 注意：这里说的暂停状态不是暂停模式，暂停模式是 readable, 是可读流的另一种模式，我们这节讨论的可读流为流动模式。 在读取文件时其实是操作 Buffer 进行读取的，需要有一个 Buffer 实例用来存储每次读取的数据，所以在 this 上挂载了一个新创建的 Buffer，长度等于 highWaterMark。 当从 start 值的位置开始读取文件，下一次读取文件的位置会发生变化，所以在 this 上挂载了 pos 属性，用于存储下次读取文件的位置。 在创建 ReadStream 的实例（可读流）时，应该打开文件并进行其他操作，所以在 this 上挂载了 open 方法并执行。 创建实例的同时监听了 newListener 事件，回调在每次使用 on 监听事件时触发，回调内部逻辑是为了将默认的暂停状态切换为流动状态，因为在使用时，流动状态是通过监听 data 事件触发的，在 newListener 的回调中判断事件类型为 data 的时候将 flowing 标识的值更改为 true，并调用读取文件的 read 方法。 在使用 ES6 的类编程时，原型上的方法都是写在 class 内部，我们下面为了把原型上的方法拆分出来成为单独的代码块，都使用 ReadStream.prototype.open = function... 直接给原型添加属性的方式，但这样的方式和直接写在 class 内有一点区别，就是 class 内部的书写的原型方法都是不可遍历的，添加属性的方式创建的方法都是可遍历的，但是这点区别对我们代码的执行没有任何影响。 打开文件方法 open 的实现在使用可读流时，打开时默认是暂停状态，会触发 open 事件，如果打开文件出错会触发 error 事件。 open 方法12345678910111213141516171819202122// 打开文件ReadStream.prototype.open = function() &#123; fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; &#123; if (err) &#123; this.emit('error', err); // 如果文件打开了出错，并配置自动关闭，则关掉文件 if (this.autoClose) &#123; // 关闭文件（触发 close 事件） this.destroy(); // 不再继续执行 return; &#125; &#125; // 存储文件描述符 this.fd = fd; // 成功打开文件后触发 open 事件 this.emit('open'); &#125;);&#125; open 方法的逻辑就是在打开文件的时候，将文件描述符存储在实例上方便后面使用，并使用 EventEmitter 的原型方法 emit 触发 open 事件，如果出错就使用 emit 触发 error 事件，如果配置 autoClose 参数为 true，就关闭文件并触发 close。 我们将关闭文件的逻辑抽取出来封装在了 ReadStream 类的 destroy 方法中，下面来实现 destroy。 关闭文件方法 destroy 的实现文件出错分为两种，第一种文件打开出错，第二种是文件不存在出错（没打开），第二种系统是没有分配文件描述符的。 detroy 方法1234567891011121314// 关闭文件ReadStream.prototype.detroy = function() &#123; // 判断是否存在文件描述符 if (typeof this.fd === 'number') &#123; // 存在则关闭文件并触发 close 事件 fs.close(fd, () =&gt; &#123; this.emit('close'); &#125;); return; &#125; // 不存在文件描述符直接触发 close 事件 this.emit('close');&#125; 如果是打开文件后出错需要关闭文件，并触发 close 事件，如果是没打开文件，则直接触发 close 事件，所以上面通过文件描述符来判断该如何处理。 读取文件方法 read 的实现还记得在 ReadStream 类中，监听的 newListener 事件的回调中如果监听了 data 事件则会执行 read 读取文件，接下来就实现读取文件的核心逻辑。 read 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 读取文件ReadStream.prototype.read = function() &#123; // 由于 open 异步执行，read 是在创建实例时同步执行 // read 执行可能早于 open，此时不存在文件描述符 if (typeof this.fd !== 'number') &#123; // 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 read return this.once('open', () =&gt; this.read()); &#125; // 如过设置了结束位置，读到结束为止就不能再读了 // 如果最后一次读取真实读取数应该小于 highWaterMark // 所以每次读取的字节数应该和 highWaterMark 取最小值 let howMuchToRead = this.end ? Math.min(this.highWaterMark, this.end - this.pos + 1) : this.highWaterMark; // 读取文件 fs.read( this.fd, this.buffer, 0, howMuchToRead, this.pos, (err, bytesRead) =&gt; &#123; // 如果读到内容执行下面代码，读不到则触发 end 事件并关闭文件 if (bytesRead &gt; 0) &#123; // 维护下次读取文件位置 this.pos += bytesRead; // 保留有效的 Buffer let realBuf = this.buffer.slice(0, bytesRead); // 根据编码处理 data 回调返回的数据 realBuf = this.encoding ? realBuf.toString(this.encoding) : realBuf; // 触发 data 事件并传递数据 this.emit('data', realBuf); // 递归读取 if (this.flowing) &#123; this.read(); &#125; &#125; else &#123; this.isEnd = true; this.emit('end'); // 触发 end 事件 this.detroy(); // 关闭文件 &#125; &#125; );&#125; 创建 ReadStream 的实例时，执行的 open 方法内部是使用 fs.open 打开文件的，是异步操作，而读取文件方法 read 是在 newListener 回调中同步执行的，这样很可能触发 read 的时候文件还没有被打开（不存在文件描述符），所以在 read 方法中判断了文件描述符是否存在，并在不存在时候使用 once 添加了 open 事件，回调中重新执行了 read。 由于在 open 方法中使用 emit 触发了 open 事件，所以 read 内用 once 添加的 open 事件的回调也会跟着执行一次，并在回调中重新调用了 read 方法，保证了 read 读取文件的逻辑在文件真正打开后才执行，为了文件打开前执行 read 而不执行读取文件的逻辑，用 once 添加 open 事件时别忘记 return。 在使用 fs.read 读取文件的时候有一个参数为本次读取几个字符到 Buffer 中，如果在创建可读流的时候设置了读取文件的结束位置 end 参数，则读到 end 位置就不应该再继续读取了，所以在存在 end 参数的时候每次都计算一下读取个数和 highWaterMark 取最小值，保证读取内容小于 highWaterMark 的时候不会多读，因为读取时是包括 end 值作为 Buffer 的索引这一项的，所以计算时多减去的要 +1 加回来，再一次读取这个读取个数计算结果变成了 0，也就结束了读取。 因为 end 参数的情况，所以在内部读取逻辑前判断了 bytesRead （实际读取字节数）是否大于 0，如果不满足条件则在实例添加是否读取结束标识 isEnd（后面使用），触发 end 事件并关闭文件，如果满足条件，也是通过 bytesRead 对 Buffer 进行截取，保留了有用的 Buffer，并且通过 encoding 编码对 Buffer 进行处理后，触发 data 事件，并将处理后的数据传递给 data 事件的回调。 暂停、恢复读取 pause 和 resumepause 的目的就是暂停读取，其实就是阻止 read 方法在读取时进行递归，所以只需要更改 flowing 的值即可。 pause 方法1234// 暂停读取ReadStream.prototype.pause = function() &#123; this.flowing = false;&#125;; resume 的目的是恢复读取，在更改 flowing 值得基础上重新执行 read 方法，由于在 pause 调用时 read 内部还是执行得读取文件得分支，文件并没有关闭，读取文件位置的参数也是通过实例上的当前的属性值进行计算的，所以重新执行 read 会继续上一次的位置读取。 resume 方法12345// 恢复读取ReadStream.prototype.resume = function() &#123; this.flowing = true; if (!this.isEnd) this.read();&#125;; 上面在重新执行 read 之前使用 isEnd 标识做了判断，防止在 setInterval 中调用 resume 在读取完成后不断的触发 end 和 close 事件。 验证可读流（流动模式）ReadStream接下来我们使用自己实现的 ReadStream 类来创建可读流，并按照 fs.createReadStream 的用法进行使用并验证。 验证 ReadStream12345678910111213141516171819202122232425262728293031// 文件 1.txt 内容为 0123456789const fs = require('fs');const ReadStream = require('./ReadStream');// 创建可读流const rs = new ReadStream('1.txt', &#123; encoding: 'utf8', start: 0, end: 5, highWaterMark: 2&#125;);rs.on('open', () =&gt; console.log('open'));rs.on('data', data =&gt; &#123; console.log(data, new Date()); rs.pause();&#125;);rs.on('end', () =&gt; console.log('end'));rs.on('close', () =&gt; console.log('close'));rs.on('error', err =&gt; console.log(err));setInterval(() =&gt; rs.resume(), 1000);// open// 01 2018-07-04T10:44:20.384Z// 23 2018-07-04T10:44:21.384Z// 45 2018-07-04T10:44:22.384Z// end// close 执行上面的代码正常的执行逻辑是先触发 open 事件，然后触发 data 事件，读取一次后暂停，每隔一秒恢复读取一次，再读取完成后触发 end 和 close 事件，通过运行代码结果和我们希望的一样。 可读流的实现（暂停模式）在 fs 中的暂停模式的真正用法在 fs 模块中用 createReadStream 创建的可读流中通过监听 readable 事件触发暂停模式（监听 data 事件触发流动模式），通过下面例子感受暂停模式与流动模式的不同，现在读取文件 1.txt，内容为 0~9 十个数字。 暂停模式的用法1234567891011121314151617181920212223242526272829// 读取的const fs = require('fs');// 创建可读流const rs = fs.createReadStream('1.txt', &#123; encoding: 'utf8', start: 0, highWaterMark: 3&#125;);rs.on('readable', () =&gt; &#123; // read 参数为本次读取的个数 let r = rs.read(3); // 打印读取的数据 console.log(r); // 打印容器剩余空间 console.log(rs._readableState.length);&#125;);// 012// 0// 345// 0// 678// 0// null// 1// 90// 0 通俗的解释，暂停模式的 readable 事件默认会触发一次，监听 readable 事件后就像创建了一个 “容器”，容量为 highWaterMark，文件中的数据会自动把容器注满，调用可读流的 read 方法读取时，会从容器中取出数据，如果 read 方法读取的数据小于 highWaterMark，则直接暂停，不再继续读取，如果大于 highWaterMark ，说明 “容器” 空了，则会触发 readable 事件，无论读取字节数与 highWaterMark 关系如何，只要 “容器” 内容量剩余小于 highWaterMark 就会进行 “续杯”，再次向 “容器” 中填入 highWaterMark 个，所以有些时候真实的容量会大于 highWaterMark。 read 方法读取的内容会返回 null 是因为容器内真实的数据数小于了读取数，如果不是最后一次读取，会在多次读取后将值一并返回，如果是最后一次读取，会把剩余不足的数据返回。 1、readable 事件的触发条件：“容器” 空了；2、“续杯” 条件：读取后 “容器” 内剩余量小于 highWaterMark。3、read 返回 null：“容器” 容器内可悲读取数据无法满足一次读取字节数。 ReadableStream 类的实现同为可读流，暂停模式与流动模式相同，都依赖 fs 模块和 events 模块的 EventEmitter 类，参数依然为读取文件的路径和 options。 创建 ReadableStream 类1234567891011121314151617181920212223242526272829303132333435363738// 引入依赖const EventEmitter = require('events');const fs = require('fs');class ReadableStream extends EventEmitter &#123; constructor(path, options = &#123;&#125;) &#123; super(); this.path = path; // 读取文件的路径 this.flags = options.flags || 'r'; // 文件标识位 this.encoding = options.encoding || null; // 字符编码 this.fd = options.fd || null; // 文件描述符 this.mode = options.mode || 0o666; // 权限位 this.autoClose = options.autoClose || true; // 是否自动关闭 this.start = options.start || 0; // 读取文件的起始位置 // 每次读取文件的字节数 this.highWaterMark = options.highWaterMark || 64 * 1024; this.reading = false; // 如果正在读取，则不再读取 // 当缓存区的长度等于 0 的时候， 触发 readable this.emitReadable = false; this.arr = []; // 缓存区 this.len = 0; // 缓存区的长度 this.pos = this.start; // 下次读取文件的位置（变化的） // 创建可读流要打开文件 this.open(); this.on('newListener', type =&gt; &#123; if (type === 'readable') &#123; this.read(); // 监听readable就开始读取 &#125; &#125;); &#125;&#125;// 导出模块module.exports = ReadableStream; 在类的添加了 newListener 事件，在回调中判断是否监听了 readable 事件，如果监听了开始从 “容器” 中读取。 打开、关闭文件 open 和 detroy打开和关闭文件的方法和流动模式的套路基本相似。 open 方法1234567891011121314// 打开文件ReadableStream.prototype.open = function() &#123; fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; &#123; if (err) &#123; this.emit('error', err); if (this.autoClose) &#123; this.destroy(); return; &#125; &#125; this.fd = fd; this.emit('open'); &#125;);&#125; detroy 方法12345678910// 关闭文件ReadableStream.prototype.detroy = function() &#123; if (typeof this.fd === 'number') &#123; fs.close(fd, () =&gt; &#123; this.emit('close'); &#125;); return; &#125; this.emit('close');&#125; 从 “容器” 中读取 read 方法的实现read 方法的参数不传时就相当于从 “容器” 读取 highWaterMart 个字节，如果传参表示读取参数数量的字节数。 read 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ReadableStream.prototype.read = function(n) &#123; // 如果读取大于了 highWaterMark，重新计算 highWaterMark，并重新读取 if (n &gt; this.len) &#123; // 计算新的 highWaterMark，方法摘自 NodeJS 源码 this.highWaterMark = computeNewHighWaterMark(n); this.reading = true; this._read(); &#125; // 将要返回的数据 let buffer; // 如果读取的字节数大于 0 小于等于当前缓存 Buffer 的总长度 if (n &gt; 0 &amp;&amp; n &lt;= this.len) &#123; // 则从缓存中取出 buffer = Buffer.alloc(n); let current; // 存储每次从缓存区读出的第一个 Buffer let index = 0; // 每次读取缓存 Buffer 的索引 let flag = true; // 是否结束整个 while 循环的标识 // 开始读取 while ((current = this.arr.shift()) &amp;&amp; flag) &#123; for (let i = 0; i &lt; current.length; i++) &#123; // 将缓存中取到的 Buffer 的内容读到自己定义的 Buffer 中 buffer[index++] = current[i]; // 如果当前索引值已经等于了读取个数，结束 for 循环 if (index === n) &#123; flag = false; // 取出当前 Buffer 没有消耗的 let residue = current.slice(i + 1); // 在读取后维护缓存的长度 this.len -= n; // 如果 BUffer 真的有剩下的就给塞回到缓存中 if (residue.length) &#123; this.arr.unshift(residue); &#125; break; &#125; &#125; &#125; &#125; // 如果当前 读取的 Buffer 为 0，将触发 readable 事件 if (this.len === 0) &#123; this.emitReadable = true; &#125; // 如果当前的缓存区大小小于 highWaterMark，就要读取 if (this.len &lt; this.highWaterMark) &#123; // 如果不是正在读取才开始读取 if (!this.read) &#123; this.reading = true; this._read(); // 正真读取的方法 &#125; &#125; // 将 buffer 转回创建可读流设置成的编码格式 if (buffer) &#123; buffer = this.encoding ? buffer.toString(this.encoding) : buffer; &#125; return buffer;&#125; 上面的 read 方法的参数大小对比缓存区中取出的 Buffer 长度有两种情况，一种是小于当前缓存区内取出 Buffer 的长度，一种是大于了真个缓存区的 len 的长度。 小于当前缓存区总长度通过循环取出需要的 Buffer 存储了我们要返回创建的 Buffer 中，剩余的 Buffer 会丢失，所以我们做了一个小小的处理，将剩下的 Buffer 作为第一个 Buffer 塞回到了缓存区中，在处理这个问题时与流动模式不相同，流动模式处理后直接跳出了，而暂停模式相当于从 “容器” 中读取，如果第一次读取后还有剩余还要接着从容器中继续读取。 大于 len 属性时，规定需要重新计算 highWaterMark，遵循的原则是将当前 highWaterMark 设定为当前读取字节个数距离最接近的 2 的 n 次方的数值，NodeJS 源码中方法名称为 computeNewHighWaterMark，为了提高性能是使用位运算的方式进行计算的，源码如下。 重新计算 highWaterMark12345678910function computeNewHighWaterMark(n) &#123; n--; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; n++; return n;&#125; 在调用该方法重新计算 highWaterMark 后更改正在读取状态，重新读取，由于读取逻辑的重复，所以真正读取文件的逻辑抽取成一个 _read 方法来实现，下面呢就来看看 _read 内部都做了什么。 真正读取文件的 _read对比可读流（流动模式）的 read 方法，在调用 _read 方法读取时，是在 newListener 中同步执行 _read，所以为了保证 _read 的逻辑是在 open 方法打开文件以后执行，使用了与 read 相同的处理方式。 _read 方法1234567891011121314151617181920212223242526272829303132333435ReadableStream.prototype._read = function() &#123; if (typeof this.fd !== 'number') &#123; return this.once('open', () =&gt; _read()); &#125; // 创建本次读取的 Buffer let buffer = Buffer.alloc(this.highWaterMark); // 读取文件 fs.read( this.fd, buffer, 0, this.highWaterMark, this.pos, (err, bytesRead) =&gt; &#123; if (bytesRead &gt; 0) &#123; this.arr.push(buffer); // 缓存 this.len += bytesRead; // 维护缓存区长度 this.pos += bytesRead; // 维护下一次读取位置 this.reading = false; // 读取完毕 // 触发 readable 事件 if (this.emitReadable) &#123; // 触发后更改触发状态为 false this.emitReadable = false; this.emit('readable'); &#125; &#125; else &#123; // 如果读完触发结束事件 this.emit('end'); &#125; &#125; );&#125; 由于缓存区是一个数组，存储的每一个 Buffer 是独立存在的，所以不能挂载在实例上共用，如果挂在实例上则引用相同，一动全动，这不是我们想要的，所以每一次执行 _read 方法时都创建新的 Buffer 实例存入读取的数据后存储在缓存区中，如果读取完成 bytesRead 为 0，则触发 end 事件。 注意：在 NodeJS 源码中，可读流的两种模式代码都是混合在一起的，只是使用 fs.createReadStream 创建一个可读流，通过监听 data 和 readable 两种不同的事件来触发两种不同的模式，而我们为了模拟，把两种模式拆开成了两个类来实现的，在测试时需要创建不同类的实例。 验证可读流（暂停模式）ReadableStream为了统一我们依然读取真正用法中 1.txt 文件，内容为 0~9 十个数字。 验证 ReadableStream123456789101112131415// 引入依赖const fs = require('fs');const ReadableStream = require('./ReadableStream');const rs = new ReadableStream('1.txt', &#123; encoding: 'utf8', start: 0, highWaterMark: 3&#125;);rs.on('readable', () =&gt; &#123; let r = rs.read(3); console.log(r); console.log(rs.len);&#125;); 在打印 “容器” 剩余容量时，我们使用在 ReadableStream 上构造的 len 属性。 流动模式和暂停模式分别有不同的应用场景，如果只是希望读取一个文件，并最快的获得结果使用流动模式是很好的选择，如果希望了解读取文件的具体内容，并进行精细的处理，使用暂停模式更好一些。 可写流的实现WriteStream 类创建在使用 fs 的 createWriteStream 创建可写流时，返回了 WriteStream 对象，上面也存在事件和方法，创建可写流的时也是创建类的实例，我们将这个类命名为 WriteStream。事件同样依赖 events 模块的 EventEmitter 类，文件操作同样依赖 fs 模块，所以需提前引入。 创建 WriteStream 类1234567891011121314151617181920212223242526272829303132// 引入依赖模块const EventEmitter = require('events');const fs = require('fs');// 创建 WriteStream 类class WriteStream extends EventEmitter &#123; constructor(path, options = &#123;&#125;) &#123; super(); // 创建可写流参数传入的属性 this.path = path; // 写入文件的路径 this.flags = options.flags || 'w'; // 文件标识位 this.encoding = options.encoding || 'utf8'; // 字符编码 this.fd = options.fd || null; // 文件描述符 this.mode = options.mode || 0o666; // 权限位 this.autoClose = options.autoClose || true; // 是否自动关闭 this.start = options.start || 0; // 写入文件的起始位置 // 对比写入字节数的标识 this.highWaterMark = options.highWaterMark || 16 * 1024; this.writing = false; // 是否正在写入 this.needDrain = false; // 是否需要触发 drain 事件 this.buffer = []; // 缓存，正在写入就存入缓存中 this.len = 0; // 当前缓存的个数 this.pos = this.start; // 下次写入文件的位置（变化的） // 创建可写流要打开文件 this.open(); &#125;&#125;// 导出模块module.exports = WriteStream; 使用 fs.createWriteStream 创建可写流时传入了两个参数，写入的文件路径和一个 options 选项，options 上有七个参数，我们在创建 ReadStream 类的时候将这些参数初始化到了 this 上。 创建可写流后需要使用 write 方法进行写入，写入时第一次会真的通过内存写入到文件中，而再次写入则会将内容写到缓存中，注意这里的 “内存” 和 “缓存”，内存是写入文件是的系统内存，缓存是我们自己创建的数组，第一次写入以后要写入文件的 Buffer 都会先存入这个数组中，这个数组名为 buffer，挂载在实例上，实例上同时挂载了 len 属性用来存储当前缓存中 Buffer 总共的字节数（长度）。 我们在可读流上挂载了是否正在写入的状态 writing 属性，只要缓存区中存在未写入的 Buffer，writing 的状态就是正在写入，当写入的字节数大于了 highWaterMark 需要触发 drain 事件，所以又挂载了是否需要触发 drain 事件的标识 needDrain 属性。 当从文件的 start 值对应的位置开始写入，下一次写入文件的位置会发生变化，所以在 this 上挂载了 pos 属性，用于存储下次写入文件的位置。 在 NodeJS 流的源码中缓存是用链表实现的，通过指针来操作缓存中的 Buffer，而我们为了简化逻辑就使用数组来作为缓存，虽然性能相对链表要差。 打开、关闭文件 open 和 detroy在 WriteStream 中，写入文件之前也应该打开文件，在打开文件过程中出错时也应该触发 error 事件并关闭文件，打开和关闭文件的方法 open 和 detroy 与 ReadStream 的 open 和 detroy 方法的逻辑如出一辙，所以这里直接拿过来用了。 open 方法1234567891011121314// 打开文件WriteStream.prototype.open = function() &#123; fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; &#123; if (err) &#123; this.emit('error', err); if (this.autoClose) &#123; this.destroy(); return; &#125; &#125; this.fd = fd; this.emit('open'); &#125;);&#125; detroy 方法12345678910// 关闭文件WriteStream.prototype.detroy = function() &#123; if (typeof this.fd === 'number') &#123; fs.close(fd, () =&gt; &#123; this.emit('close'); &#125;); return; &#125; this.emit('close');&#125; 写入文件方法 write 的实现write 方法默认支持传入三个参数： chunk：写入文件的内容； encoding：写入文件的编码格式； callback：写入成功后执行的回调。 write 方法12345678910111213141516171819202122232425262728293031// 写入文件的方法，只要逻辑为写入前的处理WriteStream.prototype.write = function( chunk, encoding = this.encoding, callback) &#123; // 为了方便操作将要写入的数据转换成 Buffer chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk); // 维护缓存的长度 this.len += chunk.lenth; // 维护是否触发 drain 事件的标识 this.needDrain = this.highWaterMark &lt;= this.len; // 如果正在写入 if (this.writing) &#123; this.buffer.push(&#123; chunk, encoding, callback &#125;); &#125; else &#123; // 更改标识为正在写入，再次写入的时候走缓存 this.writing = true; // 如果已经写入清空缓存区的内容 this._write(chunk, encoding, () =&gt; this.clearBuffer()); &#125; return !this.needDrain;&#125; 与可写流的 read 一样，我们在使用 write 方法将数据写入文件时，也是操作 Buffer，在 write 方法中，首先将接收到的要写入的数据转换成了 Buffer，因为是多次写入，要知道缓存中 Buffer 字节数的总长度，所以维护了 len 变量。 我们的 WriteStream 构造函数中，this 挂载了 needDrain 属性，在使用 fs.createWriteStream 创建的可读流时，是写入的字节长度超过 highWaterMark 才会触发 drain 事件，而 needDrain 与 write 的返回值正好相反，所以我们用 needDrain 取反来作为 write 方法的返回值。 在写入的逻辑中第一次是直接通过内存写入到文件，但是再次写入就需要将数据存入缓存，将数据写入到文件中写入状态 writing 默认为 false，通过缓存再写入证明应该正在写入中，所以在第一次写入后应更改 writing 的状态为 true，写入缓存其实就是把转换的 Buffer、编码以及写入成功后要执行的回调挂在一个对象上存入缓存的数组 buffer 中。 我们把真正写入文件的逻辑抽取成一个单独的方法 _write，并传入 chunk（要写入的内容，已经处理成 Buffer）、encoding（字符编码）、回调函数，在回调函数中执行了原型方法 clearBuffer，接下来就来实现 _write 和 clearBuffer。 注意：方法使用 `` 开头代表私有方法，轻易不要在外部调用或修改，这是一个开发者之间约定俗成的不成文规定。_ 真正的文件操作 _write对比可读流（流动模式）的 read 方法，在调用 _write 方法写入时，是在创建可写流之后的同步代码中执行的，与可读流在 newListener 中同步执行 read 的情况类似，所以为了保证 _write 的逻辑是在 open 方法打开文件以后执行，使用了与 read 相同的处理方式。 _write 方法123456789101112131415161718192021222324252627// 真正的写入文件操作的方法WriteStream.prototype._write = function(chunk, encoding, callback) &#123; // 由于 open 异步执行，write 是在创建实例时同步执行 // write 执行可能早于 open，此时不存在文件描述符 if (typeof this.fd !== 'number') &#123; // 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 write return this.once( 'open', () =&gt; this._write(chunk, encoding, callback) ); &#125; // 读取文件 fs.write( this.fd, chunk, 0, chunk.length, this.pos, (err, bytesWritten) =&gt; &#123; // 维护下次写入的位置和缓存区 Buffer 的总字节数 this.pos += bytesWritten; this.len -= bytesWritten; callback(); &#125; );&#125; 在打开文件并写入的时候需要维护两个变量，下次写入的位置 pos 和当前缓存区内 Buffer 所占总字节数 len，本次写入了多少个字节，下次写入需要在写入位置的基础上加多少个字节，而 len 恰恰相反，本次写入了多少个字节，缓存区中的总长度应该对应的减少多少个字节。 在维护两个变量的值以后调用 callback，其实 callback 内执行的是 clearBuffer 方法，就如方法名，译为 “清空缓存”，其实就是一次一次的将数据写入文件并从缓存中移除，很明显需要递归调用 _write 方法，我们将这个递归的逻辑统一放在 clearBuffer 方法中实现。 清空缓存操作 clearBufferclearBuffer 方法1234567891011121314151617181920// 清空缓存方法WriteStream.prototype.clearBuffer = function() &#123; // 先写入的在数组前面，从前面取出缓存中的 Buffer let buf = this.buffer.shift(); // 如果存在 buf，证明缓存还有 Buffer 需要写入 if (buf) &#123; // 递归 _write 按照编码将数据写入文件 this._write(buf.chunk, buf.encoding, () =&gt; this.clearBuffer); &#125; else &#123; // 如果没有 buf，说明缓存内的内容已经完全写入文件并清空，需要触发 drain 事件 this.emit('drain'); // 更改正在写入状态 this.writing = false; // 更改是否需要触发 drain 事件状态 this.needDrain = false; &#125;&#125; clearBuffer 方法中获取了缓存区数组的最前面的 Buffer（最前面的是先写入缓存的，也应该先取出来写入文件），存在这个 Buffer 时，递归 _write 方法按照编码将数据写入文件，如果不存在说明缓存区已经清空了，代表内容完全写入文件中，所以触发 drain 事件，最后更改了 writing 和 needDrain 的状态。 更正 writing 是为了 WriteStream 创建的可读流在下次调用 write 方法时默认第一次真正写入文件，而更正 needDrain 的状态是在缓存区要清空的最后一个 Buffer 的长度小于了 highWaterMark 时，保证 write 方法的返回值是正确的。 第一次是真正写入，其他的都写入缓存，再一个一个的将缓存中存储的 Buffer 写入并从缓存清空，之所以这样设计是为了把写入的内容排成一个队列，假如有 3 个人同时操作一个文件写入内容，只有第一个人是真的写入，其他的人都写在缓存中，再按照写入缓存的顺序依次写入文件，避免冲突和写入顺序出错。 验证可写流 WriteStream接下来我们使用自己实现的 WriteStream 类来创建可写流，并按照 fs.createWriteStream 的用法进行使用并验证。 验证 WriteStream123456789101112131415161718192021222324252627282930313233// 向 1.txt 文件中写入 012345const fs = require('fs');const WriteStream = require('./WriteStream');// 创建可写流const ws = new WriteStream('2.txt', &#123; highWaterMark: 3&#125;);let i = 0;function write() &#123; let flag = true; while (i &lt;= 6 &amp;&amp; flag) &#123; i++; flag = ws.write(i + '', 'utf8'); &#125;&#125;ws.on('drain', function() &#123; console.log('写入成功'); write();&#125;);write();// true// true// false// 写入成功// true// true// false// 写入成功 可以使用 fs.createWriteStream 和 WriteStream 类分别执行上面的代码，对比结果，看看是否相同。 可读流和可写流的桥梁 pipe可写流和可读流一般是通过 pipe 配合来使用的，pipe 方法是可读流 ReadStream 的原型方法，参数为一个可写流。 pipe 方法12345678910111213141516171819// 连接可读流和可写流的方法 pipeReadStream.prototype.pipe = function(dest) &#123; // 开始读取 this.on('data', data =&gt; &#123; // 如果超出可写流的 highWaterMark，暂停读取 let flag = dest.write(data); if (!flag) this.pause(); &#125;); dest.on('drain', () =&gt; &#123; // 当可写流清空内存时恢复读取 this.resume(); &#125;); this.on('end', () =&gt; &#123; // 在读取完毕后关闭文件 this.destroy(); &#125;);&#125; pipe 方法其实就是通过可读流的 data 事件触发流动状态，并用可写流接收读出的数据进行写入，当写入数据超出 highWaterMark，则暂停可读流的读取，直到可写流的缓存被清空并把内容写进文件后，恢复可读流的读取，当读取结束后关闭文件。 下面我们实现一个将 1.txt 的内容拷贝 2.txt 中的例子。 验证 pipe1234567891011121314151617// pipe 的使用const fs = require('fs');// 引入自己的 ReadStream 类和 WriteStream 类const ReadStream = rquire('./ReadStream');const WriteStream = rquire('./WriteStream');// 创建可读流和可写流const rs = new ReadStream('1.txt', &#123; highWaterMark: 3&#125;);const ws = new WriteStream('2.txt', &#123; highWaterMark: 2&#125;);// 使用 pipe 实现文件内容复制rs.pipe(ws); 总结在 NodeJS 源码中，可读流和可写流的内容要比本篇内容多很多，本篇是将源码精简，抽出核心逻辑并针对流的使用方式进行实现，主要目的是帮助理解流的原理和使用，争取做到 “知其然知其所以然”，了解了一些底层再对流使用时，也能游刃有余。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"Stream","slug":"Stream","permalink":"https://www.pandashen.com/tags/Stream/"}]},{"title":"NodeJS —— Stream 的基本使用","date":"2018-07-03T15:10:32.000Z","path":"2018/07/03/20180703231032/","text":"流的介绍在 NodeJS 中，我们对文件的操作需要依赖核心模块 fs，fs 中有很基本 API 可以帮助我们读写占用内存较小的文件，如果是大文件或内存不确定也可以通过 open、read、write、close 等方法对文件进行操作，但是这样操作文件每一个步骤都要关心，非常繁琐，fs 中提供了可读流和可写流，让我们通过流来操作文件，方便我们对文件的读取和写入。 可读流createReadStream 创建可读流createReadStream 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 options 选项，其中有八个参数： flags：标识位，默认为 r； encoding：字符编码，默认为 null； fd：文件描述符，默认为 null； mode：权限位，默认为 0o666； autoClose：是否自动关闭文件，默认为 true； start：读取文件的起始位置； end：读取文件的（包含）结束位置； highWaterMark：最大读取文件的字节数，默认 64 * 1024。 createReadStream 的返回值为 fs.ReadStream 对象，读取文件的数据在不指定 encoding 时，默认为 Buffer。 创建可读流12345678const fs = require('fs');// 创建可读流，读取 1.txt 文件const rs = fs.creatReadStream('1.txt', &#123; start: 0, end: 3, highWaterMark: 2&#125;); 在创建可读流后默认是不会读取文件内容的，读取文件时，可读流有两种状态，暂停状态和流动状态。 注意：本篇的可写流为流动模式，流动模式中有暂停状态和流动状态，而不是暂停模式，暂停模式是另一种可读流 readable。 流动状态流动状态的意思是，一旦开始读取文件，会按照 highWaterMark 的值一次一次读取，直到读完为止，就像一个打开的水龙头，水不断的流出，直到流干，需要通过监听 data 事件触发。 假如现在 1.txt 文件中的内容为 0~9 十个数字，我们现在创建可读流并用流动状态读取。 流动状态123456789101112131415161718192021const fs = require('fs');const rs = fs.createReadStream('1.txt', &#123; start: 0, end: 3, highWaterMark: 2&#125;);// 读取文件rs.on('data', data =&gt; &#123; console.log(data);&#125;);// 监听读取结束rs.on('end', () =&gt; &#123; console.log('读完了');&#125;);// &lt;Buffer 30 31&gt;// &lt;Buffer 32 33&gt;// 读完了 在上面代码中，返回的 rs 对象监听了两个事件： data：每次读取 highWaterMark 个字节，触发一次 data 事件，直到读取完成，回调的参数为每次读取的 Buffer； end：当读取完成时触发并执行回调函数。 我们希望最后读到的结果是完整的，所以我们需要把每一次读到的结果在 data 事件触发时进行拼接，以前我们可能使用下面这种方式。 错误拼接数据的方式12345678910111213141516171819const fs = require('fs');const rs = fs.createReadStream('1.txt', &#123; start: 0, end: 3, highWaterMark: 2&#125;);let str = '';rs.on('data', data =&gt; &#123; str += data;&#125;);rs.on('end', () =&gt; &#123; console.log(str);&#125;);// 0123 在上面代码中如果读取的文件内容是中文，每次读取的 highWaterMark 为两个字节，不能组成一个完整的汉字，在每次读取时进行 += 操作会默认调用 toString 方法，这样会导致最后读取的结果是乱码。 在以后通过流操作文件时，大部分情况下都是在操作 Buffer，所以应该用下面这种方式来获取最后读取到的结果。 正确拼接数据的方式1234567891011121314151617181920const fs = require('fs');const rs = fs.createReadStream('1.txt', &#123; start: 0, end: 3, highWaterMark: 2&#125;);// 存储每次读取回来的 Bufferconst bufArr = [];rs.on('data', data =&gt; &#123; bufArr.push(data);&#125;);rs.on('end', () =&gt; &#123; console.log(Buffer.concat(bufArr).toString());&#125;);// 0123 暂停状态在流动状态中，一旦开始读取文件，会不断的触发 data 事件，直到读完，暂停状态是我们每读取一次就直接暂停，不再继续读取，即不再触发 data 事件，除非我们主动控制继续读取，就像水龙头打开放水一次后马上关上水龙头，下次使用时再打开。 类似于开关水龙头的动作，也就是暂停和恢复读取的动作，在可读流返回的 rs 对象上有两个对应的方法，pause 和 resume。 在下面的场景中我们把创建可读流的结尾位置更改成 9，在每次读两个字节并暂停一秒后恢复读取，直到读完 0~9 十个数字。 暂停状态123456789101112131415161718192021222324252627282930const fs = require('fs');const rs = fs.createReadStream('1.txt', &#123; start: 0, end: 9, highWaterMark: 2&#125;);const bufArr = [];rs.on('data', data =&gt; &#123; bufArr.push(data); rs.pause(); // 暂停读取 console.log('暂停', new Date()); setTimeout(() =&gt; &#123; rs.resume(); // 恢复读取 &#125;, 1000)&#125;);rs.on('end', () =&gt; &#123; console.log(Buffer.concat(bufArr).toString());&#125;);// 暂停 2018-07-03T23:52:52.436Z// 暂停 2018-07-03T23:52:53.439Z// 暂停 2018-07-03T23:52:54.440Z// 暂停 2018-07-03T23:52:55.442Z// 暂停 2018-07-03T23:52:56.443Z// 0123456789 错误监听在通过可读流读取文件时都是异步读取，在异步读取中如果遇到错误也可以通过异步监听到，可读流返回值 rs 对象可以通过 error 事件来监听错误，在读取文件出错时触发回调函数，回调函数参数为 err，即错误对象。 错误监听12345678910111213141516171819202122const fs = require('fs');// 读取一个不存在的文件const rs = fs.createReadStream('xxx.js', &#123; highWarterMark: 2&#125;);const bufArr = [];rs.on('data', data =&gt; &#123; bufArr.push(data);&#125;);rs.on('err', err =&gt; &#123; console.log(err);&#125;);rs.on('end', () =&gt; &#123; console.log(Buffer.concat(bufArr).toString());&#125;);// &#123; Error: ENOENT: no such file or directory, open '......xxx.js' ......&#125; 打开和关闭文件的监听流的适用性非常广，不只是文件读写，也可以用在 http 中数据的请求和响应上，但是在针对文件读取返回的 rs 上有两个专有的事件用来监听文件的打开与关闭。 open 事件用来监听文件的打开，回调函数在打开文件后执行，close 事件用来监听文件的关闭，如果创建的可读流的 autoClose 为 true，在自动关闭文件时触发，回调函数在关闭文件后执行。 打开和关闭可读流的监听1234567891011121314151617const fs = require('fs');const rs = fs.createReadStream('1.txt', &#123; start: 0, end: 3, highWaterMark: 2&#125;);rs.on('open', () =&gt; &#123; console.log('open');&#125;);rs.on('close', () =&gt; &#123; console.log('close');&#125;);// open 在上面代码我们看出只要创建了可读流就会打开文件触发 open 事件，因为默认为暂停状态，没有对文件进行读取，所以不会关闭文件，即不会触发 close 事件。 暂停状态1234567891011121314151617181920212223242526272829const fs = require('fs');const rs = fs.createReadStream('1.txt', &#123; start: 0, end: 3, highWaterMark: 2&#125;);rs.on('open', () =&gt; &#123; console.log('open');&#125;);rs.on('data', data =&gt; &#123; console.log(data);&#125;);rs.on('end', () =&gt; &#123; console.log('end');&#125;);rs.on('close', () =&gt; &#123; console.log('close');&#125;);// open// &lt;Buffer 30 31&gt;// &lt;Buffer 32 33&gt;// end// close 从上面例子执行的打印结果可以看出只有开始读取文件并读完后，才会关闭文件并触发 close 事件，end 事件的触发要早于 close。 可写流createWriteStream 创建可写流createWriteStream 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 options 选项，其中有七个参数： flags：标识位，默认为 w； encoding：字符编码，默认为 utf8； fd：文件描述符，默认为 null； mode：权限位，默认为 0o666； autoClose：是否自动关闭文件，默认为 true； start：写入文件的起始位置； highWaterMark：一个对比写入字节数的标识，默认 16 * 1024。 createWriteStream 返回值为 fs.WriteStream 对象，第一次写入时会真的写入文件中，继续写入，会写入到缓存中。 创建可写流1234567const fs = require('fs');// 创建可写流，写入 2.txt 文件const ws = fs.createWriteStream('2.txt', &#123; start: 0, highWaterMark: 3&#125;); 可写流的 write 方法在可写流中将内容写入文件需要使用 ws 的 write 方法，参数为写入的内容，返回值是一个布尔值，代表 highWaterMark 的值是否足够当前的写入，如果足够，返回 true，否则返回 false，换种说法就是写入内容的长度是否超出了 highWaterMark，超出返回 false。 write 方法写入12345678910111213141516171819const fs = require('fs');const ws = fs.createWriteSteam('2.txt', &#123; start: 0, highWaterMark: 3&#125;);let flag1 = ws.write('1');console.log(flag1);let flag2 = ws.write('2');console.log(flag2);let flag3 = ws.write('3');console.log(flag3);// true// true// false 写入不存在的文件时会自动创建文件，如果 start 的值不是 0，在写入不存在的文件时默认找不到写入的位置。 可写流的 drain 事件drain 意为 “吸干”，当前写入的内容已经大于等于了 highWaterMark，会触发 drain 事件，当内容全部从缓存写入文件后，会执行回调函数。 drain 事件123456789101112131415161718192021222324const fs = require('fs');const ws = fs.createWriteStream('2.txt', &#123; start: 0, highWaterMark: 3&#125;);let flag1 = ws.write('1');console.log(flag1);let flag2 = ws.write('2');console.log(flag2);let flag3 = ws.write('3');console.log(flag3);ws.on('drain', () =&gt; &#123; console.log('吸干');&#125;);// true// true// false 可写流的 end 方法end 方法传入的参数为最后写入的内容，end 会将缓存未写入的内容清空写入文件，并关闭文件。 end 方法12345678910111213141516171819202122232425const fs = require('fs');const ws = fs.createWriteStream('2.txt', &#123; start: 0, highWaterMark: 3&#125;);let flag1 = ws.write('1');console.log(flag1);let flag2 = ws.write('2');console.log(flag2);let flag3 = ws.write('3');console.log(flag3);ws.on('drain', () =&gt; &#123; console.log('吸干');&#125;);ws.end('写完了');// true// true// false 在调用 end 方法后，即使再次写入的值超出了 highWaterMark 也不会再触发 drain 事件了，此时打开 2.txt 后发现文件中的内容为 ‘123写完了’。 常见报错123456789101112const fs = require('fs');const ws = fs.createWriteStream('2.txt', &#123; start: 0, highWaterMark: 3&#125;);ws.write('1');ws.end('写完了');ws.write('2');// Error [ERR_STREAM_WRITE_AFTER_END]: write after end... 在调用 end 方法后，不可以再调用 write 方法写入，否则会报一个很常见的错误 write after end，文件原有内容会被清空，而且不会被写入新内容。 可写流与可读流混合使用可写流和可读流一般配合来使用，读来的内容如果超出了可写流的 highWaterMark，则调用可读流的 pause 暂停读取，等待内存中的内容写入文件，未写入的内容小于 highWaterMark 时，调用可写流的 resume 恢复读取，创建可写流返回值的 rs 上的 pipe 方法是专门用来连接可读流和可写流的，可以将一个文件读来的内容通过流写到另一个文件中。 pipe 方法使用123456789101112const fs = require('fs');// 创建可读流和可写流const rs = fs.createReadStream('1.txt', &#123; highWaterMark: 3&#125;);const ws = fs.createWriteStream('2.txt', &#123; highWaterMark: 2&#125;);// 将 1.txt 的内容通过流写入 2.txt 中rs.pipe(ws); 通过上面的这种类似于管道的方式，将一个流从一个文件输送到了另一个文件中，而且会根据读流和写流的 highWaterMark 自由的控制写入的 “节奏”，不用担心内存的消耗。 总结这篇是关于读流和写流的基本用法，在平时的开发当中，大多数的 API 都用不到，只有最后的 pipe 用的最多，无论是在文件的读写还是请求的响应，其他的 API 虽然用的少，但是作为一个合格的程序员一定要有所了解。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"Stream","slug":"Stream","permalink":"https://www.pandashen.com/tags/Stream/"}]},{"title":"NodeJS 树结构遍历 —— 深度优先和广度优先","date":"2018-07-02T04:29:23.000Z","path":"2018/07/02/20180702122923/","text":"树的基本概念树（Tree）是 n 个结点的有限集，n 为 0 时，称为空树，在任意一棵非空树中有且仅有一个特定的被称为根（Root）的结点，当 n 大于 1 时，其余结点可分为 m 个互不相交的有限集 T1、T2、......、Tm，其中每一个集合本身又是一棵树，并且称为 SubTree，即根的子树。 需要强调的是，n&gt;0 时根结点是唯一的，不可能存在多个根结点，m&gt;0 时，子树的个数没有限制，但它们一定是互不相交的。 从根开始定义起，根为第一层，根的孩子为第二层，若某结点在第 l 层，则其子树就在第 l+1 层，其双亲在同一层的结点互为 “堂兄弟”，树中结点的最大层级数称为树的深度（Depth）或高度。 树结构的组成 在对树结构进行遍历时，按顺序可分为先序、中序和后续，按遍历的方式可分为深度优先和广度优先，我们这篇文章就通过使用先序深度优先和先序广度优先来实现 NodeJS 中递归删除目录结构，体会对树结构的遍历，文章中会大量用到 NodeJS 核心模块 fs 的方法，可以通过 NodeJS 文件操作 —— fs 基本使用 来了解文中用到的 fs 模块的方法及用法。 先序深度优先实现递归删除文件目录深度优先的意思就是在遍历当前文件目录的时候，如果子文件夹内还有内容，就继续遍历子文件夹，直到遍历到最深层不再有文件夹，则删除其中的文件，再删除这个文件夹，然后继续遍历它的 “兄弟”，直到内层文件目录都被删除，再删除上一级，最后根文件夹为空，删除根文件夹。 先序深度优先 同步的实现我们要实现的函数参数为要删除的根文件夹的路径，执行函数后会删除这个根文件夹。 深度优先 —— 同步1234567891011121314151617181920212223242526272829303132// 引入依赖模块const fs = require('fs');const path = require('path');// 先序深度优先同步删除文件夹function rmDirDepSync(p) &#123; // 获取根文件夹的 Stats 对象 let statObj = fs.statSync(p); // 检查该文件夹的是否是文件夹 if (statObj.isDirectory()) &#123; // 查看文件夹内部 let dirs = fs.readdirSync(p); // 将内部的文件和文件夹拼接成正确的路径 dirs = dirs.map(dir =&gt; path.jion(p, dir)); // 循环递归处理 dirs 内的每一个文件或文件夹 for (let i = 0; i &lt; dirs.length; i++) &#123; rmDirDepSync(dirs[i]); &#125; // 等待都处理完后删除该文件夹 fs.rmdirSync(p); &#125; else &#123; // 若是文件则直接删除 fs.unlinkSync(p); &#125;&#125;// 调用rmDirDepSync('a'); 上面代码在调用 rmDirDepSync 时传入 a，先判断 a 是否是文件夹，不是则直接删除文件，是则查看文件目录，使用 map 将根文件路径拼接到每一个成员的名称前，并返回合法的路径集合，循环这个集合并对每一项进行递归，重复执行操作，最终实现删除根文件夹内所有的文件和文件夹，并删除根文件夹。 异步回调的实现同步的实现会阻塞代码的执行，每次执行一个文件操作，必须在执行完毕之后才能执行下一行代码，相对于同步，异步的方式性能会更好一些，我们下面使用异步回调的方式来实现递归删除文件目录的函数。 函数有两个参数，第一个参数同样为根文件夹的路径，第二个参数为一个回调函数，在文件目录被全部删除后执行。 深度优先 —— 异步回调1234567891011121314151617181920212223242526272829303132333435363738// 引入依赖模块const fs = require('fs');const path = require('path');// 先序深度优先异步（回调函数）删除文件夹function rmDirDepCb(p, callback) &#123; // 获取传入路径的 Stats 对象 fs.stat(p, (err, statObj) =&gt; &#123; // 判断路径下是否为文件夹 if (statObj.isDirectory()) &#123; // 是文件夹则查看内部成员 fs.readdir(p, (err, dirs) =&gt; &#123; // 将文件夹成员拼接成合法路径的集合 dirs = dirs.map(dir =&gt; path.join(p, dir)); // next 方法用来检查集合内每一个路径 function next(index) &#123; // 如果所有成员检查并删除完成则删除上一级目录 if (index === dirs.length) return fs.rmdir(p, callback); // 对路径下每一个文件或文件夹执行递归，回调为递归 next 检查路径集合中的下一项 rmDirDepCb(dirs[index], () =&gt; next(index + 1)); &#125; next(0); &#125;); &#125; else &#123; // 是文件则直接删除 fs.unlink(p, callback); &#125; &#125;);&#125;// 调用rmDirDepCb('a', () =&gt; &#123; console.log('删除完成');&#125;);// 删除完成 上面方法也遵循深度优先，与同步相比较主要思路是相同的，异步回调的实现更为抽象，并不是通过循环去处理的文件夹下的每个成员的路径，而是通过调用 next 函数和在成功删除文件时递归执行 next 函数并维护 index 变量实现的。 异步 Promise 的实现在异步回调函数的实现方式中，回调嵌套层级非常多，这在对代码的可读性和维护性上都造成困扰，在 ES6 规范中，Promise 的出现就是用来解决 “回调地狱” 的问题，所以我们也使用 Promise 来实现。 函数的参数为要删除的根文件夹的路径，这次之所以不需要传 callback 参数是因为 callback 中的逻辑可以在调用函数之后链式调用 then 方法来执行。 深度优先 —— 异步 Promise123456789101112131415161718192021222324252627282930313233343536// 引入依赖模块const fs = require('fs');const path = require('path');// 先序深度优先异步（Promise）删除文件夹function rmDirDepPromise(p) &#123; return new Promise((resolve, reject) =&gt; &#123; // 获取传入路径的 Stats 对象 fs.stat(p, (err, statObj) =&gt; &#123; // 判断路径下是否为文件夹 if (statObj.isDirectory()) &#123; // 是文件夹则查看内部成员 fs.readdir(p, (err, dirs) =&gt; &#123; // 将文件夹成员拼接成合法路径的集合 dirs = dirs.map(dir =&gt; path.join(p, dir)); // 将所有的路径都转换成 Promise dirs = dirs.map(dir =&gt; rmDirDepPromise(dir)); // 数组中路径下所有的 Promise 都执行了 resolve 时，删除上级目录 Promise.all(dirs).then(() =&gt; fs.rmdir(p, resolve)); &#125;); &#125; else &#123; // 是文件则直接删除 fs.unlink(p, resolve); &#125; &#125;); &#125;);&#125;// 调用rmDirDepPromise('a').then(() =&gt; &#123; console.log('删除完成');&#125;);// 删除完成 与异步回调函数的方式不同的是在调用 rmDirDepPromise 时直接返回了一个 Promise 实例，而在删除文件成功或在删除文件夹成功时直接调用了 resolve，在一个子文件夹下直接将这些成员通过递归 rmDirDepPromise 都转换为 Promise 实例，则可以用 Primise.all 来监听这些成员删除的状态，如果都成功再调用 Primise.all 的 then 直接删除上一级目录。 异步 async/await 的实现Promise 版本相对于异步回调版本从代码的可读性上有所提升，但是实现逻辑还是比较抽象，没有同步代码的可读性好，如果想要 “鱼” 和 “熊掌” 兼得，既要性能又要可读性，可以使用 ES7 标准中的 async/await 来实现。 由于 async 函数的返回值为一个 Promise 实例，所以参数只需要传被删除的根文件夹的路径即可。 深度优先 —— 异步 async/await1234567891011121314151617181920212223242526272829303132333435363738394041424344// 引入依赖模块const fs = require('fs');const path = require('path');const &#123; promisify &#125; = require('util');// 将用到 fs 模块的异步方法转换成 Primiseconst stat = promisify(fs.stat);const readdir = promisify(fs.readdir);const rmdir = promisify(fs.rmdir);const unlink = promisify(fs.unlink);// 先序深度优先异步（async/await）删除文件夹async function rmDirDepAsync(p) &#123; // 获取传入路径的 Stats 对象 let statObj = await stat(p); // 判断路径下是否为文件夹 if (statObj.isDirectory()) &#123; // 是文件夹则查看内部成员 let dirs = await readdir(p); // 将文件夹成员拼接成合法路径的集合 dirs = dirs.map(dir =&gt; path.join(p, dir)); // 循环集合递归 rmDirDepAsync 处理所有的成员 dirs = dirs.map(dir =&gt; rmDirDepAsync(dir)); // 当所有的成员都成功 await Promise.all(dirs); // 删除该文件夹 await rmdir(p); &#125; else &#123; // 是文件则直接删除 await unlink(p); &#125;&#125;// 调用rmDirDepAsync('a').then(() =&gt; &#123; console.log('删除完成');&#125;);// 删除完成 在递归 rmDirDepAsync 时，所有子文件夹内部的成员必须都删除成功，才删除这个子文件夹，在使用 unlink 删除文件时，必须等待文件删除结束才能让 Promise 执行完成，所以也需要 await，所有递归之前的异步 Promise 都需要在递归内部的异步 Promise 执行完成后才能执行完成，所以涉及到异步的操作都使用了 await 进行等待。 先序广度优先实现递归删除文件目录广度优先的意思是遍历文件夹目录的时候，先遍历根文件夹，将内部的成员路径一个一个的存入数组中，再继续遍历下一层，再将下一层的路径都存入数组中，直到遍历到最后一层，此时数组中的路径顺序为第一层的路径，第二层的路径，直到最后一层的路径，由于要删除的文件夹必须为空，所以删除时，倒序遍历这个数组取出路径进行文件目录的删除。 先序广度优先 在广度优先的实现方式中同样按照同步、异步回调、和 异步 async/await 这几种方式分别来实现，因为在拼接存储路径数组的时候没有异步操作，所以单纯使用 Promise 没有太大的意义。 同步的实现参数为根文件夹的路径，内部的 fs 方法同样都使用同步方法。 广度优先 —— 同步12345678910111213141516171819202122232425262728293031323334353637383940414243// 引入依赖模块const fs = require('fs');const path = require('path');// 先序广度优先同步删除文件夹function rmDirBreSync(p) &#123; let pathArr = [p]; // 创建存储路径的数组，默认存入根路径 let index = 0; // 用于存储取出数组成员的索引 let current; // 用于存储取出的成员，即路径 // 如果数组中能找到当前指定索引的项，则执行循环体，并将该项存入 current while ((current = arr[index++])) &#123; // 获取当前从数组中取出的路径的 Stats 对象 let statObj = fs.statSync(current); // 如果是文件夹，则读取内容 if (statObj.isDirectory()) &#123; let dirs = fs.readdir(current); // 将获取到的成员路径处理为合法路径 dirs = dirs.map(dir =&gt; path.join(current, dir)); // 将原数组的成员路径和处理后的成员路径重新解构在 pathArr 中 pathArr = [...pathArr, ...dirs]; &#125; &#125; // 逆序循环 pathArr for (let i = pathArr.length - 1; i &gt;= 0; i--) &#123; let pathItem = pathArr[i]; // 当前循环项 let statObj = fs.statSync(pathItem); // 获取 Stats 对象 // 如果是文件夹则删除文件夹，是文件则删除文件 if (statObj.isDirectory()) &#123; fs.rmdirSync(pathItem); &#125; else &#123; fs.unlinkSync(pathItem); &#125; &#125;&#125;// 调用rmDirBreSync('a'); 通过 while 循环广度遍历，将所有的路径按层级顺序存入 pathArr 数组中，在通过 for 反向遍历数组，对遍历到的路径进行判断并调用对应的删除方法，pathArr 后面的项存储的都是最后一层的路径，从后向前路径的层级逐渐减小，所以反向遍历不会导致删除非空文件夹的操作。 异步回调的实现函数有两个参数，第一个参数为根文件夹的路径，第二个为 callback，在删除结束后执行。 广度优先 —— 异步回调12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 引入依赖模块const fs = require('fs');const path = require('path');// 先序广度优先异步（回调函数）删除文件夹function rmDirBreCb(p, callback) &#123; let pathArr = [p]; // 创建存储路径的数组，默认存入根路径 function next(index) &#123; // 如果已经都处理完，则调用删除的函数 if (index === pathArr.length) return remove(); // 取出数组中的文件路径 let current = arr[index]; // 获取取出路径的 Stats 对象 fs.stat(currrent, (err, statObj) =&gt; &#123; // 判断是否是文件夹 if (statObj.isDirectory()) &#123; // 是文件夹读取内部成员 fs.readdir(current, (err, dirs) =&gt; &#123; // 将数组中成员名称修改为合法路径 dirs = dirs.map(dir =&gt; path.join(current, dir)); // 将原数组的成员路径和处理后的成员路径重新解构在 pathArr 中 pathArr = [...pathArr, ...dirs]; // 递归取出数组的下一项进行检测 next(index + 1); &#125;); &#125; else &#123; // 如果是文件则直接递归获取数组的下一项进行检测 next(index + 1); &#125; &#125;); &#125; next(0); // 删除的函数 function remove() &#123; function next(index) &#123; // 如果全部删除完成，执行回调函数 if (index &lt; 0) return callback(); // 获取数组的最后一项 let current = pathArr[index]; // 获取该路径的 Stats 对象 fs.stat(current, (err, statObj) =&gt; &#123; // 不管是文件还是文件夹都直接删除 if (statObj.isDirectory()) &#123; fs.rmdir(current, () =&gt; next(index - 1)); &#125; else &#123; fs.unlink(current, () =&gt; next(index - 1)); &#125; &#125;); &#125; next(arr.length - 1); &#125;&#125;// 调用rmDirBreCb('a', () =&gt; &#123; console.log('删除完成');&#125;);// 删除完成 在调用 rmDirBreCb 时主要执行两个步骤，第一个步骤是构造存储路径的数组，第二个步骤是逆序删除数组中对应的文件或文件夹，为了保证性能，两个过程都是通过递归 next 函数并维护存储索引的变量来实现的，而非循环。 在构造数组的过程中如果构造数组完成后，调用的删除函数 remove，在 remove 中在删除完成后，调用的 callback，实现思路是相同的，都是在递归时设置判断条件，如果构造数组或删除结束以后不继续递归，而是直接执行对应的函数并跳出。 异步 async/await 的实现参数为删除根文件夹的路径，因为 async 最后返回的是 Promise 实例，所以不需要 callback，删除后的逻辑可以通过调用返回 Promise 实例的 then 来实现。 广度优先 —— 异步 async/await123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 引入依赖模块const fs = require('fs');const path = require('path');const &#123; promisify &#125; = require('util');// 将用到 fs 模块的异步方法转换成 Primiseconst stat = promisify(fs.stat);const readdir = promisify(fs.readdir);const rmdir = promisify(fs.rmdir);const unlink = promisify(fs.unlink);// 先序广度优先异步（async/await）删除文件夹async function rmDirBreAsync(p) &#123; let pathArr = [p]; // 创建存储路径的数组，默认存入根路径 let index = 0; // 去数组中取出路径的索引 // 如果存在该项则继续循环 while (index !== pathArr.length) &#123; // 取出当前的路径 let current = pathArr[index]; // 获取 Stats 对象 let statObj = await stat(current); // 判断是否是文件夹 if (statObj.isDirectory()) &#123; // 查看文件夹成员 let dirs = await readdir(current); // 将路径集合更改为合法路径集合 dirs = dirs.map(dir =&gt; path.join(current, dir)); // 合并存储路径的数组 pathArr = [...pathArr, ...dirs]; &#125; index++; &#125; let current; // 删除的路径 // 循环取出路径 while ((current = pathArr.pop())) &#123; // 获取 Stats 对象 let statObj = await stat(current); // 不管是文件还是文件夹都直接删除 if (statObj.isDirectory()) &#123; await rmdir(current); &#125; else &#123; await unlink(current); &#125; &#125;&#125;// 调用rmDirBreAsync('a').then(() =&gt; &#123; console.log('删除完成');&#125;);// 删除完成 上面的写法都是使用同步的写法，但对文件的操作都是异步的，并使用 await 进行等待，在创建路径集合的数组和倒序删除的过程都是通过 while 循环实现的。 总结深度优先和广度优先的两种遍历方式应该是考虑具体场景选择最适合的方式使用，上面这么多实现递归删除文件目录的方法中，重点在于体会深度遍历和广度遍历的不同，其实在类似于递归删除文件目录的这种功能使用深度优先更适合一些。","tags":[{"name":"异步","slug":"异步","permalink":"https://www.pandashen.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"https://www.pandashen.com/tags/Promise/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"ES6","slug":"ES6","permalink":"https://www.pandashen.com/tags/ES6/"},{"name":"ES7","slug":"ES7","permalink":"https://www.pandashen.com/tags/ES7/"},{"name":"async/await","slug":"async-await","permalink":"https://www.pandashen.com/tags/async-await/"},{"name":"fs","slug":"fs","permalink":"https://www.pandashen.com/tags/fs/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.pandashen.com/tags/数据结构/"}]},{"title":"NodeJS 文件操作 —— fs 基本使用","date":"2018-06-30T09:26:01.000Z","path":"2018/06/30/20180630172601/","text":"fs 概述在 NodeJS 中，所有与文件操作都是通过 fs 核心模块来实现的，包括文件目录的创建、删除、查询以及文件的读取和写入，在 fs 模块中，所有的方法都分为同步和异步两种实现，具有 sync 后缀的方法为同步方法，不具有 sync 后缀的方法为异步方法，在了解文件操作的方法之前有一些关于系统和文件的前置知识，如文件的权限位 mode、标识位 flag、文件描述符 fd 等，所以在了解 fs 方法的之前会先将这几个概念明确。 权限位 mode因为 fs 模块需要对文件进行操作，会涉及到操作权限的问题，所以需要先清楚文件权限是什么，都有哪些权限。 文件权限表： 权限分配文件所有者文件所属组其他用户权限项读写执行读写执行读写执行字符表示rwxrwxrwx数字表示421421421 在上面表格中，我们可以看出系统中针对三种类型进行权限分配，即文件所有者（自己）、文件所属组（家人）和其他用户（陌生人），文件操作权限又分为三种，读、写和执行，数字表示为八进制数，具备权限的八进制数分别为 4 、2、1，不具备权限为 0。 为了更容易理解，我们可以随便在一个目录中打开 Git，使用 Linux 命令 ls -al 来查目录中文件和文件夹的权限位，如果对 Git 和 Linux 命令不熟悉，可以看 Git 命令总结，从零到熟悉（全）。 drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core -rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md 在上面的目录信息当中，很容易看出用户名、创建时间和文件名等信息，但最重要的是开头第一项（十位的字符）。 第一位代表是文件还是文件夹，d 开头代表文件夹，- 开头的代表文件，而后面九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限。 权限参数 mode 主要针对 Linux 和 Unix 操作系统，Window 的权限默认是可读、可写、不可执行，所以权限位数字表示为 0o666，转换十进制表示为 438。 rw—r——r——420400400644 标识位 flagNodeJS 中，标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，在下面用一张表来表示文件操作的标识位和其对应的含义。 符号含义r读取文件，如果文件不存在则抛出异常。r+读取并写入文件，如果文件不存在则抛出异常。rs读取并写入文件，指示操作系统绕开本地文件系统缓存。w写入文件，文件不存在会被创建，存在则清空后写入。wx写入文件，排它方式打开。w+读取并写入文件，文件不存在则创建文件，存在则清空后写入。wx+和 w+ 类似，排他方式打开。a追加写入，文件不存在则创建文件。ax与 a 类似，排他方式打开。a+读取并追加写入，不存在则创建。ax+与 a+ 类似，排他方式打开。 上面表格就是这些标识位的具体字符和含义，但是 flag 是不经常使用的，不容易被记住，所以在下面总结了一个加速记忆的方法。 r：读取 w：写入 s：同步 +：增加相反操作 x：排他方式 r+ 和 w+ 的区别，当文件不存在时，r+ 不会创建文件，而会抛出异常，但 w+ 会创建文件；如果文件存在，r+ 不会自动清空文件，但 w+ 会自动把已有文件的内容清空。 文件描述符 fd操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件，Window 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。 在 NodeJS 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2 三个比较特殊的描述符，分别代表 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）。 文件操作的基本方法文件操作中的基本方法都是对文件进行整体操作，即整个文件数据直接放在内存中操作，如读取、写入、拷贝和追加，由于计算机的内存容量有限，对文件操作需要考虑性能，所以这些方法只针对操作占用内存较小的文件。 文件读取同步读取方法 readFileSyncreadFileSync 有两个参数： 第一个参数为读取文件的路径或文件描述符； 第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding； 返回值为文件的内容，如果没有 encoding，返回的文件内容为 Buffer，如果有按照传入的编码解析。 若现在有一个文件名为 1.txt，内容为 “Hello”，现在使用 readFileSync 读取。 同步读取 readFileSync1234567const fs = require('fs');let buf = fs.readFileSync('1.txt');let data = fs.readFileSync('1.txt', 'utf8');console.log(buf); // &lt;Buffer 48 65 6c 6c 6f&gt;console.log(data); // Hello 异步读取方法 readFile异步读取方法 readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和 data（数据），该方法没有返回值，回调函数在读取文件成功后执行。 依然读取 1.txt 文件： 异步读取 readFile123456const fs = require('fs');fs.readFile('1.txt', 'utf8', (err, data) =&gt; &#123; console.log(err); // null console.log(data); // Hello&#125;); 文件写入同步写入方法 writeFileSyncwriteFileSync 有三个参数： 第一个参数为写入文件的路径或文件描述符； 第二个参数为写入的数据，类型为 String 或 Buffer； 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding。 若现在有一个文件名为 2.txt，内容为 “12345”，现在使用 writeFileSync 写入。 同步写入 writeFileSync123456const fs = require('fs');fs.writeFileSync('2.txt', 'Hello world');let data = fs.readFileSync('2.txt', 'utf8');console.log(data); // Hello world 异步写入方法 writeFile异步写入方法 writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行。 异步写入 writeFile123456789const fs = require('fs');fs.writeFile('2.txt', 'Hello world', err =&gt; &#123; if (!err) &#123; fs.readFile('2.txt', 'utf8', (err, data) =&gt; &#123; console.log(data); // Hello world &#125;); &#125;&#125;); 文件追加写入同步追加写入方法 appendFileSyncappendFileSync 有三个参数： 第一个参数为写入文件的路径或文件描述符； 第二个参数为写入的数据，类型为 String 或 Buffer； 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding。 若现在有一个文件名为 3.txt，内容为 “Hello”，现在使用 appendFileSync 追加写入 “ world”。 同步追加 appendFileSync123456const fs = require('fs');fs.appendFileSync('3.txt', ' world');let data = fs.readFileSync('3.txt', 'utf8');console.log(data); // Hello world 异步追加写入方法 appendFile异步追加写入方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件追加写入数据成功后执行。 异步追加 appendFile123456789const fs = require('fs');fs.appendFile('3.txt', ' world', err =&gt; &#123; if (!err) &#123; fs.readFile('3.txt', 'utf8', (err, data) =&gt; &#123; console.log(data); // Hello world &#125;); &#125;&#125;); 文件拷贝写入同步拷贝写入方法 copyFileSync同步拷贝写入方法 copyFileSync 有两个参数，第一个参数为被拷贝的源文件路径，第二个参数为拷贝到的目标文件路径，如果目标文件不存在，则会创建并拷贝。 现在将上面 3.txt 的内容拷贝到 4.txt 中： 同步拷贝 copyFileSync123456const fs = require('fs');fs.copyFileSync('3.txt', '4.txt');let data = fs.readFileSync('4.txt', 'utf8');console.log(data); // Hello world 异步拷贝写入方法 copyFile异步拷贝写入方法 copyFile 和 copyFileSync 前两个参数相同，最后一个参数为回调函数，在拷贝完成后执行。 异步拷贝 copyFile1234567const fs = require('fs');fs.copyFile('3.txt', '4.txt', () =&gt; &#123; fs.readFile('4.txt', 'utf8', (err, data) =&gt; &#123; console.log(data); // Hello world &#125;);&#125;); 模拟同步、异步拷贝写入文件使用 readFileSync 和 writeFileSync 可以模拟同步拷贝写入文件，使用 readFile 和 writeFile 可以模拟异步写入拷贝文件，代码如下： 模拟同步拷贝123456789101112const fs = require('fs');function copy(src, dest) &#123; let data = fs.readFileSync(src); fs.writeFileSync(dest, data);&#125;// 拷贝copy('3.txt', '4.txt');let data = fs.readFileSync('4.txt', 'utf8');console.log(data); // Hello world 模拟异步拷贝123456789101112131415const fs = require('fs');function copy(src, dest, cb) &#123; fs.readFile(src, (err, data) =&gt; &#123; // 没错误就正常写入 if (!err) fs.writeFile(dest, data, cb); &#125;);&#125;// 拷贝copy('3.txt', '4.txt', () =&gt; &#123; fs.readFile('4.txt', 'utf8', (err, data) =&gt; &#123; console.log(data); // Hello world &#125;);&#125;); 文件操作的高级方法打开文件 openopen 方法有四个参数： path：文件的路径； flag：标识位； mode：权限位，默认 0o666； callback：回调函数，有两个参数 err（错误）和 fd（文件描述符），打开文件后执行。 异步打开文件1234567891011const fs = require('fs');fs.open('4.txt', 'r', (err, fd) =&gt; &#123; console.log(fd); fs.open('5.txt', 'r', (err, fd) =&gt; &#123; console.log(fd); &#125;);&#125;);// 3// 4 关闭文件 closeclose 方法有两个参数，第一个参数为关闭文件的文件描述符 fd，第二参数为回调函数，回调函数有一个参数 err（错误），关闭文件后执行。 异步关闭文件123456789const fs = require('fs');fs.open('4.txt', 'r', (err, fd) =&gt; &#123; fs.close(fd, err =&gt; &#123; console.log('关闭成功'); &#125;);&#125;);// 关闭成功 读取文件 readread 方法与 readFile 不同，一般针对于文件太大，无法一次性读取全部内容到缓存中或文件大小未知的情况，都是多次读取到 Buffer 中。想了解 Buffer 可以看 NodeJS —— Buffer 解读。 read 方法中有六个参数： fd：文件描述符，需要先使用 open 打开； buffer：要将内容读取到的 Buffer； offset：整数，向 Buffer 写入的初始位置； length：整数，读取文件的长度； position：整数，读取文件初始位置； callback：回调函数，有三个参数 err（错误），bytesRead（实际读取的字节数），buffer（被写入的缓存区对象），读取执行完成后执行。 下面读取一个 6.txt 文件，内容为 “你好”。 异步读取文件12345678910111213141516171819202122232425const fs = require('fs');let buf = Buffer.alloc(6);// 打开文件fs.open('6.txt', 'r', (err, fd) =&gt; &#123; // 读取文件 fs.read(fd, buf, 0, 3, 0, (err, bytesRead, buffer) =&gt; &#123; console.log(bytesRead); console.log(buffer); // 继续读取 fs.read(fd, buf, 3, 3, 3, (err, bytesRead, buffer) =&gt; &#123; console.log(bytesRead); console.log(buffer); console.log(buffer.toString()); &#125;); &#125;);&#125;);// 3// &lt;Buffer e4 bd a0 00 00 00&gt;// 3// &lt;Buffer e4 bd a0 e5 a5 bd&gt;// 你好 同步磁盘缓存 fsyncfsync 方法有两个参数，第一个参数为文件描述符 fd，第二个参数为回调函数，回调函数中有一个参数 err（错误），在同步磁盘缓存后执行。 在使用 write 方法向文件写入数据时，由于不是一次性写入，所以最后一次写入在关闭文件之前应先同步磁盘缓存，fsync 方法将在后面配合 write 一起使用。 写入文件 writewrite 方法与 writeFile 不同，是将 Buffer 中的数据写入文件，Buffer 的作用是一个数据中转站，可能数据的源占用内存太大或内存不确定，无法一次性放入内存中写入，所以分段写入，多与 read 方法配合。 write 方法中有六个参数： fd：文件描述符，需要先使用 open 打开； buffer：存储将要写入文件数据的 Buffer； offset：整数，从 Buffer 读取数据的初始位置； length：整数，读取 Buffer 数据的字节数； position：整数，写入文件初始位置； callback：回调函数，有三个参数 err（错误），bytesWritten（实际写入的字节数），buffer（被读取的缓存区对象），写入完成后执行。 下面将一个 Buffer 中间的两个字写入文件 6.txt，原内容为 “你好”。 选择范围写入1234567891011121314151617181920212223const fs = require('fs');let buf = Buffer.from('你还好吗');// 打开文件fs.open('6.txt', 'r+', (err, fd) =&gt; &#123; // 读取 buf 向文件写入数据 fs.write(fd, buf, 3, 6, 3, (err, bytesWritten, buffer) =&gt; &#123; // 同步磁盘缓存 fs.fsync(fd, err =&gt; &#123; // 关闭文件 fs.close(fd, err =&gt; &#123; console.log('关闭文件'); &#125;); &#125;); &#125;);&#125;);// 这里为了看是否写入成功简单粗暴的使用 readFile 方法fs.readFile('6.txt', 'utf8', (err, data) =&gt; &#123; console.log(data);&#125;);// 你还好 上面代码将 “你还好吗” 中间的 “还好” 从 Buffer 中读取出来写入到 6.txt 的 “你” 字之后，但是最后的 “好” 并没有被保留，说明先清空了文件中 “你” 字之后的内容再写入。 针对大文件实现 copy之前我们使用 readFile 和 writeFile 实现了一个 copy 函数，那个 copy 函数是将被拷贝文件的数据一次性读取到内存，一次性写入到目标文件中，针对小文件。 如果是一个大文件一次性写入不现实，所以需要多次读取多次写入，接下来使用上面的这些方法针对大文件和文件大小未知的情况实现一个 copy 函数。 大文件拷贝123456789101112131415161718192021222324252627282930313233343536// copy 方法function copy(src, dest, size = 16 * 1024, callback) &#123; // 打开源文件 fs.open(src, 'r', (err, readFd) =&gt; &#123; // 打开目标文件 fs.open(dest, 'w', (err, writeFd) =&gt; &#123; let buf = Buffer.alloc(size); let readed = 0; // 下次读取文件的位置 let writed = 0; // 下次写入文件的位置 (function next() &#123; // 读取 fs.read(readFd, buf, 0, size, readed, (err, bytesRead) =&gt; &#123; readed += bytesRead; // 如果都不到内容关闭文件 if (!bytesRead) fs.close(readFd, err =&gt; console.log('关闭源文件')); // 写入 fs.write(writeFd, buf, 0, bytesRead, writed, (err, bytesWritten) =&gt; &#123; // 如果没有内容了同步缓存，并关闭文件后执行回调 if (!bytesWritten) &#123; fs.fsync(writeFd, err =&gt; &#123; fs.close(writeFd, err =&gt; return !err &amp;&amp; callback()); &#125;); &#125; writed += bytesWritten; // 继续读取、写入 next(); &#125;); &#125;); &#125;)(); &#125;); &#125;);&#125; 在上面的 copy 方法中，我们手动维护的下次读取位置和下次写入位置，如果参数 readed 和 writed 的位置传入 null，NodeJS 会自动帮我们维护这两个值。 现在有一个文件 6.txt 内容为 “你好”，一个空文件 7.txt，我们将 6.txt 的内容写入 7.txt 中。 验证大文件拷贝123456789101112const fs = require('fs');// buffer 的长度const BUFFER_SIZE = 3;// 拷贝文件内容并写入copy('6.txt', '7.txt', BUFFER_SIZE, () =&gt; &#123; fs.readFile('7.txt', 'utf8', (err, data) =&gt; &#123; // 拷贝完读取 7.txt 的内容 console.log(data); // 你好 &#125;);&#125;); 在 NodeJS 中进行文件操作，多次读取和写入时，一般一次读取数据大小为 64k，写入数据大小为 16k。 文件目录操作方法下面的这些操作文件目录的方法有一个共同点，就是传入的第一个参数都为文件的路径，如：a/b/c/d，也分为同步和异步两种实现。 查看文件目录操作权限同步查看操作权限方法 accessSyncaccessSync 方法传入一个目录的路径，检查传入路径下的目录是否可读可写，当有操作权限的时候没有返回值，没有权限或路径非法时抛出一个 Error 对象，所以使用时多用 try...catch... 进行异常捕获。 同步查看操作权限12345678const fs = require('fs');try &#123; fs.accessSync('a/b/c'); console.log('可读可写');&#125; catch (err) &#123; console.error('不可访问');&#125; 异步查看操作权限方法 accessaccess 方法与第一个参数为一个目录的路径，最后一个参数为一个回调函数，回调函数有一个参数为 err（错误），在权限检测后触发，如果有权限 err 为 null，没有权限或路径非法 err 是一个 Error 对象。 异步查看操作权限123456789const fs = require('fs');fs.access('a/b/c', err =&gt; &#123; if (err) &#123; console.error('不可访问'); &#125; else &#123; console.log('可读可写'); &#125;&#125;); 获取文件目录的 Stats 对象文件目录的 Stats 对象存储着关于这个文件或文件夹的一些重要信息，如创建时间、最后一次访问的时间、最后一次修改的时间、文章所占字节和判断文件类型的多个方法等等。 同步获取 Stats 对象方法 statSyncstatSync 方法参数为一个目录的路径，返回值为当前目录路径的 Stats 对象，现在通过 Stats 对象获取 a 目录下的 b 目录下的 c.txt 文件的字节大小，文件内容为 “你好”。 同步获取 Stats 对象1234const fs = require('fs');let statObj = fs.statSync('a/b/c.txt');console.log(statObj.size); // 6 异步获取 Stats 对象方法 statstat 方法的第一个参数为目录的路径，最后一个参数为回调函数，回调函数有两个参数 err（错误）和 Stats 对象，在读取 Stats 后执行，同样实现上面的读取文件字节数的例子。 异步获取 Stats 对象12345const fs = require('fs');fs.stat('a/b/c.txt', (err, statObj) =&gt; &#123; console.log(statObj.size); // 6&#125;); 创建文件目录同步创建目录方法 mkdirSyncmkdirSync 方法参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常。 同步创建文件目录1234const fs = require('fs');// 假设已经有了 a 文件夹和 a 下的 b 文件夹fs.mkdirSync('a/b/c'); 异步创建目录方法 mkdirmkdir 方法的第一个参数为目录的路径，最后一个参数为回调函数，回调函数有一个参数 err（错误），在执行创建操作后执行，同样需要路径前部分的文件夹都存在。 异步创建文件目录12345678const fs = require('fs');// 假设已经有了 a 文件夹和 a 下的 b 文件夹fs.mkdir('a/b/c', err =&gt; &#123; if (!err) console.log('创建成功');&#125;);// 创建成功 读取文件目录同步读取目录方法 readdirSyncreaddirSync 方法有两个参数： 第一个参数为目录的路径，传入的路径前部分的目录必须存在，否则会报错； 第二个参数为 options，其中有 encoding（编码，默认值为 utf8），也可直接传入 encoding； 返回值为一个存储文件目录中成员名称的数组。 假设现在已经存在了 a 目录和 a 下的 b 目录，b 目录中有 c 目录和 index.js 文件，下面读取文件目录结构。 同步读取目录1234const fs = require('fs');let data = fs.readdirSync('a/b');console.log(data); // [ 'c', 'index.js' ] 异步读取目录方法 readdirreaddir 方法的前两个参数与 readdirSync 相同，第三个参数为一个回调函数，回调函数有两个参数 err（错误）和 data（存储文件目录中成员名称的数组），在读取文件目录后执行。 上面案例异步的写法： 异步读取目录1234567const fs = require('fs');fs.readdir('a/b', (err, data) =&gt; &#123; if (!err) console.log(data);&#125;);// [ 'c', 'index.js' ] 删除文件目录无论同步还是异步，删除文件目录时必须保证文件目录的路径存在，且被删除的文件目录为空，即不存在任何文件夹和文件。 同步删除目录方法 rmdirSyncrmdirSync 的参数为要删除目录的路径，现在存在 a 目录和 a 目录下的 b 目录，删除 b 目录。 同步删除目录123const fs = require('fs');fs.rmdirSync('a/b'); 异步删除目录方法 rmdirrmdir 方法的第一个参数与 rmdirSync 相同，最后一个参数为回调函数，函数中存在一个参数 err（错误），在删除目录操作后执行。 异步删除目录1234567const fs = require('fs');fs.rmdir('a/b', err =&gt; &#123; if (!err) console.log('删除成功');&#125;);// 删除成功 删除文件操作同步删除文件方法 unlinkSyncunlinkSync 的参数为要删除文件的路径，现在存在 a 目录和 a 目录下的 index.js 文件，删除 index.js 文件。 同步删除文件123const fs = require('fs');fs.unlinkSync('a/inde.js'); 异步删除文件方法 unlinkunlink 方法的第一个参数与 unlinkSync 相同，最后一个参数为回调函数，函数中存在一个参数 err（错误），在删除文件操作后执行。 异步删除文件1234567const fs = require('fs');fs.unlink('a/index.js', err =&gt; &#123; if (!err) console.log('删除成功');&#125;);// 删除成功 实现递归创建目录我们创建一个函数，参数为一个路径，按照路径一级一级的创建文件夹目录。 同步的实现递归删除文件目录 —— 同步1234567891011121314151617181920212223const fs = require('fs');const path = require('path');// 同步创建文件目录function mkPathSync(dirPath) &#123; // path.sep 文件路径分隔符（mac 与 window 不同） // 转变成数组，如 ['a', 'b', 'c'] let parts = dirPath.split(path.sep); for (let i = 1; i &lt;= parts.length; i++) &#123; // 重新拼接成 a a/b a/b/c let current = parts.slice(0, i).join(path.sep); // accessSync 路径不存在则抛出错误在 catch 中创建文件夹 try &#123; fs.accessSync(current); &#125; catch(e) &#123; fs.mkdirSync(current); &#125; &#125;&#125;// 创建文件目录mkPathSync(path.join('a', 'b', 'c')); 同步代码就是利用 accessSync 方法检查文件路径是否存在，利用 try...catch... 进行错误捕获，如果路径不存在，则会报错，会进入 catch 完成文件夹的创建。 异步回调的实现递归删除文件目录 —— 异步回调123456789101112131415161718192021222324252627282930313233const fs = require('fs');const path = require('path');function mkPathAsync(dirPath, callback) &#123; // 转变成数组，如 ['a', 'b', 'c'] let parts = dirPath.split(path.sep); let index = 1; // 创建文件夹方法 function next() &#123; // 重新拼接成 a a/b a/b/c let current = parts.slice(0, index).join(path.sep); index++; // 如果路径检查成功说明已经有该文件目录，则继续创建下一级 // 失败则创建目录，成功后递归 next 创建下一级 fs.access(current, err =&gt; &#123; if (err) &#123; fs.mkdir(current, next); &#125; else &#123; next(); &#125; &#125;); &#125; next();&#125;// 创建文件目录mkPathAsync(path.join('a', 'b', 'c'), () =&gt; &#123; console.log('创建文件目录完成')&#125;);// 创建文件目录完成 上面方法中没有通过循环实现每次目录的拼接，而是通过递归内部函数 next 的方式并维护 index 变量来实现的，在使用 access 的时候成功说明文件目录已经存在，就继续递归创建下一级，如果存在 err 说明不存在，则创建文件夹。 异步 async/await 的实现上面两种方式，同步阻塞代码，性能不好，异步回调函数嵌套性能好，但是维护性差，我们想要具备性能好，代码可读性又好可以使用现在 NodeJS 中正流行的 async/await 的方式进行异步编程，想了解 async/await 可以看 异步发展流程 —— 异步编程的终极大招 async/await 这篇文章。 使用 async 函数中 await 等待的异步操作必须转换成 Promise，以前我们都使用 util 模块下的 promisify 方法进行转换，其实 promisify 方法的原理很简单，我们在实现递归创建文件目录之前先实现 promisify 方法。 promisify 原理12345678// 将一个异步方法转换成 Promisefunction promisify(fn) &#123; return function (...args) &#123; return new Promise((resolve, reject) =&gt; &#123; fn.call(null, ...args, err =&gt; err ? reject() : resolve()); &#125;); &#125;&#125; 其实 promisify 方法就是利用闭包来实现的，调用时传入一个需要转换成 Promise 的函数 fn，返回一个闭包函数，在闭包函数中返回一个 Promise 实例，并同步执行了 fn，通过 call 将闭包函数中的参数和回调函数作为参数传入了 fn 中，该回调在存在错误的时候调用了 Promise 实例的 reject，否则调用 resolve； 递归删除文件目录 —— 异步 async/await12345678910111213141516171819202122232425262728293031const fs = require('fs');const path = require('path');// 将 fs 中用到的方法转换成 Promiseconst access = promisify(fs.access);const mkdir = promisify(fs.mkdir);// async/await 实现递归创建文件目录async function mkPath(dirPath) &#123; // 转变成数组，如 ['a', 'b', 'c'] let parts = dirPath.split(path.sep); for (let i = 1; i &lt;= parts.length; i++) &#123; // 重新拼接成 a a/b a/b/c let current = parts.slice(0, i).join(path.sep); // accessSync 路径不存在则抛出错误在 catch 中创建文件夹 try &#123; await access(current); &#125; catch(e) &#123; await mkdir(current); &#125; &#125;&#125;// 创建文件目录mkPath(path.('a', 'b', 'c')).then(() =&gt; &#123; console.log('创建文件目录完成');&#125;);// 创建文件目录完成 使用 async/await 的写法，代码更像同步的实现方式，却是异步执行，所以同时兼顾了性能和代码的可读性，优势显而易见，在使用 NodeJS 框架 Koa 2.x 版本时大量使用这种方式进行异步编程。 总结在 fs 所有模块都有同步异步两种实现，同步方法的特点就是阻塞代码，导致性能差，异步代码的特点就是回调函数嵌套多，在使用 fs 应尽量使用异步方式编程来保证性能，如果觉得回调函数嵌套不好维护，可以使用 Promise 和 async/await 的方式解决。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"fs","slug":"fs","permalink":"https://www.pandashen.com/tags/fs/"}]},{"title":"NodeJS —— Buffer 解读","date":"2018-06-29T03:53:13.000Z","path":"2018/06/29/20180629115313/","text":"Buffer 概述在 ES6 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 NodeJS API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。Buffer 属于 Global 对象，使用时不需引入，且 Buffer 的大小在创建时确定，无法调整。 创建 Buffer在 NodeJS v6.0.0 版本之前，Buffer 实例是通过 Buffer 构造函数创建的，即使用 new 关键字创建，它根据提供的参数返回不同的 Buffer，但在之后的版本中这种声明方式就被废弃了，替代 new 的创建方式主要有以下几种。 Buffer.alloc 和 Buffer.allocUnsafe用 Buffer.alloc 和 Buffer.allocUnsafe 创建 Buffer 的传参方式相同，参数为创建 Buffer 的长度，数值类型。 Buffer.alloc 和 Buffer.allocUnsafe 创建 Buffer12345678// Buffer.alloc 创建 Bufferlet buf1 = Buffer.alloc(6);// Buffer.allocUnsafe 创建 Bufferlet buf2 = Buffer.allocUnsafe(6);console.log(buf1); // &lt;Buffer 00 00 00 00 00 00&gt;console.log(buf2); // &lt;Buffer 00 e7 8f a0 00 00&gt; 通过代码可以看出，用 Buffer.alloc 和 Buffer.allocUnsafe 创建 Buffer 是有区别的，Buffer.alloc 创建的 Buffer 是被初始化过的，即 Buffer 的每一项都用 00 填充，而 Buffer.allocUnsafe 创建的 Buffer 并没有经过初始化，在内存中只要有闲置的 Buffer 就直接 “抓过来” 使用。 Buffer.allocUnsafe 创建 Buffer 使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感数据，有明显性能优势的同时又是不安全的，所以使用需格外 “小心”。 Buffer.fromBuffer.from 支持三种传参方式： 第一个参数为字符串，第二个参数为字符编码，如 ASCII、UTF-8、Base64 等等。 传入一个数组，数组的每一项会以十六进制存储为 Buffer 的每一项。 传入一个 Buffer，会将 Buffer 的每一项作为新返回 Buffer 的每一项。 传入字符串和字符编码： 传入字符串和字符编码123let buf = Buffer.from('hello', 'utf8');console.log(buf); // &lt;Buffer 68 65 6c 6c 6f&gt; 传入数组： 数组成员为十进制数123let buf = Buffer.from([1, 2, 3]);console.log(buf); // &lt;Buffer 01 02 03&gt; 数组成员为十六进制数1234let buf = Buffer.from([0xe4, 0xbd, 0xa0, 0xe5, 0xa5, 0xbd]);console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt;console.log(buf.toString('utf8')); // 你好 在 NodeJS 中不支持 GB2312 编码，默认支持 UTF-8，在 GB2312 中，一个汉字占两个字节，而在 UTF-8 中，一个汉字占三个字节，所以上面 “你好” 的 Buffer 为 6 个十六进制数组成。 数组成员为字符串类型的数字123let buf = Buffer.from(['1', '2', '3']);console.log(buf); // &lt;Buffer 01 02 03&gt; 传入的数组成员可以是任何进制的数值，当成员为字符串的时候，如果值是数字会被自动识别成数值类型，如果值不是数字或成员为是其他非数值类型的数据，该成员会被初始化为 00。 创建的 Buffer 可以通过 toString 方法直接指定编码进行转换，默认编码为 UTF-8。 传入 Buffer： 传入一个 Buffer12345678let buf1 = Buffer.from('hello', 'utf8');let buf2 = Buffer.from(buf1);console.log(buf1); // &lt;Buffer 68 65 6c 6c 6f&gt;console.log(buf2); // &lt;Buffer 68 65 6c 6c 6f&gt;console.log(buf1 === buf2); // trueconsole.log(buf1[0] === buf2[0]); // false 当传入的参数为一个 Buffer 的时候，会创建一个新的 Buffer 并复制上面的每一个成员。 Buffer 为引用类型，一个 Buffer 复制了另一个 Buffer 的成员，当其中一个 Buffer 复制的成员有更改，另一个 Buffer 对应的成员会跟着改变，因为指向同一个引用，类似于 “二维数组”。 Buffer 类比二维数组12345let arr1 = [1, 2, [3]];let arr2 = arr1.slice();arr2[2][0] = 5;console.log(arr1); // [1, 2, [5]] Buffer 的常用方法fillBuffer 的 fill 方法可以向一个 Buffer 中填充数据，支持传入三个参数： value：将要填充的数据； start：填充数据的开始位置，不指定默认为 0； end：填充数据的结束位置，不指定默认为 Buffer 的长度。 1234let buf = Buffer.alloc(3);buf.fill(1);console.log(buf); // &lt;Buffer 01 01 01&gt; 1234let buf = Buffer.alloc(6);buf.fill(1, 2, 4);console.log(buf); // &lt;Buffer 00 00 01 01 00 00&gt; 上面代码可以看出填充数据是 “包前不包后的”，fill 的第一个参数也支持是多个字节，从被填充 Buffer 的起始位置开始，一直到结束，会循环填充这些字节，剩余的位置不够填充这几个字节，会填到哪算哪，有可能不完整，如果 fill 指定的结束位置大于了 Buffer 的长度，会抛出 RangeError 的异常。 1234let buf = Buffer.alloc(6);buf.fill('abc', 1, 5);console.log(buf); // &lt;Buffer 00 61 62 63 61 00&gt; 1234let buf = Buffer.alloc(3);buf.fill('abc', 4, 8);console.log(buf); // throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE'); sliceBuffer 的 slice 方法与数组的 slice 方法用法完全相同，相信数组的 slice 已经足够熟悉了，这里就不多赘述了，Buffer 中截取出来的都是 Buffer。 123456789let buf = Buffer.from('hello', 'utf8');let a = buf.slice(0, 2);let b = buf.slice(2);let b = buf.slice(-2);console.log(a.toString()); // heconsole.log(b.toString()); // lloconsole.log(c.toString()); // o indexOfBuffer 的 indexOf 用法与数组和字符串的 indexOf 类似，第一个参数为查找的项，第二个参数为查找的起始位置，不同的是，对于 Buffer 而言，查找的可能是一个字符串，代表多个字节，查找的字节在 Buffer 中必须有连续相同的字节，返回连续的字节中第一个字节的索引，没查找到返回 -1。 12345let buf = Buffer.from('你*好*吗', 'utf8');console.log(buf); // &lt;Buffer e4 bd a0 2a e5 a5 bd 2a e5 90 97&gt;console.log(buf.indexOf('*')); // 3console.log(buf.indexOf('*', 4)); // 7 copyBuffer 的 copy 方法用于将一个 Buffer 的字节复制到另一个 Buffer 中去，有四个参数： target：目标 Buffer targetStart：目标 Buffer 的起始位置 sourceStart：源 Buffer 的起始位置 sourceEnd：源 Buffer 的结束位置 容器 Buffer 长度充足1234567let targetBuf = Buffer.alloc(6);let sourceBuf = Buffer.from('你好', 'utf8');// 将 “你好” 复制到 targetBuf 中sourceBuf.copy(targetBuf, 0, 0, 6);console.log(targetBuf.toString()); // 你好 容器 Buffer 长度不足12345let targetBuf = Buffer.alloc(3);let sourceBuf = Buffer.from('你好', 'utf8');sourceBuf.copy(targetBuf, 0, 0, 6);console.log(targetBuf.toString()); // 你 上面第二个案例中虽然要把整个源 Buffer 都复制进目标 Buffer 中，但是由于目标 Buffer 的长度只有 3，所以最终只能复制进去一个 “你” 字。 Buffer 与数组不同，不能通过操作 length 和索引改变 Buffer 的长度，Buffer 一旦被创建，长度将保持不变。 数组对比 Buffer —— 操作 length1234567891011121314151617// 数组let arr = [1, 2, 3];arr[3] = 4;console.log(arr); // [1, 2, 3, 4]arr.length = 5;console.log(arr); // [1, 2, 3, 4, empty]// Bufferlet buf = Buffer.alloc(3);buf[3] = 0x00;console.log(buf); // &lt;Buffer 00 00 00&gt;buf.length = 5;console.log(buf); // &lt;Buffer 00 00 00&gt;console.log(buf.length); // 3 通过上面代码可以看出数组可以通过 length 和索引对数组的长度进行改变，但是 Buffer 中类似的操作都是不生效的。 copy 方法的 Polyfill： 模拟 copy 方法12345678910Buffer.prototype.myCopy = function( target, targetStart, sourceStart, sourceEnd) &#123; for (let i = 0; i &lt; sourceEnd - sourceStart; i++) &#123; target[targetStart + i] = this[sourceStart + i]; &#125;&#125; Buffer.concat与数组类似，Buffer 也存在用于拼接多个 Buffer 的方法 concat，不同的是 Buffer 中的 concat 不是实例方法，而是静态方法，通过 Buffer.concat 调用，且传入的参数不同。 Buffer.concat 有两个参数，返回值是一个新的 Buffer： 第一个参数为一个数组，数组中的每一个成员都是一个 Buffer； 第二个参数代表新 Buffer 的长度，默认值为数组中每个 Buffer 长度的总和。 Buffer.concat 会将数组中的 Buffer 进行拼接，存入新 Buffer 并返回，如果传入第二个参数规定了返回 Buffer 的长度，那么返回值存储拼接后前规定长度个字节。 1234567891011let buf1 = Buffer.from('你', 'utf8');let buf2 = Buffer.from('好', 'utf8');let result1 = Buffer.concat([buf1, buf2]);let result2 = Buffer.concat([buf1, buf2], 3);console.log(result1); // &lt;Buffer e4 bd a0 e5 a5 bd&gt;console.log(result1.toString()); // 你好console.log(result2); // &lt;Buffer e4 bd a0&gt;console.log(result2.toString()); // 你 Buffer.concat 方法的 Polyfill： 模拟 Buffer.concat123456789101112131415Buffer.myConcat = function(bufferList, len) &#123; // 新 Buffer 的长度 len = len || bufferList.reduce((prev, next) =&gt; prev + next.length, 0); let newBuf = Buffer.alloc(len); // 创建新 Buffer let index = 0; // 下次开始的索引 // 循环存储 Buffer 的数组进行复制 bufferList.forEach(buf =&gt; &#123; buf.myCopy(newBuf, index, 0, buf.length); index += buf.length; &#125;); return newBuf;&#125; Buffer.isBufferBuffer.isBuffer 是用来判断一个对象是否是一个 Buffer，返回布尔值。 12345let obj = &#123;&#125;;let buf = Buffer.alloc(6);console.log(Buffer.isBuffer(obj)); // falseconsole.log(Buffer.isBuffer(buf)); // true 封装一个 split字符串中的 split 是经常使用的方法，可以用分隔符将字符串切成几部分存储在数组中，Buffer 本身没有 split 方法，但是也会有类似的使用场景，所以我们在 Buffer 中自己封装一个 split。 Buffer 的 split 方法参数为一个分隔符，这个分隔符可能是一个或多个字节的内容，返回值为一个数组，分隔开的部分作为独立的 Buffer 存储在返回的数组中。 封装 Buffer 的 split 方法12345678910111213141516171819Buffer.prototype.split = function(sep) &#123; let len = Buffer.from(sep).length; // 分隔符所占的字节数 let result = []; // 返回的数组 let start = 0; // 查找 Buffer 的起始位置 let offset = 0; // 偏移量 // 循环查找分隔符 while ((offset = this.indexOf(sep, start)) !== -1) &#123; // 将分隔符之前的部分截取出来存入 result.push(this.slice(start, offset)); start = offset + len; &#125; // 处理剩下的部分 result.push(this.slice(start)); // 返回结果 return result;&#125; 验证 split 方法： 验证 split12345678910let buf = Buffer.from('哈登爱篮球爱夜店', 'utf8');let bufs = buf.split('爱');console.log(bufs);// [ &lt;Buffer e5 93 88 e7 99 bb&gt;,// &lt;Buffer e7 af ae e7 90 83&gt;,// &lt;Buffer e5 a4 9c e5 ba 97&gt; ]newBufs = bufs.map(buf =&gt; buf.toString());console.log(newBufs); // [ '哈登', '篮球', '夜店' ] Buffer 的编码转换我们知道 NodeJS 中的默认编码为 UTF-8，且不支持 GB2312 编码，假如现在有一个编码格式为 GB2312 的 txt 文件，内容为 “你好”，现在我们使用 NodeJS 去读取它，由于在 UTF-8 与 GB2312 编码中汉字所占字节数不同，所以读出的内容无法解析，即为乱码。 1234567891011// 引入依赖const fs = require('fs');const path = require('path');let buf = Buffer.from('你好', 'utf8');let result = fs.readFileSync(path.resolve(__dirname, 'a.txt'));console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt;console.log(buf.toString()); // 你好console.log(result); // &lt;Buffer c4 e3 ba c3&gt;console.log(result.toString()); // ��� 如果一定要在 NodeJS 中来正确解析这样的内容，这样的问题还是有办法解决的，我们需要借助 iconv-lite 模块，这个模块可以将一个 Buffer 按照指定的编码格式进行编码或解码。 由于 iconv-lite 是第三方提供的模块，在使用前需要安装，安装命令如下： npm install iconv-lite 如果想正确的读出其他编码格式文件的内容，上面代码应该更改为： 12345678// 引入依赖const fs = require('fs');const path = require('path');const iconvLite = require('iconv-lite');let result = fs.readFileSync(path.resolve(__dirname, 'a.txt'));console.log(iconvLite.decode(result, 'gb2312')); // 你好 去掉 BOM 头上面读取 GB2312 编码的 txt 文件也可以通过打开文件重新保存为 UTF-8 或用编辑器直接将编码手动修改为 UTF-8，此时读取的文件不需要进行编码转换，但是会产生新的问题。 产生 BOM 头123456789// 引入依赖const fs = require('fs');const path = require('path');let buf = Buffer.from('你好', 'utf8');let result = fs.readFileSync(path.resolve(__dirname, 'a.txt'));console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt;console.log(result); // &lt;Buffer ef bb bf e4 bd a0 e5 a5 bd&gt; 在手动修改 txt 文件编码后执行上面代码，发现读取的 Buffer 与正常情况相比前面多出了三个字节，只要存在文件编码的修改就会在这个文件的前面产生多余的字节，叫做 BOM 头。 BOM 头是用来判断文本文件是哪一种 Unicode 编码的标记，其本身是一个 Unicode 字符，位于文本文件头部。 虽然 BOM 头起到了标记文件编码的作用，但是它并不属于文件的内容部分，因此会产生一些问题，如文件编码发生变化后无法正确读取文件的内容，或者多个文件在合并的过程中，中间会夹杂着这些多余内容，所以在 NodeJS 文件操作的源码中，Buffer 编码转换的模块 iconv-lite 中，以及 Webpack 对项目文件进行打包编译时都进行了去掉 BOM 头的操作。 为了让上面的代码可以正确的读取并解析编码被手动修改过的文件内容，我们这里也需要进行去掉 BOM 头的操作。 去掉 BOM 头的方法123456789101112131415function BOMStrip(result) &#123; if (Buffer.isBuffer(result)) &#123; // 如果读取的内容为 Buffer if (result[0] === 0xef &amp;&amp; result[1] === 0xbb &amp;&amp; result[2] === 0xbf) &#123; // 若前三个字节是否和 BOM 头的前三字节相同，去掉 BOM 头 return Buffer.slice(3); &#125; &#125; else &#123; // 如果不是 Buffer if (result.charCodeAt(0) === 0xfeff) &#123; // 判断第一项是否和 BOM 头的十六进制相同，去掉 BOM 头 return result.slice(1); &#125; &#125;&#125; 使用去掉 BOM 头的方法并验证上面读文件的案例： 验证去 BOM 头的方法12345678910// 引入依赖const fs = require('fs');const path = require('path');// 两种方式读文件let result1 = fs.readFileSync(path.resolve(__dirname, 'a.txt'));let result2 = fs.readFileSync(path.resolve(__dirname, 'a.txt'), 'utf8');console.log(BOMStrip(result1).toString()); // 你好console.log(BOMStrip(result2)); // 你好 缓存 Buffer产生乱码问题1234567let buf = Buffer.from('你好', 'utf8');let a = buf.slice(0, 2);let b = buf.slice(2, 6);console.log(a.toString()); // �console.log(b.toString()); // �好 UTF-8 编码，一个汉字三个字节，使用 slice 方法对一个表达汉字的 Buffer 进行截取，如果截取长度不是 3 的整数倍，此时无法正确解析，会显示乱码，类似这种情况可以使用模块 string_decoder 对不能组成汉字的 Buffer 进行缓存，string_decoder 是核心模块，不需要安装。 缓存 Buffer12345678910111213// 引入依赖const &#123; StringDecoder &#125; = require('string_decoder');let buf = Buffer.from('你好', 'utf8');let a = buf.slice(0, 2);let b = buf.slice(2, 6);// 创建 StringDecoder 实例let sd = new StringDecoder();console.log(sd.write(a));console.log(sd.write(b)); // 你好 上面代码中使用了 string_decoder 后，截取的 Buffer 不能组成一个汉字的时候不打印，进行缓存，等到可以正确解析时取出缓存，重新拼接后打印。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"Buffer","slug":"Buffer","permalink":"https://www.pandashen.com/tags/Buffer/"}]},{"title":"EventEmitter 源码分析与简易实现","date":"2018-06-28T12:47:55.000Z","path":"2018/06/28/20180628204755/","text":"EventEmitter 简介EventEmitter 是 NodeJS 的核心模块 events 中的类，用于对 NodeJS 中的事件进行统一管理，用 events 特定的 API 对事件进行添加、触发和移除等等，核心方法的模式类似于发布订阅。 实现 EventEmitterEventEmitter 构造函数的实现文件：events.js12345678910function EventEmitter() &#123; this._events = Object.create(null);&#125;/** 其他方法*/// 导出自定义模块module.export = EventEmitter; 在构造函数 EventEmitter 上有一个属性 _events，类型为对象，用于存储和统一管理所有类型的事件，在创建构造函数的时候导出了 EventEmitter，后面实现其他方法的代码将放在构造函数与导出中间。 事件最大监听个数在 EventEmitter 中监听的每一类事件都有最大监听个数，超过了这个数值，事件虽然可以正常执行，但是会发出警告信息，其目的是为了防止内存泄露。 默认事件最大监听个数1EventEmitter.defaultMaxListeners = 10; 这个同类型事件最大个数默认是 10，EventEmitter 当然也有方法设置和获取这个值，下面是设置和获取同类型事件最大监听个数的方法实现。 操作最大事件监听个数123456789// 设置同类型事件监听最大个数EventEmitter.prototype.setMaxListeners = function(count) &#123; this._count = count;&#125;// 获取同类型事件监听最大个数EventEmitter.prototype.getMaxListeners = function() &#123; return this._count || EventEmitter.defaultMaxListeners;&#125; 在设置这个值的时候其实就是给 EventEmitter 实例添加了一个 _count 的属性用来存储设置的新值来作为这个类型事件的最大监听个数，在获取的时候就是获取 _count，如果没有设置过就获取默认值。 添加事件监听在给 EventEmitter 的实例添加事件监听时，在 _event 对象中会以事件的类型作为属性名，值为一个数组，每次添加这个类型事件的时候，会将要执行的函数存入这个数组中进行统一管理。 添加事件监听的方法有 on、once、addListener、prependListener 和 prependOnceListener： on 等同于 addListener 将函数正常添加到 _event 对应事件类型的数组中； once 将函数添加到 _event 对应事件类型的数组中，但是只能执行一次； prependListener 将函数添加到 _event 对应事件类型的数组中的前面； prependOnceListener 将函数添加到 _event 对应事件类型的数组中的前面，但只能执行一次。 在 EventEmitter 中正常添加事件有四点需要注意：1、如果其他的类使用 util 模块的 inherits 方法继承 EventEmitter 时是无法继承实例属性的，在调用操作 _events 的方法中因为无法获取到 _events 导致报错，为了兼容这种继承的情况，在获取不到 _events 时应添加一个 _events 到继承 EventEmitter 的类的实例上；2、如果添加事件的类型为 newListener，传入要执行的函数会有一个参数 type ，是事件的类型，之后再添加事件的时候，就会执行 newListener 的函数，对添加的事件的事件类型进行处理；3、on 方法表面上有两个参数，实际上有第三个参数，为布尔值，代表是否从 _events 对应事件类型的数组前面追加函数成员；4、在添加事件的时候需要判断是否超出这个类型事件的最大监听个数，如果超出要打印警告信息。 on 方法和 addListener 方法的实现： on 和 addListener 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344// 添加事件监听EventEmitter.prototype.on = EventEmitter.prototype.addListener = function( type, callback, flag) &#123; // 兼容继承不存在 _events 的情况 if (!this._events) this._events = Object.create(null); // 如果 type 不是 newListener 就去执行 newListener 的回调 if (type !== 'newListener') &#123; // 如果没添加过 newListener 事件就忽略此处的逻辑 if ( this._events['newListener'] &amp;&amp; this._events['newListener'].length ) &#123; this._events['newListener'].forEach(fn =&gt; fn(type)); &#125; &#125; // 如果不是第一次添加 callback 存入数组中 if (this._events[type]) &#123; // 是否从数组前面添加 callback if (flag) &#123; this._events[type].unshift(callback); &#125; else &#123; this._events[type].push(callback); &#125; &#125; else &#123; // 第一次添加，在 _events 中创建数组并添加 callback 到数组中 this._events[type] = [callback]; &#125; // 获取事件最大监听个数 let maxListeners = this.getMaxListeners(); // 判断 type 类型的事件是否超出最大监听个数，超出打印警告信息 if (this._events[type].length - 1 === maxListeners) &#123; console.error( `MaxListenersExceededWarning: $&#123;maxListeners + 1&#125; $&#123;type&#125; listeners added` ); &#125;&#125; 通过上面代码可以看出 on 方法的第三个参数其实是服务于 prependListener 方法的，其他添加事件的方法都是基于 on 来实现的，只是在调用 on 的外层做了不同的处理，而我们平时调这些添加事件监听的方法时都只传入 type 和 callback。 prependListener 方法的实现： prependListener 方法12345// 添加事件监听，从数组的前面追加EventEmitter.prototype.prependListener = function(type, callback) &#123; // 第三个参数为 true 表示从 _events 对应事件类型的数组前面添加 callback this.on(type, callback, true);&#125; once 方法的实现： once 方法123456789101112131415// 添加事件监听，只能执行一次EventEmitter.prototype.once = function(type, callback, flag) &#123; const wrap =&gt; (...args) &#123; callback(...args); // 执行 callback 后立即从数组中移除 callback this.removeListener(type, wrap); &#125; // 存储 callback，确保单独使用 removeListener 删除传入的 callback 时可以被删除掉 wrap.realCallback = callback; // 调用 on 添加事件监听 this.on(type, wrap, flag);&#125; 想让事件只执行一次，需要在执行 callback 之后就立即在数组中移除这个函数，由于是同步执行，直接操作 callback 是很难实现的，添加事件其实就是添加 callback 到 _events 对应类型的数组中，我们在使用 once 的时候将 callback 包一层函数名为 wrap，将这个外层函数存入数组，wrap 的内部逻辑就是真正 callback 的调用和移除 wrap，这里涉及到事件监听的移除方法 removeListener 在后面来详细说明。 once 的第三个参数是为了 prependOnceListener 服务的，prependOnceListener 与 prependListener 实现方式类似，不同的是 prependOnceListener 是基于 once 实现的。 prependOnceListener 方法的实现： prependOnceListener 方法12345// 添加事件监听，从数组的前面追加，只执行一次EventEmitter.prototype.prependOnceListener = function(type, callback) &#123; // 第三个参数为 true 表示从 _events 对应事件类型的数组前面添加 callback this.once(type, callback, true);&#125; 移除事件监听移除事件监听有两个方法，分别是 removeListener 和 removeAllListeners，前者的作用是移除某个类型数组中的某个回调函数，后者的作用是移除某个类型数组的所有成员，如果类型参数为空，则清空整个 _events。 removeListener 方法的实现： removeListener 方法123456789// 移除事件执行程序EventEmitter.prototype.removeListener = function(type, callback) &#123; if (this._events[type]) &#123; // 过滤掉当前传入的要移除的 callback this._events[type] = this._events[type].filter(fn =&gt; &#123; return fn !== callback &amp;&amp; fn !== callback.realCallback; &#125;); &#125;&#125; 由于 once 中在真正的 callback 包了一层 wrap, 只有在触发事件时才能执行 wrap 并执行 removeListener 删掉函数，如果在事件触发之前使用 removeListener 删除，传入的是真正的回调 callback，无法删除，所以在 once 方法中对真正的 callback 进行了存储，在 removeListener 中调用 filter 时的返回条件的逻辑中做了处理。 removeAllListeners 方法的实现： removeAllListeners 方法123456789// 移除全部事件执行程序EventEmitter.prototype.removeAllListeners = function(type) &#123; // 存在 type 清空 _events 对应的数组，否则直接清空 _events if (type) &#123; this._events[type] = []; &#125; else &#123; this._events = Object.create(null); &#125;&#125; 触发事件监听执行事件就比较简单了，取出 _events 中对应类型的数组进行循环，执行内部的每一个函数，第一个参数为 type，后面参数会作为数组中函数执行传入的参数。 emit 方法1234567// 触发事件EventEmitter.prototype.emit = function(type, ...args) &#123; if (this._events[type]) &#123; // 循环执行函数，并将 this 指回 EventEmitter 实例 this._events[type].forEach(fn =&gt; fn.call(this, ...args)); &#125;&#125; 获取事件类型名称集合eventNames 方法1234// 获取监听的所有事件类型EventEmitter.prototype.eventNames = function() &#123; return Object.keys(this._events);&#125; 按事件类型获取执行程序的集合listeners 方法1234// 获取事件类型对应的数组EventEmitter.prototype.listeners = function(type) &#123; return this._events[type];&#125; EventEmitter 的基本使用EventEmitter 的核心逻辑已经实现，由于上面大多数方法需要组合使用，所以在没有一一验证，下面让我们通过一些案例来了解 EventEmitter 的用法。 我们在这里引入自己自定义的 events 模块，并使用 util 模块的 inherits 继承 EventEmitter，下面是前置代码，后面将不在重复。 文件：events-demo.js1234567891011// 引入依赖const EventEmitter = require('./events');const util = require('util');function Girl() &#123;&#125;// 使 Girl 继承 EventEmitterutil.inherits(Girl, EventEmitter);// 创建 Girl 的实例const girl = new Girl(); 案例 1：设置和获取同类型事件的最大监听个数 文件：events-demo.js123456// 获取事件最大监听个数console.log(girl.getMaxListeners()); // 10// 设置事件最大监听个数girl.setMaxListeners(2);console.log(girl.getMaxListeners()); // 2 案例 2：使用 on 添加事件并执行 文件：events-demo.js1234567girl.on('失恋', () =&gt; console.log('哭了'));girl.on('失恋', () =&gt; console.log('喝酒'));girl.emit('失恋');// 哭了// 喝酒 案例 3：使用 prependListener 添加事件并执行 文件：events-demo.js1234567girl.on('失恋', () =&gt; console.log('哭了'));girl.prependListener('失恋', () =&gt; console.log('喝酒'));girl.emit('失恋');// 喝酒// 哭了 案例 4：添加 newListener 类型的事件 文件：events-demo.js1234567girl.on('newListener', (type) =&gt; console.log(type));girl.on('失恋', () =&gt; console.log('哭了'));girl.on('和好', () =&gt; console.log('开心'));// 失恋// 和好 案例 5：添加同类型事件超出最大个数并执行事件 文件：events-demo.js12345678910111213// 设置事件最大监听个数girl.setMaxListeners(2);girl.on('失恋', () =&gt; console.log('哭了'));girl.on('失恋', () =&gt; console.log('喝酒'));girl.on('失恋', () =&gt; console.log('吸烟'));girl.emit('失恋');// MaxListenersExceededWarning: 3 失恋 listeners added// 哭了// 喝酒// 吸烟 案例 6：对比 on 和 once 文件：events-demo.js123456789girl.on('失恋', () =&gt; console.log('哭了'));girl.once('失恋', () =&gt; console.log('喝酒'));girl.emit('失恋');girl.emit('失恋');// 哭了// 喝酒// 哭了 案例 7：移除 on 和 once 添加的事件监听 文件：events-demo.js1234567891011const cry = () =&gt; console.log('哭了');const drink = () =&gt; console.log('喝酒');girl.on('失恋', cry);girl.once('失恋', drink);girl.on('失恋', () =&gt; console.log('吸烟'));girl.removeListener('失恋', cry);girl.removeListener('失恋', drink);// 吸烟 案例 8：使用 prependOnceListener 添加事件监听 文件：events-demo.js123456789girl.on('失恋', () =&gt; console.log('哭了'));girl.prependOnceListener('失恋', () =&gt; console.log('喝酒'));girl.emit('失恋');girl.emit('失恋');// 喝酒// 哭了// 哭了 案例 9：获取某个事件类型执行程序的集合 文件：events-demo.js12345678910const cry = () =&gt; console.log('哭了');const drink = () =&gt; console.log('喝酒');girl.on('失恋', cry);girl.once('失恋', drink);girl.once('失恋', () =&gt; console.log('吸烟'));console.log(girl.listeners('失恋'));// [ [Function: cry], [Function: drink], [Function] ] 案例 10：获取所有事件类型名称 文件：events-demo.js123456girl.on('失恋', () =&gt; console.log('哭了'));girl.on('和好', () =&gt; console.log('开心'));console.log(girl.eventNames());// [ '失恋', '和好' ] 案例 11：使用 removeAllListeners 按类型移除事件监听 文件：events-demo.js12345678910girl.on('失恋', () =&gt; console.log('哭了'));girl.on('失恋', () =&gt; console.log('喝酒'));girl.on('和好', () =&gt; console.log('开心'));// 移除 “失恋” 类型事件监听girl.removeAllListeners('失恋');console.log(girl.listeners('失恋'));// [] 案例 12：使用 removeAllListeners 移除全部事件监听 文件：events-demo.js12345678910girl.on('失恋', () =&gt; console.log('哭了'));girl.on('失恋', () =&gt; console.log('喝酒'));girl.on('和好', () =&gt; console.log('开心'));// 移除全部事件监听girl.removeAllListeners();console.log(girl._events);// &#123;&#125; EventEmitter 总结events 模块在 NodeJS 中的使用率非常高，很多其他模块的事件执行机制都是通过继承该模块的 EventEmitter 类来实现的，比如 ReadStream（可读流）、WriteStream（可写流）、net（tcp）和 http 等等，我们也可以通过上面案例的方式创建自己的类去继承 EventEmitter 来实现事件的管理。","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"EventEmitter","slug":"EventEmitter","permalink":"https://www.pandashen.com/tags/EventEmitter/"}]},{"title":"CommonJS 模块化简易实现","date":"2018-06-26T06:28:25.000Z","path":"2018/06/26/20180626142825/","text":"CommonJS 概述CommonJS 是一种模块化的标准，而 NodeJS 是这种标准的实现，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 NodeJS 模块化的简易实现在实现模块加载之前，我们需要清除模块的加载过程： 假设 A 文件夹下有一个 a.js，我们要解析出一个绝对路径来； 我们写的路径可能没有后缀名 .js、.json； 得到一个真实的加载路径（模块会被缓存）先去缓存中看一下这个文件是否存在，如果存在返回缓存 没有则创建一个模块； 得到对应文件的内容，加一个闭包，把内容塞进去，之后执行即可。 提前加载需要用到的模块因为我们只是实现 CommonJS 的模块加载方法，并不会去实现整个 Node，在这里我们需要依赖一些 Node 的模块，所以我们就 “不要脸” 的使用 Node 自带的 require 方法把模块加载进来。 依赖模块12345678// 操作文件的模块const fs = require('fs');// 处理路径的模块const path = require('path');// 虚拟机，帮我们创建一个黑箱执行代码，防止变量污染const vm = require('vm'); 创建 Module 构造函数其实 CommonJS 中引入的每一个模块我们都需要通过 Module 构造函数创建一个实例。 创建 Module 构造函数12345678/** @param &#123;String&#125; p*/function Module(p) &#123; this.id = p; // 当前文件的表示（绝对路径） this.exports = &#123;&#125;; // 每个模块都有一个 exports 属性，用来存储模块的内容 this.loaded = false; // 标记是否被加载过&#125; 定义静态属性存储我们需要使用的一些值Module 静态变量1234567891011121314// 函数后面需要使用的闭包的字符串Module.wrapper = [ '(function(exports, require, module, __dirname, __filename) &#123;', '\\n&#125;)'];// 根据绝对路径进行缓存的模块的对象Module._cacheModule = &#123;&#125;;// 处理不同文件后缀名的方法Module._extensions = &#123; '.js': function() &#123;&#125;, '.json': function() &#123;&#125;&#125;; 创建引入模块的 req 方法为了防止和 Node 自带的 require 方法重名，我们将模拟的方法重命名为 req。 引入模块方法 req12345678910/** @param &#123;String&#125; moduleId*/function req(moduleId) &#123; // 将 req 传入的参数处理成绝对路径 let p = Module._resolveFileName(moduleId); // 生成一个新的模块 let module = new Module(p);&#125; 在上面代码中，我们先把传入的参数通过 Module._resolveFileName 处理成了一个绝对路径，并创建模块实例把绝对路径作为参数传入，我们现在实现一下 Module._resolveFileName 方法。 返回文件绝对路径 Module._resolveFileName 方法的实现这个方法的功能就是将 req 方法的参数根据是否有后缀名两种方式处理成带后缀名的文件绝对路径，如果 req 的参数没有后缀名，会去按照 Module._extensions 的键的后缀名顺序进行查找文件，直到找到后缀名对应文件的绝对路径，优先 .js，然后是 .json，这里我们只实现这两种文件类型的处理。 处理绝对路径 _resolveFileName 方法12345678910111213141516171819202122232425262728293031323334/** @param &#123;String&#125; moduleId*/Module._resolveFileName = function(moduleId) &#123; // 将参数拼接成绝对路径 let p = path.resolve(moduleId); // 判断是否含有后缀名 if (!/\\.\\w+$/.test(p)) &#123; // 创建规范规定查找文件后缀名顺序的数组 .js .json let arr = Object.keys(Module._extensions); // 循环查找 for (let i = 0; i &lt; arr.length; i++) &#123; // 将绝对路径与后缀名进行拼接 let file = p + arr[i]; // 查找不到文件时捕获异常 try &#123; // 并通过 fs 模块同步查找文件的方法对改路径进行查找 // 文件未找到会直接进入 catch 语句 fs.accessSync(file); // 如果找到文件将该文件绝对路径返回 return file; &#125; catch (e) &#123; // 当后缀名循环完毕都没有找到对应文件时，抛出异常 if (i &gt;= arr.length) throw new Error('not found module'); &#125; &#125; &#125; else &#123; // 有后缀名直接返回该绝对路径 return p; &#125;&#125;; 加载模块的 load 方法完善 req 方法123456789101112131415161718192021/** @param &#123;String&#125; moduleId*/function req(moduleId) &#123; // 将 req 传入的参数处理成绝对路径 let p = Module._resolveFileName(moduleId); // 生成一个新的模块 let module = new Module(p); // ********** 下面为新增代码 ********** // 加载模块 let content = module.load(p); // 将加载后返回的内容赋值给模块实例的 exports 属性上 module.exports = content; // 最后返回 模块实例的 exports 属性，即加载模块的内容 return module.exports; // ********** 上面为新增代码 **********&#125; 上面代码实现了一个实例方法 load，传入文件的绝对路径，为模块加载文件的内容，在加载后将值存入模块实例的 exports 属性上最后返回，其实 req 函数返回的就是模块加载回来的内容。 load 方法1234567891011// 模块加载的方法Module.prototype.load = function(filepath) &#123; // 判断加载的文件是什么后缀名 let ext = path.extname(filepath); // 根据不同的后缀名处理文件内容，参数是当前实例 let content = Moudule._extensions[ext](this); // 将处理后的结果返回 return content;&#125;; 实现加载 .js 文件和 .json 文件的方法还记得前面准备的静态属性中有 Module._extensions 就是用来存储这两个方法的，下面我们来完善这两个方法。 处理后缀名方法的 _extensions 对象123456789101112131415161718192021222324Module._extensions = &#123; '.js': function(module) &#123; // 读取 js 文件，返回文件的内容 let script = fs.readFileSync(module.id, 'utf8'); // 给 js 文件的内容增加一个闭包环境 let fn = Module.wrap(script); // 创建虚拟机，将我们创建的 js 函数执行，将 this 指向模块实例的 exports 属性 vm.runInThisContext(fn).call( module.exports, module.exports, req, module ); // 返回模块实例上的 exports 属性（即模块的内容） return module.exports; &#125;, '.json': function(module) &#123; // .json 文件的处理相对简单，将读出的字符串转换成对象即可 return JSON.parse(fs.readFileSync(module.id, 'utf8')); &#125;&#125;; 我们这里使用了 Module.wrap 方法，代码如下，其实帮助我们加了一个闭包环境（即套了一层函数并传入了我们需要的参数），里面所有的变量都是私有的。 创建闭包 wrap 方法123Module.wrap = function(content) &#123; return Module.wrapper[0] + content + Module.wrapper[1];&#125;; Module.wrapper 的两个值其实就是我们需要在外层包了一个函数的前半段和后半段。 这里我们要划重点了，非常重要：1、我们在虚拟机中执行构建的闭包函数时利用执行上/下文 call 将 this 指向了模块实例的 exports 属性上，所以这也是为什么我们用 Node 启动一个 js 文件，打印 this 时，不是全局对象 global，而是一个空对象，这个空对象就是我们的 module.exports，即当前模块实例的 exports 属性。2、还是第一条的函数执行，我们传入的第一个参数是改变 this 指向，那第二个参数是 module.exports，所以在每个模块导出的时候，使用 module.exports = xxx，其实直接替换了模块实例的值，即直接把模块的内容存放在了模块实例的 exports 属性上，而 req 最后返回的就是我们模块导出的内容。3、第三个参数之所以传入 req 是因为我们还可能在一个模块中导入其他模块，而 req 会返回其他模块的导出在当前模块使用，这样整个 CommonJS 的规则就这样建立起来了。 对加载过的模块进行缓存我们现在的程序是有问题的，当重复加载了一个已经加载过得模块，当执行 req 方法的时候会发现，又创建了一个新的模块实例，这是不合理的，所以我们下面来实现一下缓存机制。 还记得之前的一个静态属性 Module._cacheModule，它的值是一个空对象，我们会把所有加载过的模块的实例存储到这个对象上。 完善 req 方法（处理缓存）1234567891011121314151617181920212223242526272829303132333435/** @param &#123;String&#125; moduleId*/function req(moduleId) &#123; // 将 req 传入的参数处理成绝对路径 let p = Module._resolveFileName(moduleId); // ********** 下面为新增代码 ********** // 判断是否已经加载过 if (Module._cacheModule[p]) &#123; // 模块存在，如果有直接把 exports 对象返回即可 return Module._cacheModule[p].exprots; &#125; // ********** 上面为新增代码 ********** // 生成一个新的模块 let module = new Module(p); // 加载模块 let content = module.load(p); // ********** 下面为新增代码 ********** // 存储时是拿模块的绝对路径作为键与模块内容相对应的 Module._cacheModule[p] = module; // 是否缓存表示改为 true module.loaded = true; // ********** 上面为新增代码 ********** // 将加载后返回的内容赋值给模块实例的 exports 属性上 module.exports = content; // 最后返回 模块实例的 exports 属性，即加载模块的内容 return module.exports;&#125; 试用 req 加载模块在同级目录下新建一个文件 a.js，使用 module.exports 随便导出一些内容，在我们实现模块加载的最下方尝试引入并打印内容。 导出自定义模块12// a.jsmodule.exports = 'Hello world'; 检测 req 方法12const a = req('./a');console.log(a); // Hello world CommonJS 模块查找规范其实我们只实现了 CommonJS 规范的一部分，即自定义模块的加载，其实在 CommonJS 的规范当中关于模块查找的规则还有很多，具体的我们就用下面的流程图来表示。 CommonJS 模块加载流程图 这篇文章让我们了解了 CommonJS 是什么，主要目的在于理解 Node 模块化的实现思路，想要更深入的了解 CommonJS 的实现细节，建议看一看 NodeJS 源码对应的部分，如果觉得源码比较多，不容易找到模块化实现的代码，也可以在 VSCode 中通过调用 require 方法引入模块时，打断点调试，一步一步的跟进到 Node 源码中查看。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"CommonJS","slug":"CommonJS","permalink":"https://www.pandashen.com/tags/CommonJS/"}]},{"title":"高阶函数应用 —— 柯里化与反柯里化","date":"2018-06-23T00:40:25.000Z","path":"2018/06/23/20180623084025/","text":"前言在 JavaScript 中，柯里化和反柯里化是高阶函数的一种应用，在这之前我们应该清楚什么是高阶函数，通俗的说，函数可以作为参数传递到函数中，这个作为参数的函数叫回调函数，而拥有这个参数的函数就是高阶函数，回调函数在高阶函数中调用并传递相应的参数，在高阶函数执行时，由于回调函数的内部逻辑不同，高阶函数的执行结果也不同，非常灵活，也被叫做函数式编程。 柯里化在 JavaScript 中，函数柯里化是函数式编程的重要思想，也是高阶函数中一个重要的应用，其含义是给函数分步传递参数，每次传递部分参数，并返回一个更具体的函数接收剩下的参数，这中间可嵌套多层这样的接收部分参数的函数，直至返回最后结果。 最基本的柯里化拆分柯里化拆分12345678910111213141516171819// 原函数function add(a, b, c) &#123; return a + b + c;&#125;// 柯里化函数function addCurrying(a) &#123; return function(b) &#123; return function(c) &#123; return a + b + c; &#125; &#125;&#125;// 调用原函数add(1, 2, 3); // 6// 调用柯里化函数addCurrying(1)(2)(3) // 6 被柯里化的函数 addCurrying 每次的返回值都为一个函数，并使用下一个参数作为形参，直到三个参数都被传入后，返回的最后一个函数内部执行求和操作，其实是充分的利用了闭包的特性来实现的。 柯里化通用式上面的柯里化函数没涉及到高阶函数，也不具备通用性，无法转换形参个数任意或未知的函数，我们接下来封装一个通用的柯里化转换函数，可以将任意函数转换成柯里化。 柯里化通用式 ES512345678910111213141516171819202122function currying(func, args) &#123; // 形参个数 var arity = func.length; // 上一次传入的参数 var args = args || []; return function() &#123; // 将参数转化为数组 var _args = [].slice.call(arguments); // 将上次的参数与当前参数进行组合并修正传参顺序 Array.prototype.unshift.apply(_args, args); // 如果参数不够，返回闭包函数继续收集参数 if (_args.length &lt; arity) &#123; return currying.call(null, func, _args); &#125; // 参数够了则直接执行被转化的函数 return func.apply(null, _args); &#125;&#125; 上面主要使用的是 ES5 的语法来实现，大量的使用了 call 和 apply，下面我们通过 ES6 的方式实现功能完全相同的柯里化转换通用式。 柯里化通用式 ES612345678910111213function currying(func, args = []) &#123; let arity = func.length; return function(..._args) &#123; _args.unshift(...args); if (_args.length &lt; arity) &#123; return currying(func, _args); &#125; return func(..._args); &#125;&#125; 函数 currying 算是比较高级的转换柯里化的通用式，可以随意拆分参数，假设一个被转换的函数有多个形参，我们可以在任意环节传入任意个数的参数进行拆分，举一个例子，假如 5 个参数，第一次可以传入 2 个，第二次可以传入 1 个, 第三次可以传入剩下的，也有其他的多种传参和拆分方案，因为在 currying 内部收集参数的同时按照被转换函数的形参顺序进行了更正。 柯里化的一个很大的好处是可以帮助我们基于一个被转换函数，通过对参数的拆分实现不同功能的函数，如下面的例子。 柯里化通用式应用 —— 普通函数1234567891011// 被转换函数，用于检测传入的字符串是否符合正则表达式function checkFun(reg, str) &#123; return reg.test(str);&#125;// 转换柯里化const check = currying(checkFun);// 产生新的功能函数const checkPhone = check(/^1[34578]\\d&#123;9&#125;$/);const checkEmail = check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/); 上面的例子根据一个被转换的函数通过转换变成柯里化函数，并用 check 变量接收，以后每次调用 check 传递不同的正则就会产生一个检测不同类型字符串的功能函数。 这种使用方式同样适用于被转换函数是高阶函数的情况，比如下面的例子。 柯里化通用式应用 —— 高阶函数1234567891011121314151617181920// 被转换函数，按照传入的回调函数对传入的数组进行映射function mapFun(func, array) &#123; return array.map(func);&#125;// 转换柯里化const getNewArray = currying(mapFun);// 产生新的功能函数const createPercentArr = getNewArray(item =&gt; `$&#123;item * 100&#125;%`);const createDoubleArr = getNewArray(item =&gt; item * 2);// 使用新的功能函数let arr = [1, 2, 3, 4, 5];let percentArr = createPercentArr(arr);// ['100%', '200%', '300%', '400%', '500%',]let doubleArr = createDoubleArr(arr);// [2, 4, 6, 8, 10] 3、柯里化与 bindbind 方法是经常使用的一个方法，它的作用是帮我们将调用 bind 函数内部的上下文对象 this 替换成我们传递的第一个参数，并将后面其他的参数作为调用 bind 函数的参数。 bind 方法原理模拟123456789// bind 方法的模拟Function.prototype.bind = function(context) &#123; var self = this; var args = [].slice.call(arguments, 1); return function() &#123; return self.apply(context, args); &#125;&#125; 通过上面代码可以看出，其实 bind 方法就是一个柯里化转换函数，将调用 bind 方法的函数进行转换，即通过闭包返回一个柯里化函数，执行该柯里化函数的时候，借用 apply 将调用 bind 的函数的执行上下文转换成了 context 并执行，只是这个转换函数没有那么复杂，没有进行参数拆分，而是函数在调用的时候传入了所有的参数。 反柯里化反柯里化的思想与柯里化正好相反，如果说柯里化的过程是将函数拆分成功能更具体化的函数，那反柯里化的作用则在于扩大函数的适用性，使本来作为特定对象所拥有的功能函数可以被任意对象所使用。 反柯里化通用式反柯里化通用式的参数为一个希望可以被其他对象调用的方法或函数，通过调用通用式返回一个函数，这个函数的第一个参数为要执行方法的对象，后面的参数为执行这个方法时需要传递的参数。 反柯里化通用式 ES51234567function uncurring(fn) &#123; return function() &#123; // 取出要执行 fn 方法的对象，同时从 arguments 中删除 var obj = [].shift.call(arguments); return fn.apply(obj, arguments); &#125;&#125; 反柯里化通用式 ES612345function uncurring(fn) &#123; return function(...args) &#123; return fn.call(...args); &#125;&#125; 下面我们通过一个例子来感受一下反柯里化的应用。 反柯里化通用式应用12345678910111213141516171819// 构造函数 Ffunction F() &#123;&#125;// 拼接属性值的方法F.prototype.concatProps = function() &#123; let args = Array.from(arguments); return args.reduce((prev, next) =&gt; `$&#123;this[prev]&#125;&amp;$&#123;this[next]&#125;`);&#125;// 使用 concatProps 的对象const obj = &#123; name: 'Panda', age: 16&#125;;// 使用反柯里化进行转化const concatProps = uncurring(F.prototype.concatProps);concatProps(obj, 'name', 'age'); // Panda&amp;16 反柯里化还有另外一个应用，用来代替直接使用 call 和 apply，比如检测数据类型的 Object.prototype.toString 等方法，以往我们使用时是在这个方法后面直接调用 call 更改上下文并传参，如果项目中多处需要对不同的数据类型进行验证是很麻的，常规的解决方案是封装成一个检测数据类型的模块。 检测数据类型常规方案123function checkType(val) &#123; return Object.prototype.toString.call(val);&#125; 如果需要这样封装的功能很多就麻烦了，代码量也会随之增大，其实我们也可以使用另一种解决方案，就是利用反柯里化通用式将这个函数转换并将返回的函数用变量接收，这样我们只需要封装一个 uncurring 通用式就可以了。 反柯里化创建检测类型函数12345const checkType = uncurring(Object.prototype.toString);checkType(1); // [object Number]checkType('hello'); // [object String]checkType(true); // [object Boolean] 通过函数调用生成反柯里化函数在 JavaScript 我们经常使用面向对象的编程方式，在两个类或构造函数之间建立联系实现继承，如果我们对继承的需求仅仅是希望一个构造函数的实例能够使用另一个构造函数原型上的方法，那进行繁琐的继承很浪费，简单的继承父子类的关系又不那么的优雅，还不如之间不存在联系。 将反柯里化方法扩展到函数原型123456Function.prototype.uncurring = function() &#123; var self = this; return function() &#123; return Function.prototype.call.apply(self, arguments); &#125;&#125; 之前的问题通过上面给函数扩展的 uncurring 方法完全得到了解决，比如下面的例子。 函数应用反柯里化原型方法1234567891011// 构造函数function F() &#123;&#125;F.prototype.sayHi = function() &#123; return \"I'm \" + this.name + \", \" + this.age + \" years old.\";&#125;// 希望 sayHi 方法被任何对象使用sayHi = F.prototype.sayHi.uncurring();sayHi(&#123; name: 'Panda', age: 20&#125;); // I'm Panda, 20 years old. 在 Function 的原型对象上扩展的 uncurring 中，难点是理解 Function.prototype.call.apply，我们知道在 call 的源码逻辑中 this 指的是调用它的函数，在 call 内部用第一个参数替换了这个函数中的 this，其余作为形参执行了函数。 而在 Function.prototype.call.apply 中 apply 的第一个参数更换了 call 中的 this，这个用于更换 this 的就是例子中调用 uncurring 的方法 F.prototype.sayHi，所以等同于 F.prototype.sayHi.call，arguments 内的参数会传入 call 中，而 arguments 的第一项正是用于修改 F.prototype.sayHi 中 this 的对象。 总结看到这里你应该对柯里化和反柯里化有了一个初步的认识了，但要熟练的运用在开发中，还需要我们更深入的去了解它们内在的含义。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"高阶函数","slug":"高阶函数","permalink":"https://www.pandashen.com/tags/高阶函数/"},{"name":"柯里化","slug":"柯里化","permalink":"https://www.pandashen.com/tags/柯里化/"}]},{"title":"Canvas + WebSocket + Redis 实现一个视频弹幕","date":"2018-06-21T03:30:25.000Z","path":"2018/06/21/20180621113025/","text":"页面布局首先，我们需要实现页面布局，在根目录创建 index.html 布局中我们需要有一个 video 多媒体标签引入我们的本地视频，添加输入弹幕的输入框、确认发送的按钮、颜色选择器、字体大小滑动条，创建一个 style.css 来调整页面布局的样式，这里我们顺便创建一个 index.js 文件用于后续实现我们的核心逻辑，先引入到页面当中。 HTML 布局代码如下： 文件：index.html1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;title&gt;视频弹幕&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"cantainer\"&gt; &lt;h2&gt;Canvas + WebSocket + Redis 实现视频弹幕&lt;/h2&gt; &lt;div id=\"content\"&gt; &lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt; &lt;video id=\"video\" src=\"./barrage.mp4\" controls&gt;&lt;/video&gt; &lt;/div&gt; &lt;!-- 输入弹幕内容 --&gt; &lt;input type=\"text\" id=\"text\"&gt; &lt;!-- 添加弹幕按钮 --&gt; &lt;button id=\"add\"&gt;发送&lt;/button&gt; &lt;!-- 选择文字颜色 --&gt; &lt;input type=\"color\" id=\"color\"&gt; &lt;!-- 调整字体大小 --&gt; &lt;input type=\"range\" max=\"40\" min=\"20\" id=\"range\"&gt; &lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS 样式代码如下： 文件：style.css123456789101112131415161718#cantainer &#123; text-align: center;&#125;#content &#123; width: 640px; margin: 0 auto; position: relative;&#125;#canvas &#123; position: absolute;&#125;video &#123; width: 640px; height: 360px;&#125;input &#123; vertical-align: middle;&#125; 布局效果如下图： 弹幕布局 定义接口，构造假数据我们弹幕中的弹幕数据正常情况下应该是通过与后台数据交互请求回来，所以我们需要先定义数据接口，并构造假数据来实现前端逻辑。 数据字段定义： value：表示弹幕的内容（必填） time：表示弹幕出现的时间（必填） speed：表示弹幕移动的速度（选填） color：表示弹幕文字的颜色（选填） fontSize：表示弹幕的字体大小（选填） opacity：表示弹幕文字的透明度（选填） 上面的 value 和 time 是必填参数，其他的选填参数可以在前端设置默认值。 前端定义的假数据如下： 文件：index.js12345678910111213const data = [ &#123; value: '这是第一条弹幕', speed: 2, time: 0, color: 'red', fontSize: 20 &#125;, &#123; value: '这是第二条弹幕', time: 1 &#125;]; 实现前端弹幕的逻辑我们希望是把弹幕封装成一个功能，只要有需要的地方就可以使用，从而实现复用，那么不同的地方使用这个功能通常的方式是 new 一个实例，传入当前使用该功能对应的参数，我们也使用这种方式来实现，所以我们需要封装一个统一的构造函数或者类，参数为当前的 canvas 元素、video 元素和一个 options 对象，options 里面的 data 属性为我们的弹幕数据，之所以不直接传入 data 是为了后续参数的扩展，严格遵循开放封闭原则，这里我们就统一使用 ES6 的 class 类来实现。 创建弹幕功能的类及基本参数处理布局时需要注意 Canvas 的默认宽为 300px，高为 150px，我们要保证 Canvas 完全覆盖整个视频，需要让 Canvas 与 video 宽高相等。因为我们不确定每一个使用该功能的视频的宽高都是一样的，所以 Canvas 画布的宽高并没有通过 CSS 来设置，而是通过 JS 在类创建实例初始化属性的时候动态设置。 文件：index.js123456789101112131415161718192021222324252627class CanvasBarrage &#123; constructor(canvas, video, options = &#123;&#125;) &#123; // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = &#123; fontSize: 20, color: 'gold', speed: 2, opacity: 0.3, data: [] &#125;; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); &#125;&#125; 应该挂在实例上的属性除了有当前的 canvas 元素、video 元素、弹幕数据的默认选项以及弹幕数据之外，还应该有一个代表当前是否渲染弹幕的参数，因为视频暂停的时候，弹幕也是暂停的，所以没有重新渲染，因为是否暂停与弹幕是否渲染的状态是一致的，所以我们这里就用 isPaused 参数来代表当前是否暂停或重新渲染弹幕，值类型为布尔值。 创建构造每一条弹幕的类我们知道，后台返回给我们的弹幕数据是一个数组，这个数组里的每一个弹幕都是一个对象，而对象上有着这条弹幕的信息，如果我们需要在每一个弹幕对象上再加一些新的信息或者在每一个弹幕对象的处理时用到了当前弹幕功能类 CanvasBarrage 实例的一些属性值，取值显然是不太方便的，这样为了后续方便扩展，遵循开放封闭原则，我们把每一个弹幕的对象转变成同一个类的实例，所以我们创建一个名为 Barrage 的类，让我们每一条弹幕的对象进入这个类里面走一遭，挂上一些扩展的属性。 文件：index.js12345678class Barrage &#123; constructor(item, ctx) &#123; this.value = item.value; // 弹幕的内容 this.time = item.time; // 弹幕出现的时间 this.item = item; // 每一个弹幕的数据对象 this.ctx = ctx; // 弹幕功能类的执行上下文 &#125;&#125; 在我们的 CanvasBarrage 类上有一个存储弹幕数据的数组 data，此时我们需要给 CanvasBarrage 增加一个属性用来存放 “加工” 后的每条弹幕对应的实例。 文件：index.js1234567891011121314151617181920212223242526272829303132class CanvasBarrage &#123; constructor(canvas, video, options = &#123;&#125;) &#123; // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = &#123; fontSize: 20, color: 'gold', speed: 2, opacity: 0.3, data: [] &#125;; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // ********** 以下为新增代码 ********** // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // ********** 以上为新增代码 ********** &#125;&#125; 其实通过上面操作以后，我们相当于把 data 里面的每一条弹幕对象转换成了一个 Barrage 类的一个实例，把当前的上下文 this 传入后可以随时在每一个弹幕实例上获取 CanvasBarrage 类实例的属性，也方便我们后续扩展方法，遵循这种开放封闭原则的方式开发，意义是不言而喻的。 在 CanvasBarrage 类实现渲染所有弹幕的 render 方法CanvasBarrage 的 render 方法是在创建弹幕功能实例的时候应该渲染 Canvas 所以应该在 CanvasBarrage 中调用，在 render 内部，每一次渲染之前都应该先将 Canvas 画布清空，所以需要给当前的 CanvasBarrage 类新增一个属性用于存储 Canvas 画布的内容。 文件：index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class CanvasBarrage &#123; constructor(canvas, video, options = &#123;&#125;) &#123; // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = &#123; fontSize: 20, color: 'gold', speed: 2, opacity: 0.3, data: [] &#125;; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // ********** 以下为新增代码 ********** // Canvas 画布的内容 this.context = canvas.getContext(\"2d\"); // 渲染所有的弹幕 this.render(); // ********** 以上为新增代码 ********** &#125; // ********** 以下为新增代码 ********** render() &#123; // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) &#123; // 递归渲染 requestAnimationFrame(this.render.bind(this)); &#125; &#125; // ********** 以上为新增代码 **********&#125; 在上面的 CanvasBarrage 的 render 函数中，清空时由于 Canvas 性能比较好，所以将整个画布清空，所以从坐标 (0, 0) 点，清空的宽高为整个 Canvas 画布的宽高。 只要视频是在播放状态应该不断的调用 render 方法实现清空画布、渲染弹幕、判断是否暂停，如果非暂停状态继续渲染，所以我们用到了递归调用 render 去不断的实现渲染，但是递归时如果直接调用 render，性能特别差，程序甚至会挂掉，以往这种情况我们会在递归外层加一个 setTimeout 来定义一个短暂的递归时间，但是这个过程类似于动画效果，如果使用 setTimeout 其实是将同步代码转成了异步执行，会增加不确定性导致画面出现卡顿的现象。 这里我们使用 H5 的新 API requestAnimationFrame，可以在平均 1/60 S 内帮我执行一次该方法传入的回调，我们直接把 render 函数作为回调函数传入 requestAnimationFrame，该方法是按照帧的方式执行，动画流畅，需要注意的是，render 函数内使用了 this，所以应该处理一下 this 指向问题。 由于我们使用面向对象的方式，所以渲染弹幕的具体细节，我们抽离出一个单独的方法 renderBarrage，接下来看一下 renderBarrage 的实现。 CanvasBarrage 类 render 内部 renderBarrage 的实现文件：index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class CanvasBarrage &#123; constructor(canvas, video, options = &#123;&#125;) &#123; // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = &#123; fontSize: 20, color: 'gold', speed: 2, opacity: 0.3, data: [] &#125;; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // Canvas 画布的内容 this.context = canvas.getContext('2d'); // 渲染所有的弹幕 this.render(); &#125; render() &#123; // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) &#123; // 递归渲染 requestAnimationFrame(this.render.bind(this)); &#125; &#125; // ********** 以下为新增代码 ********** renderBarrage() &#123; // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕 let time = this.video.currentTime; this.barrages.forEach(barrage =&gt; &#123; // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位） if (time &gt;= barrage.time) &#123; // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化 // 节省性能，初始化后再进行绘制 // 如果没有初始化，先去初始化一下 if (!barrage.isInited) &#123; // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited barrage.init(); barrage.isInited = true; &#125; &#125; &#125;); &#125; // ********** 以上为新增代码 **********&#125; 此处的 renderBarrage 方法内部主要对每一条弹幕实例所设置的出现时间和视频的播放时间做对比，如果视频的播放时间大于等于了弹幕出现的时间，说明弹幕需要绘制在 Canvas 画布内。 之前我们的每一条弹幕实例的属性可能不全，弹幕的其他未传参数并没有初始化，所以为了最大限度的节省性能，我们在弹幕该第一次绘制的时候去初始化参数，等到视频播放的时间变化再去重新绘制时，不再初始化参数，所以初始化参数的方法放在了判断弹幕出现时间的条件里面执行，又设置了代表弹幕实例是不是初始化了的参数 isInited，初始化函数 init 执行过一次后，马上修改 isInited 的值，保证只初始化参数一次。 在 renderBarrage 方法中我们可以看出来，其实我们是循环了专门存放每一条弹幕实例（Barrage 类的实例）的数组，我们在内部用实例去调用的方法 init 应该是在 Barrage 类的原型上，下面我们去 Barrage 类上实现 init 的逻辑。 Barrage 类 init 的实现文件：index.js1234567891011121314151617181920212223242526272829303132333435363738394041424344class Barrage &#123; constructor(item, ctx) &#123; this.value = item.value; // 弹幕的内容 this.time = item.time; // 弹幕出现的时间 this.item = item; // 每一个弹幕的数据对象 this.ctx = ctx; // 弹幕功能类的执行上下文 &#125; // ********** 以下为新增代码 ********** init() &#123; this.opacity = this.item.opacity || this.ctx.opacity; this.color = this.item.color || this.ctx.color; this.fontSize = this.item.fontSize || this.ctx.fontSize; this.speed = this.item.speed || this.ctx.speed; // 求自己的宽度，目的是用来校验当前是否还要继续绘制（边界判断） let span = document.createElement('span'); // 能决定宽度的只有弹幕的内容和文字的大小，和字体 // 字体默认为微软雅黑，我们就不做设置了 span.innerText = this.value; span.style.font = this.fontSize + 'px \"Microsoft YaHei\"'; // span 为行内元素，取不到宽度，所以我们通过定位给转换成块级元素 span.style.position = 'absolute'; document.body.appendChild(span); // 放入页面 this.width = span.clientWidth; // 记录弹幕的宽度 document.body.removeChild(span); // 从页面移除 // 存储弹幕出现的横纵坐标 this.x = this.ctx.canvas.width; this.y = this.ctx.canvas.height; // 处理弹幕纵向溢出的边界处理 if (this.y &lt; this.fontSize) &#123; this.y = this.fontSize; &#125; if (this.y &gt; this.ctx.canvas.height - this.fontSize) &#123; this.y = this.ctx.canvas.height - this.fontSize; &#125; &#125; // ********** 以上为新增代码 **********&#125; 在上面代码的 init 方法中我们其实可以看出，每条弹幕实例初始化的时候初始的信息除了之前说的弹幕的基本参数外，还获取了每条弹幕的宽度（用于后续做弹幕是否已经完全移出屏幕的边界判断）和每一条弹幕的 x 和 y 轴方向的坐标并为了防止弹幕在 y 轴显示不全做了边界处理。 实现每条弹幕的渲染和弹幕移除屏幕的处理我们当时在 CanvasBarrage 类的 render 方法中的渲染每个弹幕的方法 renderBarrage中（原谅这么啰嗦，因为到现在内容已经比较多，说的具体一点方便知道是哪个步骤，哈哈）只做了对每一条弹幕实例的初始化操作，并没有渲染在 Canvas 画布中，这时我们主要做两部操作，实现每条弹幕渲染在画布中和左侧移出屏幕不再渲染的边界处理。 文件：index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class CanvasBarrage &#123; constructor(canvas, video, options = &#123;&#125;) &#123; // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = &#123; fontSize: 20, color: 'gold', speed: 2, opacity: 0.3, data: [] &#125;; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // Canvas 画布的内容 this.context = canvas.getContext('2d'); // 渲染所有的弹幕 this.render(); &#125; render() &#123; // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) &#123; // 递归渲染 requestAnimationFrame(this.render.bind(this)); &#125; &#125; renderBarrage() &#123; // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕 let time = this.video.currentTime; this.barrages.forEach(barrage =&gt; &#123; // ********** 以下为改动的代码 ********** // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位） if (!barrage.flag &amp;&amp; time &gt;= barrage.time) &#123; // ********** 以上为改动的代码 ********** // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化 // 节省性能，初始化后再进行绘制 // 如果没有初始化，先去初始化一下 if (!barrage.isInited) &#123; // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited barrage.init(); barrage.isInited = true; &#125; // ********** 以下为新增代码 ********** barrage.x -= barrage.speed; barrage.render(); // 渲染该条弹幕 if (barrage.x &lt; barrage.width * -1) &#123; barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作 &#125; // ********** 以上为新增代码 ********** &#125; &#125;); &#125;&#125; 每个弹幕实例都有一个 speed 属性，该属性代表着弹幕移动的速度，换个说法其实就是每次减少的 x 轴的差值，所以我们其实是通过改变 x 轴的值再重新渲染而实现弹幕的左移，我们创建了一个标识 flag 挂在每个弹幕实例下，代表是否已经离开屏幕，如果离开则更改 flag 的值，使外层的 CanvasBarrage 类的 render 函数再次递归时不进入渲染程序。 每一条弹幕具体是怎么渲染的，通过代码可以看出每个弹幕实例在 x 坐标改变后都调用了实例方法 render 函数，注意此 render 非彼 render，该 render 函数属于 Barrage 类，目的是为了渲染每一条弹幕，而 CanvasBarrage 类下的 render，是为了在视频时间变化时清空并重新渲染整个 Canvas 画布。 Barrage 类下的 render 方法的实现文件：index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Barrage &#123; constructor(item, ctx) &#123; this.value = item.value; // 弹幕的内容 this.time = item.time; // 弹幕出现的时间 this.item = item; // 每一个弹幕的数据对象 this.ctx = ctx; // 弹幕功能类的执行上下文 &#125; init() &#123; this.opacity = this.item.opacity || this.ctx.opacity; this.color = this.item.color || this.ctx.color; this.fontSize = this.item.fontSize || this.ctx.fontSize; this.speed = this.item.speed || this.ctx.speed; // 求自己的宽度，目的是用来校验当前是否还要继续绘制（边界判断） let span = document.createElement('span'); // 能决定宽度的只有弹幕的内容和文字的大小，和字体 // 字体默认为微软雅黑，我们就不做设置了 span.innerText = this.value; span.style.font = this.fontSize + 'px \"Microsoft YaHei'; // span 为行内元素，取不到宽度，所以我们通过定位给转换成块级元素 span.style.position = 'absolute'; document.body.appendChild(span); // 放入页面 this.width = span.clientWidth; // 记录弹幕的宽度 document.body.removeChild(span); // 从页面移除 // 存储弹幕出现的横纵坐标 this.x = this.ctx.canvas.width; this.y = this.ctx.canvas.height; // 处理弹幕纵向溢出的边界处理 if (this.y &lt; this.fontSize) &#123; this.y = this.fontSize; &#125; if (this.y &gt; this.ctx.canvas.height - this.fontSize) &#123; this.y = this.ctx.canvas.height - this.fontSize; &#125; &#125; // ********** 以下为新增代码 ********** render() &#123; this.ctx.context.font = this.fontSize + 'px \"Microsoft YaHei\"'; this.ctx.context.fillStyle = this.color; this.ctx.context.fillText(this.value, this.x, this.y); &#125; // ********** 以上为新增代码 **********&#125; 从上面新增代码我们可以看出，其实 Barrage 类的 render 方法只是将每一条弹幕的字号、颜色、内容、坐标等属性通过 Canvas 的 API 添加到了画布上。 实现播放、暂停事件还记得我们的 CanvasBarrage 类里面有一个属性 isPaused，属性值控制了我们是否递归渲染，这个属性与视频暂停的状态是一致的，我们在播放的时候，弹幕不断的清空并重新绘制，当暂停的时候弹幕也应该跟着暂停，说白了就是不在调用 CanvasBarrage 类的 render 方法，其实就是在暂停、播放的过程中不断的改变 isPaused 的值即可。 还记得我们之前构造的两条假数据 data 吧，接下来我们添加播放、暂停事件，来尝试使用一下我们的弹幕功能。 文件：index.js123456789101112131415161718192021// 实现一个简易选择器，方便获取元素，后面获取元素直接调用 $const $ = document.querySelector.bind(document);// 获取 Canvas 元素和 Video 元素const canvas = $('#canvas');const video = $('#video');const canvasBarrage = new CanvasBarrage(canvas, video, &#123; data&#125;);// 添加播放事件video.addEventListener('play', function() &#123; canvasBarrage.isPaused = false; canvasBarrage.render();&#125;);// 添加暂停事件video.addEventListener('pause', function() &#123; canvasBarrage.isPaused = true;&#125;); 实现发送弹幕事件文件：index.js12345678$('#add').addEventListener('click', function() &#123; let time = video.currentTime; // 发送弹幕的时间 let value = $('#text').value; // 发送弹幕的文字 let color = $('#color').value; // 发送弹幕文字的颜色 let fontSize = $('#range').value; // 发送弹幕的字体大小 let sendObj = &#123; time, value, color, fontSize &#125;; //发送弹幕的参数集合 canvasBarrage.add(sendObj); // 发送弹幕的方法&#125;); 其实我们发送弹幕时，就是向 CanvasBarrage 类的 barrages 数组里添加了一条弹幕的实例，我们单独封装了一个 add 的实例方法。 文件：index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class CanvasBarrage &#123; constructor(canvas, video, options = &#123;&#125;) &#123; // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = &#123; fontSize: 20, color: 'gold', speed: 2, opacity: 0.3, data: [] &#125;; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // Canvas 画布的内容 this.context = canvas.getContext('2d'); // 渲染所有的弹幕 this.render(); &#125; render() &#123; // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) &#123; // 递归渲染 requestAnimationFrame(this.render.bind(this)); &#125; &#125; renderBarrage() &#123; // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕 let time = this.video.currentTime; this.barrages.forEach(barrage =&gt; &#123; // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位） if (!barrage.flag &amp;&amp; time &gt;= barrage.time) &#123; // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化 // 节省性能，初始化后再进行绘制 // 如果没有初始化，先去初始化一下 if (!barrage.isInited) &#123; // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited barrage.init(); barrage.isInited = true; &#125; barrage.x -= barrage.speed; barrage.render(); // 渲染该条弹幕 if (barrage.x &lt; barrage.width * -1) &#123; barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作 &#125; &#125; &#125;); &#125; // ********** 以下为新增代码 ********** add(item) &#123; this.barrages.push(new Barrage(item, this)); &#125; // ********** 以上为新增代码 **********&#125; 拖动进度条实现弹幕的前进和后退其实我们发现，弹幕虽然实现了正常的播放、暂停以及发送，但是当我们拖动进度条的时候弹幕应该是跟着视频时间同步播放的，现在的弹幕一旦播放过无论怎样拉动进度条弹幕都不会再出现，我们现在就来解决这个问题。 文件：index.js1234// 拖动进度条事件video.addEventListener('seeked', function() &#123; canvasBarrage.reset();&#125;); 我们在事件内部其实只是调用了一下 CanvasBarrage 类的 reset 方法，这个方法就是在拖动进度条的时候来帮我们初始化弹幕的状态。 文件：index.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class CanvasBarrage &#123; constructor(canvas, video, options = &#123;&#125;) &#123; // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = &#123; fontSize: 20, color: 'gold', speed: 2, opacity: 0.3, data: [] &#125;; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // Canvas 画布的内容 this.context = canvas.getContext('2d'); // 渲染所有的弹幕 this.render(); &#125; render() &#123; // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) &#123; // 递归渲染 requestAnimationFrame(this.render.bind(this)); &#125; &#125; renderBarrage() &#123; // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕 let time = this.video.currentTime; this.barrages.forEach(barrage =&gt; &#123; // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位） if (!barrage.flag &amp;&amp; time &gt;= barrage.time) &#123; // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化 // 节省性能，初始化后再进行绘制 // 如果没有初始化，先去初始化一下 if (!barrage.isInited) &#123; // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited barrage.init(); barrage.isInited = true; &#125; barrage.x -= barrage.speed; barrage.render(); // 渲染该条弹幕 if (barrage.x &lt; barrage.width * -1) &#123; barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作 &#125; &#125; &#125;); &#125; add(item) &#123; this.barrages.push(new Barrage(item, this)); &#125; // ********** 以下为新增代码 ********** reset() &#123; // 先清空 Canvas 画布 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); let time = this.video.currentTime; // 循环每一条弹幕实例 this.barrages.forEach(barrage =&gt; &#123; // 更改已经移出屏幕的弹幕状态 barrage.flag = false; // 当拖动到的时间小于等于当前弹幕时间是，重新初始化弹幕的数据，实现渲染 if (time &lt;= barrage.time) &#123; barrage.isInited = false; &#125; else &#123; barrage.flag = true; // 否则将弹幕的状态设置为以移出屏幕 &#125; &#125;); &#125; // ********** 以上为新增代码 **********&#125; 其实 reset 方法中值做了几件事： 清空 Canvas 画布； 获取当前进度条拖动位置的时间； 循环存储弹幕实例的数组； 将所有弹幕更改为未移出屏幕； 判断拖动时间和每条弹幕的时间； 在当前时间以后的弹幕重新初始化数据； 以前的弹幕更改为已移出屏幕。 从而实现了拖动进度条弹幕的 “前进” 和 “后退” 功能。 使用 WebSocket 和 Redis 实现前后端通信及数据存储服务器代码的实现要使用 WebSocket 和 Redis 首先需要去安装 ws、redis 依赖，在项目根目录执行下面命令： npm install ws redis 我们创建一个 server.js 文件，用来写服务端的代码： 文件：index.js12345678910111213141516171819202122232425262728293031323334353637383940const WebSocket = require('ws'); // 引入 WebSocketconst redis = require('redis'); // 引入 redis// 初始化 WebSocket 服务器，端口号为 3000const wss = new WebSocket.Server(&#123; port: 3000&#125;);// 创建 redis 客户端const client = redis.createClient(); // key value// 原生的 websocket 就两个常用的方法 on('message')、on('send')wss.on('connection', function(ws) &#123; // 监听连接 // 连接上需要立即把 redis 数据库的数据取出返回给前端 client.lrange('barrages', 0, -1, function(err, applies) &#123; // 由于 redis 的数据都是字符串，所以需要把数组中每一项转成对象 applies = applies.map(item =&gt; JSON.parse(item)); // 使用 websocket 服务器将 redis 数据库的数据发送给前端 // 构建一个对象，加入 type 属性告诉前端当前返回数据的行为，并将数据转换成字符串 ws.send(JSON.stringify(&#123; type: 'INIT', data: applies &#125;)); &#125;); // 当服务器收到消息时，将数据存入 redis 数据库 ws.on('message', function(data) &#123; // 向数据库存储时存的是字符串，存入并打印数据，用来判断是否成功存入数据库 client.rpush('barrages', data, redis.print); // 再将当前这条数据返回给前端 // 同样添加 type 字段告诉前端当前行为，并将数据转换成字符串 ws.send(JSON.stringify(&#123; type: 'ADD', data: JSON.parse(data) &#125;)); &#125;);&#125;); 服务器的逻辑很清晰，在 WebSocket 连接上时，立即获取 Redis 数据库的所有弹幕数据返回给前端，当前端点击发送弹幕按钮发送数据时，接收数据存入 Redis 数据库中并打印验证数据是否成功存入，再通过 WebSocket 服务把当前这一条数返回给前端，需要注意一下几点： 从 Redis 数据库中取出全部弹幕数据的数组内部都存储的是字符串，需要使用 JSON.parse 方法进行解析； 将数据发送前端时，最外层要使用 JSON.stringify 重新转换成字符串发送； 在初始化阶段 WebSocket 发送所有数据和前端添加新弹幕 WebSocket 将弹幕的单条数据重新返回时，需要添加对应的 type 值告诉前端，当前的操作行为。 前端代码的修改在没有实现后端代码之前，前端使用的是 data 的假数据，是在添加弹幕事件中，将获取的新增弹幕信息通过 CanvasBarrage 类的 add 方法直接创建 Barrage 类的实例，并加入到存放弹幕实例的 barrages 数组中。 现在我们需要更正一下交互逻辑，在发送弹幕事件触发时，我们应该先将获取的单条弹幕数据通过 WebSocket 发送给后端服务器，在服务器重新将消息返还给我们的时候，去将这条数据通过 CanvasBarrage 类的 add 方法加入到存放弹幕实例的 barrages 数组中。 还有在页面初始化时，我们之前在创建 CanvasBarrage 类实例的时候直接传入了 data 假数据，现在需要通过 WebSocket 的连接事件，在监听到连接 WebSocket 服务时，去创建 CanvasBarrage 类的实例，并直接把服务端返回 Redis 数据库真实的数据作为参数传入，前端代码修改如下： 文件：index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ********** 下面代码被删掉了 **********// let canvasBarrage = new CanvasBarrage(canvas, video, &#123;// data// &#125;);// ********** 上面代码被删掉了 **********// ********** 以下为新增代码 **********let canvasBarrage;// 创建 WebSocket 连接const socket = new WebSocket('ws://localhost:3000');// 监听连接事件socket.onopen = function() &#123; // 监听消息 socket.onmessage = function(e) &#123; // 将收到的消息从字符串转换成对象 let message = JSON.parse(e.data); // 根据不同情况判断是初始化还是发送弹幕 if (message.type === 'INIT') &#123; // 创建 CanvasBarrage 的实例添加弹幕功能，传入真实的数据 canvasBarrage = new CanvasBarrage(canvas, video, &#123; data: message.data &#125;); &#125; else if (message.type === 'ADD') &#123; // 如果是添加弹幕直接将 WebSocket 返回的单条弹幕存入 barrages 中 canvasBarrage.add(message.data); &#125; &#125;&#125;// ********** 以上为新增代码 **********$('#add').addEventListener('click', function() &#123; let time = video.currentTime; // 发送弹幕的时间 let value = $('#text').value; // 发送弹幕的文字 let color = $('#color').value; // 发送弹幕文字的颜色 let fontSize = $('#range').value; // 发送弹幕的字体大小 let sendObj = &#123; time, value, color, fontSize &#125;; //发送弹幕的参数集合 // ********** 以下为新增代码 ********** socket.send(JSON.stringify(sendObj)); // ********** 以上为新增代码 ********** // ********** 下面代码被删掉了 ********** // canvasBarrage.add(sendObj); // 发送弹幕的方法 // ********** 上面代码被删掉了 **********&#125;); 现在我们可以打开 index.html 文件并启动 server.js 服务器，就可以实现真实的视频弹幕操作了，但是我们还是差了最后一步，当前的服务只能同时服务一个人，但真实的场景是同时看视频的有很多人，而且发送的弹幕是共享的。 实现多端通信、弹幕共享我们需要处理两件事情： 第一件事情是实现多端通信共享数据库信息； 第二件事情是当有人离开的时候清除关闭的 WebSocket 对象。 文件：server.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const WebSocket = require('ws'); // 引入 WebSocketconst redis = require('redis'); // 引入 redis// 初始化 WebSocket 服务器，端口号为 3000const wss = new WebSocket.Server(&#123; port: 3000&#125;);// 创建 redis 客户端const client = redis.createClient(); // key value// ********** 以下为新增代码 **********// 存储所有 WebSocket 用户const clientsArr = [];// ********** 以上为新增代码 **********// 原生的 websocket 就两个常用的方法 on('message')、on('send')wss.on('connection', function(ws) &#123; // ********** 以下为新增代码 ********** // 将所有通过 WebSocket 连接的用户存入数组中 clientsArr.push(ws); // ********** 以上为新增代码 ********** // 监听连接 // 连接上需要立即把 redis 数据库的数据取出返回给前端 client.lrange('barrages', 0, -1, function(err, applies) &#123; // 由于 redis 的数据都是字符串，所以需要把数组中每一项转成对象 applies = applies.map(item =&gt; JSON.parse(item)); // 使用 websocket 服务器将 redis 数据库的数据发送给前端 // 构建一个对象，加入 type 属性告诉前端当前返回数据的行为，并将数据转换成字符串 ws.send(JSON.stringify(&#123; type: 'INIT', data: applies &#125;)); &#125;); // 当服务器收到消息时，将数据存入 redis 数据库 ws.on('message', function(data) &#123; // 向数据库存储时存的是字符串，存入并打印数据，用来判断是否成功存入数据库 client.rpush('barrages', data, redis.print); // ********** 以下为修改后的代码 ********** // 循环数组，将某一个人新发送的弹幕在存储到 Redis 之后返回给所有用户 clientsArr.forEach(w =&gt; &#123; // 再将当前这条数据返回给前端 // 同样添加 type 字段告诉前端当前行为，并将数据转换成字符串 w.send(JSON.stringify(&#123; type: 'ADD', data: JSON.parse(data) &#125;)); &#125;); // ********** 以上为修改后的代码 ********** &#125;); // ********** 以下为新增代码 ********** // 监听关闭连接事件 ws.on('close', function() &#123; // 当某一个人关闭连接离开时，将这个人从当前存储用户的数组中移除 clientsArr = clientsArr.filter(client =&gt; client != ws); &#125;); // ********** 以上为新增代码 **********&#125;); 上面就是 Canvas + WebSocket + Redis 视频弹幕的实现，实现过程可能有些复杂，但整个过程写的还是比较详细，可能需要一定的耐心慢慢的读完，并最好一步一步跟着写一写，希望这篇文章可以让读到的人解决视频弹幕类似的需求，真正理解整个过程和开放封闭原则，认识到前端面向对象编程思想的美。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://www.pandashen.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://www.pandashen.com/tags/CSS/"},{"name":"Canvas","slug":"Canvas","permalink":"https://www.pandashen.com/tags/Canvas/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://www.pandashen.com/tags/WebSocket/"},{"name":"Redis","slug":"Redis","permalink":"https://www.pandashen.com/tags/Redis/"}]},{"title":"异步发展流程 —— 异步编程的终极大招 async/await","date":"2018-06-15T13:20:40.000Z","path":"2018/06/15/20180615212040/","text":"前言这篇文章是异步发展流程系列的最后一篇，可能会涉及 Promise、Generators、co 等前置知识，如果对这些不是很了解可以看这个系列的前三篇： 异步发展流程 —— Promise 的基本使用 异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise 异步发展流程 —— Generators + co 让异步更优雅 如果已经具备这些前置知识，那我们继续看看今天的主角，JavaScript 异步编程的终极大招 async/await。 async/await 简介async/await 指的是两个关键字，是 ES7 引入的新标准，async 关键字用于声明 async 函数，await 关键字用来等待异步（必须是 Promise）操作，说白了 async/await 就是 Generators + co 的语法糖。 async/await 和 Generators + co 的写法非常的相似，只是把用于声明 Generator 函数的 * 关键字替换成了 async 并写在了 function 关键字的前面，把 yield 关键字替换成了 await；另外，async 函数是基于 Promise 的，await 关键字后面等待的异步操作必须是一个 Promise 实例，当然也可以是原始类型的值，只不过这时的执行效果等同于同步，与 Generator 不同的是，await 关键字前可以使用变量去接收这个正在等待的 Promise 实例执行后的结果。 async 函数的基本用法async 函数返回一个 Promise 实例，可以使用 then 方法添加回调函数。当函数执行的时候，只要遇到 await 就会等待，直到 await 后面的同步或异步操作完成，再接着执行函数体内后面的语句。 async 函数声明async 的声明方式大概有以下几种： async 函数声明123456789101112131415161718192021222324// 函数声明async function fn() &#123;&#125;// 函数表达式const fn = async function() &#123;&#125;;// 箭头函数const fn = async () =&gt; &#123;&#125;;// 作为对象的方法const obj = &#123; async fn() &#123;&#125;&#125;;// 作为 class 的方法class Person(name) &#123; constructor () &#123; this.name = name; &#125; async getName() &#123; const name = await this.name; return name; &#125;&#125; 在上一篇介绍 Generators + co 的文章中我们举了一个例子，使用 NodeJS 的 fs 模块连续异步读文件，第一个文件名为 a.txt，读到的内容为 b.txt，作为要读的第二个文件的文件名，继续读 b.txt 后将读到的内容 “Hello world” 打印出来。 我们来使用 async/await 的方式来实现一下： async 函数实现文件读取123456789101112131415161718// 引入依赖const fs = require('fs');const util = require('util');// 将 fs.readFile 转换成 Promiseconst readFile = util.promisify(fs.readFile);// 声明 async 函数async function read(file) &#123; let aData = await readFile(file, 'utf8'); let bData = await readFile(aData, 'utf8'); return bData;&#125;// 调用 async 函数read('a.txt').then(data =&gt; &#123; console.log(data); // Hello world&#125;); 其实对比上一篇文章 Generator 的案例，与 Generator 函数一样，写法像同步，执行是异步，不同的是我们即没有手动调用 next 方法，也没有借助 co 库，其实是 async 函数内部集成了类似于 co 的执行器，帮我们在异步完成后自动向下执行代码，所以说 async/await 是 Generators + co 的语法糖。 async 函数错误处理async 函数内部如果执行错误可以有三种方式进行错误处理： 在 await 后面的 Promise 实例使用 then 方法错误的回调或 catch 方法进行错误处理； 如果有多个 await，可以在 async 函数执行完后使用 catch 方法统一处理； 由于 async 内部代码是同步的写法，多个 await 的情况也可以使用 try...catch... 进行处理。 需要注意的是，如果在 async 函数内部使用了 try...catch... 又在函数执行完后使用了 catch，错误会优先被同步的 try...catch... 捕获到，后面的 catch 就不会再捕获了。 async 函数异常捕获12345678910111213141516171819202122232425262728// 第一种async function fn() &#123; let result = await Promise.reject('error').catch(err =&gt; &#123; console.log(err); &#125;);&#125;fn(); // error// 第二种async function fn() &#123; try &#123; let val1 = await Promise.reject('error'); let val2 = await Promise.resolve('success'); &#125; catch (e) &#123; console.log(e); &#125;&#125;fn(); // error// 第三种async function fn() &#123; let val1 = await Promise.resolve('success'); let val2 = await Promise.reject('error');&#125;fn().catch((err =&gt; console.log(err))); // error await 异步并发在 async 函数中，如果有多个 await 互不依赖，这种情况下如果执行一个，等待一个完成，再执行一个，再等待完成，这样是很浪费性能的，所以我们要把这些异步操作同时触发。 假设我们异步读取两个文件，且这两个文件不相关，我可以使用下面的方式来实现： await 异步并发123456789101112131415161718192021222324252627282930313233343536// 前置const fs = require('fs');const util = require('util');const readFile = util.promisify(fs.readFile);// 需要改进的 async 函数async function fn() &#123; let aData = await readFile('a.txt', 'utf8'); let bData = await readFile('b.txt', 'utf8'); return [aData, bData];&#125;fn();// 在 async 函数外部触发异步let aDataPromise = readFile('a.txt', 'utf8');let bDataPromise = readFile('b.txt', 'utf8');async function fn() &#123; let aData = await aDataPromise; let bData = await bDataPromise; return [aData, bData];&#125;fn();// 使用 Promise.allasync function fn() &#123; let dataArr = await Promise.all( readFile('a.txt', 'utf8'), readFile('a.txt', 'utf8') ); return dataArr;&#125;fn(); 使用 async/await 的注意点使用 async/await 应注意以下几点： 对 await 习惯性错误处理； await 命令后互不依赖的异步应同时触发； async 函数中，函数的执行上/下文发生变化时，不能使用 await（如使用 forEach 循环的回调中）。 针对第一点，在 async 函数中 await 命令后面大多情况下是 Promise 异步操作，运行结果可能出现错误并调用 reject 函数，最好对这个 await 语句进行错误处理，具体方式参照 async 函数基本用法中关于错误处理的内容。 针对第二点，如果两个或多个 await 命令后的异步操作没有依赖关系，执行时，需先触发第一个，等待异步完成，再触发第二个，再等异步完成，依次类推，这样比较耗时，性能不好，所以应该将这些异步操作同时触发，触发方式参照 async 函数基本用法中的 await 异步并发的内容。 针对第三点，如果声明一个 async 函数并传入一个数组，数组里面存储的都是 Promise 实例，若使用 forEach 循环数组，由于函数的执行上/下文发生了变化，此时使用 await 命令会报错。 循环内使用 await123456789101112131415161718192021222324// 创建 Promise 实例let p1 = Promise.resolve('p1 success');let p2 = Promise.resolve('p2 success');let p3 = Promise.resolve('p3 success');// async 函数async function fn(promises) &#123; promise.forEach(function(promise) &#123; await promise; &#125;);&#125;fn([p1, p2, p3]); // 执行时报错// 修改方式async function fn(promises) &#123; for (let i = 0; i &lt; promises.length; i++) &#123; await pormises[i]; &#125;&#125;fn([p1, p2, p3]); // 正常执行 总结async/await 的实现原理，其实就是在 async 函数内部逻辑映射成了 Generator 函数并集成了一个类似于 co 的执行器，所以我们使用 async/await 的时候，代码更简洁，没有了自己触发遍历器的 next 或调用 co 充当执行器的过程，只需要关心 async 函数的内部逻辑就可以了，因为写法与同步相同，更提高了代码的可读性，所以说 async/await 是异步编程的终极大招。 由于 async/await 是 ES7 规范，在浏览器端的支持并不是那么的友好，所以现在这种写法多用在 NodeJS 的异步操作当中，在 NodeJS 框架 Koa 2.x 版本得到广泛应用。 最后希望大家在读过异步发展流程这个系列之后，对 JavaScript 异步已经有了较深的认识，并可以在不同情况下游刃有余的使用这些处理异步的编程手段。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.pandashen.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"https://www.pandashen.com/tags/Promise/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"ES7","slug":"ES7","permalink":"https://www.pandashen.com/tags/ES7/"},{"name":"async/await","slug":"async-await","permalink":"https://www.pandashen.com/tags/async-await/"}]},{"title":"异步发展流程 —— Generators + co 让异步更优雅","date":"2018-06-14T08:14:13.000Z","path":"2018/06/14/20180614161413/","text":"Generators 简介Generator 函数是 ES6 提供的一种异步编程解决方案，是一个生成器，用于生成一个遍历器的函数，语法行为与传统函数完全不同。 Iterator 遍历器JavaScript 原有的表示 “集合” 的数据结构，主要有 Array 和 Object，在 ES6 中又加入了 Set 和 Map，这样就有了四种数据集合，还可以组合使用它们，如数组的成员是 Map 或 Object，这样就需要一种统一的接口机制，用来处理所有不同的数据结构。 遍历器 Iterator 就是这样一种机制，它是一种接口，为不同的数据结构提供统一的、简便的访问机制，任何数据结构只要部署了 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员。 Iterator 遍历器其实就是一个指针对象，上面有 next 方法，第一次调用 next 指针指向数据结构的第一个成员，第二次 next 调用指针指向第二个成员，直到指针指向最后一个成员。 我们可以使用 ES6 的展开运算符 ... 和 for...of... 去遍历带有 Iterator 接口的数据结构，需要注意的是，Object 本身不具备 Iterator 接口，所以我们无法通过 ... 把一个对象扩展到一个数组中，并且会报错，我们可以通过代码手动将 Object 类型实现 Iterator 接口。 给对象扩展 Iterator 接口1234567891011121314151617// 通过 Generator 函数给 Object 扩展 Iterator 接口Object.prototype[Symbol.iterator] = function*() &#123; for (var key in this) &#123; yield this[key]; &#125;&#125;// 测试 Iterator 接口const obj = &#123; a: 1, b: 2, c: 3&#125;;const arr = [...obj];console.log(arr); // [1, 2, 3] 上面我们其实是通过 ES6 的 Generator 函数简单粗暴的给 Object 类型实现了 Iterator 接口，后面我们会简单模拟 Generator 生成器。 模拟 GeneratorGenerator 函数是一个生成器，调用后会返回给我们一个 Iterator 遍历器对象，在对象中有一个 next 方法，调用一次 next，帮我遍历一次，返回值为一个对象，内部有 value 和 done 两个属性，value 属性代表当前遍历的值，done 属性代表是否遍历完成，如果遍历完成后继续调用 next，返回的对象中 value 属性值为 undefined，done 属性值为 true，这个遍历器在进行数据遍历时更像给我们提供了一个暂停功能，每次都需要手动调用 next 去进行下一次遍历。 我们根据 Generator 的特性用 ES5 简单模拟一个遍历器生成函数： 模拟遍历器生成函数123456789101112131415function iterator(arr) &#123; var i = 0; return &#123; next: function() &#123; var done = i &gt;= arr.length; var value = !done ? arr[i++] : undefined; return &#123; value: value, done: done &#125;; &#125; &#125;;&#125; 测试一下模拟的遍历器生成函数： 测试 iterator 函数123456789var arr = [1, 3, 5];// 遍历器var result = iterator(arr);result.next(); // &#123;value: 1, done: false&#125;result.next(); // &#123;value: 3, done: false&#125;result.next(); // &#123;value: 5, done: false&#125;result.next(); // &#123;value: undefined, done: true&#125; Generator 的基本使用在普通的函数 function 关键字后加一个 * 就代表声明了一个生成器函数，执行后返回一个遍历器对象，每次调用遍历器的 next 方法时，遇到 yield 关键字暂停执行，并将 yield 关键字后面的值会作为返回对象中 value 的值，如果函数有返回值，会把返回值作为调用 next 方法进行遍历完成后返回的对象中 value 的值，果已经遍历完成，再次 next 调用这个 value 的值会变成 undefined。 1234567891011121314// 生成器函数function* gen() &#123; yield 1; yield 2; return 3;&#125;// 遍历器const it = gen();it.next(); // &#123;value: 1, done: false&#125;it.next(); // &#123;value: 2, done: false&#125;it.next(); // &#123;value: 3, done: true&#125;it.next(); // &#123;value: undefined, done: true&#125; 在 Generator 函数中可以使用变量接收 yield 关键字执行后的返回值，只是接收的值并不是 yield 关键字后面表达式执行的结果，而是遍历器在下一次调用 next 方法时传入的参数。 也就是说我们第一次调用 next 方法进行遍历时是不需要传递参数的，因为上面并没有变量来接收它，即使传参也会被忽略掉，我们用一个例子感受一下这种比较特殊的执行机制： 12345678910111213141516// 生成器函数function* gen(arr) &#123; let a = yield 1; let b = yield a; let c = yield b; return c;&#125;// 遍历器const it = gen();it.next(); // &#123;value: 1, done: false&#125;it.next(2); // &#123;value: 2, done: false&#125;it.next(3); // &#123;value: 3, done: false&#125;it.next(4); // &#123;value: 4, done: true&#125;it.next(5); // &#123;value: undefined, done: true&#125; 如果已经遍历完成，并把上次遍历接收到的值作为返回值传递给返回对象 value 属性的值，后面再次调用 next 传入的参数也会被忽略，返回对象的 value 值为 undefined。 在 Generator 函数中，如果在其他函数或方法调用的回调内部（函数的执行上/下文发生变化）不能直接使用 yield 关键字。 循环中使用 yield12345678910111213// 错误的写法function* gen(arr) &#123; arr.forEach(*item =&gt; &#123; yield* item; &#125;);&#125;// 正确的写法function* gen(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; yield arr[i]; &#125;&#125; 如果在一个 Generator 函数中调用了另一个 Generator 函数，在调用外层函数返回遍历器的 next 方法时是不会遍历内部函数返回的遍历器的。 合并生成器 —— 错误12345678910111213141516171819// 外层的生成器函数function* genOut() &#123; yield 'a'; yield genIn(); yield 'c';&#125;// 内层的生成器函数function* genIn() &#123; yield 'b';&#125;// 遍历器const it = genOut();it.next(); // &#123;value: 'a', done: false&#125;it.next(); // 返回 genIn 的遍历器对象it.next(); // &#123;value: 'c', done: false&#125;it.next(); // &#123;value: undefined, done: true&#125; 上面代码如果想在调用 genOut 返遍历器的 next 方法时，同时遍历 genIn 调用后返回的遍历器，需要使用 yield* 表达式。 合并生成器 —— yield*12345678910111213141516171819// 外层的生成器函数function* genOut() &#123; yield 'a'; yield* genIn(); yield 'c';&#125;// 内层的生成器函数function* genIn() &#123; yield 'b';&#125;// 遍历器const it = genOut();it.next(); // &#123;value: 'a', done: false&#125;it.next(); // &#123;value: 'b', done: false&#125;it.next(); // &#123;value: 'c', done: false&#125;it.next(); // &#123;value: undefined, done: true&#125; 在 genOut 返回的遍历器调用 next 遇到 yield* 表达式时帮我们去遍历了 genIn 返回的遍历器，其实 yield* 内部做了处理，等同于下面代码： 合并生成器 —— for of123456789101112131415161718192021// 外层的生成器function* genOut() &#123; yield 'a'; for (let v of genIn()) &#123; yield v; &#125; yield 'c';&#125;// 内层的生成器function* genIn() &#123; yield 'b';&#125;// 遍历器const it = genOut();it.next(); // &#123;value: 'a', done: false&#125;it.next(); // &#123;value: 'b', done: false&#125;it.next(); // &#123;value: 'c', done: false&#125;it.next(); // &#123;value: undefined, done: true&#125; Generators 与 Promise 结合Promise 也是 ES6 的规范，同样是解决异步的一种手段，如果对 Promise 还不了解，可以阅读下面两篇文章： 异步发展流程 —— Promise 的基本使用 异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise 因为 Generator 函数在执行时遇到 yield 关键字会暂停执行，那么 yield 后面可以是异步操作的代码，比如 Promise，需要继续执行，就手动调用返回遍历器的 next 方法，因为中间有一个等待的过程，所以在执行异步代码的时候避免了回调函数的嵌套，在写法上更像同步，更容易理解。 我们来设计一个 Generator 函数与 Promise 异步操作结合的使用场景，假设我们需要使用 NodeJS 的 fs 模块读取一个文件 a.txt 的内容，而 a.txt 的内容是另一个需要读取文件 b.txt 的文件名，读取 b.txt 最后打印读取到的内容 “Hello world”。 回调函数的实现： 连续读取文件 —— 异步回调123456789101112// 引入依赖const fs = require('fs');fs.readFile('a.txt', 'utf8', (err, data) =&gt; &#123; if (!err) &#123; fs.readFile(data, 'utf8', (err, data) =&gt; &#123; if (!err) &#123; console.log(data); // Hello world &#125; &#125;); &#125;&#125;); 上面代码因为只有两层回调函数嵌套，所以感觉没那么复杂，但是嵌套的回调函数多了，代码就不那么的优雅了，我们接下来使用 Generator 结合 Promise 来实现，为了方便将 fs 异步的方法转换成 Promise，我们引入 util 模块，并转换 readFile 方法。 连续读取文件 —— Generator + Promise12345678910111213141516171819202122// 引入依赖const fs = require('fs');const util = require('util');// 将 readFile 方法转换成 Promiseconst read = util.promisify(fs.readFile);// 生成器函数function* gen() &#123; let aData = yield read('1.txt', 'utf8'); let bData = yield read(aData, 'utf8'); return bData;&#125;// 遍历器const it = gen();it.next().value.then(data =&gt; &#123; it.next(data).then(data =&gt; &#123; console.log(data); // Hello world &#125;);&#125;); 我们只看 Generator 函数 gen 内部的执行，虽然是异步操作，但是在写法上几乎和同步没有区别，理解起来更容易，唯一美中不足的是，我们需要自己手动的调用遍历器的 next 和 Promise 实例的 then，这个问题 co 库可以帮我们解决。 co 库的使用co 库的作者是著名的 NodeJS 大神 TJ，是基于 Generator 和 Promise 的，这个库能帮我们实现自动调用 Generator 函数返回遍历器的 next 方法，并执行 yield 后面 Promise 实例的 then 方法，所以每次 yield 后面的异步操作返回的必须是一个 Promise 实例，代码看起来像同步，执行其实是异步，不用自己手动进行下一次遍历，这更是我们想要的。 由于 co 是一个第三方的模块，所以在使用时需要我们提前下载： npm install co 我们使用 co 来实现之前异步连续读文件的案例： 连续读取文件 —— Generator + co12345678910111213141516171819// 引入依赖const fs = require('fs');const util = require('util');const co = require('co');// 将 readFile 方法转换成 Promiseconst read = util.promisify(fs.readFile);// 生成器函数function* gen() &#123; let aData = yield read('1.txt', 'utf8'); let bData = yield read(aData, 'utf8'); return bData;&#125;// 使用 co 库代替手动调用 nextco(gen()).then(data =&gt; &#123; console.log(data); // Hello world&#125;); 从上面代码可以看出，co 库的 co 函数参数是一个遍历器，即 Generator 函数执行后的返回结果，在 co 内部操作遍历器并遍历完成后返回了一个 Promise 实例，遍历器最终的返回结果的 value 值作为 then 方法回调的参数，所以我们可以使用 then 对结果进行后续的处理。 co 库的实现原理我们其实在上面使用 co 的过程中对于 co 函数的内部做了什么已经有所了解，主要就是帮助我们调用遍历器的 next 和调用 yield 后面代码执行后返回 Promise 实例的 then，并在整个遍历结束后，返回一个新的 Promise 实例。 下面我们根据上面分析的 co 函数的原理来模拟一个简易版的 co 库： 文件：myCo.js —— co 原理1234567891011121314151617181920212223242526// co 函数，it 为遍历器对象function co(it) &#123; // 返回 Promise 实例 return new Promise((resolve, reject) =&gt; &#123; // 异步递归 function next(data) &#123; // 第一次调用 next 不需要传参 let &#123; value, done &#125; = it.next(data); if (!done) &#123; // 如果没完成遍历，调用返回 Promise 的 then 方法 value.then(data =&gt; &#123; // 如果 Promise 成功，继续递归，如果失败直接执行 reject next(data); &#125;, reject); &#125; else &#123; // 如果遍历完成直接执行 resolve 并传入 value resolve(value); &#125; &#125; next(); &#125;);&#125;// 导出模块module.exports = co; 验证 myCo.js 实现的 co 函数： 验证 myCo12345678910111213141516171819// 引入依赖const fs = require('fs');const util = require('util');const myCo = require('./myCo');// 将 readFile 方法转换成 Promiseconst read = util.promisify(fs.readFile);// 生成器函数function* gen() &#123; let aData = yield read('1.txt', 'utf8'); let bData = yield read(aData, 'utf8'); return bData;&#125;// 使用 co 库代替手动调用 nextmyCo(gen()).then(data =&gt; &#123; console.log(data); // Hello world&#125;); 我们将引入的 co 库替换成了自己实现的简易版 myCo 模块，上面读取文件的案例依然生效，这说明我们模拟的 co 库核心逻辑是没问题的，跟原版不同的是并没有处理很多细节，并定义指针，如果对 co 库感兴趣建议看看 TJ 大神的源码，整个库写的非常精简，值得学习。 总结Generators 相当于把一个函数拆分成若干个部分执行，执行一次时将指针指向下一段要执行的代码，直到结束位置，Generators 配合 co 库的使用场景多在 NodeJS 当中，并在 Koa 1.x 版本中居多，现在已经升级到 Koa 2.x 版本，使用更多的是基于 Generators 和 co 库衍生出来的 ES7 新标准 async/await，我们在下一篇异步发展流程系列的文章中来详细介绍。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.pandashen.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"https://www.pandashen.com/tags/Promise/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"},{"name":"ES6","slug":"ES6","permalink":"https://www.pandashen.com/tags/ES6/"},{"name":"Generators","slug":"Generators","permalink":"https://www.pandashen.com/tags/Generators/"}]},{"title":"异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise","date":"2018-06-13T11:36:26.000Z","path":"2018/06/13/20180613193626/","text":"概述Promise 是 js 异步编程的一种解决方案，避免了 “回调地狱” 给编程带来的麻烦，在 ES6 中成为了标准，这篇文章重点不是叙述 Promise 的基本用法，而是从零开始，手写一版符合 Promise/A+ 规范的 Promise，如果想了解更多 Promise 的基本用法，可以看 异步发展流程 —— Promise 的基本使用 这篇文章。 Promise 构造函数的实现我们在使用 Promise 的时候其实是使用 new 关键字创建了一个 Promise 的实例，其实 Promise 是一个类，即构造函数，下面来实现 Promise 构造函数。 Promise/A+ 规范的内容比较多，详情查看 https://promisesaplus.com/，我们在实现 Promise 逻辑时会根据实现的部分介绍相关的 Promise/A+ 规范内容。 在 Promise/A+ 规范中规定: 构造函数的参数为一个名为 executor 的执行器，即函数，在创建实例时该函数内部逻辑为同步，即立即执行； executor 执行时的参数分别为 resolve 和 reject，一个为成功时执行的函数，一个为失败时执行的函数； 在 executor 执行时，一旦出现错误立即调用 reject 函数，并设置错误信息给 reason 属性； 每个 Promise 实例有三个状态 pending、fulfilled 和 rejected，默认状态为 pending； 状态只能从 pending 到 fulfilled 或从 pending 到 rejected，且不可逆； 执行 resolve 函数会使状态从 pending 变化到 fulfilled 并将参数存入实例的 value 属性中； 执行 reject 函数会使状态从 pending 变化到 rejected 并将错误信息存入实例的 reason 属性中。 针对上面的 Promise/A+ 规范，Promise 构造函数代码实现如下： promise.js -- Promise 构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Promise(executor) &#123; var self = this; self.status = 'pending'; // 当前 Promise 实例的状态 self.value = undefined; // 当前 Promise 实例成功状态下的值 self.reason = undefined; // 当前 Promise 实例失败状态的错误信息 self.onFulfilledCallbacks = []; // 存储成功的回调函数的数组 self.onRejectedCallbacks = []; // 存储失败的回调函数的数组 // 成功的执行的函数 function resolve(value) &#123; // 处理 executor 执行时，调用 resolve 将一个新的 Promis 实例作为结果返回 if (value instanceof Promise) &#123; return value.then(function(data) &#123; resolve(data); &#125;, function(err) &#123; reject(err) &#125;); &#125; if (self.status === 'pending') &#123; self.status = 'fulfilled'; self.value = value; // 每次调用 resolve 时 // 执行 onFulfilledCallbacks 内部存储的所有的函数 // 在实现 then 方法中详细说明 self.onFulfilledCallbacks.forEach(function(fn) &#123; fn(); &#125;); &#125; &#125; // 失败执行的函数 function reject(reason) &#123; if (self.status === 'pending') &#123; self.status = 'rejected'; self.reason = reason; // 每次调用 reject 时 // 执行 onRejectedCallbacks 内部存储的所有的函数 // 在实现 then 方法中详细说明 self.onRejectedCallbacks.forEach(function(fn) &#123; fn(); &#125;); &#125; &#125; // 调用执行器函数 try &#123; executor(resolve, reject); &#125; catch (e) &#123; // 如果执行器执行时出现错误，直接调用失败的函数 reject(e); &#125;&#125;// 将自己的 Promise 导出module.exports = Promise; 上面构造函数中的 resolve 和 reject 方法在执行的时候都进行了当前状态的判断，只有状态为 pending 时，才能执行判断内部逻辑，当两个函数有一个执行后，此时状态发生变化，再执行另一个函数时就不会通过判断条件，即不会执行判断内部的逻辑，从而实现了两个函数只有一个执行判断内部逻辑的效果，使用如下： verify-promise.js -- 验证 promise.js 的代码12345678910// 引入自己的 Promise 模块// 因为都验证代码都写在 verify-promise.js 文件中，后面就不再引入了const Promise = require('./promise.js');let p = new Promise((resolve, reject) =&gt; &#123; // ...同步代码 resolve(); reject(); // 上面两个函数只有先执行的 resolve 生效&#125;); 实例方法的实现then 方法的实现没有 Promise 之前在一个异步操作的回调函数中返回一个结果在输入给下一个异步操作，下一个异步操作结束后需要继续执行回调，就形成回调函数的嵌套，在 Promise 中，原来回调函数中的逻辑只需要调用当前 Promise 实例的 then 方法，并在 then 方法的回调中执行，改变了原本异步的书写方式。 在 then 方法中涉及到的 Promise/A+ 规范： Promise 实例的 then 方法中有两个参数，都为函数，第一个参数为成功的回调 onFulfilled，第二个参数为失败的回调 onRejected； 当 Promise 内部执行 resolve 时，调用实例的 then 方法执行成功的回调 onFulfilled，当 Promise 内部执行 reject 或执行出错时，调用实例的 then 方法执行错误的回调 onRejected； then 方法需要支持异步，即如果 resovle 或 reject 执行为异步时，then 方法的回调 onFulfilled 或 onRejected 需要在后面执行； Promise 需要支持链式调用，Promise 实例调用 then 方法后需要返回一个新的 Promise 实例。如果 then 的回调中有返回值且是一个 Promise 实例，则该 Promise 实例执行后成功或失败的结果传递给下一个 Promise 实例的 then 方法 onFulfilled （成功的回调）或 onRejected（失败的回调）的参数，如果返回值不是 Promise 实例，直接将这个值传递给下一个 Promise 实例 then 方法回调的参数，then 的回调如果没有返回值相当于返回 undefined； Promise 实例链式调用 then 时，当任何一个 then 执行出错，链式调用下一个 then 时会执行错误的回调，错误的回调没有返回值相当于返回了 undefined，再次链式调用 then 时会执行成功的回调； Promise 实例的链式调用支持参数穿透，即当上一个 then 没有传递回调函数，或参数为 null 时，需要后面调用的 then 的回调函数来接收； executor 在 Promise 构造函数中执行时使用 try...catch... 捕获异常，但是内部执行的代码有可能是异步的，所以需要在 then 方法中使用 try...catch... 再次捕获； Promise 实例的 then 方法中的回调为 micro-tasks（微任务），回调内的代码应晚于同步代码执行，在浏览器内部调用微任务接口，我们这里模拟使用宏任务代替。 针对上面的 Promise/A+ 规范，then 方法代码实现如下： promise.js -- then 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Promise.prototype.then = function(onFulfilled, onRejected) &#123; // 实现参数穿透 if (typeof onFulfilled !== 'function') &#123; onFulfilled = function(data) &#123; return data; &#125; &#125; if (typeof onRejected !== 'function') &#123; onRejected = function(err) &#123; throw err; &#125; &#125; // 返回新的 Promise，规范中规定这个 Promise 实例叫 promise2 var promise2 = new Promise(function(resolve, reject) &#123; if (this.status === 'fulfilled') &#123; // 用宏任务替代模拟微任务，目的是使 `then` 的回调晚于同步代码执行 setTimeout(function() &#123; try &#123; // 捕获异步的异常 // onFulfilled 执行完返回值的处理，x 为成功回调的返回值 var x = onFulfilled(this.value); // 处理返回值单独封装一个方法 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;.bind(this), 0); &#125; if (this.status === 'rejected') &#123; setTimeout(function() &#123; try &#123; // onRejected 执行完返回值的处理，x 为失败回调的返回值 var x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;.bind(this), 0); &#125; // 如果在 Promise 执行 resolve 或 renject 为异步 // 将 then 的执行程序存储在实例对应的 // onFulfilledCallbacks 或 onRejectedCallbacks 中 if (this.status === 'pending') &#123; this.onFulfilledCallbacks.push(function() &#123; setTimeout(function() &#123; try &#123; var x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;.bind(this), 0); &#125;); this.onRejectedCallbacks.push(function() &#123; setTimeout(function() &#123; try &#123; var x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;.bind(this), 0); &#125;); &#125; &#125;); return promise2;&#125;; 在处理 then 回调的返回值时，其实就是在处理该返回值与 then 方法在执行后返回的新 Promise 实例（即 promise2）之间的关系，因为无论 Promise 的执行器在执行 resolve 还是 reject 是同步或是异步，都需要进行处理，所以我们单独封装一个函数 resolvePromise 来处理。 resolvePromise 函数有四个参数： promise2：then 执行后返回的 Promise 实例； x：then 的回调返回的结果； resolve：promise2 的 resolve 函数； reject：promise2 的 reject 函数。 在 resolvePromise 函数中涉及到的 Promise/A+ 规范： 将每个 Promise 实例调用 then 后返回的新 Promise 实例称为 promise2，将 then 回调返回的值称为 x； 如果 promise2 和 x 为同一个对象，由于 x 要将执行成功或失败的结果传递 promise2 的 then 方法回调的参数，因为是同一个 Promise 实例，此时既不能成功也不能失败（自己不能等待自己完成），造成循环引用，这种情况下规定应该抛出一个类型错误来回绝； 如果 x 是一个对象或者函数且不是 null，就去取 x 的 then 方法，如果 x 是对象，防止 x 是通过 Object.defineProperty 添加 then 属性，并添加 get 和 set 监听，如果在监听中抛出异常，需要被捕获到，x.then 是一个函数，就当作 x 是一个 Promise 实例，直接执行x 的 then 方法，执行成功就让 promise2 成功，执行失败就让 promise2 失败，如果 x.then 不是函数，则说明 x 为普通值，直接调用 promise2 的 resolve 方法将 x 传入，不满足条件说明该返回值就是一个普通值，直接执行 promise2 的 resolve 并将 x 作为参数传入； 如果每次执行 x 的 then 方法，回调中传入的参数还是一个 Promise 实例，循环往复，需要递归 resolvePromise 进行解析； 在递归的过程中存在内、外层同时调用了 resolve 和 reject 的情况，应该声明一个标识变量 called 做判断来避免这种情况。 针对上面的 Promise/A+ 规范，resolvePromise 函数代码实现如下： promise.js -- resolvePromise 方法12345678910111213141516171819202122232425262728293031323334353637383940414243function resolvePromise(promise2, x, resolve, reject) &#123; // 判断 x 和 promise2 是不是同一个函数 if (promise2 === x) &#123; reject(new TypeError('循环引用')); &#125; // x 是对象或者函数并且不是 null，如果不满足该条件说明 x 只是一个普通的值 if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; // 标识变量，防止递归内外层 resolve 和 reject 同时调用 // 针对 Promise，x 为普通值的时候可以放行 var called; // 为了捕获 Object.defineProperty 创建的 then 属性时添加监听所抛出的异常 try &#123; var then = x.then; // then 为一个方法，就当作 x 为一个 promise if (typeof then === 'function') &#123; // 执行 then，第一个参数为 this（即 x） // 第二个参数为成功的回调，第三个参数为失败的回调 then.call(x, function(y) &#123; if (called) return; called = true; // 如果 y 是 Promise 就继续递归解析 resolvePromise(promise2, y, resolve, reject); &#125;, function(err) &#123; if (called) return; called = true; reject(err); &#125;); &#125; else &#123; // x 是一个普通对象，直接成功即可 resolve(x); &#125; &#125; catch(e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; 上面我们按照 Promise/A+ 规范实现了 Promise 的 then 方法，接下来针对上面的规范，用一些有针对行的案例来对 then 方法一一进行验证。 验证异步调用 resolve 或 reject： 文件：verify-promise.js12345678// 验证 promise.js 异步调用 resolve 或 rejectlet p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(), 1000);&#125;);p.then(() =&gt; console.log('执行了'));// 执行了 验证链式调用 then 返回 Promise 实例： 文件：verify-promise.js1234567// 验证 promise.js then 回调返回 Promise 实例let p1 = new Promise((resolve, reject) =&gt; resolve());let p2 = new Promise((resolve, reject) =&gt; resolve('hello'));p1.then(() =&gt; p2).then(data =&gt; console.log(data));// hello 验证链式调用 then 返回普通值： 文件：verify-promise.js123456// 验证 promise.js then 回调返回普通值let p = new Promise((resolve, reject) =&gt; resolve());p.then(() =&gt; 'hello').then(data =&gt; console.log(data));// hello 验证链式调用 then 中执行出错链式调用 then 执行错误的回调后，再次链式调用 then： 文件：verify-promise.js123456789101112131415161718// 验证 promise.js 链式调用 then 中执行出错// 链式调用 then 执行错误的回调后，再次链式调用 thenlet p = new Promise((resolve, reject) =&gt; resolve());p.then(() =&gt; &#123; throw new Error('error');&#125;).then(() =&gt; &#123; console.log('success');&#125;, err =&gt; &#123; console.log(err);&#125;).then(() =&gt; &#123; console.log('成功');&#125;, () =&gt; &#123; console.log('失败');&#125;);// Error: error at p.then...// 成功 验证 then 的参数穿透： 文件：verify-promise.js123456789101112// 验证 then 的参数穿透let p1 = new Promise((resolve, reject) =&gt; resolve('ok'));let p2 = p1.then().then(data =&gt; &#123; console.log(data); throw new Error('出错了');&#125;);p2.then().then(null, err =&gt; console.log(err));// ok// 出错了 验证 then 方法是否晚于同步代码执行： 文件：verify-promise.js12345678910// 验证 then 方法是否晚于同步代码执行let p = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;);p.then(data =&gt; console.log(data));console.log(2);// 2// 1 验证循环引用： 文件：verify-promise.js123456789101112131415// 验证 promise.js 循环引用let p1 = new Promise((resolve, reject) =&gt; resolve());// 让 p1 then 方法的回调返回自己var p2 = p1.then(() =&gt; &#123; return p2;&#125;);p2.then(() =&gt; &#123; console.log('成功');&#125;, err =&gt; &#123; console.log(err);&#125;);// TypeError: 循环引用 at resolvePromise... 验证 then 回调返回对象通过 Object.definePropertype 添加 then 属性并添加 get 监听，在触发监听时抛出异常： 文件：verify-promise.js12345678910111213141516171819// 验证 promise.js then 回调// 返回对象通过 Object.definePropertype 添加 then 和 get 监听，捕获异常let obj = &#123;&#125;;Object.defineProperty(obj, 'then', &#123; get () &#123; throw new Error(); &#125;&#125;);let p = new Promise((resolve, reject) =&gt; resolve());p.then(() =&gt; &#123; return obj;&#125;).then(() =&gt; &#123; console.log('成功');&#125;, () =&gt; &#123; console.log('出错了');&#125;);// 出错了 验证每次执行 resolve 都传入 Promise 实例，需要将最终的执行结果传递给下一个 Promise 实例 then 的回调中： 文件：verify-promise.js12345678910111213141516// 验证 promise.js 每次执行 resolve 都传入 Promise 实例let p = new Promise((resolve, reject) =&gt; resolve());p.then(() =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(new Promise(resolve, reject) =&gt; &#123; resolve(new Promise(resolve, reject) =&gt; &#123; resolve(200); &#125;); &#125;); &#125;);&#125;).then(data =&gt; &#123; console.log(data);&#125;);// 200 catch 方法的实现promise.js -- catch 方法123Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected);&#125; catch 方法可以理解为是 then 方法的一个简写，只是参数中少了成功的回调，所以利用 Promise/A+ 规范中参数穿透的特性，很容易就实现了 catch 方法，catch 方法的真相就是这么的简单。 验证 catch 方法： 文件：verify-promise.js1234567891011// 验证 promise.js 的 catch 方法let p = new Promise((resolve, reject) =&gt; reject('err'));p.then().catch(err =&gt; &#123; console.log(err);&#125;).then(() =&gt; &#123; console.log('成功了');&#125;);// err// 成功了 finally 方法的实现promise.js -- finally 方法123456Promise.prototype.finally = function(callback) &#123; return this.then( value =&gt; Promise.resolve(callback()).then(() =&gt; value), reason =&gt; Promise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125; finally 方法是在 ES9 的规范中实现的，特点是无论成功或者失败都会执行传入的回调函数，并且回调函数没有任何参数，而在 finally 后可以再链式调用 then 或 catch 去处理后续逻辑或捕获异常，因为参数不是在 finally 方法传入的回调中返回的，所以借助了静态方法 Promise.resolve（该方法实现方式在静态方法中会说明），在 finally 内部调用 then 返回 Promise 实例，并传入成功和失败的回调用来返回最初成功或失败的结果，finally 的回调中执行的返回结果不生效。 验证 finally 方法： 文件：verify-promise.js123456789101112131415161718192021// 验证 promise.js 的 finally 方法let p = new Promise((resolve, reject) =&gt; resolve('nihao'));p.finally(() =&gt; &#123; // node版本的问题 8以上 console.log('hello'); throw 'error'&#125;).catch(err =&gt; &#123; console.log('err', err);&#125;);p.finally(() =&gt; &#123; console.log('hello'); return 100;&#125;).then(data =&gt; &#123; console.log('data', data);&#125;);// hello// hello// err error// data nihao 静态方法的实现Promise.resolve 方法的实现Promise.resolve 方法传入一个参数，并返回一个新的 Promise 实例，这个参数作为新 Promise 实例 then 方法成功回调的参数，在调用时感觉直接成功了，其实是直接执行了返回 Promise 实例的 resolve。 promise.js -- Promise.resolve 方法12345Promise.resolve = function(val) &#123; return new Promise(function(resolve, reject) &#123; resolve(val); &#125;);&#125; 验证 Promise.resolve 方法： 文件：verify-promise.js1234// 验证 promise.js 的 Promise.resolve 方法Promise.resolve('成功了').then(data =&gt; console.log(data));// 成功了 Promise.reject 方法的实现Promise.reject 方法与 Promise.resolve 的实现思路相同，不同的是，直接调用了返回新 Promise 实例的 reject。 promise.js -- Promise.reject 方法12345Promise.reject = function(reason) &#123; return new Promise(function(resolve, reject) &#123; reject(reason); &#125;);&#125; 验证 Promise.reject 方法： 文件：verify-promise.js1234// 验证 promise.js 的 Promise.reject 方法Promise.reject('失败了').then(err =&gt; console.log(err));// 失败了 Promise.all 方法的实现Promise.all 方法可以实现多个 Promise 实例的并行，返回值为一个新的 Promise 实例，当所有结果都为成功时，返回一个数组，该数组存储的为每一个 Promise 实例的返回结果，这些 Promise 实例的返回顺序先后不确定，但是返回值的数组内存储的返回结果是按照数组中 Promise 实例最初顺序进行排列的，返回的数组作为返回 Promise 实例成功回调的参数，当其中一个失败，直接返回错误信息，并作为返回 Promise 实例失败回调的参数。 promise.js -- Promise.all 方法12345678910111213141516171819202122232425262728293031323334Promise.all = function(promises) &#123; return new Promise(function(resolve, reject) &#123; // 存储返回值 var result = []; // 代表存入的个数，因为 Promise 为异步 // 不知道哪个 Promise 先成功，不能用数组的长度来判断 var idx = 0; // 用来构建全部成功的返回值 function processData(index, data) &#123; result[index] = data; // 将返回值存入数组 idx++; if (idx === promises.length) &#123; resolve(result); &#125; &#125; for (var i = 0; i &lt; promises.length; i++) &#123; var current = promises[i]; // 因为 Primise 为异步，保证 i 值是顺序传入 (function(i) &#123; if (current &amp;&amp; current.then &amp;&amp; typeof current.then === 'function') &#123; current.then(function(data) &#123; processData(i, data); &#125;, reject); &#125; else &#123; processData(i, current); &#125; &#125;)(i); &#125; &#125;);&#125; 验证 Promise.all 方法： 文件：verify-promise.js1234567891011121314151617181920212223242526// 验证 promise.js 的 Promise.all 方法let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(1), 2000);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(2), 1000);&#125;);Promise.all([p1, p2, 3]).then(data =&gt; console.log(data));// [1, 2, 3]let p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(1), 2000);&#125;);let p4 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(2), 1000)&#125;);Promise.all([p3, p4]).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);&#125;);// 2 Promise.race 方法的实现Promise.race 方法与 Promise.all 类似，同样可以实现多个 Promise 实例的并行，同样返回值为一个新的 Promise 实例，参数同样为一个存储多个 Promise 实例的数组，区别是只要有一个 Promise 实例返回结果，无论成功或失败，则直接返回这个结果，并作为新 Promise 实例 then 方法中成功或失败的回调函数的参数。 promise.js -- Promise.race 方法12345678910111213Promise.race = function(promises) &#123; return new Promise(function(resolve, reject) &#123; for (var i = 0; i &lt; promises.length; i++) &#123; var current = promises[i]; if (current &amp;&amp; current.then &amp;&amp; typeof current.then === 'function') &#123; current.then(resolve, reject); &#125; else &#123; resolve(current); &#125; &#125; &#125;);&#125; 验证 Promise.race 方法： 文件：verify-promise.js1234567891011121314151617181920212223242526// 验证 promise.js 的 Promise.race 方法let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(1), 2000);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(2), 1000);&#125;);Promise.race([p1, p2]).then(data =&gt; console.log(data));// 2let p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(1), 2000);&#125;);let p4 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(2), 1000);&#125;);Promise.all([p3, p4]).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);&#125;);// 2 使用 promises-aplus-test 测试 Promise 是否符合 Promise/A+ 规范promises-aplus-test 是专门用来验证 Promise 代码是否符合 Promise/A+ 规范的包，需要通过 npm 下载。 npm install promises-aplus-test -g 测试方法： 在 promise.js 中写入测试代码； 在命令行中输入命令 promises-aplus-test + fileName。 测试代码： promise.js -- 测试方法 Promise.derfer12345678910111213// Promise 语法糖// 好处：解决 Promise 嵌套问题// 坏处：错误处理不方便Promise.derfer = Promise.deferred = function() &#123; const dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125; 输入命令： promises-aplus-test promise.js 执行上面命令后，会根据 Promise/A+ 规范一条一条进行极端的验证，当验证通过后会在窗口中这一条对应的执行项前打勾，验证不通过打叉，直到所有的规范都验证完毕。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.pandashen.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"https://www.pandashen.com/tags/Promise/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"},{"name":"ES6","slug":"ES6","permalink":"https://www.pandashen.com/tags/ES6/"}]},{"title":"异步发展流程 —— Promise 的基本使用","date":"2018-06-11T20:50:05.000Z","path":"2018/06/12/20180612045005/","text":"Promise 简介Promise 是 ES6 的新特性，提供了对 js 异步编程控制的新的解决方案，在过去书写异步代码时要靠回调函数，当异步操作依赖于其他异步操作的返回值时，会出现一种现象，被程序员们称为 “回调地狱”，即多层回调函数嵌套，这种代码的可读性、维护性都很差，因此诞生了 Promise，当然 Promise 并不是完全摆脱回调，而只是改变了传递回调的位置，大大减少了回调函数嵌套。 Promise 的使用实例方法 thenPromise 中的代码默认是同步执行的，then 方法中的回调在微任务队列中执行，在 Promise 的 then 方法中支持传入两个参数，一个是成功的回调，一个是失败的回调，在 Promise 中调用了 resolve 方法，就会在 then 中执行成功的回调，调用了 reject 方法，就会在 then 中执行失败的回调，成功的回调和失败的回调只能执行一个，resolve 和 reject 方法调用时传入的参数会传递给 then 方法中对应的回调函数。 执行 resolve12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; console.log(1); resovle(3);&#125;);console.log(2);p.then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log(err);&#125;);// 1// 2// 3 执行 reject1234567891011let p = new Promise((resolve, reject) =&gt; &#123; reject();&#125;);p.then(() =&gt; &#123; console.log(1);&#125;, () =&gt; &#123; console.log(2);&#125;);// 2 如果 Promise 中发生错误，就会在 then 中执行失败的回调。 失败的回调1234567891011let p = new Primise((resolve, reject) =&gt; &#123; throw new Error();&#125;);p.then(() =&gt; &#123; console.log(1);&#125;, () =&gt; &#123; console.log('报错啦');&#125;);// 报错啦 当同一个 Promise 实例的 then 方法多次调用时，就会多次执行。 多次调用 then1234567891011121314let p = new Promise((resolve, reject) =&gt; &#123; resolve('成功');&#125;);p.then(data =&gt; &#123; console.log(data);&#125;);p.then(data =&gt; &#123; console.log(data);&#125;);// 成功// 成功 Promise 的链式调用Promise 支持链式调用，每次调用一次 then 方法都会返回一个新的 Promise实例，如果该 then 方法中执行的回调函数有返回值，并且这个返回值会作为返回的下一个 Promise 实例的 then 方法回调的参数，如果 then 方法的返回值是一个 Promise 实例，那就返回一个新的 Promise 实例，将 then 返回的 Promise 实例执行后的结果作为返回 Promise 实例回调的参数。 链式调用 then1234567891011121314151617181920212223242526272829303132function read(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(url, 'utf8', (err, data) =&gt; &#123; if (err) reject(err); resolve(data); &#125;); &#125;);&#125;read('1.txt').then(data =&gt; &#123; // 假设此时读到的内容为 Hello world return data;&#125;, err =&gt; &#123; console.log(err);&#125;).then(data =&gt; &#123; console.log(data); // Hello world&#125;, err =&gt; &#123; console.log(err);&#125;);read('1.txt').then(data =&gt; &#123; // 假如此时读到的 1.txt 的内容为 2.txt 的字符串，2.txt 的内容为 Hello world return read(data);&#125;, err =&gt; &#123; console.log(err);&#125;).then(data =&gt; &#123; console.log(data); // Hello world&#125;, err =&gt; &#123; console.log(err);&#125;); 在 Promise 实例的 then 中如果有错误产生，在返回的新的 Promise 实例中的 then 方法中会执行错误的回调。 链式调用 then 出错1234567891011121314151617let p = new Promise((resolve, reject) =&gt; &#123; resolve();&#125;);p.then(() =&gt; &#123; console.log('success', 1); throw new Error();&#125;, () =&gt; &#123; console.log('error', 1);&#125;).then(() =&gt; &#123; console.log('success', 2);&#125;, () =&gt; &#123; console.log('error', 2)&#125;);// success 1// error 2 在 Promise 中有三个状态： pending：等待态 fulfilled：成功态 rejected：失败态 Promise 实例的状态只能从 pending 到 fulfilled 或从 pending 到 rejected，状态一旦发生变化就不可逆，所以 Promise 实现链式调用与 jQuery 不同，返回的不是 this，只能是一个新的 Promise。 实例方法 catch在 Promise 中实例的 catch 方法可以捕获链式调用中的异常，不需要每次调用 then 方法中都传入错误的回调，在链式调用的过程中只要有任何一个 then 中出现错误，都会被 catch 方法捕获到。 catch 方法1234567891011121314151617181920212223242526let p = new Promise((resolve, reject) =&gt; &#123; resolve();&#125;);p.then(() =&gt; &#123; throw new Error(); console.log('success', 1);&#125;).then(() =&gt; &#123; console.log('success', 2);&#125;).catch(() =&gt; &#123; console.log('出错了');&#125;);// 出错了p.then(() =&gt; &#123; console.log('success', 1);&#125;).then(() =&gt; &#123; throw new Error(); console.log('success', 2);&#125;).catch(() =&gt; &#123; console.log('出错了');&#125;);// success 1// 出错了 静态方法 Promise.allPromise 中的静态方法 all 可以实现多个 Promise 实例的并行，当所有结果都为成功时，返回一个数组，该数组存储的为每一个 Promise 实例的返回结果，每一个 Promise 实例的返回顺序先后不固定，但是返回值的数组内存储每一个 Promise 的返回值的结果按照最初传入的顺序排列，all 方法的返回值为一个新的 Promise 实例，返回的数组作为返回新 Promise 的 then 方法成功回调的参数。 当 all 传入的参数数组中的 Promise 实例执行时，只要有一个失败，则直接返回该 Promise 实例失败的结果或错误信息。 Promise.all 方法12345678910111213let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; resolve(2);&#125;);Promise.all([p1, p2]).then(data =&gt; &#123; console.log(data);&#125;);// [1, 2] Promise.all 错误捕获123456789101112131415let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; reject(2);&#125;);Promise.all([p1, p2]).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);&#125;);// 2 静态方法 Promise.racePromise 的静态方法 race 的用法和 all 类似，参数同为一个存储 Promise 实例的数组，返回值同样是一个新的 Promise 的实例，不同的是，数组中的 Promise 实例只有一个结果为成功，那就直接返回这个结果（只取出最快返回的结果），在没有成功的结果之前有一个出错，就直接返回这个错误。 Promise.race 方法123456789101112131415let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(1), 2000);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(2), 1000);&#125;);Promise.race([p1, p2]).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);&#125;);// 2 Promise.race 错误捕获123456789101112131415let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(1), 1000);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(2), 2000);&#125;);Promise.race([p1, p2]).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);&#125;);// 1 静态方法 Promise.resolvePromise 的静态方法 resolve 可以直接将 Promise 的状态变为成功并返回一个新的 Promise 实例，resolve 的参数会传递给返回的新 Promise 实例 then 中成功回调。 Promise.resolve 方法12345Promise.resolve('hello').then(data =&gt; &#123; console.log(data);&#125;);// hello 静态方法 Promise.rejectPromise 的静态方法 reject 与 resolve 使用完全相同，都返回一个新的 Promise 实例，不同的是 reject 的参数会传递给新 Promise 实例的 then 方法失败回调。 Promise.reject 方法12345Promise.reject('出错了').then(null, err =&gt; &#123; console.log(err);&#125;);// 出错了 当成功的回调不传递时，可以使用 null 代替，因为 null 作为参数会被忽略掉，将参数穿透到下一个 then 的回调中。 总结Promise 是异步编程的一大趋势，也是当前更先进的异步解决方案的基础，下一篇我们着重讨论一下 Promise 的实现原理以及 A+ 规范。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.pandashen.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"https://www.pandashen.com/tags/Promise/"},{"name":"ES6","slug":"ES6","permalink":"https://www.pandashen.com/tags/ES6/"}]},{"title":"九种 “姿势” 让你彻底解决跨域问题","date":"2018-06-10T17:06:38.000Z","path":"2018/06/11/20180611010638/","text":"同源策略同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。所谓同源是指 “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。 什么是跨域？当协议、域名、端口号，有一个或多个不同时，有希望可以访问并获取数据的现象称为跨域访问，同源策略限制下 cookie、localStorage、dom、ajax、IndexDB 都是不支持跨域的。 假设 cookie 支持了跨域，http 协议无状态，当用户访问了一个银行网站登录后，银行网站的服务器给返回了一个 sessionId，当通过当前浏览器再访问一个恶意网站，如果 cookie 支持跨域，恶意网站将获取 sessionId 并访问银行网站，出现安全性问题；IndexDB、localStorage 等数据存储在不同域的页面切换时是获取不到的；假设 dom 元素可以跨域，在自己的页面写入一个 iframe 内部嵌入的地址是 www.baidu.com，当在百度页面登录账号密码时就可以在自己的页面获取百度的数据信息，这显然是不合理的。 这就是为什么 cookie、localStorage、dom、ajax、IndexDB 会受到同源策略会限制，下面还有一点对跨域理解的误区： 误区：同源策略限制下，访问不到后台服务器的数据，或访问到后台服务器的数据后没有返回；正确：同源策略限制下，可以访问到后台服务器的数据，后台服务器会正常返回数据，而被浏览器给拦截了。 实现跨域的方式使用 jsonp 跨域使用场景：当自己的项目前端资源和后端部署在不同的服务器地址上，或者其他的公司需要访问自己对外公开的接口，需要实现跨域获取数据，如百度搜索。 封装 jsonp12345678910111213141516171819202122232425262728293031323334353637// 封装 jsonp 跨域请求的方法function jsonp(&#123; url, params, cb &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建一个 script 标签帮助我们发送请求 let script = document.createElement('script'); const arr = []; params = &#123; ...params, cb &#125;; // 循环构建键值对形式的参数 for (let key in params) &#123; arr.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; // 创建全局函数 window[cb] = function(data) &#123; resolve(data); // 在跨域拿到数据以后将 script 标签销毁 document.body.removeChild(script); &#125;; // 拼接发送请求的参数并赋值到 src 属性 script.src = `$&#123;url&#125;?$&#123;arr.join('&amp;')&#125;`; document.body.appendChild(script); &#125;);&#125;// 调用方法跨域请求百度搜索的接口json(&#123; url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', params: &#123; wd: 'jsonp' &#125;, cb: 'show'&#125;).then(data =&gt; &#123; // 打印请求回的数据 console.log(data);&#125;); 缺点： 只能发送 get 请求 不支持 post、put、delete； 不安全，容易引发 xss 攻击，别人在返回的结果中返回了下面代码。 123`let script = document.createElement('script');script.src = 'http://192.168.0.57:8080/xss.js';document.body.appendChild(script);`; 会把别人的脚本引入到自己的页面中执行，如：弹窗、广告等，甚至更危险的脚本程序。 使用 CORS 跨域跨源资源共享/CORS（Cross-Origin Resource Sharing）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 使用场景：多用于开发时，前端与后台在不同的 ip 地址下进行数据访问。 现在启动两个端口号不同的服务器，创建跨域条件，服务器（NodeJS）代码如下： 服务器1234567891011121314// 服务器1const express = require(express);const app = express();app.use(express.static(__dirname));app.listen(3000);// 服务器2const express = require('express');const app = express();app.get('/getDate', function(req, res) &#123; res.end('I love you');&#125;);app.use(express.static(__dirname));app.listen(4000); 由于我们的 NodeJS 服务器使用 express 框架，在我们的项目根目录下的命令行中输入下面代码进行安装： npm install express --save 通过访问 http://localhost:3000/index.html 获取 index.html 文件并执行其中的 Ajax 请求 http://localhost:4000/getDate 接口去获取数据，index.html 文件内容如下： 文件：index.html12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;CORS 跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; const xhr = new XMLHttpRequest(); // 正常 cookie 是不允许跨域的 document.cookie = 'name=hello'; // cookie 想要实现跨域必须携带凭证 xhr.withCredentials = true; // xhr.open('GET', 'http://localhost:4000/getDate', true); xhr.open('PUT', 'http://localhost:4000/getDate', true); // 设置名为 name 的自定义请求头 xhr.setRequestHeader('name', 'hello'); xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; // 打印返回的数据 console.log(xhr.response); // 打印后台设置的自定义头信息 console.log(xhr.getResponseHeader('name')); &#125; &#125; &#125; xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面 index.html 代码中发送请求访问不在同源的服务器 2，此时会在控制台给出错误信息，告诉我们缺少了哪些响应头，我们对应报错信息去修改访问的服务器 2 的代码，添加对应的响应头，实现 CORS 跨域。 服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 服务器2const express = require('express');const app = express();// 允许访问域的白名单const whiteList = ['http://localhost:3000'];app.use(function(req, res, next) &#123; let origin = req.header.origin; if (whiteList.includes(origin)) &#123; // 设置那个源可以访问我，参数为 * 时 // 允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用 res.setHeader('Access-Control-Allow-Origin', origin); // 想要获取 ajax 的头信息，需设置响应头 res.setHeader('Access-Control-Allow-Headers', 'name'); // 处理复杂请求的头 res.setHeader('Access-Control-Allow-Methods', 'PUT'); // 允许发送 cookie 凭证的响应头 res.setHeader('Access-Control-Allow-Credentials', true); // 允许前端获取哪个头信息 res.setHeader('Access-Control-Expose-Headers', 'name'); // 处理 OPTIONS 预检的存活时间，单位 s res.setHeader('Access-Control-Max-Age', 5); // 发送 PUT 请求会做一个试探性的请求 OPTIONS // 其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理 if (req.method === 'OPTIONS') &#123; res.end(); &#125; &#125; next();&#125;);app.put('/getDate', function(req, res) &#123; // res.setHeader('name', 'nihao'); // 设置自定义响应头信息 res.end('I love you');&#125;);app.get('/getDate', function(req, res) &#123; res.end('I love you');&#125;);app.use(express.static(__dirname));app.listen(4000); 使用 postMessage 实现跨域postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时候简称为 XMD，指的是在来自不同域的页面间传递消息。 调用方式：window.postMessage(message, targetOrigin) message：发送的数据 targetOrigin：发送的窗口的域 在对应的页面中用 message 事件接收，事件对象中有 data、origin、source 三个重要信息 data：接收到的数据 origin：接收到数据源的域（数据来自哪个域） source：接收到数据源的窗口对象（数据来自哪个窗口对象） 使用场景：不是使用 Ajax 的数据通信，更多是在两个页面之间的通信，在 A 页面中引入 B 页面，在 A、B 两个页面之间通信。 与上面 CORS 类似，我们要创建跨域场景，搭建两个端口号不同的 Nodejs 服务器，后面相同方式就不多赘述了。 服务器1234567891011// 服务器1const express = require(express);const app = express();app.use(express.static(__dirname));app.listen(3000);// 服务器2const express = require(express);const app = express();app.use(express.static(__dirname));app.listen(4000); 通过访问 http://localhost:3000/a.html，在 a.html 中使用 iframe 标签引入 http://localhost:4000/b.html，在两个窗口间传递数据。 文件：a.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面 A&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/b.html\" id=\"frame\" onload=\"load()\"&gt; &lt;/iframe&gt; &lt;script&gt; function load() &#123; let frame = document.getElementById('frame'); frame.contentWindow.postMessage('I love you', 'http://localhost:4000'); window.onmessage = function(e) &#123; console.log(e.data); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文件：b.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面 B&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onmessage = function(e) &#123; // 打印来自页面 A 的消息 console.log(e.data); // 给页面 A 发送回执 e.source.postMessage('I love you, too', e.origin); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 window.name 实现跨域同样是页面之间的通信，需要借助 iframe 标签，A 页面和 B 页面是同域的 http://localhost:3000，C 页面在独立的域 http://localhost:4000。 服务器1234567891011// 服务器1const express = require(express);const app = express();app.use(express.static(__dirname));app.listen(3000);// 服务器2const express = require(express);const app = express();app.use(express.static(__dirname));app.listen(4000); 实现思路：在 A 页面中将 iframe 的 src 指向 C 页面，在 C 页面中将属性值存入 window.name 中，再把 iframe 的 src 换成同域的 B 页面，在当前的 iframe 的 window 对象中取出 name 的值，访问 http://localhost:3000/a.html。 文件：a.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面 A&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/c.html\" id=\"frame\" onload=\"load()\"&gt; &lt;/iframe&gt; &lt;script&gt; // 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值 let isFirst = true; function load() &#123; let frame = document.getElementById('frame'); if (isFirst) &#123; frame.src = 'http://localhost:3000/b.html'; isFirst = false; &#125; else &#123; console.log(frame.contentWindow.name); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文件：c.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面 C&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.name = 'I love you'; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 location.hash 实现跨域与 window.name 跨域的情况相同，是不同域的页面间的参数传递，需要借助 iframe 标签，A 页面和 B 页面是同域的 http://localhost:3000，C 页面是独立的域 http://localhost:4000。 服务器1234567891011// 服务器1const express = require(express);const app = express();app.use(express.static(__dirname));app.listen(3000);// 服务器2const express = require(express);const app = express();app.use(express.static(__dirname));app.listen(4000); 实现思路：A 页面通过 iframe 引入 C 页面，并给 C 页面传一个 hash 值，C 页面收到 hash 值后创建 iframe 引入 B 页面，把 hash 值传给 B 页面，B 页面将自己的 hash 值放在 A 页面的 hash 值中，访问 http://localhost:3000/a.html。 文件：a.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面 A&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/c.html#Iloveyou\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; // 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值 window.onhashchange = function() &#123; console.log(location.hash); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文件：c.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面 C&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 打印 A 页面引入 C 页面设置的 hash 值 console.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#Iloveyoutoo'; document.body.appendChild(iframe); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文件：b.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面 B&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 将 C 页面引入 B 页面设置的 hash 值设置给 A页面 window.parent.parent.location.hash = location.hash; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 document.domain 实现跨域使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 www.baidu.com 与 video.baidu.com 之间。 服务器12345const express = require('express');const app = express();app.use(express.static(__dirname));app.listen(3000); 想要模拟使用 document.domain 跨域的场景需要做些小小的准备，到 C:\\Windows\\System32\\drivers\\etc 该路径下找到 hosts 文件，在最下面创建一个一级域名和一个二级域名。 127.0.0.1 www.domainacross.com127.0.0.1 sub.domainacross.com 命名是随意的，只要是符合一级域名与 二级域名的关系即可，然后访问 http://www.domainacross.com:3000/a.html。 文件：a.html123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面 A&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是页面 A 的内容&lt;/p&gt; &lt;iframe src=\"http://sucess.domainacross.com:3000/b.html\" onload=\"load()\" id=\"frame\" &gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'domainacross.com'; function load() &#123; console.log(frame.contentWindow.message); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文件：b.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;页面 B&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是 B 页面的内容&lt;/p&gt; &lt;script&gt; document.domain = 'domainacross.com'; var message = 'Hello A'; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 WebSocket 实现跨域WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 socket.io 的库，WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），协议是 ws:// 和 wss:// 对应 http:// 和 https://，因为没有跨域限制，所以使用 file:// 协议也可以进行通信。 由于我们在 NodeJS 服务中使用了 WebSocket，所以需要安装对应的依赖： npm install ws --save 文件：index.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 创建 webSocket const socket = new WebSocket('ws://localhost:3000'); // 连接上触发 socket.onopen = function() &#123; socket.send('I love you'); &#125; // 收到消息触发 socket.onmessage = function(e) &#123; // 打印收到的数据 console.log(e.data); // I love you, too &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务器123456789101112131415161718const express = require('express');const app = express();// 引入 webSocketconst WebSocket = require('ws');// 创建连接，端口号与前端相对应const wss = new WebSocket.Server(&#123; port: 3000 &#125;);// 监听连接wss.on('connection', function(ws) &#123; // 监听消息 ws.on('message', function(data) &#123; // 打印消息 console.log(data); // I love you // 发送消息 ws.send('I love you, too'); &#125;);&#125;); 使用 nginx 实现跨域nginx 本身就是一个服务器，因此我们需要去 nginx 官网下载服务环境 http://nginx.org/en/download.html。 下载后解压到一个文件夹中 双击 nginx.exe 启动（此时可以通过 http://localhost 访问 nginx 服务） 在目录新建 json 文件夹 进入 json 文件夹新建 data.json 文件并写入内容 回到 nginx 根目录进入 conf 文件夹 使用编辑器打开 nginx.conf 进行配置 data.json 文件： 文件：data.json123&#123; \"name\": \"nginx\"&#125; nginx.conf 文件： nginx 配置123456789101112server &#123; . . . location ~.*\\.json &#123; root json; add_header \"Access-Control-Allow-Origin\" \"*\"; &#125; . . .&#125; 含义： ~.*\\.json：代表忽略大小写，后缀名为 json 的文件； root json：代表 json 文件夹； add_header：代表加入跨域的响应头及允许访问的域，* 为允许任何访问。 在 nginx 根目录启动 cmd 命令行（windows 系统必须使用 cmd 命令行）执行下面代码重启 nginx。 nginx -s reload 不跨域访问：http://localhost/data.json 跨域访问时需要创建跨域条件代码如下： 服务器12345const express = require('express');const app = express();app.use(express.static(__dirname));app.listen(3000); 跨域访问：http://localhost:3000/index.html 文件：index.html123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;nginx跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; const xhr = new XMLHttpRequest(); xhr.open('GET', 'http://localhost/data.json', true); xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; console.log(xhr.response); &#125; &#125; &#125; xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 http-proxy-middleware 实现跨域NodeJS 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证。 非 vue 框架的跨域（2 次跨域）文件：index.html12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;proxy 跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; const xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写 cookie xhr.withCredentials = true; // 访问 http-proxy-middleware 代理服务器 xhr.open('get', 'http://www.proxy1.com:3000/login?user=admin', true); xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中间代理服务中使用了 http-proxy-middleware 中间件，因此需要提前下载： npm install http-proxy-middleware --save-dev 中间代理服务器1234567891011121314151617181920212223const express = require('express');const proxy = require('http-proxy-middleware');const app = express();app.use( '/', proxy(&#123; // 代理跨域目标接口 target: 'http://www.proxy2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带 cookie onProxyRes: function(proxyRes, req, res) &#123; res.header('Access-Control-Allow-Origin', 'http://www.proxy1.com'); res.header('Access-Control-Allow-Credentials', 'true'); &#125;, // 修改响应信息中的 cookie 域名 cookieDomainRewrite: 'www.proxy1.com' // 可以为 false，表示不修改 &#125;););app.listen(3000); 服务器12345678910111213141516171819const http = require('http');const qs = require('querystring');const server = http.createServer();server.on('request', function(req, res) &#123; let params = qs.parse(req.url.substring(2)); // 向前台写 cookie res.writeHead(200, &#123; // HttpOnly：脚本无法读取 'Set-Cookie': 'l=a123456;Path=/;Domain=www.proxy2.com;HttpOnly' &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080'); vue 框架的跨域（1 次跨域）利用 node + webpack + webpack-dev-server 代理接口跨域。在开发环境下，由于 Vue 渲染服务和接口代理服务都是 webpack-dev-server，所以页面与代理接口之间不再跨域，无须设置 Headers 跨域信息了。 导出服务器配置12345678910111213141516module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: '/login', target: 'http://www.proxy2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些 https 服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为 false，表示不修改 &#125;], noInfo: true &#125;&#125; 本篇文章在于帮助我们理解跨域，以及不同跨域方式的基本原理，在公司的项目比较多，多个域使用同一个服务器或者数据，以及在开发环境时，跨域的情况基本无法避免，一般会有各种各样形式的跨域解决方案，但其根本原理基本都在上面的跨域方式当中方式，我们可以根据开发场景不同，选择最合适的跨域解决方案。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"跨域","slug":"跨域","permalink":"https://www.pandashen.com/tags/跨域/"},{"name":"JSONP","slug":"JSONP","permalink":"https://www.pandashen.com/tags/JSONP/"}]},{"title":"模拟 Vue 手写一个 MVVM","date":"2018-03-28T06:00:39.000Z","path":"2018/03/28/20180328140039/","text":"MVVM 的前世今生MVVM 设计模式，是由 MVC（最早来源于后端）、MVP 等设计模式进化而来，M - 数据模型（Model），VM - 视图模型（ViewModel），V - 视图层（View）。 在 MVC 模式中，除了 Model 和 View 层以外，其他所有的逻辑都在 Controller 中，Controller 负责显示页面、响应用户操作、网络请求及与 Model 的交互，随着业务的增加和产品的迭代，Controller 中的处理逻辑越来越多、越来越复杂，难以维护。为了更好的管理代码，为了更方便的扩展业务，必须要为 Controller “瘦身”，需要更清晰的将用户界面（UI）开发从应用程序的业务逻辑与行为中分离，MVVM 为此而生。 很多 MVVM 的实现都是通过数据绑定来将 View 的逻辑从其他层分离，可以用下图来简略的表示。 MVVM 模型图 使用 MVVM 设计模式的前端框架很多，其中渐进式框架 Vue 是典型的代表，并在开发使用中深得广大前端开发者的青睐，我们这篇就根据 Vue 对于 MVVM 的实现方式来简单模拟一版 MVVM 库。 MVVM 的流程分析在 Vue 的 MVVM 设计中，我们主要针对 Compile（模板编译）、Observer（数据劫持）、Watcher（数据监听）和 Dep（发布订阅）几个部分来实现，核心逻辑流程可参照下图： MVVM 流程图 类似这种 “造轮子” 的代码毋庸置疑一定是通过面向对象编程来实现的，并严格遵循开放封闭原则，由于 ES5 的面向对象编程比较繁琐，所以，在接下来的代码中统一使用 ES6 的 class 来实现。 MVVM 类的实现在 Vue 中，对外只暴露了一个名为 Vue 的构造函数，在使用的时候 new 一个 Vue 实例，然后传入了一个 options 参数，类型为一个对象，包括当前 Vue 实例的作用域 el、模板绑定的数据 data 等等。 我们模拟这种 MVVM 模式的时候也构建一个类，名字就叫 MVVM，在使用时同 Vue 框架类似，需要通过 new 指令创建 MVVM 的实例并传入 options。 文件：MVVM.js12345678910111213141516171819202122232425262728293031class MVVM &#123; constructor(options) &#123; // 先把 el 和 data 挂在 MVVM 实例上 this.$el = options.el; this.$data = options.data; // 如果有要编译的模板就开始编译 if (this.$el) &#123; // 数据劫持，就是把对象所有的属性添加 get 和 set new Observer(this.$data); // 将数据代理到实例上 this.proxyData(this.$data); // 用数据和元素进行编译 new Compile(this.el, this); &#125; &#125; proxyData(data) &#123; // 代理数据的方法 Object.keys(data).forEach(key =&gt; &#123; Object.defineProperty(this, key, &#123; get() &#123; return data[key]; &#125; set(newVal) &#123; data[key] = newVal; &#125; &#125;); &#125;); &#125;&#125; 通过上面代码，我们可以看出，在我们 new 一个 MVVM 的时候，在参数 options 中传入了一个 Dom 的根元素节点和数据 data 并挂在了当前的 MVVM 实例上。 当存在根节点的时候，通过 Observer 类对 data 数据进行了劫持，并通过 MVVM 实例的方法 proxyData 把 data 中的数据挂在当前 MVVM 实例上，同样对数据进行了劫持，是因为我们在获取和修改数据的时候可以直接通过 this 或 this.$data，在 Vue 中实现数据劫持的核心方法是 Object.defineProperty，我们也使用这个方式通过添加 getter 和 setter 来实现数据劫持。 最后使用 Compile 类对模板和绑定的数据进行了解析和编译，并渲染在根节点上，之所以数据劫持和模板解析都使用类的方式实现，是因为代码方便维护和扩展，其实不难看出，MVVM 类其实作为了 Compile 类和 Observer 类的一个桥梁。 模板编译 Compile 类的实现Compile 类在创建实例的时候需要传入两个参数，第一个参数是当前 MVVM 实例作用的根节点，第二个参数就是 MVVM 实例，之所以传入 MVVM 的实例是为了更方便的获取 MVVM 实例上的属性。 在 Compile 类中，我们会尽量的把一些公共的逻辑抽取出来进行最大限度的复用，避免冗余代码，提高维护性和扩展性，我们把 Compile 类抽取出的实例方法主要分为两大类，辅助方法和核心方法，在代码中用注释标明。 解析根节点内的 Dom 结构文件：Compile.js123456789101112131415161718192021222324252627282930313233class Compile &#123; constructor(el, vm) &#123; this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; // 如过传入的根元素存在，才开始编译 if (this.el) &#123; // 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片） let fragment = this.node2fragment(this.el); &#125; &#125; /* 辅助方法 */ // 判断是否是元素节点 isElementNode(node) &#123; return node.nodeType === 1; &#125; /* 核心方法 */ // 将根节点转移至文档碎片 node2fragment(el) &#123; // 创建文档碎片 let fragment = document.createDocumentFragment(); // 第一个子节点 let firstChild; // 循环取出根节点中的节点并放入文档碎片中 while (firstChild = el.firstChild) &#123; fragment.appendChild(firstChild); &#125; return fragment; &#125;&#125; 上面编译模板的过程中，前提条件是必须存在根元素节点，传入的根元素节点允许是一个真实的 Dom 元素，也可以是一个选择器，所以我们创建了辅助方法 isElementNode 来帮我们判断传入的元素是否是 Dom，如果是就直接使用，是选择器就获取这个 Dom，最终将这个根节点存入 this.el 属性中。 解析模板的过程中为了性能，我们应取出根节点内的子节点存放在文档碎片中（内存），需要注意的是将一个 Dom 节点内的子节点存入文档碎片的过程中，会在原来的 Dom 容器中删除这个节点，所以在遍历根节点的子节点时，永远是将第一个节点取出存入文档碎片，直到节点不存在为止。 编译文档碎片中的结构在 Vue 中的模板编译的主要就是两部分，也是浏览器无法解析的部分，元素节点中的指令和文本节点中的 Mustache 语法（双大括号）。 文件：Compile.js —— 完善123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103class Compile &#123; constructor(el, vm) &#123; this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; // 如过传入的根元素存在，才开始编译 if (this.el) &#123; // 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片） let fragment = this.node2fragment(this.el); // ********** 以下为新增代码 ********** // 2、将模板中的指令中的变量和 &#123;&#123;&#125;&#125; 中的变量替换成真实的数据 this.compile(fragment); // 3、把编译好的 fragment 再塞回页面中 this.el.appendChild(fragment); // ********** 以上为新增代码 ********** &#125; &#125; /* 辅助方法 */ // 判断是否是元素节点 isElementNode(node) &#123; return node.nodeType === 1; &#125; // ********** 以下为新增代码 ********** // 判断属性是否为指令 isDirective(name) &#123; return name.includes('v-'); &#125; // ********** 以上为新增代码 ********** /* 核心方法 */ // 将根节点转移至文档碎片 node2fragment(el) &#123; // 创建文档碎片 let fragment = document.createDocumentFragment(); // 第一个子节点 let firstChild; // 循环取出根节点中的节点并放入文档碎片中 while (firstChild = el.firstChild) &#123; fragment.appendChild(firstChild); &#125; return fragment; &#125; // ********** 以下为新增代码 ********** // 解析文档碎片 compile(fragment) &#123; // 当前父节点节点的子节点，包含文本节点，类数组对象 let childNodes = fragment.childNodes; // 转换成数组并循环判断每一个节点的类型 Array.from(childNodes).forEach(node =&gt; &#123; if (this.isElementNode(node)) &#123; // 是元素节点 // 递归编译子节点 this.compile(node); // 编译元素节点的方法 this.compileElement(node); &#125; else &#123; // 是文本节点 // 编译文本节点的方法 this.compileText(node); &#125; &#125;); &#125; // 编译元素 compileElement(node) &#123; // 取出当前节点的属性，类数组 let attrs = node.attributes; Array.form(attrs).forEach(attr =&gt; &#123; // 获取属性名，判断属性是否为指令，即含 v- let attrName = attr.name; if (this.isDirective(attrName)) &#123; // 如果是指令，取到该属性值得变量在 data 中对应得值，替换到节点中 let exp = attr.value; // 取出方法名 let [, type] = attrName.split('-'); // 调用指令对应得方法 CompileUtil[type](node, this.vm, exp); &#125; &#125;); &#125; // 编译文本 compileText(node) &#123; // 获取文本节点的内容 let exp = node.contentText; // 创建匹配 &#123;&#123;&#125;&#125; 的正则表达式 let reg = /\\&#123;\\&#123;([^&#125;+])\\&#125;\\&#125;/g; // 如果存在 &#123;&#123;&#125;&#125; 则使用 text 指令的方法 if (reg.test(exp)) &#123; CompileUtil['text'](node, this.vm, exp); &#125; &#125; // ********** 以上为新增代码 **********&#125; 上面代码新增内容得主要逻辑就是做了两件事： 调用 compile 方法对 fragment 文档碎片进行编译，即替换内部指令和 Mustache 语法中变量对应的值； 将编译好的 fragment 文档碎片塞回根节点。 在第一个步骤当中逻辑是比较繁琐的，首先在 compile 方法中获取所有的子节点，循环进行编译，如果是元素节点需要递归 compile，传入当前元素节点。在这个过程当中抽取出了两个方法，compileElement 和 compileText 用来对元素节点的属性和文本节点进行处理。 compileElement 中的核心逻辑就是处理指令，取出元素节点所有的属性判断是否是指令，是指令则调用指令对应的方法。compileText 中的核心逻辑就是取出文本的内容通过正则表达式匹配出被 Mustache 语法的 “&#123;&#123; &#125;&#125;” 包裹的内容，并调用处理文本的 text 方法。 文本节点的内容有可能存在 “&#123;&#123; &#125;&#125; &#123;&#123; &#125;&#125; &#123;&#123; &#125;&#125;”，正则匹配默认是贪婪的，为了防止第一个 “&#123;” 和最后一个 “&#125;” 进行匹配，所以在正则表达式中应使用非贪婪匹配。 在调用指令的方法时都是调用的 CompileUtil 下对应的方法，我们之所以单独把这些指令对应的方法抽离出来存储在 CompileUtil 对象下的目的是为了解耦，因为后面其他的类还要使用。 CompileUtil 对象中指令方法的实现CompileUtil 中存储着所有的指令方法及指令对应的更新方法，由于 Vue 的指令很多，我们这里只实现比较典型的 v-model 和 “&#123;&#123; &#125;&#125;” 对应的方法，考虑到后续更新的情况，我们统一把设置值到 Dom 中的逻辑抽取出对应上面两种情况的方法，存放到 CompileUtil 的 updater 对象中。 文件：CompileUtil.js12345678910111213const CompileUtil = &#123;&#125;;// 更新节点数据的方法CompileUti.updater = &#123; // 文本更新 textUpdater(node, value) &#123; node.textContent = value; &#125;, // 输入框更新 modelUpdater(node, value) &#123; node.value = value; &#125;&#125;; 这部分的整个思路就是在 Compile 编译模板后处理 v-model 和 “&#123;&#123; &#125;&#125;” 时，其实都是用 data 中的数据替换掉 fragment 文档碎片中对应的节点中的变量。因此会经常性的获取 data 中的值，在更新节点时又会重新设置 data 中的值，所以我们抽离出了三个方法 getVal、getTextVal 和 setVal 挂在了 CompileUtil 对象下。 文件：CompileUtil.js —— 取值方法1234567891011121314151617181920212223242526272829303132// 获取 data 值的方法CompileUtil.getVal = function(vm, exp) &#123; // 将匹配的值用 . 分割开，如 vm.data.a.b exp = exp.split('.'); // 归并取值 return exp.reduce((prev, next) =&gt; &#123; return prev[next]; &#125;, vm.$data);&#125;;// 获取文本 &#123;&#123;&#125;&#125; 中变量在 data 对应的值CompileUtil.getTextVal = function(vm, exp) &#123; // 使用正则匹配出 &#123;&#123; &#125;&#125; 间的变量名，再调用 getVal 获取值 return exp.replace(/\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g, (...args) =&gt; &#123; return this.getVal(vm, args[1]); &#125;);&#125;;// 设置 data 值的方法CompileUtil.setVal = function(vm, exp, newVal) &#123; exp = exp.split('.'); return exp.reduce((prev, next, currentIndex) =&gt; &#123; // 如果当前归并的为数组的最后一项，则将新值设置到该属性 if (currentIndex === exp.length - 1) &#123; return prev[next] = newVal &#125; // 继续归并 return prev[next]; &#125;, vm.$data);&#125; 获取和设置 data 的值两个方法 getVal 和 setVal 思路相似，由于获取的变量层级不定，可能是 data.a，也可能是 data.obj.a.b，所以都是使用归并的思路，借用 reduce 方法实现的，区别在于 setVal 方法在归并过程中需要判断是不是归并到最后一级，如果是则设置新值，而 getTextVal 就是在 getVal 外包了一层处理 “&#123;&#123; &#125;&#125;” 的逻辑。 在这些准备工作就绪以后就可以实现我们的主逻辑，即对 Compile 类中解析的文本节点和元素节点指令中的变量用 data 值进行替换，还记得前面说针对 v-model 和 “&#123;&#123; &#125;&#125;” 进行处理，因此设计了 model 和 text 两个核心方法。 CompileUtil.model 方法的实现： 文件：CompileUtil.js —— model 方法12345678910111213141516171819202122232425// 处理 v-model 指令的方法CompileUtil.model = function(node, vm, exp) &#123; // 获取赋值的方法 const updateFn = this.updater['modelUpdater']; // 获取 data 中对应的变量的值 let value = this.getVal(vm, exp); // 添加观察者，作用与 text 方法相同 new Watcher(vm, exp, newValue =&gt; &#123; updateFn &amp;&amp; updateFn(node, newValue); &#125;); // v-model 双向数据绑定，对 input 添加事件监听 node.addEventListener('input', e =&gt; &#123; // 获取输入的新值 let newValue = e.target.value; // 更新到节点 this.setVal(vm, exp, newValue); &#125;); // 第一次设置值 updateFn &amp;&amp; updateFn(vm, value);&#125;; CompileUtil.text 方法的实现： 文件：CompileUtil.js —— text 方法123456789101112131415161718192021// 处理文本节点 &#123;&#123;&#125;&#125; 的方法CompileUtil.text = function(node, vm, exp) &#123; // 获取赋值的方法 const updateFn = this.updater['textUpdater']; // 获取 data 中对应的变量的值 let value = this.getTextVal(vm, exp); // 通过正则替换，将取到数据中的值替换掉 &#123;&#123; &#125;&#125; exp.replace(/\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g, (...args) =&gt; &#123; // 解析时遇到了模板中需要替换为数据值的变量时，应该添加一个观察者 // 当变量重新赋值时，调用更新值节点到 Dom 的方法 new Watcher(vm, arg[1], newValue =&gt; &#123; // 如果数据发生变化，重新获取新值 updateFn &amp;&amp; updateFn(node, newValue); &#125;); &#125;); // 第一次设置值 updateFn &amp;&amp; updateFn(vm, value);&#125;; 上面两个方法逻辑相似，都获取了各自的 updater 中的方法，对值进行设置，并且在设置的同时为了后续 data 中的数据修改，视图的更新，创建了 Watcher 的实例，并在内部用新值重新更新节点，不同的是 Vue 的 v-model 指令在表单中实现了双向数据绑定，只要表单元素的 value 值发生变化，就需要将新值更新到 data 中，并响应到页面上。 所以我们的实现方式是给这个绑定了 v-model 的表单元素监听了 input 事件，并在事件中实时的将新的 value 值更新到 data 中，至于 data 中的改变后响应到页面中需要另外三个类 Watcher、Observer 和 Dep 共同实现，我们下面就来实现 Watcher 类。 观察者 Watcher 类的实现在 CompileUtil 对象的方法中创建 Watcher 实例的时候传入了三个参数，即 MVVM 的实例、模板绑定数据的变量名 exp 和一个 callback，这个 callback 内部逻辑是为了更新数据到 Dom，所以我们的 Watcher 类内部要做的事情就清晰了，获取更改前的值存储起来，并创建一个 update 实例方法，在值被更改时去执行实例的 callback 以达到视图的更新。 文件：Watcher.js1234567891011121314151617181920212223242526272829303132class Watcher &#123; constructor(vm, exp, callback) &#123; this.vm = vm; this.exp = exp; this.callback = callback; // 更改前的值 this.value = this.get(); &#125; get() &#123; // 将当前的 watcher 添加到 Dep 类的静态属性上 Dep.target = this; // 获取值触发数据劫持 let value = CompileUtil.getVal(this.vm, this.exp); // 清空 Dep 上的 Watcher，防止重复添加 Dep.target = null; return value; &#125; update() &#123; // 获取新值 let newValue = CompileUtil.getVal(this.vm, this.exp); // 获取旧值 let oldValue = this.value; // 如果新值和旧值不相等，就执行 callback 对 dom 进行更新 if (newValue !== oldValue) &#123; this.callback(newValue); &#125; &#125;&#125; 看到上面代码一定有两个疑问： 使用 get 方法获取旧值得时候为什么要将当前的实例挂在 Dep 上，在获取值后为什么又清空了； update 方法内部执行了 callback 函数，但是 update 在什么时候执行。 这就是后面两个类 Dep 和 observer 要做的事情，我们首先来介绍 Dep，再介绍 Observer 最后把他们之间的关系整个串联起来。 发布订阅 Dep 类的实现其实发布订阅说白了就是把要执行的函数统一存储在一个数组中管理，当达到某个执行条件时，循环这个数组并执行每一个成员。 文件：Dep.js12345678910111213class Dep &#123; constructor() &#123; this.subs = []; &#125; // 添加订阅 addSub(watcher) &#123; this.subs.push(watcher); &#125; // 通知 notify() &#123; this.subs.forEach(watcher =&gt; watcher.update()); &#125;&#125; 在 Dep 类中只有一个属性，就是一个名为 subs 的数组，用来管理每一个 watcher，即 Watcher 类的实例，而 addSub 就是用来将 watcher 添加到 subs 数组中的，我们看到 notify 方法就解决了上面的一个疑问，Watcher 类的 update 方法是怎么执行的，就是这样循环执行的。 接下来我们整合一下盲点： Dep 实例在哪里创建声明，又是在哪里将 watcher 添加进 subs 数组的； Dep 的 notify 方法应该在哪里调用； Watcher 内容中，使用 get 方法获取旧值得时候为什么要将当前的实例挂在 Dep 上，在获取值后为什么又清空了。 这些问题在最后一个类 Observer 实现的时候都将清晰，下面我们重点来看最后一部分核心逻辑。 数据劫持 Observer 类的实现还记得实现 MVVM 类的时候就创建了这个类的实例，当时传入的参数是 MVVM 实例的 data 属性，在 MVVM 中把数据通过 Object.defineProperty 挂到了实例上，并添加了 getter 和 setter，其实 Observer 类主要目的就是给 data 内的所有层级的数据都进行这样的操作。 文件：Observer.js1234567891011121314151617181920212223242526272829303132333435363738394041class Observer &#123; constructor (data) &#123; this.observe(data); &#125; // 添加数据监听 observe(data) &#123; // 验证 data if (!data || typeof data !== 'object') return; // 要对这个 data 数据将原有的属性改成 set 和 get 的形式 // 要将数据一一劫持，先获取到 data 的 key 和 value Object.keys(data).forEach(key =&gt; &#123; // 劫持（实现数据响应式） this.defineReactive(data, key, data[key]); this.observe(data[key]); // 深度劫持 &#125;); &#125; // 数据响应式 defineReactive (object, key, value) &#123; let _this = this; // 每个变化的数据都会对应一个数组，这个数组是存放所有更新的操作 const dep = new Dep(); // 获取某个值被监听到 Object.defineProperty(object, key, &#123; enumerable: true, configurable: true, get() &#123; // 当取值时调用的方法 Dep.target &amp;&amp; dep.addSub(Dep.target); return value; &#125;, set(newValue) &#123; // 当给 data 属性中设置的值适合，更改获取的属性的值 if (newValue !== value) &#123; _this.observe(newValue); // 重新赋值如果是对象进行深度劫持 value = newValue; dep.notify(); // 通知所有人数据更新了 &#125; &#125; &#125;); &#125;&#125; 在的代码中 observe 的目的是遍历对象，在内部对数据进行劫持，即添加 getter 和 setter，我们把劫持的逻辑单独抽取成 defineReactive 方法，需要注意的是 observe 方法在执行最初就对当前的数据进行了数据类型验证，然后再循环对象每一个属性进行劫持，目的是给同为 Object 类型的子属性递归调用 observe 进行深度劫持。 在 defineReactive 方法中，创建了 Dep 的实例，并对 data 的数据使用 get 和 set 进行劫持，还记得在模板编译的过程中，遇到模板中绑定的变量，就会解析，并创建 watcher，会在 Watcher 类的内部获取旧值，即当前的值，这样就触发了 get，在 get 中就可以将这个 watcher 添加到 Dep 的 subs 数组中进行统一管理，因为在代码中获取 data 中的值操作比较多，会经常触发 get，我们又要保证 watcher 不会被重复添加，所以在 Watcher 类中，获取旧值并保存后，立即将 Dep.target 赋值为 null，并且在触发 get 时对 Dep.target 进行了短路操作，存在才调用 Dep 的 addSub 进行添加。 而 data 中的值被更改时，会触发 set，在 set 中做了性能优化，即判断重新赋的值与旧值是否相等，如果相等就不重新渲染页面，不等的情况有两种，如果原来这个被改变的值是基本数据类型没什么影响，如果是引用类型，我们需要对这个引用类型内部的数据进行劫持，因此递归调用了 observe，最后调用 Dep 的 notify 方法进行通知，执行 notify 就会执行 subs 中所有被管理的 watcher 的 update，就会执行创建 watcher 时的传入的 callback，就会更新页面。 在 MVVM 类将 data 的属性挂在 MVVM 实例上并劫持与通过 Observer 类对 data 的劫持还有一层联系，因为整个发布订阅的逻辑都是在 data 的 get 和 set 上，只要触发了 MVVM 中的 get 和 set 内部会自动返回或设置 data 对应的值，就会触发 data 的 get 和 set，就会执行发布订阅的逻辑。 通过上面长篇大论的叙述后，这个 MVVM 模式用到的几个类的关系应该完全叙述清晰了，虽然比较抽象，但是细心琢磨还是会明白之间的关系和逻辑，下面我们就来对我们自己实现的这个 MVVM 进行验证。 验证 MVVM我们按照 Vue 的方式根据自己的 MVVM 实现的内容简单的写了一个模板如下： 文件：index.html12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;MVVM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 双向数据绑定 靠的是表单 --&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;message&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;!-- 引入依赖的 js 文件 --&gt; &lt;script src=\"./js/Watcher.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/Observer.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/Compile.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/CompileUtil.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/Dep.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/MVVM.js\"&gt;&lt;/script&gt; &lt;script&gt; const vm = new MVVM(&#123; el: '#app', data: &#123; message: 'hello world!' &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开 Chrom 浏览器的控制台，在上面通过下面操作来验证： 输入 vm.message = &#39;hello&#39; 看页面是否更新； 输入 vm.$data.message = &#39;hello&#39; 看页面是否更新； 改变文本输入框内的值，看页面的其他元素是否更新。 总结通过上面的测试，相信应该理解了 MVVM 模式对于前端开发重大的意义，实现了双向数据绑定，实时保证 View 层与 Model 层的数据同步，并可以让我们在开发时基于数据编程，而最少的操作 Dom，这样大大提高了页面渲染的性能，也可以使我们把更多的精力用于业务逻辑的开发上。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://www.pandashen.com/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"https://www.pandashen.com/tags/MVVM/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.pandashen.com/tags/源码分析/"}]},{"title":"浅析 event-loop 事件轮询","date":"2018-03-25T09:02:08.000Z","path":"2018/03/25/20180325170208/","text":"浏览器中的事件轮询JavaScript 是一门单线程语言，之所以说是单线程，是因为在浏览器中，如果是多线程，并且两个线程同时操作了同一个 Dom 元素，那最后的结果会出现问题。所以，JavaScript 是单线程的，但是如果完全由上至下的一行一行执行代码，假如一个代码块执行了很长的时间，后面必须要等待当前执行完毕，这样的效率是非常低的，所以有了异步的概念，确切的说，JavaScript 的主线程是单线程的，但是也有其他的线程去帮我们实现异步操作，比如定时器线程、事件线程、Ajax 线程。 在浏览器中执行 JavaScript 有两个区域，一个是我们平时所说的同步代码执行，是在栈中执行，原则是先进后出，而在执行异步代码的时候分为两个队列，macro-task（宏任务）和 micro-task（微任务），遵循先进先出的原则。 作用域链12345678910111213141516function one() &#123; console.log(1); function two() &#123; console.log(2); function three() &#123; console.log(3); &#125; three(); &#125; two();&#125;one();// 1// 2// 3 上面的代码都是同步的代码，在执行的时候先将全局作用域放入栈中，执行全局作用域中的代码，解析了函数 one，当执行函数调用 one() 的时候将 one 的作用域放入栈中，执行 one 中的代码，打印了 1，解析了 two，执行 two()，将 two 放入栈中，执行 two，打印了 2，解析了 three，执行了 three()，将 three 放入栈中，执行 three，打印了 3。 在函数执行完释放的过程中，因为全局作用域中有 one 正在执行，one 中有 two 正在执行，two 中有 three 正在执行，所以释放内存时必须由内层向外层释放，three 执行后释放，此时 three 不再占用 two 的执行环境，将 two 释放，two 不再占用 one 的执行环境，将 one 释放，one 不再占用全局作用域的执行环境，最后释放全局作用域，这就是在栈中执行同步代码时的先进后出原则，更像是一个杯子，先放进去的在最下面，需要最后取出。 而异步队列更像时一个管道，有两个口，从入口进，从出口出，所以是先进先出，在宏任务队列中代表的有 setTimeout、setInterval、setImmediate、MessageChannel，微任务的代表为 Promise 的 then 方法、MutationObserve（已废弃）。 案例 1 1234567891011121314const messageChannel = new MessageChannel();const prot2 = messageChannel.port2;messageChannel.port1.postMessage('I love you');console.log(1);prot2.onmessage = function(e) &#123; console.log(e.data);&#125;;console.log(2);// 1// 2// I love you 从上面案例中可以看出，MessageChannel 是宏任务，晚于同步代码执行。 案例 2 1234567setTimeout(() =&gt; console.log(1), 2000);setTimeout(() =&gt; console.log(2), 1000);console.log(3);// 3// 2// 1 上面代码可以看出其实 setTimeout 并不是在同步代码执行的时候就放入了异步队列，而是等待时间到达时才会放入异步队列，所以才会有了上面的结果。 案例 3 12345678910111213setImmediate(function() &#123; console.log('setImmediate');&#125;);setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);console.log(1);// 1// setTimeout// setImmediate 同为宏任务，setImmediate 在 setTimeout 延迟时间为 0 时是晚于 setTimeout 被放入异步队列的，这里需要注意的是 setImmediate 在浏览器端，到目前为止只有 IE 实现了。 上面的案例都是关于宏任务，下面我们举一个有微任务的案例来看一看微任务和宏任务的执行机制，在浏览器端微任务的代表其实就是 Promise 的 then 方法。 案例 4 123456789101112131415161718setTimeout(() =&gt; &#123; console.log('setTimeout1'); Promise.resolve().then(data =&gt; &#123; console.log('Promise1'); &#125;);&#125;, 0);Promise.resolve().then(data =&gt; &#123; console.log('Promise2'); setTimeout(() =&gt; &#123; console.log('setTimeout2'); &#125;, 0);&#125;);// Promise2// setTimeout1// Promise1// setTimeout2 从上面的执行结果其实可以看出，同步代码在栈中执行完毕后会先去执行微任务队列，将微任务队列执行完毕后，会去执行宏任务队列，宏任务队列执行一个宏任务以后，会去看看有没有产生新的微任务，如果有则清空微任务队列后再执行下一个宏任务，依次轮询，直到清空整个异步队列。 Node 中的事件轮询在 Node 中的事件轮询机制与浏览器相似又不同，相似的是，同样先在栈中执行同步代码，同样是先进后出，不同的是 Node 有自己的多个处理不同问题的阶段和对应的队列，也有自己内部实现的微任务 process.nextTick，Node 的整个事件轮询机制是 Libuv 库实现的。 Node 中事件轮询的流程如下图： Node 事件环流程图 从图中可以看出，在 Node 中有多个队列，分别执行不同的操作，而每次在队列切换的时候都去执行一次微任务队列，反复的轮询。 案例 1 1234567setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);setImmediate(function() &#123; console.log('setInmediate');&#125;); 默认情况下 setTimeout 和 setImmediate 是不知道哪一个先执行的，顺序不固定，Node 执行的时候有准备的时间，setTimeout 延迟时间设置为 0 其实是大概 4ms，假设 Node 准备时间在 4ms 之内，开始执行轮询，定时器没到时间，所以轮询到下一队列，此时要等再次循环到 timer 队列后执行定时器，所以会先执行 check 队列的 setImmediate。 如果 Node 执行的准备时间大于了 4ms，因为执行同步代码后，定时器的回调已经被放入 timer 队列，所以会先执行 timer 队列。 案例 2 12345678910111213141516setTimeout(() =&gt; &#123; console.log('setTimeout1'); Promise.resolve().then(() =&gt; &#123; console.log('Promise1'); &#125;);&#125;, 0);setTimeout(() =&gt; &#123; console.log('setTimeout2');&#125;, 0);console.log(1);// 1// setTimeout1// setTimeout2// Promise1 Node 事件轮询中，轮询到每一个队列时，都会将当前队列任务清空后，在切换下一队列之前清空一次微任务队列，这是与浏览器端不一样的。 浏览器端会在宏任务队列当中执行一个任务后插入执行微任务队列，清空微任务队列后，再回到宏任务队列执行下一个宏任务。 上面案例在 Node 事件轮询中，会将 timer 队列清空后，在轮询下一个队列之前执行微任务队列。 案例 3 1234567891011121314151617setTimeout(() =&gt; &#123; console.log('setTimeout1');&#125;, 0);setTimeout(() =&gt; &#123; console.log('setTimeout2');&#125;, 0);Promise.resolve().then(() =&gt; &#123; console.log('Promise1');&#125;);console.log(1);// 1// Promise1// setTimeout1// setTimeout2 上面代码的执行过程是，先执行栈，栈执行时打印 1，Promise.resolve() 产生微任务，栈执行完毕，从栈切换到 timer 队列之前，执行微任务队列，再去执行 timer 队列。 案例 4 12345678910111213141516171819202122232425setImmediate(() =&gt; &#123; console.log('setImmediate1'); setTimeout(() =&gt; &#123; console.log('setTimeout1'); &#125;, 0);&#125;);setTimeout(() =&gt; &#123; console.log('setTimeout2'); setImmediate(() =&gt; &#123; console.log('setImmediate2'); &#125;);&#125;, 0);//结果1// setImmediate1// setTimeout2// setTimeout1// setImmediate2// 结果2// setTimeout2// setImmediate1// setImmediate2// setTimeout1 setImmediate 和 setTimeout 执行顺序不固定，假设 check 队列先执行，会执行 setImmediate 打印 setImmediate1，将遇到的定时器放入 timer 队列，轮询到 timer 队列，因为在栈中执行同步代码已经在 timer 队列放入了一个定时器，所以按先后顺序执行两个 setTimeout，执行第一个定时器打印 setTimeout2，将遇到的 setImmediate 放入 check 队列，执行第二个定时器打印 setTimeout1，再次轮询到 check 队列执行新加入的 setImmediate，打印 setImmediate2，产生结果 1。 假设 timer 队列先执行，会执行 setTimeout 打印 setTimeout2，将遇到的 setImmediate 放入 check 队列，轮询到 check 队列，因为在栈中执行同步代码已经在 check 队列放入了一个 setImmediate，所以按先后顺序执行两个 setImmediate，执行第一个 setImmediate 打印 setImmediate1，将遇到的 setTimeout 放入 timer 队列，执行第二个 setImmediate 打印 setImmediate2，再次轮询到 timer 队列执行新加入的 setTimeout，打印 setTimeout1，产生结果 2。 案例 5 12345678910111213141516171819202122232425262728setImmediate(() =&gt; &#123; console.log('setImmediate1'); setTimeout(() =&gt; &#123; console.log('setTimeout1'); &#125;, 0);&#125;);setTimeout(() =&gt; &#123; process.nextTick(() =&gt; console.log('nextTick')); console.log('setTimeout2'); setImmediate(() =&gt; &#123; console.log('setImmediate2'); &#125;);&#125;, 0);//结果1// setImmediate1// setTimeout2// setTimeout1// nextTick// setImmediate2// 结果2// setTimeout2// nextTick// setImmediate1// setImmediate2// setTimeout1 这与上面一个案例类似，不同的是在 setTimeout 执行的时候产生了一个微任务 nextTick，我们只要知道，在 Node 事件轮询中，在切换队列时要先去执行微任务队列，无论是 check 队列先执行，还是 timer 队列先执行，都会很容易分析出上面的两个结果。 案例 6 12345678910111213const fs = require('fs');fs.readFile('./.gitignore', 'utf8', function() &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;, 0); setImmediate(function() &#123; console.log('setImmediate'); &#125;);&#125;);// setImmediate// timeout 上面案例的 setTimeout 和 setImmediate 的执行顺序是固定的，前面都是不固定的，这是为什么？ 因为前面的不固定是在栈中执行同步代码时就遇到了 setTimeout 和 setImmediate，因为无法判断 Node 的准备时间，不确定准备结束定时器是否到时并加入 timer 队列。 而上面代码明显可以看出 Node 准备结束后会直接执行 poll 队列进行文件的读取，在回调中将 setTimeout 和 setImmediate 分别加入 timer 队列和 check 队列，Node 队列的轮询是有顺序的，在 poll 队列后应该先切换到 check 队列，然后再重新轮询到 timer 队列，所以得到上面的结果。 案例 7 12345Promise.resolve().then(() =&gt; console.log('Promise'));process.nextTick(() =&gt; console.log('nextTick'));// nextTick// Promise 在 Node 中有两个微任务，Promise 的 then 方法和 process.nextTick，从上面案例的结果我们可以看出，在微任务队列中 process.nextTick 是优先执行的。 上面内容就是浏览器与 Node 在事件轮询的规则，相信在读完以后应该已经彻底弄清了浏览器的事件轮询机制和 Node 的事件轮询机制，并深刻的体会到了他们之间的相同和不同。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.pandashen.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"https://www.pandashen.com/tags/Promise/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://www.pandashen.com/tags/NodeJS/"}]},{"title":"Git 命令总结，从零到熟悉","date":"2017-12-13T18:41:01.000Z","path":"2017/12/14/20171214024101/","text":"什么是 Git？Git 是一个免费的开源分布式版本控制系统，它的设计目的是为了速度和效率的处理从小型到大型的项目；Git 可以帮我们管理我们的代码，记录历史，只要代码提交到 Git 上就永久不会丢失，可以随时 “穿越”（回到之前的某一个版本）；可以多端共享，团队协作中，多个人操作了同一个文件时，可以实现自动合并（模块化，组件化）、标记冲突，拥有强大的分支管理系统。 Git 与 SVN 的区别SVN：集中式，需要一台中央服务器，所有代码的拉取和提交都是在中央服务器，一旦中央服务器或者网络出现故障，则不能拉取和提交代码，需要不断去备份中央服务器，防止代码丢失。 Git：分布式，有一个中央服务器的同时，每个开发者本地都有自己的本地仓库，拥有完整的版本库，不用担心代码丢失，Git 存储的是代码变化的快照，更新代码的速度要比 SVN 更快。 Git 安装Windows https://git-scm.com/ Mac 如果安装过 Xcode 自带 Git，https://developer.apple.com/xcode/ 可以安装 Homebrew，是 wmac 的包管理器，https://brew.sh/，下面是两款界面美化插件： Oh My ZSH：http://ohmyz.sh/ iTerm2：https://www.iterm2.com/ Linux 命令打印工作目录 pwd 创建文件夹 mkdir 文件夹名 改变路径进入盘符： cd d: 进入文件夹： cd 文件夹名 回上一级目录： cd .. 进入某一个路径： cd 路径 想要进入某一个不知道路径的文件夹中，可以直接拖拽该文件到命令窗口，会自动识别路径。 查看文件列表 ls ls -al 下面命令加了 -al 参数可以查看隐藏文件。 创建文件 touch 文件名 移动文件 mv 文件/文件夹 路径 将文件或者文件夹移动到所输入的路径下。 查看文件内容 cat 文件名 删除文件 / 文件夹 rm -rf 文件夹名 rm 文件名 -rf 为递归删除，后面加上 * 为参数会递归删除整个文件夹的内容，rm -rf *（慎用）。 清空命令窗口 clear 查看命令历史直接在命令行中查看： history 将当前 Git 的命令历史写入文件中： history &gt; 文件名 使用 vi 编辑器编辑文件 vi 文件名 进入编辑模式： i 进入命令模式： Esc 保存并退出： :wq 强制退出： :q! 使用命令编辑文件向文件输入内容： echo 内容 > 文件名 向文件追加内容： echo 内容 >> 文件名 当使用 echo 编辑了一个不存在的文件时，会创建一个新文件并将内容编辑到文件中，而 touch 创建的是空文件。 Git 的本地操作Git 在管理文件时，所有文件都具有三种状态，已修改、已暂存、已提交。Git 在本地仓库中由三部分组成，工作区、暂存区、版本库。Git 管理的文件夹下都有一个名为 .git 的隐藏文件夹。 对应关系如下： 已修改 → 工作区 已暂存 → 暂存区（.git 文件夹下的 index 文件中） 已提交 → 版本库 配置用户不配置用户无法提交代码。 查看配置信息： git config --list 配置用户名： git config --global user.name “你的名字” 配置邮箱： git config --global user.email “你的邮箱” 初始化 Git 仓库在要初始化的文件夹下执行下面命令，告诉 Git 哪个文件夹被 Git 所管理，一个项目初始化一次，不能嵌套。 git init 查看 Git 状态 git status 文件为红色，代表有修改，文件名为绿色，代表已经加入暂存区。 添加到暂存区 git add 文件名 git add . git add -A . 和 -A 两个参数均为全部提交到暂存区，. 只监控修改、添加文件的变化，-A 监控修改、添加、删除文件。 删除暂存区 git rm --cached 文件名 git rm --cached . -r 第一个命令是删除某一个文件的暂存区，当参数为 . 的时候删除全部暂存区，所以需要加上代表递归删除的参数 -r。 提交到版本库从暂存区提交到版本库： git commit -m “版本信息” 从工作区直接提交到版本库（需要之前添加过暂存区）： git commit -a -m “版本信息” 查看提交日志 git log 比较工作区、暂存区、版本库工作区和暂存区比较： git diff 工作区和版本库比较： git diff 分支名 暂存区和版本库比较： git diff --cached 撤销操作 git checkout 文件名 git checkout . 撤销操作是将暂存区覆盖到工作区，会放弃掉当前工作区修改的内容，. 参数是将整个暂存区覆盖当前工作区，一旦撤销就回不到之前的工作区了。当不小心将当前工作区错误的代码提交到暂存区，可以使用下面命令将暂存区回滚到上一个暂存区，只可回滚一次。 git reset HEAD 文件名 回退版本查看所有的版本号： git reflog 按版本号回退版本： git reset --hard 版本号 回退到上一个版本： git reset --hard HEAD^ 回退某一个版本的文件到工作区： git checkout 版本号 文件名 回退版本会将当前版本库选中的版本重新覆盖暂存区和工作区。 分支操作查看分支： git branch Git 刚刚初始化管理的的文件夹必须有一次提交到版本库（root-commit：根提交）以后才会有主分支 master，否则即使创建了新分支也无法切换回 master。 创建分支： git branch 分支名 切换分支： git checkout 分支名 创建并切换分支： git checkout -b 分支名 删除分支（需切换出要删除的分支）： git branch -D 分支名 新创建的分支和主分支 master 还是同一个区域，新建的文件只有提交到新分支的版本库才真正脱离关系。分支工作区有更改不能直接切换其他分支，可以提交更改或者暂存更改，若暂存更改（使用暂存区覆盖掉工作区），等待重新切回分支时，还原暂存。此处所说的暂存不是之前的将代码提交到暂存区，因为当前分支工作区的代码会变成要切换分支工作区的代码，而导致当前分支工作区的更改丢失，此处的暂存类似于将修改寄存，重新切回该分支时再还原。 暂存更改： git stash 还原暂存的内容： git stash pop 合并分支： 将指定分支合并到当前所在的分支，所以，在分支开发完毕后，合并分支需要先切换回 master 主分支。 git merge 指定的分支名 查看分支合并的图谱： git log –graph git log –graph –oneline 红色线代表主分支，绿色线代表新创建的分支，分支上的 * 代表提交到版本库的节点。--oneline 参数表示提交信息显示为一行。 解决冲突当创建分支后，分支和 master 主分支分别提交代码到版本库，此时切换回 master 主分支，合并分支会出现冲突，需手动处理后，重新提交到暂存区并提交到版本库。 代码冲突12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改)master 分支代码=======开发分支的代码&gt;&gt;&gt;&gt;&gt;&gt;&gt; 开发的分支 (传入的更改) Git 操作远程仓库远程仓库可以是 Github、Gitee（码云）、Coding 或者中央服务器等等。 以下是常用免费仓库的地址，可以在首页注册账号： Github： https://github.com Gitee： https://gitee.com Coding： https://coding.net 处理需要过滤和提交的文件夹使用 WebStrom 编辑器编辑代码时，会自动在根目录生成 .idea 文件夹，使用 Mac 开发时根目录下的 .DS_Store 文件夹，以及在项目开发时会安装依赖存放在 node_modules 文件夹中，此类文件夹都是在把代码上传到远程仓库或中央服务器时不应该上传的，因此应该在上传之前过滤掉。 在根目录创建 .gitignore 文件用于记录上传时被忽略的文件夹，内容（可根据需要自行配置）如下： 文件：.gitignore123.idea.DS_Storenode_modules Git 上传时会自动忽略空文件夹，假设想要上传一个名为 public 的空文件夹，需要在文件夹内新建一个名为 .gitkeep 的文件（名字随意，最好有语义化），目的是使要提交的空文件夹不再为空。 关联远程仓库 git remote add origin 远程仓库地址 查看关联的远程仓库 git remote -v 删除远程仓库的关联 git remote rm 地址别名 地址别名指的是上面的 origin，也可以是其他名称，必须对应要删除关联的地址别名。 推送代码到远程仓库 git push origin master git push -u origin master 如果加上了 -u 参数，以后再次提交时可省略地址别名和分支名称，直接执行下面命令进行提交。 git push 拉取远程仓库的代码在提交代码时，如果直接提交到远程仓库，会将当前代码覆盖到远程仓库，如果别人之前也向远程仓库提交了代码，会在远程仓库中造成冲突，所以一般在提交代码之前先拉取远程仓库的代码与本地代码进行合并，并产生一个新的历史记录，若出现冲突，手动处理冲突后再统一提交到远程仓库。 拉取但不合并代码（与 merge 配合，不常用）： git fetch origin master 拉取并合并代码（常用）： git pull origin master 创建 gh-pages 分支来发布静态页涉及到远程仓库网站上的操作均以 Github 为例，其他仓库大同小异： 在项目中创建一个名为 gh-pages 的分支； 将分支提交到线上仓库； 找到提供给你的仓库网站的 Settings 切换到 github-pages； 点击该栏顶端的地址可以访问我们的静态页。 git checkout -b gh-pagestouch index.htmlgit add .git commit -m “提交信息”git push origin gh-pages 拉取别人的项目到本地 git clone 项目地址 项目别名 上面命令项目别名是可选的，相当于给项目根文件夹重命名。 向别人的项目提问 在远程仓库网站进入别人的项目页面； 点击 Issue 选项； 输入问题标题和问题描述并点击提交； 项目所有者可以回复或关闭问题。 更改别人的项目代码 在别人项目的主页上有一个叉子的图标，操作名为 Fork； Fork 是在当前项目下克隆了一份，如果代码更新，不会随之更新； 使用 clone 命令克隆自己的地址将项目拉到本地，进行操作； 默认就是 Git 仓库而且有 origin 地址，修改后可以将代码提交到自己的仓库上； 只有 Fork 关系才能修改别人代码后点击 New pull request 发送提交请求； 点击 Create pull request 按钮，填写提交标题，和提交详情，确认提交； 项目所有者可以在自己的项目页面中 Pull request 菜单中查看提交并处理； 点击 Close pull request 关闭，点击 Merge pull request 同意提交并合并。 如果是一个团队的其他人需要操作同一个项目，上面的过程显得很繁琐，项目所有者可以在 Settings 的 Collaborators 选项中通过添加别人的账号或用户名向项目中添加贡献者，被添加的人拥有最大权限。 GUI 界面化在当前的前端开发编辑器中，如 VSCode 和 WebStorm 等都集成了 Git，可以直接点击按钮操作，不必使用命令行，这种操作 Git 的界面称作 GUI 界面，个人建议还是尽量少的使用 GUI 界面，命令行是根本，还是多敲命令行，孰能生巧。","tags":[{"name":"Git","slug":"Git","permalink":"https://www.pandashen.com/tags/Git/"},{"name":"代码管理/版本控制","slug":"代码管理-版本控制","permalink":"https://www.pandashen.com/tags/代码管理-版本控制/"},{"name":"命令行","slug":"命令行","permalink":"https://www.pandashen.com/tags/命令行/"},{"name":"Linux","slug":"Linux","permalink":"https://www.pandashen.com/tags/Linux/"}]},{"title":"JavaScript 的继承方式及优缺点","date":"2017-07-10T08:27:24.000Z","path":"2017/07/10/20170710162724/","text":"前言JavaScript 原本不是纯粹的 “OOP” 语言，因为在 ES5 规范中没有类的概念，在 ES6 中才正式加入了 class 的编程方式，在 ES6 之前，也都是使用面向对象的编程方式，当然是 JavaScript 独有的面向对象编程，而且这种编程方式是建立在 JavaScript 独特的原型链的基础之上的，我们本篇就将对原型链以及面向对象编程最常用到的继承进行刨析。 继承简介在 JavaScript 的中的面向对象编程，继承是给构造函数之间建立关系非常重要的方式，根据 JavaScript 原型链的特点，其实继承就是更改原本默认的原型链，形成新的原型链的过程。 复制的方式进行继承复制的方式进行继承指定是对象与对象间的浅复制和深复制，这种方式到底算不算继承的一种备受争议，我们也把它放在我们的内容中，当作一个 “不正经” 的继承。 浅复制创建一个浅复制的函数，第一个参数为复制的源对象，第二个参数为目标对象。 浅复制123456789101112131415161718192021222324// 浅复制方法function extend(p, c = &#123;&#125;) &#123; for (let k in p) &#123; c[k] = p[k]; &#125; return c;&#125;// 源对象let parent = &#123; a: 1, b: function() &#123; console.log(1); &#125;&#125;;// 目标对象let child = &#123; c: 2&#125;;// 执行extend(parent, child);console.log(child); // &#123; c: 2, a: 1, b: ƒ &#125; 上面的 extend 方法在 ES6 标准中可以直接使用 Object.assign 方法所替代。 深复制可以组合使用 JSON.stringify 和 JSON.parse 来实现，但是有局限性，不能处理函数和正则类型，所以我们自己实现一个方法，参数与浅复制相同。 深复制1234567891011121314151617181920212223242526272829303132// 深复制方法function extendDeeply(p, c = &#123;&#125;) &#123; for (let k in p) &#123; if (typeof p[k] === 'object' &amp;&amp; typeof p[k] !== null) &#123; c[k] = p[k] instanceof Array ? [] : &#123;&#125;; extendDeeply(p[k], c[k]); &#125; else &#123; c[k] = p[k]; &#125; &#125; return c;&#125;// 源对象let parent = &#123; a: &#123; b: 1 &#125;, b: [1, 2, 3], c: 1, d: function() &#123; console.log(1); &#125;&#125;;// 执行let child = extendDeeply(parent);console.log(child); // &#123; a: &#123;b: 1&#125;, b: [1, 2, 3], c: 1, d: ƒ &#125;console.log(child.a === parent.a); // falseconsole.log(child.b === parent.b); // falseconsole.log(child.d === parent.d); // true 在上面可以看出复制后的新对象 child 的 a 属性和 b 的引用是独立的，与 parent 的 a 和 b 毫无关系，实现了深复制，但是 extendDeeply 函数并没有对函数类型做处理，因为函数内部执行相同的逻辑指向不同引用是浪费内存的。 原型替换原型替换是继承当中最简单也是最直接的方式，即直接让父类和子类共用同一个原型对象，一般有两种实现方式。 原型替换1234567891011// 父类function Parent() &#123;&#125;// 子类function Child() &#123;&#125;// 简单粗暴的写法Child.prototype = Parent.prototype;// 另一种种实现方式Object.setPrototypeOf(Child.prototype, Parent.prototype); 上面这种方式 Child 的原型被替换掉，Child 的实例可以直接调用 Parent 原型上的方法，实现了对父类原型方法的继承。 上面第二种方式使用了 Object.setPrototypeOf 方法，该方法是将传入第一个参数对象的原型设置为第二个参数传入的对象，所以我们第一个参数传入的是 Child 的原型，将 Child 原型的原型设置成了 Parent 的原型，使父、子类原型链产生关联，Child 的实例继承了 Parent 原型上的方法，在 NodeJS 中的内置模块 util 中用来实现继承的方法 inherits，底层就是使用这种方式实现的。 缺点：父类的实例也同样可以调用子类的原型方法，我们希望继承是单向的，否则无法区分父、子类关系，这种方式一般是不可取的。 原型链继承原型链继承的思路是子类的原型的原型是父类的原型，形成了一条原型链，建立子类与父类原型的关系。 原型链继承1234567891011// 父类function Parent(name) &#123; this.name = name; this.hobby = ['basketball', 'football'];&#125;// 子类function Child() &#123;&#125;// 继承Child.prototype = new Parent(); 上面用 Parent 的实例替换了 Child 自己的原型，由于父类的实例原型直接指向 Parent.prototype，所以也使父、子类原型链产生关联，子类实例继承了父类原型的方法。 缺点 1：只能继承父类原型上的方法，却无法继承父类上的属性。缺点 2：由于原型对象被替换，原本原型的 constructor 属性丢失。缺点 3：如果父类的构造函数中有属性，则创建的父类的实例也会有这个属性，用这个实例的作为子类的原型，这个属性就变成了所有子类实例所共有的，这个属性可能是多余的，并不是我们想要的，也可能我们希望它不是共有的，而是每个实例自己的。 构造函数继承构造函数继承又被国内的开发者叫做 “经典继承”。 构造函数继承123456789101112// 父类function Parent(name) &#123; this.name = name;&#125;// 子类function Child() &#123; Parent.apply(this, arguments);&#125;let c = new Child('Panda');console.log(c); // &#123; name: 'Panda' &#125; 构造函数继承的原理就是在创建 Child 实例的时候执行了 Child 构造函数，并借用 call 或 apply 在内部执行了父类 Parent，并把父类的属性创建给了 this，即子类的实例，解决了原型链继承不能继承父类属性的缺点。 缺点：子类的实例只能继承父类的属性，却不能继承父类的原型的方法。 构造函数原型链组合继承为了使子类既能继承父类原型的方法，又能继承父类的属性到自己的实例上，就有了这种组合使用的方式。 构造函数原型链组合继承1234567891011121314151617181920// 父类function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function() &#123; console.log(this.name);&#125;;// 子类function Child() &#123; Parent.apply(this, arguments);&#125;// 继承Child.prototype = new Parent();let c = new Child('Panda');console.log(c); // &#123; name: 'Panda' &#125;c.sayName(); // Panda 这种继承看似完美，但是之前 constructor 丢失和子类原型上多余共有属性的问题还是没有解决，在这基础上又产生了新的问题。 缺点：父类被执行了两次，在使用 call 或 apply 继承属性时执行一次，在创建实例替换子类原型时又被执行了一次。 原型式继承原型式继承主要用来解决用父类的实例替换子类的原型时共有属性的问题，以及父类构造函数执行两次的问题，也就是说通过原型式继承能保证子类的原型是 “干净的”，而保证只在继承父类的属性时执行一次父类。 原型式继承12345678910111213141516171819202122// 父类function Parent(name) &#123; this.name = name;&#125;// 子类function Child() &#123; Parent.apply(this, arguments);&#125;// 继承函数function create(obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125;// 继承Child.prototype = create(Parent.prototype);let c = new Child('Panda');console.log(c); // &#123; name: 'Panda' &#125; 原型式继承其实是借助了一个中间的构造函数，将中间构造函数 F 的 prototype 替换成了父类的原型，并创建了一个 F 的实例返回，这个实例是不具备任何属性的（干净的），用这个实例替换子类的原型，因为这个实例的原型指向 F 的原型，F 的原型同时又是父类的原型对象，所以子类实例继承了父类原型的方法，父类只在创建子类实例的时候执行了一次，省去了创建父类实例的过程。 原型式继承在 ES5 标准中被封装成了一个专门的方法 Object.create，该方法的第一个参数与上面 create 函数的参数相同，即要作为原型的对象，第二个参数则可以传递一个对象，会把对象上的属性添加到这个原型上，一般第二个参数用来弥补 constructor 的丢失问题，这个方法不兼容 IE 低版本浏览器。 寄生式继承寄生式继承就是用来解决子统一为原型式继承中返回的对象统一添加方法的问题，只是在原型式继承的基础上做了小小的修改。 寄生式继承123456789101112131415161718192021222324252627282930// 父类function Parent(name) &#123; this.name = name;&#125;// 子类function Child() &#123; Parent.apply(this, arguments);&#125;// 继承函数function create(obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125;// 将子类方法私有化函数function creatFunction(obj) &#123; // 调用继承函数 let clone = create(obj); // 子类原型方法（多个） clone.sayName = function() &#123;&#125;; clone.sayHello = function() &#123;&#125;; return clone;&#125;// 继承Child.prototype = creatFunction(Parent.prototype); 缺点：因为寄生式继承最后返回的是一个对象，如果用一个变量直接来接收它，那相当于添加的所有方法都变成这个对象自身的了，如果创建了多个这样的对象，无法实现相同方法的复用。 寄生组合式继承寄生组合式继承123456789101112131415161718192021222324252627282930313233343536373839404142434445// 父类function P(name, age) &#123; this.name = name; this.age = age;&#125;P.prototype.headCount = 1;P.prototype.eat = function() &#123; console.log('eating...');&#125;;// 子类function C(name, age) &#123; P.apply(this, arguments);&#125;// 寄生组合式继承方法function myCreate(Child, Parent) &#123; function F() &#123;&#125; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; // 让 Child 子类的静态属性 super 和 base 指向父类的原型 Child.super = Child.base = Parent.prototype;&#125;// 调用方法实现继承myCreate(C, P);// 向子类原型添加属性方法，因为子类构造函数的原型被替换，所以属性方法仍然在替换之后C.prototype.language = 'javascript';C.prototype.work = function() &#123; console.log('writing code use ' + this.language);&#125;;C.work = function() &#123; this.super.eat();&#125;;// 验证继承是否成功let f = new C('nihao', 16);f.work();C.work();// writing code use javascript// eating... 寄生组合式继承基本规避了其他继承的大部分缺点，应该比较强大了，也是平时使用最多的一种继承，其中 Child.super 方法的作用是为了在调用子类静态属性的时候可以调用父类的原型方法。 缺点：子类没有继承父类的静态方法。 class…extends… 继承在 ES6 规范中有了类的概念，使继承变得容易，在规避上面缺点的完成继承的同时，又在继承时继承了父类的静态属性。 class...extends... 继承123456789101112131415161718192021222324252627282930313233// 父类class P &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayName() &#123; console.log(this.name); &#125; static sayHi() &#123; console.log('Hello'); &#125;&#125;// 子类继承父类class C extends P &#123; constructor(name, age) &#123; supper(name, age); // 继承父类的属性 &#125; sayHello() &#123; P.sayHi(); &#125; static sayHello() &#123; super.sayHi(); &#125;&#125;let c = new C('jack', 18);c.sayName(); // jackc.sayHello(); // HelloC.sayHi(); // HelloC.sayHello(); // Hello 在子类的 constructor 中调用 supper 可以实现对父类属性的继承，父类的原型方法和静态方法直接会被子类继承，在子类的原型方法中使用父类的原型方法只需使用 this 或 supper 调用即可，此时 this 指向子类的实例，如果在子类的静态方法中使用 this 或 supper 调用父类的静态方法，此时 this 指向子类本身。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"继承","slug":"继承","permalink":"https://www.pandashen.com/tags/继承/"}]},{"title":"浅谈 JavaScript 原型链","date":"2017-07-09T05:18:56.000Z","path":"2017/07/09/20170709131856/","text":"概述在 JavaScript 中有种说法叫 “万物皆对象”，就是说无论是构造函数创建的实例，构造函数本身、原型对象、数组、函数本质上都是对象，都拥有 __proto__ 属性，即隐式原型，所有函数都拥有 prototype 属性，即显式原型（仅限函数），原型对象（prototype 属性指向的对象），在定义函数时就被创建。 原型链指向概述在 JavaScript 中整个原型链及查找机制用下图可以完整的表示出来。 JS 原型链 原型链指向： 1、通过字面量和 new Object() 所创建的对象，他们是构造函数是 function Object() 的实例，Object 构造函数的 prototype 指向原型对象 Object.prototype，Object.prototype 的 constructor 指向构造函数 Object，而实例的 __proto__ 也指向 Object.prototype，Object.prototype 的 __proto__ 指向 null，所以 Object.prototype 也叫做顶级原型对象。 2、上图中 new Foo() 创建的对象是构造函数 function Foo() 的实例，Foo 的 prototype 指向原型对象 Foo.prototype，Foo.prototype 的 constructor 指向构造函数 Foo，而实例的 __proto__ 也指向 Foo.prototype，并且 Foo.prototype 虽然是原型对象，但也是对象，所以是构造函数 Object 的实例，__proto__ 指向顶级原型对象 Object.prototype。 3、数组的构造函数是 function Array() 原型链的指向与其他除 Object 以外的构造函数相同，Array.prototype 的 __proto__ 也指向顶级原型对象 Object.prototype，每一个数组都是 Array 的实例，__proto__ 都指向 Array.prototype。 4、Object、Array、Foo 等构造函数的本质也是对象，他们的构造函数是 function Function()，Function 的 prototype 指向 Function.prototype，Function.prototype 的 constructor 指向 Function，所有的构造函数的 __proto__ 都指向 Function.prototype，包括 Function 本身，也就是说构造函数 Function 是由自己构造的，Function.prototype 的 __proto__ 同样指向顶级原型对象 Object.prototype。 prototype 原型对象prototype 是函数的一个属性，属性的值指向了一个对象，所以，只有函数才有 prototype 原型对象。 12345678910111213function Person(name, age) &#123; this.name = name; this.age = age;&#125;typeof Person.prototype; // objectPerson.prototype.constructor; // Person &#123;&#125;Person.prototype.job = 'qianduan';var p1 = new Person('panda', 18);var p2 = new Person('shen', 20);p1.constructor.prototype; // 实例对象查找构造函数原型对象的方法 一般会把对象共有的属性和方法都放在构造函数的原型对象上。 实例、构造函数、原型对象的关系构造函数的原型 prototype 属性指向一个原型对象，实例也可以通过 __proto__ 指向原型对象，但本质上实例和构造函数之间是没有关系的。 12345678function Person(name, age) &#123; this.name = name; this.age = age;&#125;var p = new Person('nihao', 16);p.constructor = &#123; name: 'haha' &#125;;p.name; // nihao 上面的代码中改变了构造函数的值为一个对象，对象中的属性 name 并没有影响实例的 name 属性值。 实例属性 __proto__上面访问实例 p 的原型，实际使用 p.constructor.prototype 去找原型对象，当构造函数的值改变后是找不到原型对象的，所以实例并不是通过 constructor.prototype 去查找原型对象的，而是通过每一个实例都有的 __proto__ 属性，这个属性指向创建实例的构造函数原本的原型对象，这个属性不是标准，在 IE 下不存在。 123456789function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.job = 'qianduan';var p = new Person('nihao', 16);p.__proto__.job; // qianduan 当构造函数的 prototype 属性值被改变之后，在之前创建的实例的 __proto__ 属性值的仍然引用原型对象，所以对构造函数改变前创建的实例是没有影响的，会影响后面创建的实例。 原型链查找机制实例对象在调用了一个属性或方法时，如果对象本身没有这个属性或方法，会去自己的原型对象查找，也就是 __proto__ 中查找，如果原型对象中没有，去原型对象的原型对象查找，一般（原型链没有被修改）情况下就是去 __proto__ 的 __proto__ 中查找，即顶级原型对象 Object.prototype，如果实例对象本身有这个属性，则直接输出，不再向上查找，如果对象本身和原型对象具有同名属性，则会屏蔽掉原型对象的属性。 123456789101112function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.job = 'qianduan';var p = new Person('nihao', 16);p.job; // qianduanp.job = 'houtai';p.job; // houtaip.__proto__.job; // qianduan 总结原型链的指向及原型链的查找机制是 JavaScript 中非常重要的基础知识，理解原型链是更深入了解继承和面向对象编程的必经之路。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"原型链","slug":"原型链","permalink":"https://www.pandashen.com/tags/原型链/"}]},{"title":"封装一个 cookie 功能","date":"2017-07-02T10:26:45.000Z","path":"2017/07/02/20170702182645/","text":"cookie 概述由于浏览器无状态的特性，cookie 技术应运而生，cookie 是一个会话级的存储，用于某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密），通过访问某些服务器而特定携带的存储信息，不支持跨域，在浏览器清空缓存或超过有效期后失效。 JavaScript 中的 cookie在 JavaScript 中操作 cookie 通过 document.cookie 来实现： 操作 cookie1document.cookie = 'key1=value1; key2=value2; path=/; domain=pandashen.com'; 在传递 cookie 过程中，使用上面这样的方式对于参数的传递和拼接都是不太方便的，下面我们来封装一个自己的 cookie 功能。 封装一个 cookie 模块整体思路设计12345678910111213141516(function() &#123; var kvTool = &#123; maxage: 'max-age', path: 'path', domain: 'domain', secure: 'secure' &#125;; function setCookie() &#123;&#125; function getCookie() &#123;&#125; var cookieUtil = function() &#123;&#125;; window.cookieUtil = cookieUtil;&#125;)(); 我们封装了一个自执行函数，在内部将 cookie 基本参数的键名存入 kvTool 对象当中设计的 options 参数的键名一一对应，并单独声明一个设置 cookie 的方法 setCookie 和获取 cookie 的方法 getCookie，最后用函数表达式的形式声明一个 cookieUtil 暴露给全局作用域。 2、setCookie 方法的实现123456789101112131415161718192021222324252627(function() &#123; var kvTool = &#123; maxage: 'max-age', path: 'path', domain: 'domain', secure: 'secure' &#125;; function setCookie(k, v, options) &#123; if (!options) &#123; document.cookie = k + '=' + v; &#125; else &#123; var tmp = []; for (var key in options) &#123; // &#123; path='/', domain='pandashen.com' &#125; tmp.push(kvTool[key] + '=' + options[key]); &#125; document.cookie = k + '=' + v + '; ' + tmp.join('; '); &#125; &#125; function getCookie() &#123;&#125; var cookieUtil = function() &#123;&#125;; window.cookieUtil = cookieUtil;&#125;)(); setCookie 方法的有三个参数： k：cookie 发送信息的键 v：cookie 发送信息的值 options：cookie 的基本参数 当没有传入基本参数 options 的时候直接将 cookie 发送信息的键值拼接赋值给 document.cookie。 传入基本参数 options 的时候取出 kvTool 真正的键名，并和 cookie 发送的信息的键值拼接成 k=v; k=v 形式的字符串赋值给 document.cookie。 getCookie 方法的实现123456789101112131415161718192021222324252627282930313233343536373839(function() &#123; var kvTool = &#123; maxage: 'max-age', path: 'path', domain: 'domain', secure: 'secure' &#125;; function setCookie(k, v, options) &#123; if (!options) &#123; document.cookie = k + '=' + v; &#125; else &#123; var tmp = []; for (var key in options) &#123; // &#123; path='/', domain='pandashen.com' &#125; tmp.push(kvTool[key] + '=' + options[key]); &#125; document.cookie = k + '=' + v + '; ' + tmp.join('; '); &#125; &#125; function getCookie(k) &#123; var strCookie = document.cookie; // 形如: 'k=v; k=v; k=v; k=v' var kvs = strCookie.split(';').map(v =&gt; v.trim()); var objCookie = &#123;&#125;; kvs.forEach(v =&gt; &#123; var kv = v.split('='); objCookie[kv[0]] = kv[1]; &#125;); return objCookie[k]; &#125; var cookieUtil = function() &#123;&#125;; window.cookieUtil = cookieUtil;&#125;)(); getCookie 方法只有一个参数，即我们要获取的 cookie 的某一个属性的键，函数会将对应的值返回。 其实对外暴露的方法只有 cookieUtil，所以 setCookie 和 getCookie 都是在 cookieUtil 内部调用的。 cookieUtil 方法的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function() &#123; var kvTool = &#123; maxage: 'max-age', path: 'path', domain: 'domain', secure: 'secure' &#125;; function setCookie(k, v, options) &#123; if (!options) &#123; document.cookie = k + '=' + v; &#125; else &#123; var tmp = []; for (var key in options) &#123; // &#123; path='/', domain='pandashen.com' &#125; tmp.push(kvTool[key] + '=' + options[key]); &#125; document.cookie = k + '=' + v + '; ' + tmp.join('; '); &#125; &#125; function getCookie(k) &#123; var strCookie = document.cookie; // 形如: 'k=v; k=v; k=v; k=v' var kvs = strCookie.split(';').map(v =&gt; v.trim()); var objCookie = &#123;&#125;; kvs.forEach(v =&gt; &#123; var kv = v.split('='); objCookie[kv[0]] = kv[1]; &#125;); return objCookie[k]; &#125; var cookieUtil = function(key, value, options) &#123; if (!value) &#123; // 没有传参, 得到数据 return getCookie(key); &#125; else &#123; setCookie(key, value, options); &#125; &#125;; window.cookieUtil = cookieUtil;&#125;)(); cookieUtil 的逻辑为当 key 和 value 两个参数都传入时，调用 setCookie 来设置 cookie，只传入 key 时，调用 getCookie 获取 cookie 对应参数的值。 上面就是我们封装的 cookie 功能模块来帮主我们设置和获取 cookie，之所以封装这个功能最终的目的就是让我们更方便的通过 JavaScript 来操作 cookie。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.pandashen.com/tags/HTTP/"},{"name":"cookie/session","slug":"cookie-session","permalink":"https://www.pandashen.com/tags/cookie-session/"}]},{"title":"简单封装一个靠谱的检测数据类型模块","date":"2017-06-30T08:22:09.000Z","path":"2017/06/30/20170630162209/","text":"简介本篇主要对 JavaScript 数据类型检测做一些介绍，并封装一个相对靠谱的数据类型检测模块。 常见检测数据类型的三种方式typeoftypeof 可以满足大部分基本数据类型的检测，如 number、string、boolean、undefined 和 symbol，对于 null 使用 typeof 则会直接返回 object，对于引用类型的检测，只有 function 是可以正确返回的，其他都返回 object，可以看出 typeof 只适用于部分场景，并不是那么的靠谱。 instanceofinstanceof 本质是用来检测一个对象是不是一个构造函数的实例，因为基本数据类型是基本包装类，已经不是对象了，所以 instanceof 是用不适合检测基本数据类型，instanceof 也有一个缺点，用 instanceof 检测一个对象原型链上的其他原型对象对应的构造函数时，也返回 true，所以说 instanceof 也不能保证绝对的准确。 Object.prototype.toString.callObject.prototype.toString.call 在我们传入数据的时候，可以 [object Object] 的形式精准的返回给我们当前的数据类型，如 [object Array] 等等，我们本次要封装的类型检测工具就是基于这个方法。 封装检测类型模块最终在全局会产生一个 checkTypes 的对象，上面对应着检测不同类型的方法，每个方法的参数都为被检测数据，返回值都为布尔值。 检测类型模块12345678910111213141516171819202122232425262728293031323334(function() &#123; // 存储检测数据类型方法的对象 var checkTypesFun = &#123;&#125;; // 涉及到的数据类型 var types = [ 'String', 'Number', 'Boolean', 'Undefined', 'Null', 'Symbol', 'Function', 'Array', 'Object', 'RegExp' ]; // 通过闭包返回检测单个类型的函数 function isType(type) &#123; return function(content) &#123; var result = Object.prototype.toString.call(content); return type === result.replace(/\\[object\\s|\\]/g, ''); &#125;; &#125; types.forEach(function(type) &#123; // 构建检测不同类型的方法，返回布尔值 checkTypesFun['is' + type] = isType(type); &#125;); // 将检测类型模块暴露在全局 window.checkTypes = checkTypesFun;&#125;)(); 使用方法上面代码是自执行函数，执行后会将 checkTypes 对象暴露在全局，可以直接使用。 使用模块12345checkTypes.isString('123'); // truecheckTypes.isNumber('123'); // falsecheckTypes.isArray([1, 2, 3]); // truecheckTypes.isRegExp(/^[0-9]$/); // truecheckTypes.isObject(&#123;&#125;); // true 可以使用 console.log(checkTypes) 查看所有的方法。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"数据类型检测","slug":"数据类型检测","permalink":"https://www.pandashen.com/tags/数据类型检测/"}]},{"title":"前端优化 —— 函数的节流和防抖","date":"2017-06-12T05:09:42.000Z","path":"2017/06/12/20170612130942/","text":"前言在前端开发当中我们经常会绑定一些事件触发的某些程序执行，有时这些事件会连续触发，如浏览器窗口的 scroll、resize，输入框的 keyup、input，以及 click 事件在连续点击时连续发送请求等等，这些情况有些会严重影响前端性能，有些会增加服务器压力，使用户体验大打折扣，而函数节流和防抖就是为了解决这样的问题。 函数节流 throtter函数节流：当持续发生事件时，保证在一个固定的时间间隔只执行一次真正的事件处理程序，通俗的说就像 “节流” 的名字一样，打开水龙头时要秉承勤俭节约的原则，把阀门关小，最好是达到在固定间隔内水一滴一滴的往下流。 节流函数的时序图 函数节流时序图 从图中可以看出，连续触发事件时，真正执行事件处理程序的间隔是固定的，多次触发，也只会在某一个时间间隔内触发一次，由于事件处理函数内部执行逻辑各不相同，我们就封装一版可通用的节流函数。 节流函数的封装文件：throtter.js123456789101112131415161718// 节流函数const throtter = (func, delay = 60) =&gt; &#123; // 锁的标识 let lock = false; // 返回一个事件处理函数 return (...args) =&gt; &#123; // 如果 lock 为 true 则跳出 if (lock) return; // 执行函数并更改锁的状态 func(...args); lock = true; // 添加定时器，在到达时间间隔时重置锁的状态 setTimeout(() =&gt; lock = false, delay); &#125;&#125; throtter 函数有两个参数，第一个参数为在事件触发时真正要执行的函数，第二个参数为定义的间隔时间，在函数执行时定义了 lock 的初始值，通过闭包返回一个函数作为事件处理函数，在返回的函数内部判断 lock 状态并确定执行真正的函数 func 还是跳出，每次执行 func 后会更改 lock 状态，通过定时器在规定的时间间隔内重置 lock，这就是函数节流的原理。 验证节流函数文件：throtter-test.js12// 使用节流函数document.addEventListener('scroll', throtter(console.log)); 上面我们给 document 对象添加了滚动事件，并不断的打印事件对象，事件处理函数的默认参数为事件对象，从执行效果应该可以看出，平均每 60ms 才会触发一次事件，达到了优化性能的目的，如果想让真正执行的函数 func 传入更多的参数，只需如下处理。 文件：throtter-test.js12345678// a b 为函数要传入的参数let a = 1, b = 2;// 返回事件处理函数const func = throtter(console.log);// 添加事件监听document.addEventListener('scroll', e =&gt; func(e, a, b)); 节流函数一般用于 scroll、resize 事件的情况较多，因为这些事件的触发是连续性的，需要在一个时间间隔内只触发一次。 函数防抖 debounce函数防抖：当持续发生事件时，事件只在上一次触发后的一段时间内没再触发事件，才会真正的执行事件处理逻辑，如果每两次触发的间隔小于这个时间，则不执行事件逻辑。 防抖函数的时序图 函数防抖时序图 从图中可以看出，连续触发事件时并没有执行事件处理函数，只有在某一阶段连续触发后的最后一次才执行，也就是上一次触发的时间间隔要大于设定值才执行，同样的，事件处理函数内部执行逻辑各不相同，我们就封装一版可通用的防抖函数。 防抖函数的封装文件：debounce.js12345678910// 防抖函数const dobounce = (func, delay = 300, timer = null) =&gt; &#123; return (...args) =&gt; &#123; // 清除定时器 clearInterval(timer); // 在定时器到时后执行事件处理函数 timer = setTimeout(() =&gt; func(...args), delay); &#125;&#125; dobounce 函数有三个参数，第一个参数为在事件触发时真正要执行的函数，第二个参数为执行事件的延迟时间，第三个参数为定时器 ID 的初始值，执行 dobounce 通过闭包返回了事件处理函数，在处理函数内部先清除定时器，然后定义定时器并将 ID 赋值给 timer，如果事件连续触发，则会不断的清除定时器，直到有一次触发间隔超过了设定延时时间 delay，才会真正执行 func。 验证防抖函数文件：index.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;函数防抖&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" id=\"ipt\"&gt;&lt;/body&gt;&lt;/html&gt; 文件：debounce-test.js12345// 使用防抖函数let ipt = document.querySelector('#ipt');// 添加事件监听ipt.addEventListener('keyup', debounce(console.log)); 上面的功能跟 throtter 类似，真正执行事件处理函数时打印事件对象，通过验证，连续输入触发 keyup 事件，上一次触发和下一次触发间隔时间必须大于 300ms 才会执行打印事件对象的逻辑，如果想传入多个参数套路相同。 文件：debounce-test.js1234567891011// 获取 dom 元素let ipt = document.querySelector('#ipt');// a b 为函数要传入的参数let a = 1, b = 2;// 返回事件处理函数const func = debounce(console.log);// 添加事件监听ipt.addEventListener('keyup', e =&gt; func(e, a, b)); 防抖函数一般用于输入框事件，常用场景就是搜索或查询，如果不使用防抖会连续发送请求，增加服务器的压力，使用防抖后，会在用户输入要查询的关键词后才发送请求，这也更符合用户的习惯，例如百度搜索，就是这样实现的。 总结“节流” 和 “防抖” 是前端在项目中经常使用的优化手段，代码虽然不多，但是确是前端面试 “出镜率” 非常高的知识点，从而能看出它们的重要性，所以建议前端同学们一定要知道，并能手写，这是 “一箭双雕” 的事，可以用来通过面试，也可以因为工作中遇到直接就写而提高工作效率。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.pandashen.com/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://www.pandashen.com/tags/性能优化/"}]},{"title":"Hexo 中 Markdown 特殊字符的处理方法","date":"2017-05-19T05:59:03.000Z","path":"2017/05/19/20170519135903/","text":"问题描述在 Hexo 搭建的博客中对文章进行编写，经常会用到一些特殊字符需要转译，比如 -、.、空格、制表符等等，在正常情况下可以使用 \\ 进行转译，但是有一些字符无法转译，使用后在执行 hexo server 命令的时候会报错。 报错信息： Unhandled rejection Template render error: (unknown path) [Line 7, Column 23] Error: Unable to call `worldcount`, which is undefined or falsey...... 解决方案报错的原因是，Hexo 编译时发生错误，可能是文章中存在特殊字符，如：&#123; &#91; &#40; &#41; &#93; &#125; 等等。如下面这段代码： 在页面中： 1&#123;&#123; worldcount(post.content) &#125;&#125; 在 Markdown 中： 1&amp;#123;&amp;#123; worldcount&amp;#40;post.content&amp;#41; &amp;#125;&amp;#125; 在 Markdown 中使用 \\ 无法转译的字符需要使用字符的命名实体或十进制编码，如上面代码中。 注意：需要转义的字符只是文本中的特殊字符，代码块中的特殊字符无需转译或使用转译字符。 常见特殊字符常用特殊字符转译字符对照表： 特殊符号 命名实体 十进制编码 空格 &#38;&#110;&#98;&#115;&#112;&#59; &#38;&#35;&#49;&#54;&#48;&#59; 全角空格 &#38;&#101;&#109;&#115;&#112;&#59; &#38;&#35;&#49;&#50;&#50;&#56;&#56;&#59; ‘ &#38;&#97;&#112;&#111;&#115;&#59; &#38;&#35;&#51;&#57;&#59; “ &#38;&#113;&#117;&#111;&#116;&#59; &#38;&#35;&#51;&#52;&#59; ( — &#38;&#35;&#52;&#48;&#59; ) — &#38;&#35;&#52;&#49;&#59; &lt; &#38;&#108;&#116;&#59; &#38;&#35;&#54;&#48;&#59; &gt; &#38;&#103;&#116;&#59; &#38;&#35;&#54;&#50;&#59; [ — &#38;&#35;&#57;&#49;&#59; ] — &#38;&#35;&#57;&#51;&#59; { — &#38;&#35;&#49;&#50;&#51;&#59; } — &#38;&#35;&#49;&#50;&#53;&#59; ´ &#38;&#97;&#99;&#117;&#116;&#101;&#59; &#38;&#35;&#49;&#56;&#48;&#59; ° &#38;&#100;&#101;&#103;&#59; &#38;&#35;&#49;&#55;&#54;&#59; ® &#38;&#114;&#101;&#103;&#59; &#38;&#35;&#49;&#55;&#52;&#59; © &#38;&#99;&#111;&#112;&#121;&#59; &#38;&#35;&#49;&#54;&#57;&#59; 常用数学转译字符对照表： 特殊符号 命名实体 十进制编码 ≤ &#38;&#108;&#101;&#59; &#38;&#35;&#56;&#56;&#48;&#52;&#59; ≥ &#38;&#103;&#101;&#59; &#38;&#35;&#56;&#56;&#48;&#53;&#59; ≈ &#38;&#97;&#115;&#121;&#109;&#112;&#59; &#38;&#35;&#56;&#55;&#55;&#51;&#59; ≠ &#38;&#110;&#101;&#59; &#38;&#35;&#56;&#56;&#48;&#48;&#59; ∩ &#38;&#99;&#97;&#112;&#59; &#38;&#35;&#56;&#55;&#52;&#53;&#59; ∪ &#38;&#99;&#117;&#112;&#59; &#38;&#35;&#56;&#55;&#52;&#54;&#59; ∠ &#38;&#97;&#110;&#103;&#59; &#38;&#35;&#56;&#55;&#51;&#54;&#59; ∞ &#38;&#105;&#110;&#102;&#105;&#110;&#59; &#38;&#35;&#56;&#55;&#51;&#52;&#59; ± &#38;&#112;&#108;&#117;&#115;&#109;&#110;&#59; &#38;&#35;&#49;&#55;&#55;&#59; √ &#38;&#114;&#97;&#100;&#105;&#99;&#59; &#38;&#35;&#56;&#55;&#51;&#48;&#59; ∑ &#38;&#115;&#117;&#109;&#59; &#38;&#35;&#56;&#55;&#50;&#50;&#59; ∫ &#38;&#105;&#110;&#116;&#59; &#38;&#35;&#56;&#55;&#52;&#55;&#59; Δ &#38;&#68;&#101;&#108;&#116;&#97;&#59; &#38;&#35;&#57;&#49;&#54;&#59; 常用希腊字母转译字符对照表： 特殊符号 命名实体 十进制编码 Φ &#38;&#80;&#104;&#105;&#59; &#38;&#35;&#57;&#51;&#52;&#59; Ω &#38;&#79;&#109;&#101;&#103;&#97;&#59; &#38;&#35;&#57;&#51;&#55;&#59; α &#38;&#97;&#108;&#112;&#104;&#97;&#59; &#38;&#35;&#57;&#52;&#53;&#59; β &#38;&#98;&#101;&#116;&#97;&#59; &#38;&#35;&#57;&#52;&#54;&#59; γ &#38;&#103;&#97;&#109;&#109;&#97;&#59; &#38;&#35;&#57;&#52;&#55;&#59; δ &#38;&#100;&#101;&#108;&#116;&#97;&#59; &#38;&#35;&#57;&#52;&#56;&#59; ε &#38;&#101;&#112;&#115;&#105;&#108;&#111;&#110;&#59; &#38;&#35;&#57;&#52;&#57;&#59; ζ &#38;&#122;&#101;&#116;&#97;&#59; &#38;&#35;&#57;&#53;&#48;&#59; η &#38;&#101;&#116;&#97;&#59; &#38;&#35;&#57;&#53;&#49;&#59; θ &#38;&#116;&#104;&#101;&#116;&#97;&#59; &#38;&#35;&#57;&#53;&#50;&#59; λ &#38;&#108;&#97;&#109;&#98;&#100;&#97;&#59; &#38;&#35;&#57;&#53;&#53;&#59; μ &#38;&#109;&#117;&#59; &#38;&#35;&#57;&#53;&#54;&#59; ξ &#38;&#120;&#105;&#59; &#38;&#35;&#57;&#53;&#56;&#59; π &#38;&#112;&#105;&#59; &#38;&#35;&#57;&#54;&#48;&#59; ρ &#38;&#114;&#104;&#111;&#59; &#38;&#35;&#57;&#54;&#49;&#59; σ &#38;&#115;&#105;&#103;&#109;&#97;&#59; &#38;&#35;&#57;&#54;&#51;&#59; φ &#38;&#112;&#104;&#105;&#59; &#38;&#35;&#57;&#54;&#54;&#59; ψ &#38;&#112;&#115;&#105;&#59; &#38;&#35;&#57;&#54;&#56;&#59; ω &#38;&#111;&#109;&#101;&#103;&#97;&#59; &#38;&#35;&#57;&#54;&#57;&#59; ∂ &#38;&#112;&#97;&#114;&#116;&#59; &#38;&#35;&#56;&#55;&#48;&#54;&#59; ∅ &#38;&#101;&#109;&#112;&#116;&#121;&#59; &#38;&#35;&#56;&#55;&#48;&#57;&#59;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.pandashen.com/tags/Hexo/"}]}]