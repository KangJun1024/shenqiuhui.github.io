<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?HIpscSc60YSz75aC"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    
    <title>NodeJS —— 流的原理分析与简易实现 | Shen&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="NodeJS,源码分析,Stream">
    <meta name="description" content="前言在之前的博客中已经了解了流的基本用法，这篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 ReadStream，流的基本用法请看这里 NodeJS —— Stream 的基本使用。">
<meta name="keywords" content="NodeJS,源码分析,Stream">
<meta property="og:type" content="article">
<meta property="og:title" content="NodeJS —— 流的原理分析与简易实现">
<meta property="og:url" content="https://www.overtaking.top/2018/07/04/20180704175217/index.html">
<meta property="og:site_name" content="Shen&#39;s Blog">
<meta property="og:description" content="前言在之前的博客中已经了解了流的基本用法，这篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 ReadStream，流的基本用法请看这里 NodeJS —— Stream 的基本使用。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.overtaking.top/2018/07/04/20180704175217/stream.png">
<meta property="og:updated_time" content="2019-04-23T03:13:59.836Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NodeJS —— 流的原理分析与简易实现">
<meta name="twitter:description" content="前言在之前的博客中已经了解了流的基本用法，这篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 ReadStream，流的基本用法请看这里 NodeJS —— Stream 的基本使用。">
<meta name="twitter:image" content="https://www.overtaking.top/2018/07/04/20180704175217/stream.png">
    
        <link rel="alternate" type="application/atom+xml" title="Shen&#39;s Blog" href="/rss2.xml">
    

    
    
<link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-next.png">



<link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32-next.png">



<link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16-next.png">



<link rel="mask-icon" href="/img/logo.svg" color>






    

    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Panda Shen</h5>
          <a href="mailto:pandashen821@163.com" title="pandashen821@163.com" class="mail">pandashen821@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/link">
                <i class="icon icon-lg icon-link"></i>
                链接
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about">
                <i class="icon icon-lg icon-user"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/shenqiuhui" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.pandashen.cn" target="_blank">
                <i class="icon icon-lg icon-weixin"></i>
                WeChat
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/shenqiuhui" target="_blank">
                <i class="icon icon-lg icon-twitter"></i>
                Twitter
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">NodeJS —— 流的原理分析与简易实现</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">NodeJS —— 流的原理分析与简易实现</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-07-04T09:52:17.000Z" itemprop="datePublished" class="page-time">
  2018-07-04
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/NodeJS/">NodeJS</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <!-- <h4>TOC</h4> -->
            <h4>文章目录</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#可读流的实现（流动模式）"><span class="post-toc-number">2.</span> <span class="post-toc-text">可读流的实现（流动模式）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ReadStream-类创建"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">ReadStream 类创建</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#打开文件方法-open-的实现"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">打开文件方法 open 的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关闭文件方法-destroy-的实现"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">关闭文件方法 destroy 的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读取文件方法-read-的实现"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">读取文件方法 read 的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#暂停、恢复读取-pause-和-resume"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">暂停、恢复读取 pause 和 resume</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#验证可读流（流动模式）ReadStream"><span class="post-toc-number">3.</span> <span class="post-toc-text">验证可读流（流动模式）ReadStream</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#可读流的实现（暂停模式）"><span class="post-toc-number">4.</span> <span class="post-toc-text">可读流的实现（暂停模式）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在-fs-中的暂停模式的真正用法"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">在 fs 中的暂停模式的真正用法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ReadableStream-类的实现"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">ReadableStream 类的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#打开、关闭文件-open-和-detroy"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">打开、关闭文件 open 和 detroy</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#从-“容器”-中读取-read-方法的实现"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">从 “容器” 中读取 read 方法的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#真正读取文件的-read"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">真正读取文件的 _read</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#验证可读流（暂停模式）ReadableStream"><span class="post-toc-number">5.</span> <span class="post-toc-text">验证可读流（暂停模式）ReadableStream</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#可写流的实现"><span class="post-toc-number">6.</span> <span class="post-toc-text">可写流的实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#WriteStream-类创建"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">WriteStream 类创建</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#打开、关闭文件-open-和-detroy-1"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">打开、关闭文件 open 和 detroy</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#写入文件方法-write-的实现"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">写入文件方法 write 的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#真正的文件操作-write"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">真正的文件操作 _write</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#清空缓存操作-clearBuffer"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">清空缓存操作 clearBuffer</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#验证可写流-WriteStream"><span class="post-toc-number">7.</span> <span class="post-toc-text">验证可写流 WriteStream</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#可读流和可写流的桥梁-pipe"><span class="post-toc-number">8.</span> <span class="post-toc-text">可读流和可写流的桥梁 pipe</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">9.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-20180704175217" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">NodeJS —— 流的原理分析与简易实现</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-07-04 17:52:17" datetime="2018-07-04T09:52:17.000Z" itemprop="datePublished">2018-07-04</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/NodeJS/">NodeJS</a></li></ul>



            

            
<span id="/2018/07/04/20180704175217/" class="leancloud-visitors" title="文章总阅读量" data-flag-title="NodeJS —— 流的原理分析与简易实现">
    <i class="icon icon-eye icon-pr post-meta-item-text"></i><span class="leancloud-visitors-count"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <img src="/2018/07/04/20180704175217/stream.png" title="流的实现原理">
<p><br></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>在之前的博客中已经了解了流的基本用法，这篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 <code>ReadStream</code>，流的基本用法请看这里 <a href="http://www.overtaking.top/2018/07/03/20180703231032/" target="_blank">NodeJS —— Stream 的基本使用</a>。</p>
</blockquote>
<a id="more"></a>
<h2 id="可读流的实现（流动模式）"><a href="#可读流的实现（流动模式）" class="headerlink" title="可读流的实现（流动模式）"></a>可读流的实现（流动模式）</h2><h3 id="ReadStream-类创建"><a href="#ReadStream-类创建" class="headerlink" title="ReadStream 类创建"></a>ReadStream 类创建</h3><p>在使用 <code>fs</code> 的 <code>createReadStream</code> 创建可读流时，返回了 <code>ReadStream</code> 对象，上面存在着一些事件和方法，其实我们在创建这个可读流的时候创建了某一个类的实例，这个实例可以调用类原型上的方法，我们这里将这个类命名为 <code>ReadStream</code>。</p>
<p>在类原型上的方法内部可能会创建一些事件，在 NodeJS 中，事件是依赖 <code>events</code> 模块的，即 <code>EventEmitter</code> 类，同时类的方法可能会操作文件，会用到 <code>fs</code> 模块，所以也提前引入 <code>fs</code>。</p>
<figure class="highlight js"><figcaption><span>创建 ReadStream 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ReadStream 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// 创建可读流参数传入的属性</span></span><br><span class="line">    <span class="keyword">this</span>.path = path; <span class="comment">// 读取文件的路径</span></span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>; <span class="comment">// 文件标识位</span></span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>; <span class="comment">// 字符编码</span></span><br><span class="line">    <span class="keyword">this</span>.fd = options.fd || <span class="literal">null</span>; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span>; <span class="comment">// 权限位</span></span><br><span class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>; <span class="comment">// 是否自动关闭</span></span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span>; <span class="comment">// 读取文件的起始位置</span></span><br><span class="line">    <span class="keyword">this</span>.end = options.end || <span class="literal">null</span>; <span class="comment">// 读取文件的结束位置（包含）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次读取文件的字节数</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">this</span>.flowing = <span class="literal">false</span>; <span class="comment">// 控制当前是否是流动状态，默认为暂停状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储读取内容的 Buffer</span></span><br><span class="line">    <span class="keyword">this</span>.buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark);</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start; <span class="comment">// 下次读取文件的位置（变化的）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可读流要打开文件</span></span><br><span class="line">    <span class="keyword">this</span>.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果监听了 data 事件，切换为流动状态</span></span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, type =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">'data'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始读取文件</span></span><br><span class="line">        <span class="keyword">this</span>.read();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br></pre></td></tr></table></figure>
<p>使用 <code>fs.createReadStream</code> 时传入了两个参数，读取文件的路径和一个 <code>options</code> 选项，<code>options</code> 上有八个参数，我们在创建 <code>ReadStream</code> 类的时候将这些参数初始化到了 <code>this</code> 上。</p>
<p>创建可读流的时候有两种状态，流动状态和暂停状态，默认创建可读流是暂停状态，只有在触发 <code>data</code> 事件时才会变为流动状态，所以在 <code>this</code> 上挂载了 <code>flowing</code> 存储当前的状态是否为流动状态，值默认为 <code>false</code>。</p>
<blockquote class="pullquote warning"><p><em><strong>注意：这里说的暂停状态不是暂停模式，暂停模式是 <code>readable</code>, 是可读流的另一种模式，我们这节讨论的可读流为流动模式。</strong></em></p>
</blockquote>
<p>在读取文件时其实是操作 Buffer 进行读取的，需要有一个 Buffer 实例用来存储每次读取的数据，所以在 <code>this</code> 上挂载了一个新创建的 Buffer，长度等于 <code>highWaterMark</code>。</p>
<p>当从 <code>start</code> 值的位置开始读取文件，下一次读取文件的位置会发生变化，所以在 <code>this</code> 上挂载了 <code>pos</code> 属性，用于存储下次读取文件的位置。</p>
<p>在创建 <code>ReadStream</code> 的实例（可读流）时，应该打开文件并进行其他操作，所以在 <code>this</code> 上挂载了 <code>open</code> 方法并执行。</p>
<p>创建实例的同时监听了 <code>newListener</code> 事件，回调在每次使用 <code>on</code> 监听事件时触发，回调内部逻辑是为了将默认的暂停状态切换为流动状态，因为在使用时，流动状态是通过监听 <code>data</code> 事件触发的，在 <code>newListener</code> 的回调中判断事件类型为 <code>data</code> 的时候将 <code>flowing</code> 标识的值更改为 <code>true</code>，并调用读取文件的 <code>read</code> 方法。</p>
<blockquote class="pullquote info"><p>在使用 ES6 的类编程时，原型上的方法都是写在 <code>class</code> 内部，我们下面为了把原型上的方法拆分出来成为单独的代码块，都使用 <code>ReadStream.prototype.open = function...</code> 直接给原型添加属性的方式，但这样的方式和直接写在 <code>class</code> 内有一点区别，就是 <code>class</code> 内部的书写的原型方法都是不可遍历的，添加属性的方式创建的方法都是可遍历的，但是这点区别对我们代码的执行没有任何影响。</p>
</blockquote>
<h3 id="打开文件方法-open-的实现"><a href="#打开文件方法-open-的实现" class="headerlink" title="打开文件方法 open 的实现"></a>打开文件方法 open 的实现</h3><p>在使用可读流时，打开时默认是暂停状态，会触发 <code>open</code> 事件，如果打开文件出错会触发 <code>error</code> 事件。</p>
<figure class="highlight js"><figcaption><span>open 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">ReadStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, <span class="keyword">this</span>.mode, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果文件打开了出错，并配置自动关闭，则关掉文件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autoClose) &#123;</span><br><span class="line">        <span class="comment">// 关闭文件（触发 close 事件）</span></span><br><span class="line">        <span class="keyword">this</span>.destroy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不再继续执行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储文件描述符</span></span><br><span class="line">    <span class="keyword">this</span>.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功打开文件后触发 open 事件</span></span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'open'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>open</code> 方法的逻辑就是在打开文件的时候，将文件描述符存储在实例上方便后面使用，并使用 <code>EventEmitter</code> 的原型方法 <code>emit</code> 触发 <code>open</code> 事件，如果出错就使用 <code>emit</code> 触发 <code>error</code> 事件，如果配置 <code>autoClose</code> 参数为 <code>true</code>，就关闭文件并触发 <code>close</code>。</p>
<p>我们将关闭文件的逻辑抽取出来封装在了 <code>ReadStream</code> 类的 <code>destroy</code> 方法中，下面来实现 <code>destroy</code>。</p>
<h3 id="关闭文件方法-destroy-的实现"><a href="#关闭文件方法-destroy-的实现" class="headerlink" title="关闭文件方法 destroy 的实现"></a>关闭文件方法 destroy 的实现</h3><p>文件出错分为两种，第一种文件打开出错，第二种是文件不存在出错（没打开），第二种系统是没有分配文件描述符的。</p>
<figure class="highlight js"><figcaption><span>detroy 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">ReadStream.prototype.detroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否存在文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在则关闭文件并触发 close 事件</span></span><br><span class="line">    fs.close(fd, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不存在文件描述符直接触发 close 事件</span></span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是打开文件后出错需要关闭文件，并触发 <code>close</code> 事件，如果是没打开文件，则直接触发 <code>close</code> 事件，所以上面通过文件描述符来判断该如何处理。</p>
<h3 id="读取文件方法-read-的实现"><a href="#读取文件方法-read-的实现" class="headerlink" title="读取文件方法 read 的实现"></a>读取文件方法 read 的实现</h3><p>还记得在 <code>ReadStream</code> 类中，监听的 <code>newListener</code> 事件的回调中如果监听了 <code>data</code> 事件则会执行 <code>read</code> 读取文件，接下来就实现读取文件的核心逻辑。</p>
<figure class="highlight js"><figcaption><span>read 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">ReadStream.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 由于 open 异步执行，read 是在创建实例时同步执行</span></span><br><span class="line">  <span class="comment">// read 执行可能早于 open，此时不存在文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 read</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, () =&gt; <span class="keyword">this</span>.read());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如过设置了结束位置，读到结束为止就不能再读了</span></span><br><span class="line">  <span class="comment">// 如果最后一次读取真实读取数应该小于 highWaterMark</span></span><br><span class="line">  <span class="comment">// 所以每次读取的字节数应该和 highWaterMark 取最小值</span></span><br><span class="line">  <span class="keyword">let</span> howMuchToRead = <span class="keyword">this</span>.end ?</span><br><span class="line">    <span class="built_in">Math</span>.min(<span class="keyword">this</span>.highWaterMark, <span class="keyword">this</span>.end - <span class="keyword">this</span>.pos + <span class="number">1</span>) :</span><br><span class="line">    <span class="keyword">this</span>.highWaterMark;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.read(</span><br><span class="line">    <span class="keyword">this</span>.fd,</span><br><span class="line">    <span class="keyword">this</span>.buffer,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    howMuchToRead,</span><br><span class="line">    <span class="keyword">this</span>.pos,</span><br><span class="line">    (err, bytesRead) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果读到内容执行下面代码，读不到则触发 end 事件并关闭文件</span></span><br><span class="line">      <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 维护下次读取文件位置</span></span><br><span class="line">        <span class="keyword">this</span>.pos += bytesRead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保留有效的 Buffer</span></span><br><span class="line">        <span class="keyword">let</span> realBuf = <span class="keyword">this</span>.buffer.slice(<span class="number">0</span>, bytesRead);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据编码处理 data 回调返回的数据</span></span><br><span class="line">        realBuf = <span class="keyword">this</span>.encoding ?</span><br><span class="line">          realBuf.toString(<span class="keyword">this</span>.encoding) :</span><br><span class="line">          realBuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发 data 事件并传递数据</span></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'data'</span>, realBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归读取</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.flowing) &#123;</span><br><span class="line">          <span class="keyword">this</span>.read();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.isEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>); <span class="comment">// 触发 end 事件</span></span><br><span class="line">        <span class="keyword">this</span>.detroy(); <span class="comment">// 关闭文件</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 <code>ReadStream</code> 的实例时，执行的 <code>open</code> 方法内部是使用 <code>fs.open</code> 打开文件的，是异步操作，而读取文件方法 <code>read</code> 是在 <code>newListener</code> 回调中同步执行的，这样很可能触发 <code>read</code> 的时候文件还没有被打开（不存在文件描述符），所以在 <code>read</code> 方法中判断了文件描述符是否存在，并在不存在时候使用 <code>once</code> 添加了 <code>open</code> 事件，回调中重新执行了 <code>read</code>。</p>
<p>由于在 <code>open</code> 方法中使用 <code>emit</code> 触发了 <code>open</code> 事件，所以 <code>read</code> 内用 <code>once</code> 添加的 <code>open</code> 事件的回调也会跟着执行一次，并在回调中重新调用了 <code>read</code> 方法，保证了 <code>read</code> 读取文件的逻辑在文件真正打开后才执行，为了文件打开前执行 <code>read</code> 而不执行读取文件的逻辑，用 <code>once</code> 添加 <code>open</code> 事件时别忘记 <code>return</code>。</p>
<p>在使用 <code>fs.read</code> 读取文件的时候有一个参数为本次读取几个字符到 Buffer 中，如果在创建可读流的时候设置了读取文件的结束位置 <code>end</code> 参数，则读到 <code>end</code> 位置就不应该再继续读取了，所以在存在 <code>end</code> 参数的时候每次都计算一下读取个数和 <code>highWaterMark</code> 取最小值，保证读取内容小于 <code>highWaterMark</code> 的时候不会多读，因为读取时是包括 <code>end</code> 值作为 Buffer 的索引这一项的，所以计算时多减去的要 <code>+1</code> 加回来，再一次读取这个读取个数计算结果变成了 <code>0</code>，也就结束了读取。</p>
<p>因为 <code>end</code> 参数的情况，所以在内部读取逻辑前判断了 <code>bytesRead</code> （实际读取字节数）是否大于 <code>0</code>，如果不满足条件则在实例添加是否读取结束标识 <code>isEnd</code>（后面使用），触发 <code>end</code> 事件并关闭文件，如果满足条件，也是通过 <code>bytesRead</code> 对 Buffer 进行截取，保留了有用的 Buffer，并且通过 <code>encoding</code> 编码对 Buffer 进行处理后，触发 <code>data</code> 事件，并将处理后的数据传递给 <code>data</code> 事件的回调。</p>
<h3 id="暂停、恢复读取-pause-和-resume"><a href="#暂停、恢复读取-pause-和-resume" class="headerlink" title="暂停、恢复读取 pause 和 resume"></a>暂停、恢复读取 pause 和 resume</h3><p><code>pause</code> 的目的就是暂停读取，其实就是阻止 <code>read</code> 方法在读取时进行递归，所以只需要更改 <code>flowing</code> 的值即可。</p>
<figure class="highlight js"><figcaption><span>pause 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停读取</span></span><br><span class="line">ReadStream.prototype.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.flowing = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>resume</code> 的目的是恢复读取，在更改 <code>flowing</code> 值得基础上重新执行 <code>read</code> 方法，由于在 <code>pause</code> 调用时 <code>read</code> 内部还是执行得读取文件得分支，文件并没有关闭，读取文件位置的参数也是通过实例上的当前的属性值进行计算的，所以重新执行 <code>read</code> 会继续上一次的位置读取。</p>
<figure class="highlight js"><figcaption><span>resume 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恢复读取</span></span><br><span class="line">ReadStream.prototype.resume = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnd) <span class="keyword">this</span>.read();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面在重新执行 <code>read</code> 之前使用 <code>isEnd</code> 标识做了判断，防止在 <code>setInterval</code> 中调用 <code>resume</code> 在读取完成后不断的触发 <code>end</code> 和 <code>close</code> 事件。</p>
<h2 id="验证可读流（流动模式）ReadStream"><a href="#验证可读流（流动模式）ReadStream" class="headerlink" title="验证可读流（流动模式）ReadStream"></a>验证可读流（流动模式）ReadStream</h2><p>接下来我们使用自己实现的 <code>ReadStream</code> 类来创建可读流，并按照 <code>fs.createReadStream</code> 的用法进行使用并验证。</p>
<figure class="highlight js"><figcaption><span>验证 ReadStream</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 1.txt 内容为 0123456789</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">5</span>,</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'open'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'open'</span>));</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  rs.pause();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'end'</span>));</span><br><span class="line">rs.on(<span class="string">'close'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'close'</span>));</span><br><span class="line">rs.on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> rs.resume(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// open</span></span><br><span class="line"><span class="comment">// 01 2018-07-04T10:44:20.384Z</span></span><br><span class="line"><span class="comment">// 23 2018-07-04T10:44:21.384Z</span></span><br><span class="line"><span class="comment">// 45 2018-07-04T10:44:22.384Z</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// close</span></span><br></pre></td></tr></table></figure>
<p>执行上面的代码正常的执行逻辑是先触发 <code>open</code> 事件，然后触发 <code>data</code> 事件，读取一次后暂停，每隔一秒恢复读取一次，再读取完成后触发 <code>end</code> 和 <code>close</code> 事件，通过运行代码结果和我们希望的一样。</p>
<h2 id="可读流的实现（暂停模式）"><a href="#可读流的实现（暂停模式）" class="headerlink" title="可读流的实现（暂停模式）"></a>可读流的实现（暂停模式）</h2><h3 id="在-fs-中的暂停模式的真正用法"><a href="#在-fs-中的暂停模式的真正用法" class="headerlink" title="在 fs 中的暂停模式的真正用法"></a>在 fs 中的暂停模式的真正用法</h3><p>在 <code>fs</code> 模块中用 <code>createReadStream</code> 创建的可读流中通过监听 <code>readable</code> 事件触发暂停模式（监听 data 事件触发流动模式），通过下面例子感受暂停模式与流动模式的不同，现在读取文件 <code>1.txt</code>，内容为 <code>0~9</code> 十个数字。</p>
<figure class="highlight js"><figcaption><span>暂停模式的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取的</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// read 参数为本次读取的个数</span></span><br><span class="line">  <span class="keyword">let</span> r = rs.read(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 打印读取的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">  <span class="comment">// 打印容器剩余空间</span></span><br><span class="line">  <span class="built_in">console</span>.log(rs._readableState.length);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 012</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 345</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 678</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 90</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>通俗的解释，暂停模式的 <code>readable</code> 事件默认会触发一次，监听 <code>readable</code> 事件后就像创建了一个 “容器”，容量为 <code>highWaterMark</code>，文件中的数据会自动把容器注满，调用可读流的 <code>read</code> 方法读取时，会从容器中取出数据，如果 <code>read</code> 方法读取的数据小于 <code>highWaterMark</code>，则直接暂停，不再继续读取，如果大于 <code>highWaterMark</code> ，说明 “容器” 空了，则会触发 <code>readable</code> 事件，无论读取字节数与 <code>highWaterMark</code> 关系如何，只要 “容器” 内容量剩余小于 <code>highWaterMark</code> 就会进行 “续杯”，再次向 “容器” 中填入 <code>highWaterMark</code> 个，所以有些时候真实的容量会大于 <code>highWaterMark</code>。</p>
<p><code>read</code> 方法读取的内容会返回 <code>null</code> 是因为容器内真实的数据数小于了读取数，如果不是最后一次读取，会在多次读取后将值一并返回，如果是最后一次读取，会把剩余不足的数据返回。</p>
<blockquote class="pullquote success"><p><em><strong>1、<code>readable</code> 事件的触发条件：“容器” 空了；</strong></em><br><em><strong>2、“续杯” 条件：读取后 “容器” 内剩余量小于 <code>highWaterMark</code>。</strong></em><br><em><strong>3、<code>read</code> 返回 <code>null</code>：“容器” 容器内可悲读取数据无法满足一次读取字节数。</strong></em></p>
</blockquote>
<h3 id="ReadableStream-类的实现"><a href="#ReadableStream-类的实现" class="headerlink" title="ReadableStream 类的实现"></a>ReadableStream 类的实现</h3><p>同为可读流，暂停模式与流动模式相同，都依赖 <code>fs</code> 模块和 <code>events</code> 模块的 <code>EventEmitter</code> 类，参数依然为读取文件的路径和 <code>options</code>。</p>
<figure class="highlight js"><figcaption><span>创建 ReadableStream 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadableStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.path = path; <span class="comment">// 读取文件的路径</span></span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>; <span class="comment">// 文件标识位</span></span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>; <span class="comment">// 字符编码</span></span><br><span class="line">    <span class="keyword">this</span>.fd = options.fd || <span class="literal">null</span>; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span>; <span class="comment">// 权限位</span></span><br><span class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>; <span class="comment">// 是否自动关闭</span></span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span>; <span class="comment">// 读取文件的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次读取文件的字节数</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">this</span>.reading = <span class="literal">false</span>; <span class="comment">// 如果正在读取，则不再读取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当缓存区的长度等于 0 的时候， 触发 readable</span></span><br><span class="line">    <span class="keyword">this</span>.emitReadable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.arr = []; <span class="comment">// 缓存区</span></span><br><span class="line">    <span class="keyword">this</span>.len = <span class="number">0</span>; <span class="comment">// 缓存区的长度</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start; <span class="comment">// 下次读取文件的位置（变化的）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可读流要打开文件</span></span><br><span class="line">    <span class="keyword">this</span>.open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, type =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">'readable'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.read(); <span class="comment">// 监听readable就开始读取</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = ReadableStream;</span><br></pre></td></tr></table></figure>
<p>在类的添加了 <code>newListener</code> 事件，在回调中判断是否监听了 <code>readable</code> 事件，如果监听了开始从 “容器” 中读取。</p>
<h3 id="打开、关闭文件-open-和-detroy"><a href="#打开、关闭文件-open-和-detroy" class="headerlink" title="打开、关闭文件 open 和 detroy"></a>打开、关闭文件 open 和 detroy</h3><p>打开和关闭文件的方法和流动模式的套路基本相似。</p>
<figure class="highlight js"><figcaption><span>open 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">ReadableStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, <span class="keyword">this</span>.mode, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autoClose) &#123;</span><br><span class="line">        <span class="keyword">this</span>.destroy();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fd = fd;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'open'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>detroy 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">ReadableStream.prototype.detroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd === <span class="string">'number'</span>) &#123;</span><br><span class="line">    fs.close(fd, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从-“容器”-中读取-read-方法的实现"><a href="#从-“容器”-中读取-read-方法的实现" class="headerlink" title="从 “容器” 中读取 read 方法的实现"></a>从 “容器” 中读取 read 方法的实现</h3><p><code>read</code> 方法的参数不传时就相当于从 “容器” 读取 <code>highWaterMart</code> 个字节，如果传参表示读取参数数量的字节数。</p>
<figure class="highlight js"><figcaption><span>read 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ReadableStream.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果读取大于了 highWaterMark，重新计算 highWaterMark，并重新读取</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="keyword">this</span>.len) &#123;</span><br><span class="line">    <span class="comment">// 计算新的 highWaterMark，方法摘自 NodeJS 源码</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = computeNewHighWaterMark(n);</span><br><span class="line">    <span class="keyword">this</span>.reading = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>._read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将要返回的数据</span></span><br><span class="line">  <span class="keyword">let</span> buffer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果读取的字节数大于 0 小于等于当前缓存 Buffer 的总长度</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n &lt;= <span class="keyword">this</span>.len) &#123;</span><br><span class="line">    <span class="comment">// 则从缓存中取出</span></span><br><span class="line">    buffer = Buffer.alloc(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> current; <span class="comment">// 存储每次从缓存区读出的第一个 Buffer</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 每次读取缓存 Buffer 的索引</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>; <span class="comment">// 是否结束整个 while 循环的标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始读取</span></span><br><span class="line">    <span class="keyword">while</span> ((current = <span class="keyword">this</span>.arr.shift()) &amp;&amp; flag) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; current.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 将缓存中取到的 Buffer 的内容读到自己定义的 Buffer 中</span></span><br><span class="line">        buffer[index++] = current[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前索引值已经等于了读取个数，结束 for 循环</span></span><br><span class="line">        <span class="keyword">if</span> (index === n) &#123;</span><br><span class="line">          flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 取出当前 Buffer 没有消耗的</span></span><br><span class="line">          <span class="keyword">let</span> residue = current.slice(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在读取后维护缓存的长度</span></span><br><span class="line">          <span class="keyword">this</span>.len -= n;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果 BUffer 真的有剩下的就给塞回到缓存中</span></span><br><span class="line">          <span class="keyword">if</span> (residue.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.arr.unshift(residue);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前 读取的 Buffer 为 0，将触发 readable 事件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.len === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.emitReadable = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前的缓存区大小小于 highWaterMark，就要读取</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark) &#123;</span><br><span class="line">    <span class="comment">// 如果不是正在读取才开始读取</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.read) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reading = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>._read(); <span class="comment">// 正真读取的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 buffer 转回创建可读流设置成的编码格式</span></span><br><span class="line">  <span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">    buffer = <span class="keyword">this</span>.encoding ? buffer.toString(<span class="keyword">this</span>.encoding) : buffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>read</code> 方法的参数大小对比缓存区中取出的 Buffer 长度有两种情况，一种是小于当前缓存区内取出 Buffer 的长度，一种是大于了真个缓存区的 <code>len</code> 的长度。</p>
<p>小于当前缓存区总长度通过循环取出需要的 Buffer 存储了我们要返回创建的 Buffer 中，剩余的 Buffer 会丢失，所以我们做了一个小小的处理，将剩下的 Buffer 作为第一个 Buffer 塞回到了缓存区中，在处理这个问题时与流动模式不相同，流动模式处理后直接跳出了，而暂停模式相当于从 “容器” 中读取，如果第一次读取后还有剩余还要接着从容器中继续读取。</p>
<p>大于 <code>len</code> 属性时，规定需要重新计算 <code>highWaterMark</code>，遵循的原则是将当前 <code>highWaterMark</code> 设定为当前读取字节个数距离最接近的 <code>2</code> 的 <code>n</code> 次方的数值，NodeJS 源码中方法名称为 <code>computeNewHighWaterMark</code>，为了提高性能是使用位运算的方式进行计算的，源码如下。</p>
<figure class="highlight js"><figcaption><span>重新计算 highWaterMark</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeNewHighWaterMark</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  n--;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  n++;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用该方法重新计算 <code>highWaterMark</code> 后更改正在读取状态，重新读取，由于读取逻辑的重复，所以真正读取文件的逻辑抽取成一个 <code>_read</code> 方法来实现，下面呢就来看看 <code>_read</code> 内部都做了什么。</p>
<h3 id="真正读取文件的-read"><a href="#真正读取文件的-read" class="headerlink" title="真正读取文件的 _read"></a>真正读取文件的 _read</h3><p>对比可读流（流动模式）的 <code>read</code> 方法，在调用 <code>_read</code> 方法读取时，是在 <code>newListener</code> 中同步执行 <code>_read</code>，所以为了保证 <code>_read</code> 的逻辑是在 <code>open</code> 方法打开文件以后执行，使用了与 <code>read</code> 相同的处理方式。</p>
<figure class="highlight js"><figcaption><span>_read 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ReadableStream.prototype._read = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, () =&gt; _read());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建本次读取的 Buffer</span></span><br><span class="line">  <span class="keyword">let</span> buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.read(</span><br><span class="line">    <span class="keyword">this</span>.fd,</span><br><span class="line">    buffer,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">this</span>.highWaterMark,</span><br><span class="line">    <span class="keyword">this</span>.pos,</span><br><span class="line">    (err, bytesRead) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.arr.push(buffer); <span class="comment">// 缓存</span></span><br><span class="line">        <span class="keyword">this</span>.len += bytesRead; <span class="comment">// 维护缓存区长度</span></span><br><span class="line">        <span class="keyword">this</span>.pos += bytesRead; <span class="comment">// 维护下一次读取位置</span></span><br><span class="line">        <span class="keyword">this</span>.reading = <span class="literal">false</span>; <span class="comment">// 读取完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发 readable 事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.emitReadable) &#123;</span><br><span class="line">          <span class="comment">// 触发后更改触发状态为 false</span></span><br><span class="line">          <span class="keyword">this</span>.emitReadable = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">this</span>.emit(<span class="string">'readable'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果读完触发结束事件</span></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'end'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于缓存区是一个数组，存储的每一个 Buffer 是独立存在的，所以不能挂载在实例上共用，如果挂在实例上则引用相同，一动全动，这不是我们想要的，所以每一次执行 <code>_read</code> 方法时都创建新的 Buffer 实例存入读取的数据后存储在缓存区中，如果读取完成 <code>bytesRead</code> 为 <code>0</code>，则触发 <code>end</code> 事件。</p>
<blockquote class="pullquote warning"><p><em><strong>注意：在 NodeJS 源码中，可读流的两种模式代码都是混合在一起的，只是使用 <code>fs.createReadStream</code> 创建一个可读流，通过监听 <code>data</code> 和 <code>readable</code> 两种不同的事件来触发两种不同的模式，而我们为了模拟，把两种模式拆开成了两个类来实现的，在测试时需要创建不同类的实例。</strong></em></p>
</blockquote>
<h2 id="验证可读流（暂停模式）ReadableStream"><a href="#验证可读流（暂停模式）ReadableStream" class="headerlink" title="验证可读流（暂停模式）ReadableStream"></a>验证可读流（暂停模式）ReadableStream</h2><p>为了统一我们依然读取真正用法中 <code>1.txt</code> 文件，内容为 0~9 十个数字。</p>
<figure class="highlight js"><figcaption><span>验证 ReadableStream</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> ReadableStream = <span class="built_in">require</span>(<span class="string">'./ReadableStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReadableStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  encoding: <span class="string">'utf8'</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> r = rs.read(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">  <span class="built_in">console</span>.log(rs.len);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在打印 “容器” 剩余容量时，我们使用在 <code>ReadableStream</code> 上构造的 <code>len</code> 属性。</p>
<blockquote class="pullquote info"><p>流动模式和暂停模式分别有不同的应用场景，如果只是希望读取一个文件，并最快的获得结果使用流动模式是很好的选择，如果希望了解读取文件的具体内容，并进行精细的处理，使用暂停模式更好一些。</p>
</blockquote>
<h2 id="可写流的实现"><a href="#可写流的实现" class="headerlink" title="可写流的实现"></a>可写流的实现</h2><h3 id="WriteStream-类创建"><a href="#WriteStream-类创建" class="headerlink" title="WriteStream 类创建"></a>WriteStream 类创建</h3><p>在使用 <code>fs</code> 的 <code>createWriteStream</code> 创建可写流时，返回了 <code>WriteStream</code> 对象，上面也存在事件和方法，创建可写流的时也是创建类的实例，我们将这个类命名为 <code>WriteStream</code>。事件同样依赖 <code>events</code> 模块的 <code>EventEmitter</code> 类，文件操作同样依赖 <code>fs</code> 模块，所以需提前引入。</p>
<figure class="highlight js"><figcaption><span>创建 WriteStream 类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖模块</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 WriteStream 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// 创建可写流参数传入的属性</span></span><br><span class="line">    <span class="keyword">this</span>.path = path; <span class="comment">// 写入文件的路径</span></span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">'w'</span>; <span class="comment">// 文件标识位</span></span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding || <span class="string">'utf8'</span>; <span class="comment">// 字符编码</span></span><br><span class="line">    <span class="keyword">this</span>.fd = options.fd || <span class="literal">null</span>; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span>; <span class="comment">// 权限位</span></span><br><span class="line">    <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>; <span class="comment">// 是否自动关闭</span></span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span>; <span class="comment">// 写入文件的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比写入字节数的标识</span></span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">this</span>.writing = <span class="literal">false</span>; <span class="comment">// 是否正在写入</span></span><br><span class="line">    <span class="keyword">this</span>.needDrain = <span class="literal">false</span>; <span class="comment">// 是否需要触发 drain 事件</span></span><br><span class="line">    <span class="keyword">this</span>.buffer = []; <span class="comment">// 缓存，正在写入就存入缓存中</span></span><br><span class="line">    <span class="keyword">this</span>.len = <span class="number">0</span>; <span class="comment">// 当前缓存的个数</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.start; <span class="comment">// 下次写入文件的位置（变化的）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可写流要打开文件</span></span><br><span class="line">    <span class="keyword">this</span>.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = WriteStream;</span><br></pre></td></tr></table></figure>
<p>使用 <code>fs.createWriteStream</code> 创建可写流时传入了两个参数，写入的文件路径和一个 <code>options</code> 选项，<code>options</code> 上有七个参数，我们在创建 <code>ReadStream</code> 类的时候将这些参数初始化到了 <code>this</code> 上。</p>
<p>创建可写流后需要使用 <code>write</code> 方法进行写入，写入时第一次会真的通过内存写入到文件中，而再次写入则会将内容写到缓存中，注意这里的 “内存” 和 “缓存”，内存是写入文件是的系统内存，缓存是我们自己创建的数组，第一次写入以后要写入文件的 Buffer 都会先存入这个数组中，这个数组名为 <code>buffer</code>，挂载在实例上，实例上同时挂载了 <code>len</code> 属性用来存储当前缓存中 Buffer 总共的字节数（长度）。</p>
<p>我们在可读流上挂载了是否正在写入的状态 <code>writing</code> 属性，只要缓存区中存在未写入的 Buffer，<code>writing</code> 的状态就是正在写入，当写入的字节数大于了 <code>highWaterMark</code> 需要触发 <code>drain</code> 事件，所以又挂载了是否需要触发 <code>drain</code> 事件的标识 <code>needDrain</code> 属性。</p>
<p>当从文件的 <code>start</code> 值对应的位置开始写入，下一次写入文件的位置会发生变化，所以在 <code>this</code> 上挂载了 <code>pos</code> 属性，用于存储下次写入文件的位置。</p>
<blockquote class="pullquote primary"><p>在 NodeJS 流的源码中缓存是用链表实现的，通过指针来操作缓存中的 Buffer，而我们为了简化逻辑就使用数组来作为缓存，虽然性能相对链表要差。</p>
</blockquote>
<h3 id="打开、关闭文件-open-和-detroy-1"><a href="#打开、关闭文件-open-和-detroy-1" class="headerlink" title="打开、关闭文件 open 和 detroy"></a>打开、关闭文件 open 和 detroy</h3><p>在 <code>WriteStream</code> 中，写入文件之前也应该打开文件，在打开文件过程中出错时也应该触发 <code>error</code> 事件并关闭文件，打开和关闭文件的方法 <code>open</code> 和 <code>detroy</code> 与 <code>ReadStream</code> 的 <code>open</code> 和 <code>detroy</code> 方法的逻辑如出一辙，所以这里直接拿过来用了。</p>
<figure class="highlight js"><figcaption><span>open 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">WriteStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, <span class="keyword">this</span>.mode, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autoClose) &#123;</span><br><span class="line">        <span class="keyword">this</span>.destroy();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fd = fd;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'open'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>detroy 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">WriteStream.prototype.detroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd === <span class="string">'number'</span>) &#123;</span><br><span class="line">    fs.close(fd, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写入文件方法-write-的实现"><a href="#写入文件方法-write-的实现" class="headerlink" title="写入文件方法 write 的实现"></a>写入文件方法 write 的实现</h3><p><code>write</code> 方法默认支持传入三个参数：</p>
<ul>
<li>chunk：写入文件的内容；</li>
<li>encoding：写入文件的编码格式；</li>
<li>callback：写入成功后执行的回调。</li>
</ul>
<figure class="highlight js"><figcaption><span>write 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件的方法，只要逻辑为写入前的处理</span></span><br><span class="line">WriteStream.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  chunk,</span></span></span><br><span class="line"><span class="function"><span class="params">  encoding = this.encoding,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了方便操作将要写入的数据转换成 Buffer</span></span><br><span class="line">  chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护缓存的长度</span></span><br><span class="line">  <span class="keyword">this</span>.len += chunk.lenth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护是否触发 drain 事件的标识</span></span><br><span class="line">  <span class="keyword">this</span>.needDrain = <span class="keyword">this</span>.highWaterMark &lt;= <span class="keyword">this</span>.len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果正在写入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.writing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.buffer.push(&#123;</span><br><span class="line">      chunk,</span><br><span class="line">      encoding,</span><br><span class="line">      callback</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更改标识为正在写入，再次写入的时候走缓存</span></span><br><span class="line">    <span class="keyword">this</span>.writing = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果已经写入清空缓存区的内容</span></span><br><span class="line">    <span class="keyword">this</span>._write(chunk, encoding, () =&gt; <span class="keyword">this</span>.clearBuffer());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !<span class="keyword">this</span>.needDrain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与可写流的 <code>read</code> 一样，我们在使用 <code>write</code> 方法将数据写入文件时，也是操作 Buffer，在 <code>write</code> 方法中，首先将接收到的要写入的数据转换成了 Buffer，因为是多次写入，要知道缓存中 Buffer 字节数的总长度，所以维护了 <code>len</code> 变量。</p>
<p>我们的 <code>WriteStream</code> 构造函数中，<code>this</code> 挂载了 <code>needDrain</code> 属性，在使用 <code>fs.createWriteStream</code> 创建的可读流时，是写入的字节长度超过 <code>highWaterMark</code> 才会触发 <code>drain</code> 事件，而 <code>needDrain</code> 与 <code>write</code> 的返回值正好相反，所以我们用 <code>needDrain</code> 取反来作为 <code>write</code> 方法的返回值。</p>
<p>在写入的逻辑中第一次是直接通过内存写入到文件，但是再次写入就需要将数据存入缓存，将数据写入到文件中写入状态 <code>writing</code> 默认为 <code>false</code>，通过缓存再写入证明应该正在写入中，所以在第一次写入后应更改 <code>writing</code> 的状态为 <code>true</code>，写入缓存其实就是把转换的 Buffer、编码以及写入成功后要执行的回调挂在一个对象上存入缓存的数组 <code>buffer</code> 中。</p>
<p>我们把真正写入文件的逻辑抽取成一个单独的方法 <code>_write</code>，并传入 <code>chunk</code>（要写入的内容，已经处理成 Buffer）、<code>encoding</code>（字符编码）、回调函数，在回调函数中执行了原型方法 <code>clearBuffer</code>，接下来就来实现 <code>_write</code> 和 <code>clearBuffer</code>。</p>
<blockquote class="pullquote warning"><p><strong><em>注意：方法使用 `</em>` 开头代表私有方法，轻易不要在外部调用或修改，这是一个开发者之间约定俗成的不成文规定。_</strong></p>
</blockquote>
<h3 id="真正的文件操作-write"><a href="#真正的文件操作-write" class="headerlink" title="真正的文件操作 _write"></a>真正的文件操作 _write</h3><p>对比可读流（流动模式）的 <code>read</code> 方法，在调用 <code>_write</code> 方法写入时，是在创建可写流之后的同步代码中执行的，与可读流在 <code>newListener</code> 中同步执行 <code>read</code> 的情况类似，所以为了保证 <code>_write</code> 的逻辑是在 <code>open</code> 方法打开文件以后执行，使用了与 <code>read</code> 相同的处理方式。</p>
<figure class="highlight js"><figcaption><span>_write 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的写入文件操作的方法</span></span><br><span class="line">WriteStream.prototype._write = <span class="function"><span class="keyword">function</span>(<span class="params">chunk, encoding, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 由于 open 异步执行，write 是在创建实例时同步执行</span></span><br><span class="line">  <span class="comment">// write 执行可能早于 open，此时不存在文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 write</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.once(</span><br><span class="line">      <span class="string">'open'</span>,</span><br><span class="line">      () =&gt; <span class="keyword">this</span>._write(chunk, encoding, callback)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.write(</span><br><span class="line">    <span class="keyword">this</span>.fd,</span><br><span class="line">    chunk,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    chunk.length,</span><br><span class="line">    <span class="keyword">this</span>.pos,</span><br><span class="line">    (err, bytesWritten) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 维护下次写入的位置和缓存区 Buffer 的总字节数</span></span><br><span class="line">      <span class="keyword">this</span>.pos += bytesWritten;</span><br><span class="line">      <span class="keyword">this</span>.len -= bytesWritten;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在打开文件并写入的时候需要维护两个变量，下次写入的位置 <code>pos</code> 和当前缓存区内 Buffer 所占总字节数 <code>len</code>，本次写入了多少个字节，下次写入需要在写入位置的基础上加多少个字节，而 <code>len</code> 恰恰相反，本次写入了多少个字节，缓存区中的总长度应该对应的减少多少个字节。</p>
<p>在维护两个变量的值以后调用 <code>callback</code>，其实 <code>callback</code> 内执行的是 <code>clearBuffer</code> 方法，就如方法名，译为 “清空缓存”，其实就是一次一次的将数据写入文件并从缓存中移除，很明显需要递归调用 <code>_write</code> 方法，我们将这个递归的逻辑统一放在 <code>clearBuffer</code> 方法中实现。</p>
<h3 id="清空缓存操作-clearBuffer"><a href="#清空缓存操作-clearBuffer" class="headerlink" title="清空缓存操作 clearBuffer"></a>清空缓存操作 clearBuffer</h3><figure class="highlight js"><figcaption><span>clearBuffer 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空缓存方法</span></span><br><span class="line">WriteStream.prototype.clearBuffer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先写入的在数组前面，从前面取出缓存中的 Buffer</span></span><br><span class="line">  <span class="keyword">let</span> buf = <span class="keyword">this</span>.buffer.shift();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在 buf，证明缓存还有 Buffer 需要写入</span></span><br><span class="line">  <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">    <span class="comment">// 递归 _write 按照编码将数据写入文件</span></span><br><span class="line">    <span class="keyword">this</span>._write(buf.chunk, buf.encoding, () =&gt; <span class="keyword">this</span>.clearBuffer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有 buf，说明缓存内的内容已经完全写入文件并清空，需要触发 drain 事件</span></span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'drain'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改正在写入状态</span></span><br><span class="line">    <span class="keyword">this</span>.writing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改是否需要触发 drain 事件状态</span></span><br><span class="line">    <span class="keyword">this</span>.needDrain = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clearBuffer</code> 方法中获取了缓存区数组的最前面的 Buffer（最前面的是先写入缓存的，也应该先取出来写入文件），存在这个 Buffer 时，递归 <code>_write</code> 方法按照编码将数据写入文件，如果不存在说明缓存区已经清空了，代表内容完全写入文件中，所以触发 <code>drain</code> 事件，最后更改了 <code>writing</code> 和 <code>needDrain</code> 的状态。</p>
<p>更正 <code>writing</code> 是为了 <code>WriteStream</code> 创建的可读流在下次调用 <code>write</code> 方法时默认第一次真正写入文件，而更正 <code>needDrain</code> 的状态是在缓存区要清空的最后一个 Buffer 的长度小于了 <code>highWaterMark</code> 时，保证 <code>write</code> 方法的返回值是正确的。</p>
<blockquote class="pullquote info"><p>第一次是真正写入，其他的都写入缓存，再一个一个的将缓存中存储的 Buffer 写入并从缓存清空，之所以这样设计是为了把写入的内容排成一个队列，假如有 <code>3</code> 个人同时操作一个文件写入内容，只有第一个人是真的写入，其他的人都写在缓存中，再按照写入缓存的顺序依次写入文件，避免冲突和写入顺序出错。</p>
</blockquote>
<h2 id="验证可写流-WriteStream"><a href="#验证可写流-WriteStream" class="headerlink" title="验证可写流 WriteStream"></a>验证可写流 WriteStream</h2><p>接下来我们使用自己实现的 WriteStream 类来创建可写流，并按照 <code>fs.createWriteStream</code> 的用法进行使用并验证。</p>
<figure class="highlight js"><figcaption><span>验证 WriteStream</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 1.txt 文件中写入 012345</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteStream = <span class="built_in">require</span>(<span class="string">'./WriteStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可写流</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= <span class="number">6</span> &amp;&amp; flag) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    flag = ws.write(i + <span class="string">''</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'写入成功'</span>);</span><br><span class="line">  write();</span><br><span class="line">&#125;);</span><br><span class="line">write();</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// 写入成功</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// 写入成功</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>fs.createWriteStream</code> 和 <code>WriteStream</code> 类分别执行上面的代码，对比结果，看看是否相同。</p>
<h2 id="可读流和可写流的桥梁-pipe"><a href="#可读流和可写流的桥梁-pipe" class="headerlink" title="可读流和可写流的桥梁 pipe"></a>可读流和可写流的桥梁 pipe</h2><p>可写流和可读流一般是通过 <code>pipe</code> 配合来使用的，<code>pipe</code> 方法是可读流 <code>ReadStream</code> 的原型方法，参数为一个可写流。</p>
<figure class="highlight js"><figcaption><span>pipe 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接可读流和可写流的方法 pipe</span></span><br><span class="line">ReadStream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 开始读取</span></span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果超出可写流的 highWaterMark，暂停读取</span></span><br><span class="line">    <span class="keyword">let</span> flag = dest.write(data);</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">this</span>.pause();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dest.on(<span class="string">'drain'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当可写流清空内存时恢复读取</span></span><br><span class="line">    <span class="keyword">this</span>.resume();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在读取完毕后关闭文件</span></span><br><span class="line">    <span class="keyword">this</span>.destroy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pipe</code> 方法其实就是通过可读流的 <code>data</code> 事件触发流动状态，并用可写流接收读出的数据进行写入，当写入数据超出 <code>highWaterMark</code>，则暂停可读流的读取，直到可写流的缓存被清空并把内容写进文件后，恢复可读流的读取，当读取结束后关闭文件。</p>
<p>下面我们实现一个将 <code>1.txt</code> 的内容拷贝 <code>2.txt</code> 中的例子。</p>
<figure class="highlight js"><figcaption><span>验证 pipe</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe 的使用</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入自己的 ReadStream 类和 WriteStream 类</span></span><br><span class="line"><span class="keyword">const</span> ReadStream = rquire(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteStream = rquire(<span class="string">'./WriteStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流和可写流</span></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'1.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WriteStream(<span class="string">'2.txt'</span>, &#123;</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 pipe 实现文件内容复制</span></span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 NodeJS 源码中，可读流和可写流的内容要比本篇内容多很多，本篇是将源码精简，抽出核心逻辑并针对流的使用方式进行实现，主要目的是帮助理解流的原理和使用，争取做到 “知其然知其所以然”，了解了一些底层再对流使用时，也能游刃有余。</p>
</blockquote>

        </div>

        
<div class="read-end">
    <span class="read-end-lg">--------------------</span>
    <span class="read-end-md">---------------</span>
    <span class="read-end-sm">----------</span>
    本文结束
    <i class="icon icon-paw"></i>
    感谢您的阅读
    <span class="read-end-sm">----------</span>
    <span class="read-end-md">---------------</span>
    <span class="read-end-lg">--------------------</span>
</div>


        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    更新时间：<time datetime="2019-04-23T03:13:59.836Z" itemprop="dateUpdated">2019-04-23 11:13:59</time>
</span><br>


        
<span class="permalink">
    本文链接：<a href="/2018/07/04/20180704175217/" target="_blank" rel="external">https://www.overtaking.top/2018/07/04/20180704175217/</a>
</span><br>


        
<span class="post-message">
    版权声明：本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 </a> 许可协议，转载请注明出处！
</span>


    </div>
    
    <footer>
        <a href="https://www.overtaking.top">
            <img src="/img/avatar.jpg" alt="Panda Shen">
            Panda Shen
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NodeJS/">NodeJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Stream/">Stream</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.overtaking.top/2018/07/04/20180704175217/&title=《NodeJS —— 流的原理分析与简易实现》 — Shen's Blog&pic=https://www.overtaking.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.overtaking.top/2018/07/04/20180704175217/&title=《NodeJS —— 流的原理分析与简易实现》 — Shen's Blog&source=

前言在之前的博客中已经了解了流的基本用法，这篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 ReadStream，流的基本用法请看这..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.overtaking.top/2018/07/04/20180704175217/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《NodeJS —— 流的原理分析与简易实现》 — Shen's Blog&url=https://www.overtaking.top/2018/07/04/20180704175217/&via=https://www.overtaking.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.overtaking.top/2018/07/04/20180704175217/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/07/05/20180705125501/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">NodeJS —— 自定义流的实现</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/07/03/20180703231032/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">NodeJS —— Stream 的基本使用</h4>
      </a>
    </div>
  
</nav>



    












<div class="comments vcomment" id="comments"></div>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechatpay.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechatpay.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/rss2.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Panda Shen &copy; 2017 - 2019</span>
            <span>
                
                
                
                    Hosted by <a href="https://pages.coding.me" target="_blank">Coding Pages</a>
                
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.overtaking.top/2018/07/04/20180704175217/&title=《NodeJS —— 流的原理分析与简易实现》 — Shen's Blog&pic=https://www.overtaking.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.overtaking.top/2018/07/04/20180704175217/&title=《NodeJS —— 流的原理分析与简易实现》 — Shen's Blog&source=

前言在之前的博客中已经了解了流的基本用法，这篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 ReadStream，流的基本用法请看这..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.overtaking.top/2018/07/04/20180704175217/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《NodeJS —— 流的原理分析与简易实现》 — Shen's Blog&url=https://www.overtaking.top/2018/07/04/20180704175217/&via=https://www.overtaking.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.overtaking.top/2018/07/04/20180704175217/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJElEQVR42u3aS3LCQAwFQO5/abLNIsCTNKTKcntFUWY87YXQZx6P+Hr+ut7fk9/fe8rowsDAuCzj+fZ6dU+yiWSF6nNf7gEDA+MGjCSA5pur4pMX8WHPGBgYGINN5DwMDAyMs4woXXv727wYxsDAwMiL2FPl6HxNDAyMuzHyrvv/f/7KfAMDA+NSjGfx6rXJeu22wq4wMDBWM/IAlw818zHnJOBiYGDch1H9Qf6wvNTMBwnREhgYGKsZ1ZbWqS1WW28fAi4GBsZSRi9RqyZ/vXI3eQoGBsZuxmQAkCdwVVL+IjAwMO7GmB+SmAfrSRqKgYGxlZEvlw8Geg24/Ps/XhMGBsZqxjdSusmd1VQVAwPjDox8GNA7LpaskATWDyEeAwNjNaPays9Dc3UgeqAWx8DAWM1I2mRJM66a3k1C+Yewi4GBsY5RPR4xL1x7BzWO/W9gYGBcitFrnCUtsHlhXBghYGBgrGYkiVd1o3kI7hWx5XNtGBgYKxiTpC0P0NXwmhw1ezmJxcDAWMqoNvfzMrXZ/4sLbAwMjLsxoiyyNbY8NdSMAi4GBsYixiR1y9ttvY0WgjgGBsZqxmTpvNHWG2Qmnw9MazEwMC7CqG4xGSHkQ4LekQsMDIx7MgpVb/xNtZ3XOwOGgYGBMWnuJyvPU0kMDAyMU/XxqQbcsdQQAwPjgox8AFkNkdXjX73jHRgYGLsZvSMOvbRvMlQ4MMjEwMC4HuMHgCOyUHOc6uMAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>





    <!-- Valine Comments -->
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var META = ['nick','mail','link'];
        var meta = 'nick,mail'.split(',').filter(function(item){
          return META.indexOf(item) > -1
        });

        new Valine({
            el: '#comments',
            notify: 'false' === 'true',
            verify: 'false' === 'true',
            appId: "RqIV72rdY61eUlDassFQDxPG-gzGzoHsz",
            appKey: "Mvo4cTDcS9hw0l03mINzvdNk",
            avatar: "mm",
            placeholder: "说点什么",
            visitor: "true" === 'true',
            highlight: "true" === 'true',
            meta: meta.length === 0 ? META : meta,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->





<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '愿风指引你前进的道路！';
            clearTimeout(titleTime);
        } else {
            document.title = '真正重要的，只是当下！';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
