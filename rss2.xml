<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Shen&#39;s Blog</title>
    <link>https://www.overtaking.top/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 24 Jun 2019 03:37:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>React 基础篇 —— React Hooks</title>
      <link>https://www.overtaking.top/2019/05/07/20190507155411/</link>
      <guid>https://www.overtaking.top/2019/05/07/20190507155411/</guid>
      <pubDate>Tue, 07 May 2019 07:54:11 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/05/07/20190507155411/react-hooks.jpeg&quot; title=&quot;React Hooks&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-Hooks-简介&quot;&gt;&lt;a href=&quot;#React-Hooks-简介&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 简介&quot;&gt;&lt;/a&gt;React Hooks 简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;code&gt;React Hooks&lt;/code&gt; 是 &lt;code&gt;16.8&lt;/code&gt; 版本中正式加入的特性，配合函数组件使用，在没有 &lt;code&gt;Hooks&lt;/code&gt; 之前，函数组件使用场景非常有限，只适合编写纯展示性的 &lt;code&gt;UI&lt;/code&gt; 组件，其余复杂的场景不得不使用类组件，而 &lt;code&gt;Hooks&lt;/code&gt; 的主要作用是在函数组件中使用原本所不具备的 &lt;code&gt;React&lt;/code&gt; 特性。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/05/07/20190507155411/react-hooks.jpeg" title="React Hooks"><p><br></p><h2 id="React-Hooks-简介"><a href="#React-Hooks-简介" class="headerlink" title="React Hooks 简介"></a>React Hooks 简介</h2><blockquote class="pullquote default"><p><code>React Hooks</code> 是 <code>16.8</code> 版本中正式加入的特性，配合函数组件使用，在没有 <code>Hooks</code> 之前，函数组件使用场景非常有限，只适合编写纯展示性的 <code>UI</code> 组件，其余复杂的场景不得不使用类组件，而 <code>Hooks</code> 的主要作用是在函数组件中使用原本所不具备的 <code>React</code> 特性。</p></blockquote><a id="more"></a><h2 id="React-Hooks-产生的动机"><a href="#React-Hooks-产生的动机" class="headerlink" title="React Hooks 产生的动机"></a>React Hooks 产生的动机</h2><p>在业务开发中，数据主要存在两种形式，业务数据和 <code>UI</code> 数据，我们需要将这两种数据区分开，而有时数据又在组件之间存在共用关系，情况稍微复杂，参数传递的方式就无法满足需求，于是就会有状态管理进入到项目中（<code>Redux</code>、<code>Mobx</code>）等，会增加开发者的学习成本和项目的维护成本。</p><p>使用 <code>React</code> 的开发者都知道，<code>React</code> 主张组件化，就是把业务页面拆分成多个组件进行组合、嵌套、渲染。为了保证项目质量，开发者会花费大量精力在项目的模块化、状态数据最小化以及功能解耦上，而一部分组件会因为数据状态的共享耦合在一起，这时需要使用高阶组件、属性渲染、渲染回调等更高级的 <code>React</code> 特性去解耦，但是会增加代码的复杂程度、降低代码的可读性，在渲染时也会增加 <code>DOM</code> 的层级。</p><p>上面这些实际问题促成了 <code>React Hooks</code> 的诞生，而在有 <code>Hooks</code> 后官方也越来越推荐使用函数组件，主要原因总结如下。</p><ul><li>为了状态相关逻辑的提取和复用；</li><li>解决复杂组件代码变得难以理解的问题；</li><li>解决类组件带给开发者一些容易混淆的点，比如 <code>this</code> 指向问题；</li><li>由于 <code>JS</code> 解释器在解释 <code>class</code> 关键字时的性能问题，使用函数组件代替。</li></ul><blockquote class="pullquote info"><p><code>React</code> 没有重大变化，完全兼容类组件，可以让开发者不必完全重写现有代码，而是在后续开发中逐步尝试使用 <code>Hooks</code>。</p></blockquote><h2 id="React-Hooks-分类"><a href="#React-Hooks-分类" class="headerlink" title="React Hooks 分类"></a>React Hooks 分类</h2><p><strong><code>React</code> 官方主要给 <code>Hooks</code> 分为两大类：</strong></p><ul><li>基础 <code>Hooks API</code>：<code>useState</code>、<code>useEffect</code>、<code>useContext</code>；</li><li>其他 <code>Hooks API</code>：<code>useReducer</code>、<code>useCallback</code>、<code>useImperativeHandle</code>、<code>useMemo</code>、<code>useRef</code>、<code>useLayoutEffect</code>、<code>useDebugValue</code>。</li></ul><h2 id="React-Hooks-使用规则"><a href="#React-Hooks-使用规则" class="headerlink" title="React Hooks 使用规则"></a>React Hooks 使用规则</h2><p>为了保证 <code>Hooks</code> 在使用时不会出现不可预测的问题，官方制定了一定要遵循的两条使用规则（非建议），在此提前声明。</p><blockquote class="pullquote warning"><p><em><strong>1、只在函数组件内部最顶层调用 <code>Hook</code>，不要在循环、条件判断或者嵌套函数中调用；</strong></em><br><em><strong>2、只能在函数组件中调用 <code>Hook</code>（自定义 <code>Hook</code> 中可以调用 <code>Hook</code>），不要在其他 <code>JavaScript</code> 函数中调用。</strong></em></p></blockquote><h2 id="React-Hooks-API"><a href="#React-Hooks-API" class="headerlink" title="React Hooks API"></a>React Hooks API</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 方法用于在函数组件内部实现组件的状态管理，可以起到类组件中 <code>state</code> 一样的作用。</p><figure class="highlight jsx"><figcaption><span>类组件实现的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Components &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Components</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click!</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面是一个类组件实现的计数器，当前计数器的值在类组件的 <code>state</code> 中进行管理。</p><figure class="highlight jsx"><figcaption><span>Hooks 实现的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>使用 <code>React Hooks</code> 的 <code>useState</code> 实现的计数器和类组件实现的功能完全相同，从 <code>useState</code> 实现的代码可以看出 <code>useState</code> 是一个函数，传入的参数是状态的初始值，返回值是一个数组，数组的第一项是当前状态的值，数组的第二项是改变状态值的方法。</p><figure class="highlight jsx"><figcaption><span>实现每次加 2 的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> countAction = <span class="function">(<span class="params">preCount, n</span>) =&gt;</span> preCount + n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(countAction(count, 2))&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面计数器功能的实现逻辑比较简单，下面来看一个类组件实现的稍微复杂的案例，然后再通过 <code>useState</code> 进行重构。</p><figure class="highlight jsx"><figcaption><span>类组件实现的模态切换功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Modal &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Toggle 组件专门提供切换状态和切换方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 on 的值</span></span><br><span class="line">    <span class="keyword">this</span>.state.on = <span class="keyword">this</span>.props.initial;</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123; <span class="attr">on</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  toggle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">on</span>: !<span class="keyword">this</span>.state.on &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.on, <span class="keyword">this</span>.toggle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Toggle initial=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        (on, toggle) =&gt; (</span><br><span class="line">          &lt;Fragment&gt;</span><br><span class="line">            &lt;Button type=<span class="string">"primary"</span> onClick=&#123;toggle&#125;&gt;</span><br><span class="line">              Open Model</span><br><span class="line">            &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Modal visible=&#123;on&#125; onCancel=&#123;toggle&#125;/</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面代码中的类组件 <code>Toggle</code> 主要的作用就是管理模态框显示的状态和对状态的控制，选择使用 <code>children</code> 并传入一个函数，目的是函数可以在类组件内部通过 <code>children</code> 属性调用，并将 <code>Toggle</code> 内部的状态和方法作为参数传入，进而将功能提供给函数组件，这种高级的用法叫做 “渲染回调”，可以成功的将组件进行解耦，但是这样的方式缺点也显而易见，就是代码的逻辑抽象，可读性差，下面来使用 <code>useState</code> 进行重构。</p><figure class="highlight jsx"><figcaption><span>useState 重构切换模态的功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Modal &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ on, setOn ] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Button type=<span class="string">"primary"</span> onClick=&#123;() =&gt; setOn(<span class="literal">true</span>)&#125;&gt;</span><br><span class="line">        Open Model</span><br><span class="line">      &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Modal visible=&#123;on&#125; onCancel=&#123;() =&gt; setOn(false)&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong>因为 <code>React Hooks</code> 的 <code>useState</code> 让函数组件具备了管理组件状态的能力，所以不需要单独实现 <code>Toggle</code> 组件，代码变得更精简、清晰，更函数式编程，更新粒度更细。</strong></p></blockquote><p><code>useState</code> 解构出的用来更改状态的函数传入的参数支持函数类型，传入函数的参数为上一次的状态值，也就是说当更新状态的新值依赖于上一次的值时，会通过这样的方式解决。</p><figure class="highlight jsx"><figcaption><span>当 useState 更新的状态依赖于上一次的值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prev =&gt; prev + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>正如 <code>useEffect</code> 钩子的命名一样，是在函数组件中专门用来处理副作用的，这个副作用是指某些操作使用了函数组件作用域外的变量，而且这个操作的结果会影响函数组件外部的环境。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次渲染后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初次渲染后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Execute once'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 count 更改时才执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count changed'</span>);</span><br><span class="line">  &#125;, [ count ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count)&#125;&gt;</span><br><span class="line">        Click no change!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面案例是通过 <code>useState</code> 一节中的计数器案例改编，我们增加了每次点击计数器将计数器状态同步到页面标题上的功能，并使用 <code>useEffect</code> 实现，<code>useEffect</code> 函数的参数为回调函数，并在每次页面渲染之后执行（包含首次渲染和更新渲染）。</p><blockquote class="pullquote primary"><p><strong>可以使用 <code>useEffect</code> 替代类组件的生命周期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</strong></p></blockquote><p><code>useEffect</code> 还支持传入第二个参数，类型为数组，数组的值为被监听的状态（被 <code>useState</code> 监听），此时 <code>useEffect</code> 内部会做一次比较，数组中变量的值没发生变化时，传入对应 <code>useEffect</code> 的回调不会执行，当传入 <code>useEffect</code> 的数组为空时，则传入的回调只在函数组件首次渲染时执行一次，作用相当于类组件的声明周期 <code>componentDidMount</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Hooks 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HooksCom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times (hooks)`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 类组件</span></span><br><span class="line"><span class="regexp">class ClassCom extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123; count: 1 &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    document.title = `You clicked $&#123;this.state.count&#125; times (class)`;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidUpdate() &#123;</span></span><br><span class="line"><span class="regexp">    document.title = `You clicked $&#123;this.state.count&#125; times (class)`;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;)&#125;&gt;Click!<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Fragment&gt;</span></span><br><span class="line"><span class="regexp">      &lt;HooksCom /</span>&gt;</span><br><span class="line">      &lt;ClassCom /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>通过上面案例，对于使用了 <code>componentDidMount</code> 生命周期的类组件和使用了 <code>useEffect</code> 的函数组件对于页面标题更改的对比，<code>useEffect</code> 的执行会晚于 <code>componentDidMount</code>。</strong></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChatAPI = &#123;</span><br><span class="line">  handle: <span class="literal">null</span>,</span><br><span class="line">  isOnline: <span class="literal">false</span>,</span><br><span class="line">  login() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOnline = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.handle &amp;&amp; <span class="keyword">this</span>.handle(&#123; <span class="attr">isOnline</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  logout() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOnline = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.handle &amp;&amp; <span class="keyword">this</span>.handle(&#123; <span class="attr">isOnline</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  subscribeToFriendStatus(id, handle) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`订阅好友：<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">  &#125;,</span><br><span class="line">  unsubscribeToFriendStatus(id, handle) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`清理好友：<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.handle = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于渲染好友在线状态的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制好友在线的变量和方法</span></span><br><span class="line">  <span class="keyword">const</span> [ isOnline, setIsOnline ] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置好友状态的函数</span></span><br><span class="line">  <span class="keyword">const</span> handleStatusChange = <span class="function">(<span class="params">status</span>) =&gt;</span> setIsOnline(status.isOnline);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 订阅好友状态</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 清除好友状态</span></span><br><span class="line">      ChatAPI.unsubscribeToFriendStatus(props.friend.id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [ props.friend.id ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;计数器：&#123;props.friend.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;br/</span>&gt;</span><br><span class="line">      &lt;span&gt;</span><br><span class="line">        登录状态：</span><br><span class="line">        &#123;</span><br><span class="line">          isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ show, setShow ] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [ userId, setUserId ] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;用户ID：&#123;userId&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;br/</span>&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        show &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">FriendStatus</span> <span class="attr">friend</span>=<span class="string">&#123;&#123;</span> <span class="attr">id:</span> <span class="attr">userId</span>, <span class="attr">name:</span> '<span class="attr">Hello</span>' &#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(!show)&#125;&gt;显示/关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setUserId(userId + 1)&#125;&gt;增加用户ID<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;增加计数器<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;ChatAPI.login.bind(ChatAPI)&#125;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;ChatAPI.logout.bind(ChatAPI)&#125;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面是一个覆盖比较全的 <code>useEffect</code> 案例，用来实现组件 <code>FriendStatus</code> 内对用户的订阅和取消订阅，其中 <code>App</code> 组件中的 <code>show</code> 状态用来控制 <code>FriendStatus</code> 组件是否渲染，<code>显示/关闭</code> 按钮用来控制 <code>show</code> 的值，<code>FriendStatus</code> 默认登录状态显示 <code>Loading...</code>，<code>登录</code> 和 <code>退出</code> 按钮用来空登录状态的显示（<code>Online</code> 或 <code>Offline</code>），<code>增加用户ID</code> 和 <code>增加计数器</code> 按钮分别用来更改当前用户 <code>ID</code> 和计数器的值，计数器的 <code>count</code> 属性和 <code>setUserId</code> 通过 <code>Render Props</code> 的方式传递给 <code>FriendStatus</code>，我们将使用到的方法统一都放在 <code>ChatAPI</code> 对象上。</p><p>默认渲染 <code>FriendStatus</code> 在控制台发现 <code>useEffect</code> 执行了，并订阅了当前传入的用户，而点击 <code>显示/关闭</code> 按钮时发现取消订阅了用户，这说明组件卸载之前执行了 <code>useEffect</code> 回调内部返回的函数，点击增加计数器按钮，<code>FriendStatus</code> 组件发生了重新渲染，而 <code>useEffect</code> 内部并没有再次对用户进行订阅，原因是指定了 <code>useEffect</code> 的第二个参数，并将用户的 <code>ID</code> 作为元素存入数组内，也就是用户 <code>ID</code> 不发生变化的时候就不会重新执行这个 <code>useEffect</code> 去订阅用户，当点击 <code>增加用户ID</code> 按钮时，控制台首先取消订阅了上一个用户，又订阅了新的用户，这说明 <code>FriendStatus</code> 组件重新渲染时，如果需要执行 <code>useEffect</code>，则会优先执行回调内返回的取消订阅的函数。</p><blockquote class="pullquote default"><p><strong>如果在 <code>useEffect</code> 方法传入的回调中返回一个函数，这个函数会在组件卸载之前执行，或重新渲染需时要执行对应的 <code>useEffect</code> 时优先执行。</strong></p></blockquote><figure class="highlight jsx"><figcaption><span>频繁更新未被监听的变量不变</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的案例是一个状态频繁变化的组件，但是我们给 <code>useEffect</code> 传入的第二个参数为空数组，这就会产生一个 <code>Bug</code>，由于 <code>useEffect</code> 默认只执行一次，并没有执行清除定时器的返回函数，所以导致取到的依然是上一次的状态值，还记得上面一节 <code>useState</code> 中提到使用上一次的状态去更新状态，这里我们可以通过这种方式修复这个 <code>Bug</code>。</p><figure class="highlight jsx"><figcaption><span>解决频繁更新未被监听变量不变的问题</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">prev</span> =&gt;</span> prev + <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>所以说在有些时候，对于 <code>useEffect</code> 第二个参数传入 <code>[ ]</code> 的行为不是绝对安全的，并且不建议这样使用。</strong></p></blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p><code>useReducer</code> 是 <code>useState</code> 的替代方案，用来处理复杂的 <code>state</code> 更新，看到这个名字大家可能会想到 <code>Redux</code> 中的 <code>reducer</code>，其实 <code>useReducer</code> 就是 <code>React Hooks</code> 中用来替代 <code>Redux</code> 解决问题的，让我们从此不需要 <code>Redux</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始 state</span></span><br><span class="line"><span class="keyword">const</span> initalCountState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.payload &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始 state 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initalCountState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>: initalCountState.count + <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initalCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalCountState, init);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      count: &#123; state.count &#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: initalCount &#125;)&#125;</span><br><span class="line">      &gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Counter initalCount=&#123;0&#125; /</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p><code>useReducer</code> 有三个参数，第一个参数为 <code>reducer</code> 函数（根据 <code>action</code> 的类型匹配新的 <code>state</code> 值），第二个参数为监听状态对象 <code>state</code> 的初始值，第三个参数也是一个函数，参数为初始的 <code>state</code>，作用是输出一个新的 <code>state</code> 替换初始的 <code>state</code>，只在最初执行一次。</p><p><code>useReducer</code> 的返回值为数组，数组第一项是监听的 <code>state</code> 对象，第二项是用来触发 <code>state</code> 的函数，参数为 <code>action</code>。</p><figure class="highlight jsx"><figcaption><span>useReducer 不传第三个参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.payload &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initalCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalCount);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      count: &#123; state.count &#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;</span><br><span class="line">          type: <span class="string">'reset'</span>,</span><br><span class="line">          payload: initalCount.count</span><br><span class="line">        &#125;)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Counter initalCount=&#123;&#123; count: 0 &#125;&#125; /</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>这个案例跟之前的稍有差别，去掉了 <code>useReducer</code> 的第三个参数，并将 <code>Counter</code> 组件的入参 <code>initalCount</code> 作为了初始 <code>state</code>。</p><blockquote class="pullquote success"><p><strong>使用 <code>React</code> 进行过项目开发应该都是用过 <code>Redux</code> 和 <code>Mobx</code> 之类的状态管理工具，但其实他们并不是专门针对 <code>React</code> 所设计的，里面都蕴含了一些关于状态管理的编程思想和自己独立的逻辑，也可以在其他框架技术栈中使用，只是和 <code>React</code> 搭配使用时更舒适，而 <code>React hooks</code> 中提供了官方自身的状态管理解决方案，避免依赖第三方库，所以 <code>Facebook</code> 挖来了 <code>Redux</code> 的作者开发了 <code>React hooks</code> 中状态管理相关的 <code>API</code>。</strong></p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>想了解 <code>useContext</code> 首先要了解 <code>context API</code>，即 <code>React.createContext</code> 方法，执行后返回一个对象，其中包含两个属性分别为 <code>Provider</code> 和 <code>Consumer</code>，都为组件，<code>Provider</code> 用于包裹提供状态的容器组件，<code>Consumer</code> 用于包裹消费这个状态的组件，更详细的用法不在这里过多赘述，可以查看 <a href="https://react.docschina.org/docs/context.html" target="_blank">React 官方文档</a>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, setCount &#125; = useContext(myContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      子组件：&#123;count&#125;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;myContext.Provider value=&#123;&#123; count, setCount &#125;&#125;&gt;</span><br><span class="line">      父组件：&#123;count&#125;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;Com /&gt;</span><br><span class="line">    &lt;<span class="regexp">/myContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面是 <code>useContext</code> 的一个简单用法，我们创建了 <code>context</code>，在父组件 <code>App</code> 中创建了 <code>count</code> 和更改 <code>count</code> 的函数 <code>setCount</code>，并将它们通过 <code>context</code> 的 <code>Provider</code> 组件提供给子组件 <code>Com</code>，子组件中调用 <code>useContext</code> 并传入这个创建的 <code>context</code> 对象，返回了父组件所提供的状态数据，并在子组件中点击的方式来更改，此时父、子组件中渲染的 <code>count</code> 都发生了变化。</p><p>上面说 <code>React hooks</code> 中提供了自己的状态管理解决方案，也就是说可以替代 <code>Redux</code> 的工作，实现整个项目的状态管理以及相关状态逻辑的复用，下面就使用 <code>useContext</code> 和 <code>useReducer</code> 来实现一个简单的状态管理逻辑。</p><figure class="highlight jsx"><figcaption><span>reducer.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态（默认值）</span></span><br><span class="line"><span class="keyword">const</span> initalState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出共用的上下文</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 reducer 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> initalState;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出提供状态的函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextProvider = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;myContext.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/myContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的 <code>reducer.js</code> 文件用来提供整个状态管理的核心逻辑，创建了初始的 <code>state</code>，创建了共用的上下文对象，创建了 <code>reducer</code> 函数（通过 <code>action</code> 来匹配并返回新的 <code>state</code>），创建了用来提供 <code>state</code> 和 <code>dispatch</code> 的公共组件 <code>ContextProvider</code>，该组件内部通过创建上下文的 <code>Provider</code> 组件给该组件中间包裹的所有子组件 <code>children</code> 通过 <code>value</code> 提供 <code>state</code> 和 <code>dispatch</code>（通过 <code>useReducer</code> 创建）。</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ContextProvider &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ContextProvider&gt;</span><br><span class="line">        &lt;Counter /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ContextProvider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p><code>App</code> 组件，是提供状态的容器（一般使用根组件），根据 <code>reducer.js</code> 的用法，只需要引入 <code>ContextProvider</code> 组件包裹需要使用状态的子组件，与 <code>react-redux</code> 的 <code>Provider</code> 组件提供 <code>store</code> 的模式相似，这样被 <code>ContextProvider</code> 组件包裹的子组件就可以使用 <code>reducer.js</code> 中所 <code>useReducer</code> 所提供的 <code>state</code> 和 <code>dispatch</code>，<code>Counter</code> 子组件代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myContext &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; state, dispatch &#125; = useContext(myContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Counter count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'reset'</span> &#125;)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure><p>在使用 <code>reducer.js</code> 中实现的状态管理逻辑的组件中，只需要引入 <code>reducer.js</code> 提供的 <code>context</code>，并使用 <code>useContext</code> 就可以解构出 <code>state</code> 和 <code>dispatch</code>，并通过 <code>action</code> 实现三种不同的对状态的 <code>state</code> 的操作。</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p><code>useCallback</code> 是 <code>React</code> 针对函数组件的优化考虑所设计的 <code>Hook API</code>，在函数被渲染时，<code>React</code> 底层是通过调用的方式去创建的，如果函数组件作用域中创建了实现某些功能的函数，则底层每次调用函数组件时，这些函数都会被重新创建，也就是指向新的引用，有了 <code>React Hooks</code> 以后，函数组件中需要的函数可以通过 <code>useCallback</code> 创建。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useCallback, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存储 useCallback 返回的函数</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 useCallback 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestUseCallback</span>(<span class="params">&#123; nums, name &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedCallback = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nums, <span class="string">'Hello world!'</span>);</span><br><span class="line">  &#125;, [ nums ]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'callback 是否相同：'</span>, <span class="built_in">Object</span>.is(fn, memoizedCallback));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nums &gt; '</span>, nums, <span class="string">'name &gt; '</span>, name);</span><br><span class="line">  fn = memoizedCallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;memoizedCallback&#125;&gt;TestUseCallback&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来触发重新 render 的类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    nums: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    name: <span class="string">'hello'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;));</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChangeNum = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">nums</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="attr">name</span>: <span class="string">'world'</span> &#125;);</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; nums, name &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Start editing to see some magic happen!<span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleChangeNum&#125;&gt;修改传入的 nums 值&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TestUseCallback nums=&#123;nums&#125; name=&#123;name&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>在上面的案例中渲染的组件 <code>App</code> 是一个类组件，该组件在挂载后会创建一个定时器，每 <code>3s</code> 更新 <code>state</code> 的 <code>count</code> 值，来完成重渲染，内部的 <code>TestUseCallback</code> 组件也会跟着重渲染，在内部检测 <code>useCallback</code> 创建的函数是否每次都会创建新的，同时打印父组件传递的参数，在通过父组件的点击事件更改的依赖的时候，观察 <code>useCallback</code> 是否会新创建返回的值。</p><blockquote class="pullquote info"><p><strong>执行 <code>useCallback</code> 方法传入的的参数为回调函数和依赖列表（数组），返回值为传入的函数，<code>React</code> 已经将传入的函数注入，只要依赖列表中的依赖没有发生变化，就不会创建新的函数返回，这样就大大减小了每次都在内存中创建新的引用来存储新函数的开销，也同时减少了 <code>GC</code> 的压力。</strong></p></blockquote><figure class="highlight jsx"><figcaption><span>组件中不同方式事件处理函数的区别</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick()&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com2</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Com1</code>：类组件，直接使用箭头函数，每次重新渲染都产生新的函数；</li><li><code>Com2</code>：类组件，在 <code>constructor</code> 中使用 <code>bind</code> 绑定 <code>this</code>，每次重新渲染都使用一个函数；</li><li><code>Com3</code>：函数组件，直接创建函数，每次重新渲染都产生新的函数；</li><li><code>Com4</code>：函数组件，使用 <code>useCallback</code> 创建函数，每次重新渲染都使用一个函数；</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = React.memo(<span class="function">(<span class="params">&#123; a, memo &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Child 渲染'</span>)&#125;</span><br><span class="line">      &lt;span&gt;a: &#123;a&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;memo&#125;&gt;Click in child&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const [ a, setA ] = useState(0);</span></span><br><span class="line"><span class="regexp">  const [ b, setB ] = useState(0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 直接创建的函数</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ const handleClick = () =&gt; console.log('click');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 使用 useCallback 创建的函数</span></span><br><span class="line"><span class="regexp">  const handleClick = useCallback(() =&gt; console.log('click'), []);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;console.log('App 渲染')&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Child a=&#123;a&#125; memo=&#123;handleClick&#125; /</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setA(a + <span class="number">1</span>)&#125;&gt;改变 a&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setB(b + 1)&#125;&gt;改变 b&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面案例中使用了 <code>React.memo</code> 的函数组件优化方法来进一步验证了 <code>useCallback</code> 的作用，方法 <code>React.memo</code> 的参数为一个函数组件，会返回一个高阶组件，作用是当传入的函数组件内部的 <code>props</code> 不发生变化时，则不会重新渲染。</p><p>父组件 <code>App</code> 中使用 <code>useCallback</code> 创建的函数和使用 <code>useState</code> 创建的状态 <code>a</code> 作为参数传递给子组件 <code>Child</code>，并通过点击事件改变 <code>a</code> 和 <code>b</code> 的状态，初次渲染时控制台打印 <code>App 渲染</code> 和 <code>Child 渲染</code>，当点击 <code>改变 a</code> 时，父、子组件同时渲染，是因为子组件 <code>props</code> 中的 <code>a</code> 发生变化，当点击 <code>改变 b</code> 时，父组件重新渲染，但是子组件并没有，说明 <code>useCallback</code> 并没有产生新的函数传递给子组件，当使用 <code>App</code> 组件注释中直接创建的函数时，则点击 <code>改变 b</code>，子组件也会重新渲染，是因为父组件重渲染创建了新的函数，导致子组件的参数发生变化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储两个组件的函数</span></span><br><span class="line"><span class="keyword">let</span> fnn1 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> fnn2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 React.memo 改写的一个渲染耗时的组件（假设很耗时）</span></span><br><span class="line"><span class="keyword">const</span> ExpensiveCom = React.memo(<span class="function">(<span class="params">&#123; onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;console.log('昂贵组件渲染了！')&#125;</span></span><br><span class="line"><span class="xml">    &#123;date.getSeconds()&#125;</span></span><br><span class="line"><span class="xml">    我是一个昂贵的组件！渲染耗时！</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com1</span>(<span class="params">&#123; p1 &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fn'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Com1'</span>, <span class="built_in">Object</span>.is(fnn1, fn));</span><br><span class="line">  fnn1 = fn;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ExpensiveCom</span> <span class="attr">onClick</span>=<span class="string">&#123;fn&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Com2(&#123; p2 &#125;) &#123;</span></span><br><span class="line"><span class="xml">  const fn = useCallback(() =&gt; console.log('fn', p2), [ p2 ]);</span></span><br><span class="line"><span class="xml">  console.log('Com2', Object.is(fnn2, fn));</span></span><br><span class="line"><span class="xml">  fnn2 = fn;</span></span><br><span class="line">  return &lt;ExpensiveCom onClick=&#123;fn&#125; /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [ p1, setP1 ] = useState(0);</span><br><span class="line">  const [ p2, setP2 ] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;每次点击 fn 都是新的&lt;/h2&gt;</span><br><span class="line">      &lt;Com1 p1=&#123;p1&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; setP1(&#123; p1: p1 + 1 &#125;)&#125;</span><br><span class="line">      &gt;p1 + 1&lt;/button&gt;</span><br><span class="line">      &lt;br/&gt;</span><br><span class="line">      &lt;h2&gt;不用重复生成 fn&lt;/h2&gt;</span><br><span class="line">      &lt;Com2 p2=&#123;p2&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; setP2(&#123; p2: p2 + 1 &#125;)&#125;</span><br><span class="line">      &gt;p2 + 1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中假设 <code>ExpensiveCom</code> 是一个渲染非常耗时的 “昂贵” 组件，并在两个不同的容器组件 <code>Com1</code> 和 <code>Com2</code> 中对比，<code>ExpensiveCom</code> 参数是在父组件 <code>Com1</code> 和 <code>Com2</code> 中创建的函数，前者直接创建，后者使用 <code>useCallback</code> 创建，在 <code>App</code> 组件中渲染 <code>Com1</code> 和 <code>Com2</code>，分别传入状态 <code>p1</code> 和 <code>p2</code>，并在 <code>Com1</code> 和 <code>Com2</code> 内部的函数中进行打印，而创建的函数作为 “昂贵” 组件的参数，并作为内部点击的执行函数。</p><p>当在页面点击 <code>p1 + 1</code> 或 <code>p2 + 1</code> 时，都会导致 <code>App</code> 的状态变化，也就是 <code>App</code> 的重渲染，而作为 <code>App</code> 的子组件, <code>Com1</code> 和 <code>Com2</code>，也会跟着重新渲染，点击 <code>p1 + 1</code>，从控制台打印结果看，只有 <code>Com1</code> 内部的 “昂贵” 组件重新渲染，而 <code>Com2</code> 中并没有，是因为 <code>useCallback</code> 中依赖的 <code>p2</code> 没有改变，没有生成新的函数，当点击 <code>p2 + 1</code> 时，<code>Com2</code> 内部的 “昂贵” 组件重新渲染，同时 <code>Com1</code> 内部的 “昂贵” 组件也重新渲染，由此可以看出 <code>Com2</code> 的性能是要优于 <code>Com1</code> 的。</p><blockquote class="pullquote default"><p><strong>在大型的项目中，可能在内层组件中存在非常耗时耗性能的 “昂贵” 组件，如果因为在外层组件中一个函数的更新导致的所有组件重新渲染，显然性能代价是非常大的，所以合理的使用 <code>useCallback</code> 对函数组件进行优化是非常有必要的。</strong></p></blockquote><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 是一种优化手段，接收两个参数，第一个参数是一个函数，第二个参数是依赖列表，返回值是传入函数的返回结果，在函数组件渲染时，其中的 <code>useMemo</code> 只有在依赖列表中的依赖发生变化，才会重新计算函数的结果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 useMemo 的返回结果</span></span><br><span class="line"><span class="keyword">let</span> ch = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于观察是否重渲染的组件</span></span><br><span class="line"><span class="keyword">const</span> Com = <span class="function">(<span class="params">&#123; val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Com 重新渲染了'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;val&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> child1 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'child1 重新计算'</span>)&#125;</span><br><span class="line">      &lt;Com val=&#123;b&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ), [ a ]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  console.log('child1 是否和之前相等', child1 === ch);</span></span><br><span class="line"><span class="regexp">  ch = child1;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  const child2 = (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;console.log('child2 重新计算')&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Com val=&#123;b&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;child1&#125;</span></span><br><span class="line"><span class="regexp">      &#123;child2&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供状态的容器组件</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ a, setA ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [ b, setB ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Parent a=&#123;a&#125; b=&#123;b&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setA(a + <span class="number">1</span>)&#125;&gt;改变 a&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setB(b + 1)&#125;&gt;改变 b&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中 <code>App</code> 组件提供状态 <code>a</code> 和 <code>b</code> 作为参数提供给 <code>Parent</code> 组件，<code>App</code> 中可以通过 <code>改变 a</code> 和 <code>改变 b</code> 按钮更新状态 <code>a</code> 和 <code>b</code>，当 <code>a</code> 和 <code>b</code> 发生变化时导致 <code>Parent</code> 组件重新渲染，内部的 <code>child1</code> 和 <code>child2</code> 分别是通过 <code>useMemo</code> 和直接创建的组件，其中分别渲染 <code>Com</code> 组件，默认情况下 <code>child1</code> 和 <code>child2</code> 都会渲染，点击 <code>改变 a</code>，<code>child1</code> 和 <code>child2</code> 重新渲染，因为 <code>child1</code> 的依赖 <code>a</code> 发生变化，点击 <code>改变 b</code>，发现只有 <code>child2</code> 重新渲染，而再此点击 <code>改变 a</code>，由于都重新渲染导致 <code>child1</code> 和 <code>child2</code> 渲染的值同步了。</p><blockquote class="pullquote primary"><p><strong><code>useMemo</code> 不仅仅可以优化耗时的复杂计算程序，同时可以优化渲染耗时且页面不要求更新的复杂组件，但有一点需要注意，就是不要在传入 <code>useMemo</code> 的函数中执行与渲染无关的操作，如副作用，这类的操作属于 <code>useEffect</code> 的范畴，而不是 <code>useMemo</code>。</strong></p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>在 <code>React</code> 组件中有一个区分方式，受控组件和非受控组件，大多场景应用于表单元素，受控组件就是通过 <code>onChange</code> 事件和 <code>state</code> 实现双向绑定，这里不过多赘述，非受控组件是通过元素的 <code>ref</code> 属性获取 <code>Dom</code> 的引用，进而对表单进行操作，在 <code>React 16.3</code> 以后推荐使用 <code>React.createRef</code> 方法创建。</p><p>类组件中使用 <code>ref</code> 通常是将引用关联到类组件的实例属性上，方便操作，而 <code>useRef</code> 就是为了在函数组件中实现这个功能而存在的，在函数组件中同样可以 <code>React.createRef</code> 来实现，但是函数组件的每一次重新渲染都会导致 <code>ref</code> 对象的重新创建，浪费内存和性能，下面是一个官方的例子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useRef, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef();</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;获取焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;TextInputWithFocusButton /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong><code>useRef</code> 的参数为创建 <code>ref</code> 对象 <code>current</code> 属性的初始值，<code>ref</code> 对象创建后会作为函数组件的实例属性，除非组件卸载，否则不会重新创建。</strong></p></blockquote><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>在介绍 <code>useImperativeHandle</code> 之前一定要清楚 <code>React</code> 关于 <code>ref</code> 转发（也叫透传）的知识点，是使用 <code>React.forwardRef</code> 方法实现的，该方法返回一个组件，参数为函数（<code>props callback</code>，并不是函数组件），函数的第一个参数为父组件传递的 <code>props</code>，第二给参数为父组件传递的 <code>ref</code>，其目的就是希望可以在封装组件时，外层组件可以通过 <code>ref</code> 直接控制内层组件或元素的行为。</p><figure class="highlight jsx"><figcaption><span>一个关于 ref 转发的例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useCallback, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 ref 的转发</span></span><br><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input ref=&#123;ref&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">    &lt;button&gt;&#123;props.children&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件中使用子组件的 ref</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef();</span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> ref.current.focus(), [ ref ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;FancyButton ref=&#123;ref&#125;&gt;Click Me&lt;<span class="regexp">/FancyButton&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClick&#125;&gt;获取焦点&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中创建了一个 <code>FancyButton</code> 组件，内部渲染了一个 <code>button</code> 元素，我们希望在父元素 <code>App</code> 中渲染 <code>FancyButton</code>，并通过传递给 <code>FancyButton</code> 的 <code>ref</code> 直接操作内部的 <code>button</code>。</p><figure class="highlight jsx"><figcaption><span>一个官方的 useImperativeHandle 例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FancyInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="xml">  const fancyInputRef = useRef();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; fancyInputRef.current.focus()&#125;</span><br><span class="line">      &gt;父组件调用子组件的 focus&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面这个例子中与直接转发 <code>ref</code> 不同，直接转发 <code>ref</code> 是将 <code>React.forwardRef</code> 中函数上的 <code>ref</code> 参数直接应用在了返回元素的 <code>ref</code> 属性上，其实父、子组件引用的是同一个 <code>ref</code> 的 <code>current</code> 对象，官方不建议使用这样的 <code>ref</code> 透传，而使用 <code>useImperativeHandle</code> 后，可以让父、子组件分别有自己的 <code>ref</code>，通过 <code>React.forwardRef</code> 将父组件的 <code>ref</code> 透传过来，通过 <code>useImperativeHandle</code> 方法来自定义开放给父组件的 <code>current</code>。</p><p><code>useImperativeHandle</code> 的第一个参数是定义 <code>current</code> 对象的 <code>ref</code>，第二个参数是一个函数，返回值是一个对象，即这个 <code>ref</code> 的 <code>current</code> 对象，这样可以像上面的案例一样，通过自定义父组件的 <code>ref</code> 来使用子组件 <code>ref</code> 的某些方法。</p><blockquote class="pullquote warning"><p><strong><code>useImperativeHandle</code> 和 <code>React.forwardRef</code> 必须是配合使用的，这也是为什么在开头要介绍 <code>ref</code> 的转发。</strong></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;</span><br><span class="line">  useState,</span><br><span class="line">  useRef,</span><br><span class="line">  useImperativeHandle,</span><br><span class="line">  useCallback</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FancyInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ fresh, setFresh ] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> attRef = useRef(<span class="number">0</span>);</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    attRef,</span><br><span class="line">    fresh</span><br><span class="line">  &#125;), [ fresh ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    attRef.current++;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;attRef.current&#125;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Fancy&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setFresh(!fresh)&#125;&gt;刷新&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const fancyInputRef = useRef();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;FancyInput ref=&#123;fancyInputRef&#125; /</span>&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; <span class="built_in">console</span>.log(fancyInputRef.current)&#125;</span><br><span class="line">      &gt;父组件访问子组件的实例属性&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的案例相对于官方的例子意图更明显一些，通过 <code>useImperativeHandle</code> 将子组件的实例属性输出到父组件，而子组件内部通过 <code>ref</code> 更改 <code>current</code> 对象后，组件不会重新渲染，需要改变 <code>useState</code> 设置的状态才能更改。</p><blockquote class="pullquote info"><p><strong><code>useImperativeHandle</code> 方法还支持传入第三个参数，即依赖列表，当监听的依赖发生变化时，<code>useImperativeHandle</code> 才会重新将子组件的实例属性输出到父组件 <code>ref</code> 的 <code>current</code> 属性上，如果为空数组，则不会重新输出。</strong></p></blockquote><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p><code>useLayoutEffect</code> 的使用方法和 <code>useEffect</code> 相同，唯一的区别就是执行时机不一样。</p><figure class="highlight jsx"><figcaption><span>对比 useLayoutEffect 与 useEffect 的执行时机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useLayoutEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Com 渲染'</span>)&#125;</span><br><span class="line">      &lt;h2&gt;Com1&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Com /&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的例子中在 <code>Com</code> 组件中同时使用了 <code>useLayoutEffect</code> 和 <code>useEffect</code>，在页面初次渲染时可以看到控制台打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 执行...</code>。</p><p>当点击 <code>App</code> 组件按钮更新状态导致 <code>Com</code> 重新渲染，打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><p>在刚接触 <code>React Hooks</code> 时，说到执行时机我们一般会和类组件的生命周期去类比，下面是一个 <code>useLayoutEffect</code>、<code>useEffect</code> 与类组件生命周期配合使用的例子。</p><figure class="highlight jsx"><figcaption><span>对比 useLayoutEffect、useEffect 与类组件生命周期的执行时机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useLayoutEffect, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 useLayoutEffect 和 useEffect 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Com 渲染'</span>)&#125;</span><br><span class="line">      &lt;h2&gt;Com1&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生命周期的类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  setCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'App componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'App componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;Com /&gt;</span><br><span class="line">        &#123;<span class="built_in">console</span>.log(<span class="string">'App 渲染'</span>)&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.setCount&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面例子中 <code>useLayoutEffect</code> 和 <code>useEffect</code> 依然在 <code>Com</code> 组件中使用，<code>App</code> 组件为类组件，<code>Com</code> 作为 <code>App</code> 的子组件，在首次渲染时控制台的打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidMount</code> → <code>useEffect 执行...</code>。</p><p>而点击按钮更改状态触发重渲染时，打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidUpdate</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><blockquote class="pullquote default"><p><strong><code>useLayoutEffect</code> 的执行时机要早于 <code>useEffect</code>，<code>useLayoutEffect</code> 的执行在类组件生命周期前，<code>useEffect</code> 的执行在类组件生命周期后，官方的建议是要求我们尽量使用 <code>useEffect</code>，以避免阻塞视觉更新，如果是将代码从类组件重构为 <code>React Hooks</code>，并且使用 <code>useEffect</code> 出现问题，再考虑使用 <code>useLayoutEffect</code>，服务端渲染时使用 <code>useLayoutEffect</code> 会触发警告。</strong></p></blockquote><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p><code>useDebugValue</code> 用于在 <code>React</code> 开发者工具（如果已安装，在浏览器控制台 <code>React</code> 选项查看）中显示 <a href="https://www.overtaking.top/2019/05/07/20190507155411/#%E8%87%AA%E5%AE%9A%E4%B9%89-Hook" target="_blank">自定义 Hook</a> 的标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useDebugValue &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调试自定义 Hook，显示在 devtools 上</span></span><br><span class="line">  useDebugValue(count &gt; num ? <span class="string">'溢出'</span> : <span class="string">'不足'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ count, myCount ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, seCount ] = useMyCount(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; seCount()&#125;&gt;setCount&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面例子中创建了 <code>useMyCount</code> 自定义 <code>Hook</code>，在内部使用 <code>useDebugValue</code> 对 <code>count</code> 的状态进行了调试，在开发工具中显示如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/05/07/20190507155411/usedebugvalue.png" alt="useDebugValue 调试效果图" title>                </div>                <div class="image-caption">useDebugValue 调试效果图</div>            </figure><p><br></p><p><code>useDebugValue</code> 还支持第二个参数，类型为函数，函数的默认参数为 <code>debug</code> 的状态，作用是对 <code>debug</code> 的值进行格式化，官方叫做 “延迟格式化”。</p><figure class="highlight jsx"><figcaption><span>延迟格式化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useDebugValue &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟格式化</span></span><br><span class="line">  useDebugValue(count &gt; num ? <span class="string">'溢出'</span> : <span class="string">'不足'</span>, status =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> status === <span class="string">'溢出'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ count, myCount ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, seCount ] = useMyCount(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; seCount()&#125;&gt;setCount&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的例子只是做了小小的改动，增加了一个格式化函数作为 <code>useDebugValue</code> 的第二个参数，当状态为 <code>不足</code> 时显示 <code>0</code>，为 <code>溢出</code> 时显示 <code>1</code>。</p><blockquote class="pullquote info"><p><strong>提示：我们不推荐你向每个自定义 <code>Hook</code> 使用 <code>useDebugValue</code>，只有自定义 <code>Hook</code> 被复用时才最有意义。</strong></p></blockquote><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>在开篇介绍 <code>React Hooks</code> 产生的动机时，提到了在类组件中使用 “高阶组件” 和 “渲染回调” 的方式对状态逻辑进行复用和解耦会导致渲染嵌套的层级增多以及代码可读性差的问题，在 <code>React 16.8</code> 以后可以通过自定义 <code>Hook</code> 来解决这些问题。</p><figure class="highlight jsx"><figcaption><span>一个没有解决问题的例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Counter1 /&gt;</span><br><span class="line">      &lt;Counter2 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面实现了两个计数器，都有自动增加状态的更新数组的功能，并且都是使用 <code>React Hooks</code> 实现的，很明显我们可以将更新状态的逻辑抽离出来，下面是通过自定义 <code>Hook</code> 改写的例子。</p><figure class="highlight jsx"><figcaption><span>使用自定义 Hook 对状态逻辑进行抽离</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = useNumber();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = useNumber();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Counter1 /&gt;</span><br><span class="line">      &lt;Counter2 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>使用自定义 <code>Hook</code> 就很容易的实现了状态逻辑的复用和解耦，代码简单易读，也避免了 “高阶组件” 和 “渲染回调” 造成渲染层级增加的问题。</p><blockquote class="pullquote primary"><p><strong>注意：官方建议在创建自定义 <code>Hook</code> 时，也采用 <code>use</code> 开头的命名方式，以保持命名的默认约定，便于识别。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><code>React Hooks</code> 出现后让我们对使用 <code>React</code> 编程如释重负，好的技术就是应该越用越简单，编写大家都读得懂的代码才是好代码，上面就是在学习完 <code>React Hooks</code> 后的一些总结，最后附上相关案例的 <a href="https://github.com/shenqiuhui/react-hooks-examples" target="_blank">Guthub 地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/05/07/20190507155411/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 获取对象属性名的方法和区别</title>
      <link>https://www.overtaking.top/2019/04/17/20190417112536/</link>
      <guid>https://www.overtaking.top/2019/04/17/20190417112536/</guid>
      <pubDate>Wed, 17 Apr 2019 03:25:36 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/04/17/20190417112536/get-object-key.png&quot; title=&quot;JavaScript 获取对象属性名的方法和区别&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;JavaScript&lt;/code&gt; 中想获取某一个对象的属性名，有多种方法可供选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for in&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Reflect.ownKeys&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/17/20190417112536/get-object-key.png" title="JavaScript 获取对象属性名的方法和区别"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>JavaScript</code> 中想获取某一个对象的属性名，有多种方法可供选择。</p><ul><li><code>for in</code></li><li><code>Object.keys</code></li><li><code>Object.getOwnPropertyNames</code></li><li><code>Object.getOwnPropertySymbols</code></li><li><code>Reflect.ownKeys</code></li></ul><p>在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。</p><a id="more"></a><h2 id="创建对象案例"><a href="#创建对象案例" class="headerlink" title="创建对象案例"></a>创建对象案例</h2><p>下面来创建一个对象的案例让这些方法来获取属性，再通过结果来看区别。</p><figure class="highlight js"><figcaption><span>父类，继承自 Object.prototype</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'symbolParent'</span>)]: &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>子类，继承自 parent</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">  c: &#123;</span><br><span class="line">    value: <span class="number">4</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    value: <span class="number">5</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'symbolChild'</span>)]: &#123;</span><br><span class="line">    value: <span class="number">6</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面我们创建了一个对象 <code>parent</code>，上面创建了两个普通属性 <code>a</code>（可枚举）、<code>b</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolParent</code>，创建了一个对象 <code>child</code> 继承自 <code>parent</code>，上面创建了两个普通属性 <code>c</code>（可枚举）、<code>d</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolChild</code>。</p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>从结果来看，<code>for...in</code> 先遍历并获取到了自身的部分属性名，又获取到了继承的部分属性名。</p><blockquote class="pullquote info"><p><strong>总结：<code>for...in</code> 可以遍历自身和继承的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c"]</span></span><br></pre></td></tr></table></figure><p>从结果来看，<code>Object.keys</code> 返回了一个数组，里面存储获取的属性的键名，不能获取继承的属性名，只能获取自身的部分属性名，这种效果相当于 <code>for...in</code> 与 <code>hasOwnProperty</code> 方法的组合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.hasOwnProperty(k)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>总结：<code>Object.keys</code> 只能遍历自身的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c", "d"]</span></span><br></pre></td></tr></table></figure><p>从结果看，<code>Object.getOwnPropertyNames</code> 方法返回了一个数组，存储获取对象属性的键名。</p><blockquote class="pullquote danger"><p><strong>总结：<code>Object.getOwnPropertyNames</code> 只能遍历自身的（包含不可枚举）、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Symbol(symbolChild)]</span></span><br></pre></td></tr></table></figure><p>从结果看，<code>Object.getOwnPropertySymbols</code> 方法返回了一个数组，存储的都是 <code>Symbol</code> 类型的键，说明是专门用来处理 <code>Symbol</code> 类型的。</p><blockquote class="pullquote default"><p><strong>总结：<code>Object.getOwnPropertySymbols</code> 只能遍历自身 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c", "d", Symbol(symbolChild)]</span></span><br></pre></td></tr></table></figure><p><code>Reflect.ownKeys</code> 的返回值为数组，存储遍历到的属性名。</p><blockquote class="pullquote success"><p><strong>总结：<code>Reflect.ownKeys</code> 可以遍历自身的所有属性（包含不可枚举和 <code>Symbol</code> 类型）。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/17/20190417112536/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript 基础知识总结</title>
      <link>https://www.overtaking.top/2019/04/16/20190416160637/</link>
      <guid>https://www.overtaking.top/2019/04/16/20190416160637/</guid>
      <pubDate>Tue, 16 Apr 2019 08:06:37 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/04/16/20190416160637/typescript.jpeg&quot; title=&quot;Typescript&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;TypeScript-简介&quot;&gt;&lt;a href=&quot;#TypeScript-简介&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 简介&quot;&gt;&lt;/a&gt;TypeScript 简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 是由微软开发的开源编程语言（后面简称 &lt;code&gt;TS&lt;/code&gt;），是 &lt;code&gt;JavaScript&lt;/code&gt; 的超集（后面简称 &lt;code&gt;JS&lt;/code&gt;），由于 &lt;code&gt;JS&lt;/code&gt; 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 &lt;code&gt;Bug&lt;/code&gt; 和风险，而 &lt;code&gt;TS&lt;/code&gt; 更适合大型企业应用，是因为 &lt;code&gt;TS&lt;/code&gt; 需要编译成 &lt;code&gt;JS&lt;/code&gt; 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/16/20190416160637/typescript.jpeg" title="Typescript"><p><br></p><h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><blockquote class="pullquote info"><p><code>TypeScript</code> 是由微软开发的开源编程语言（后面简称 <code>TS</code>），是 <code>JavaScript</code> 的超集（后面简称 <code>JS</code>），由于 <code>JS</code> 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 <code>Bug</code> 和风险，而 <code>TS</code> 更适合大型企业应用，是因为 <code>TS</code> 需要编译成 <code>JS</code> 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。</p></blockquote><a id="more"></a><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/04/16/20190416160637/ts-js.png" alt="TypeScript 与 JavaScript 关系图" title>                </div>                <div class="image-caption">TypeScript 与 JavaScript 关系图</div>            </figure><p><br></p><p><code>TS</code> 是前端开发工程化新的趋势，目前很多的开源项目内部都是用 <code>TS</code> 编写，也有很多大牛在推广 <code>TS</code>，目前使用 <code>TS</code> 开发的典型项目有 <code>VSCode</code>、<code>Angular6</code>、<code>Vue3</code> 和 <code>React16</code> 等。</p><h2 id="如何使用-TS"><a href="#如何使用-TS" class="headerlink" title="如何使用 TS"></a>如何使用 TS</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用 <code>TS</code> 之前应该先进行全局安装。</p><figure class="highlight bash"><figcaption><span>安装 TS 的命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure><p>全局安装后会提供 <code>tsc</code> 命令，<code>tsc -v</code> 可以查看当前安装 <code>TS</code> 版本。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>我们可以通过命令单独对文件进行编译，也可以编译整个项目的 <code>TS</code> 文件。</p><figure class="highlight bash"><figcaption><span>编译单个文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>块级作用域变量名检测，两个文件（无论 <code>JS</code> 还是 <code>TS</code>）不允许有相同的变量名。</strong></p></blockquote><p>编译整个项目的 <code>TS</code> 文件需要在项目中设置 <code>tsconfig.json</code> 的配置文件，快速生成配置文件命令如下。</p><figure class="highlight bash"><figcaption><span>生成 tsconfig.json 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>生成 <code>TS</code> 配置文件以后，编译命令 <code>tsc</code> 不需要再指定文件名，会默认读取 <code>tsconfig.json</code> 文件的配置进行编译，关于 <code>tsconfig.json</code> 属性详解请看 <code>TO DO</code>。</p><p>当 <code>TS</code> 文件发生变化时，可以通过 <code>--watch</code> 参数进行实时监听，并当 <code>TS</code> 文件变化时实时编译，也可以把命令配置在 <code>package.json</code> 中通过 <code>npm</code> 执行。</p><figure class="highlight"><figcaption><span>package.json 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "tsc",</span><br><span class="line">    "start": "tsc --watch"</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS-的数据类型"><a href="#TS-的数据类型" class="headerlink" title="TS 的数据类型"></a>TS 的数据类型</h2><p>在 <code>TS</code> 中提供了强大的类型系统，编译时帮助我们对代码中定义的数据类型和值进行检查，如果使用支持 <code>TS</code> 比较好的编辑器，如 <code>VSCode</code>，可以在代码编写时及时发现错误。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="基本数据类型定义"><a href="#基本数据类型定义" class="headerlink" title="基本数据类型定义"></a>基本数据类型定义</h4><p><code>TS</code> 中包含了 <code>JS</code>，所以 <code>TS</code> 也有 <code>6</code> 种基本数据类型，<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'panda'</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> merried: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = Symbol();</span><br></pre></td></tr></table></figure><p>上面声明变量的值与所定义的数据类型必须严格符合，否则编译时报错（编辑器默认就会报错，后面统一说成报错）。</p><p><code>undefined</code> 和 <code>null</code> 是其他基本类型的子类型，类型定义为 <code>undefined</code> 的变量只能赋值 <code>undefined</code>，类型定义为 <code>null</code> 的变量只能赋值 <code>null</code>，类型定义为其他的可以赋值为 <code>undefined</code> 和 <code>null</code>。</p><figure class="highlight ts"><figcaption><span>默认不会报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果想让其他类型的赋值也必须严格与其定义相对应，可以通过配置 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性实现，也被叫做严格类型检查模式。</p><figure class="highlight"><figcaption><span>tsconfig.json 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    "strictNullChecks": true</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类型-any"><a href="#数据类型-any" class="headerlink" title="数据类型 any"></a>数据类型 any</h4><p>希望定义的数据类型可以赋值任何值，可以将数据类型定义为 <code>any</code>，这样相当于没有使用类型校验，等同于直接使用 <code>JS</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span> = <span class="number">18</span>;</span><br><span class="line">value = <span class="string">'hello world'</span>;</span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line">value = <span class="literal">null</span>;</span><br><span class="line">value = <span class="literal">undefined</span>;</span><br><span class="line">value = Symbol();</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p>上面代码中的赋值操作不会报任何错误，因为变量的值类型定义为了 <code>any</code>。</p></blockquote><h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><p>在 <code>TS</code> 中，如果定义的变量没有定义类型，则会对变量的类型进行推测，同样可以在代码编译阶段按照推测的类型校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num = <span class="string">'hello'</span>; <span class="comment">// 报错，不能将类型“"hello"”分配给类型“number”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'world'</span>;</span><br><span class="line">str = <span class="number">1</span>; <span class="comment">// 报错，不能将类型“1”分配给类型“string”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value; <span class="comment">// let value: any</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>类型推论规则：</strong></p><ul><li><strong>从报错的结果可以看出，<code>TS</code> 中声明变量如果没有指定值的类型，则会默认将声明变量时赋值数据的类型定义为该变量的值类型；</strong></li><li><strong>当声明变量没有直接赋值时，<code>TS</code> 会将变量的值类型定义为 <code>any</code>。</strong></li></ul></blockquote><h4 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h4><p><code>TS</code> 也包含基本包装类，基本数据类型是没有方法的（只有对象可以调用对应原型上的方法），在基本数据类型调用方法时是先进行包装过程，把基本类型包装成对象类型。</p><figure class="highlight ts"><figcaption><span>基本数据类型调用方法的包装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num.toFixed(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Number(num).toFixed(2);</span></span><br></pre></td></tr></table></figure><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>有些时候定义的变量在不同场景会赋不同类型的值，我们想要指定这个变量只接受某几个固定类型的值，可以使用联合类型的方式。</p><figure class="highlight ts"><figcaption><span>联合类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">'hello'</span>;</span><br><span class="line">value = <span class="number">10</span>;</span><br><span class="line">value = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>被定义联合类型的变量可以指定符合联合类型中任意一种类型的值，定义时不同的数据类型用 <code>|</code> 隔开，当被赋值不符合联合类型时会报错。</p><blockquote class="pullquote warning"><p><strong>上面联合类型的写法如果多处相同会让代码冗余，在 <code>TS</code> 中提供了 <code>type</code> 关键字来声明类型，用法如下。</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冗余的写法</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> z: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后...</span></span><br><span class="line"><span class="keyword">type</span> MyType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">let</span> x: MyType = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> y: MyType = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> z: MyType = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>被定义联合类型的变量可以通过类型断言指定为更具体的类型，不可以指定联合类型中不包含的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">value = <span class="string">'hello'</span>;</span><br><span class="line">value = <span class="number">10</span>;</span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((value <span class="keyword">as</span> <span class="built_in">string</span>).length); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>断言的语法是将变量使用 <code>as</code> 关键字指定要断言的类型，上面代码中因为变量 <code>value</code> 值最后已经是布尔，而强行将 <code>value</code> 指定为 <code>string</code> 类型去获取 <code>length</code> 属性报错，因为布尔值无法调用 <code>length</code> 属性。</p><h4 id="值的联合"><a href="#值的联合" class="headerlink" title="值的联合"></a>值的联合</h4><p>值的联合（又叫字面量联合）与联合类型不同的是，联合类型只是指定了变量的值类型必须为哪几种，而值的联合则限定了变量的值，变量赋值必须是值的联合中的其中某一个，否则报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: <span class="number">1</span> | <span class="number">6</span> | <span class="number">10</span>;</span><br><span class="line">point = <span class="number">10</span>;</span><br><span class="line">point = <span class="string">'hello'</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> level: <span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'C'</span>;</span><br><span class="line">level = <span class="string">'B'</span>;</span><br><span class="line">level = <span class="string">'b'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 <code>TS</code> 中，数组是引用类型，定义一个数组类型时需要定义数组内部元素的类型。</p><figure class="highlight ts"><figcaption><span>普通数组类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: <span class="built_in">string</span>[] = [<span class="string">'Jim'</span>, <span class="string">'Peter'</span>];</span><br><span class="line"><span class="keyword">let</span> ages: <span class="built_in">number</span>[] = [<span class="number">18</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>泛型定义（泛型会在后面详细说明）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'Jim'</span>, <span class="string">'Peter'</span>];</span><br><span class="line"><span class="keyword">let</span> ages: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">18</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>上面两种方式定义的数组内元素类型必须统一，如果让数组内部元素类型不同该怎么办，在 <code>TS</code> 中有一种特殊的数组类型定义叫做 “元组类型”（<code>tuple</code>）。</p><figure class="highlight ts"><figcaption><span>元组类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Jim'</span>, <span class="number">18</span>];</span><br></pre></td></tr></table></figure><p><strong>元组类型和数组类型的特点如下表：</strong></p><table><thead><tr><th style="text-align:left">元组</th><th style="text-align:left">数组</th></tr></thead><tbody><tr><td style="text-align:left">元素可以是不同类型</td><td style="text-align:left">元素必须为相同类型</td></tr><tr><td style="text-align:left">有预定的长度</td><td style="text-align:left">没有预定的长度</td></tr><tr><td style="text-align:left">用于表示一个结构</td><td style="text-align:left">用于表示一个列表</td></tr></tbody></table><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型是 <code>JS</code> 中所不包含的数据类型，通过 <code>enum</code> 关键字定义，在业务需求中经常会出现某个业务类型对应固定的值，前后端交互的参数都是通过这个值进行约束和传递的。</p><h4 id="普通枚举"><a href="#普通枚举" class="headerlink" title="普通枚举"></a>普通枚举</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Gender &#123;</span><br><span class="line">  BOY,</span><br><span class="line">  GIRL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">  MONDAY = <span class="string">'1'</span>,</span><br><span class="line">  TUESDAY = <span class="string">'2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>编译后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Gender;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Gender</span>) </span>&#123;</span><br><span class="line">  Gender[Gender[<span class="string">"BOY"</span>] = <span class="number">0</span>] = <span class="string">"BOY"</span>;</span><br><span class="line">  Gender[Gender[<span class="string">"GIRL"</span>] = <span class="number">1</span>] = <span class="string">"GIRL"</span>;</span><br><span class="line">&#125;)(Gender || (Gender = &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Week;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Week</span>) </span>&#123;</span><br><span class="line">  Week[<span class="string">"MONDAY"</span>] = <span class="string">"1"</span>;</span><br><span class="line">  Week[<span class="string">"TUESDAY"</span>] = <span class="string">"2"</span>;</span><br><span class="line">&#125;)(Week || (Week = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>从编译结果来看，枚举类型编译成 <code>JS</code> 后帮助我们创建了一个类似于映射表的同名对象，所以可以在 <code>TS</code> 中通过对象属性的方式获取枚举的值。</p><figure class="highlight ts"><figcaption><span>获取枚举值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Gender.BOY); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Week.MONDAY); <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure><h4 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h4><p>常数枚举的的语法是在创建枚举的 <code>enum</code> 关键字前使用 <code>const</code> 声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  RED,</span><br><span class="line">  YELLOW,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [Colors.RED, Colors.YELLOW, Colors.BLUE];</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>编译后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">0</span> <span class="comment">/* RED */</span>, <span class="number">1</span> <span class="comment">/* YELLOW */</span>, <span class="number">2</span> <span class="comment">/* BLUE */</span>];</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>常数枚举与普通枚举的不同是，在编译阶段不会为枚举的类型创建对象，使用枚举类型值的位置直接编译成对应的枚举值。</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数类型定义"><a href="#参数类型定义" class="headerlink" title="参数类型定义"></a>参数类型定义</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在函数中经常会定义可选参数，即非必传，但是 <code>TS</code> 中函数如果按照上面方式定义在调用时不传会报错，可选参数的类型定义如下。</p><figure class="highlight ts"><figcaption><span>可选参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">people</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people(<span class="string">'jim'</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>?:</code> 替代 <code>:</code>，即代表该参数为可选参数，在 <code>TS</code> 中也支持使用默认参数和剩余参数，使用方式如下。</p><figure class="highlight ts"><figcaption><span>默认参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">sum: <span class="built_in">number</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>剩余参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">prefix: <span class="built_in">string</span>, ...args: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix + args.reduce(<span class="function">(<span class="params">sum, val</span>) =&gt;</span> sum + val, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="string">'$'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>在使用默认参数和剩余参数时，设置的参数初始值和传入的剩余参数与定义类型不符合，则会报错。</p><h4 id="返回值类型定义"><a href="#返回值类型定义" class="headerlink" title="返回值类型定义"></a>返回值类型定义</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊的返回值类型：</strong></p><ul><li><code>never</code>：是其他类型的子类型，代表不会出现的值，作为没有返回值的返回类型，函数无法执行完；</li><li><code>void</code>：表示没有任何类型，指函数没有返回值，函数可以正常执行完，如果一个函数没有返回值，则 <code>TS</code> 认为返回值为 <code>void</code> 类型。</li></ul><figure class="highlight ts"><figcaption><span>never 为返回值类型的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">nerver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">nerver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个函数返回值设置为 <code>never</code>，因为抛错和死循环导致都没有执行完毕，此时函数编译不会报错。</p><figure class="highlight ts"><figcaption><span>void 为返回值类型的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>fn2</code> 函数只在非严格检查模式下不会报错，非严格检查模式下返回值类型被定义为 <code>void</code> 的函数可以返回 <code>null</code> 和 <code>undefined</code>。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>之前的函数参数和返回值类型定义是函数声明的方式，声明函数同样有另外一种方式，函数表达式，即给变量赋值为函数，那如何为接收函数的变量定义类型呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fullName: <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">fullName = <span class="function"><span class="keyword">function</span> (<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>括号中 <code>x</code> 和 <code>y</code> 代表定义参数的类型，箭头后代表定义返回值的类型，也可以使用 <code>type</code> 关键字进行声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fn = <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fullName: Fn = <span class="function"><span class="keyword">function</span> (<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>赋值函数的参数类型必须与变量声明的函数参数类型严格一致，返回值同理。</strong></p></blockquote><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是强类型语言中的特性，在 <code>Java</code> 中代表多个同名函数参数不相同，而在 <code>TS</code> 中有所不同，代表为同一个函数提供多个参数类型及返回值定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">type</span> MyType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载限定函数 double</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">boolean</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: MyType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) <span class="keyword">return</span> val + val;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) <span class="keyword">return</span> <span class="number">2</span> * val;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) <span class="keyword">return</span> !val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double(<span class="string">'hello'</span>); <span class="comment">// hellohello</span></span><br><span class="line">double(<span class="number">5</span>); <span class="comment">// 10</span></span><br><span class="line">double(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>重载限定某个函数的方式只有函数声明、函数名、参数及返回值的类型，而没有函数体。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p><code>TS</code> 类的定义与 <code>JS</code> 相同，使用 <code>class</code> 关键字声明，但可以直接对属性、方法定义参数类型和返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  getName(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">'neil'</span>;</span><br><span class="line">p.getName(); <span class="comment">// neil</span></span><br></pre></td></tr></table></figure><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>在 <code>TS</code> 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为，并可以定义存取器的参数及返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  myName: <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">myName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(newVal: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// neil</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'jim'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// jim</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>上面都在类中定义属性，也可以使用参数属性进行简化，代码如下。</p><figure class="highlight ts"><figcaption><span>简化前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>简化后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> myName: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.myName); <span class="comment">// neil</span></span><br></pre></td></tr></table></figure><p><code>public</code> 修饰符写在 <code>constructor</code> 的参数前，代表创建一个与参数同名的公有属性。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>在 <code>TS</code> 中可以在类中定义只读属性，只需要通过 <code>readonly</code> 修饰符修饰即可，只在编译阶段进行检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> readonly myName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.myName); <span class="comment">// neil</span></span><br><span class="line">p.myName = <span class="string">'jim'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>不同类别的（非互斥）的修饰符可以同时修饰一个变量，使用空格隔开。</strong></p></blockquote><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>类与类之间通过 <code>extends</code> 关键字实现继承，子类继承父类后拥有父类的属性和方法，可以增强代码的复用性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  hobby: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, hobby: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">    <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">  &#125;</span><br><span class="line">  getHobby(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hobby;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child(<span class="string">'neil'</span>, <span class="number">20</span>, <span class="string">'swim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.getHobby()); <span class="comment">// swim</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getName()); <span class="comment">// neil</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getAge()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>在 <code>TS</code> 的类中有三种访问控制修饰符，分别为 <code>public</code>、<code>protected</code> 和 <code>private</code>。</p><ul><li><code>public</code>：公有的属性，所有地方都能访问；</li><li><code>protected</code>：受保护的的属性，只能在自己和自己的子类中被访问；</li><li><code>private</code>：私有属性，只有自己内部可以访问。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> money: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, money: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.money = money;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.money);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name, age, money</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age, money);</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.money); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中 <code>name</code> 属性可以通过父类的实例访问、子类的实例访问，父类的 <code>getName</code> 方法访问，子类的 <code>getName</code> 方法访问，<code>age</code> 属性可以只能通过父类和子类的 <code>getAge</code> 方法访问，<code>money</code> 属性只能通过父类 <code>getMoney</code> 方法访问，其他不被允许的访问方式都会报错。</p><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>在 <code>TS</code> 中给类定义私有属性和方法的修饰符为 <code>static</code>，与 <code>JS</code> 的类相同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Father &#123;</span><br><span class="line">  <span class="keyword">static</span> myName: <span class="built_in">string</span> = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">static</span> getMyName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Father.myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Father.myName); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.getMyName()); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种抽象的概念，使用 <code>abstract</code> 关键字定义，无法被实例化（无法使用 <code>new</code>），只能被继承。</p><p>抽象类的内部包含抽象方法和抽象属性，同样使用 <code>abstract</code> 关键字定义，抽象方法不能在抽象类中实现，具体实现细节只能在抽象类的子类中实现，而且必须实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">abstract</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">abstract</span> speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'喵喵喵'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>继承抽象类的子类中必须包含所有抽象类中所定义的内容，继承中这种子类覆盖抽象类所定义抽象方法的行为叫做 “重写”，多个子类创建不同的抽象方法的现象被叫做 “多态”。</strong></p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口是 <code>TS</code> 中的核心之一，主要有两个作用：</strong></p><ul><li>用于描述或约束一种对象结构，描述属性的名称和值的类型；</li><li>用来表示行为的抽象，让类去实现接口。</li></ul><h3 id="接口的定义和使用"><a href="#接口的定义和使用" class="headerlink" title="接口的定义和使用"></a>接口的定义和使用</h3><p><code>TS</code> 中使用 <code>interface</code> 关键字来定义接口，接口成员可以是属性或方法名，多个成员可以使用分号、逗号或换行隔开，主要定义属性的名称和值的类型。</p><figure class="highlight ts"><figcaption><span>定义接口，使用接口创建对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: UserInterface = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面 <code>UserInterface</code> 接口创建的对象 <code>user</code>，属性和值的类型必须与定义的接口严格对应。</p><figure class="highlight ts"><figcaption><span>让类去实现定义的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Flyable &#123;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bird <span class="keyword">implements</span> Flyable &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bird fly'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让类实现一个接口使用 <code>implements</code> 关键字，接口在定义方法时与抽象类非常类似，只需要定义方法和类型，不需要具体实现，在实现接口的类中对方法进行具体实现。</p><figure class="highlight ts"><figcaption><span>一个类实现多个接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> Speakable &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Eatable &#123;</span><br><span class="line">  food: <span class="built_in">string</span>;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Speakable, Eatable &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>;</span><br><span class="line">  food: <span class="string">'cake'</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat cake'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong>继承与实现接口的区别是，一个类可以实现多个接口，一个接口可以被多个类实现，而一个父类（包含抽象类）可以被多个类所继承，一个子类只能继承一个父类（单继承）。</strong></p></blockquote><h3 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h3><p>接口中可以定义只读属性，这样通过接口创建的对象的值在修改时会报错，可以在定义接口属性是加上 <code>readonly</code> 修饰符实现。</p><figure class="highlight ts"><figcaption><span>接口的只读属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>;</span><br><span class="line">  name: <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// 1</span></span><br><span class="line">p.name = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h3><p>在上面接口定义时，创建的对象和实现接口类的属性方法都必须与接口定义的属性名、类型一致，其实在接口定义时也可以定义一些非必须的可选属性，在使用接口创建对象或使用类实现接口时，这样的属性不定义不会报错。</p><figure class="highlight ts"><figcaption><span>接口的可选属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Person = &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  name: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义接口的可选属性与函数定义可选参数类似，都是使用 <code>?:</code> 替代原本的 <code>:</code> 即代表可选。</p><h3 id="接口的未知属性"><a href="#接口的未知属性" class="headerlink" title="接口的未知属性"></a>接口的未知属性</h3><p>当接口中存在可选属性时，也只是满足某些属性可以在使用接口时（对象、类），可选属性可以不创建，但是如果对象和类上扩展了未知的其他任意属性，则编译会报错，此时定义接口未知属性，可以解决编译时报错的问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  [proName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong><code>proName</code> 名字是任意的，可以随意取，<code>string</code> 代表属性的类型，<code>any</code> 代表属性值的类型，上面的写法不固定，可以根据需求定义，只需满足 <code>[name: type]: type</code> 的结构即可。</strong></p></blockquote><p>根据上面的未知属性格式可以衍生出 “可索引接口” 专门用来限制长度未知的数组、属性名和属性个数未知的对象。</p><p><strong>可索引接口限制数组和对象：</strong></p><figure class="highlight ts"><figcaption><span>限制数组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userArr: UserInterface = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">userArr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">1</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面的数组 <code>userArr</code> 内的的索引为数字类型，满足可索引接口的要求，但是使用 <code>UserInterface</code> 约束后，所有项必须是字符串，如果改成其他类型则会报错。</p><figure class="highlight ts"><figcaption><span>限制对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userObj: UserInterface = &#123;</span><br><span class="line">  jim: <span class="string">'1'</span>,</span><br><span class="line">  bob: <span class="string">'2'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的对象 <code>userObj</code> 使用 <code>UserInterface</code> 约束后，键和值必须都为字符串，否则报错。</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口的继承同类的继承相同，使用 <code>extends</code> 关键字实现，下面是一段接口继承的代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父接口</span></span><br><span class="line"><span class="keyword">interface</span> Speakable &#123;</span><br><span class="line">  speak(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子接口</span></span><br><span class="line"><span class="keyword">interface</span> SpeakChinese <span class="keyword">extends</span> Speakable &#123;</span><br><span class="line">  speakChinese(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现接口</span></span><br><span class="line"><span class="keyword">class</span> ChinesePerson <span class="keyword">implements</span> SpeakChinese &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'speak'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  speakChinese() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你好'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>当类实现的接口继承了其他的接口，那这个类的内部需要同时实现子接口和父接口的属性和方法。</strong></p></blockquote><h3 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h3><p>函数型接口专门对函数或方法传入的参数和返回值进行约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Discount &#123;</span><br><span class="line">  (price: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dFun: Discount = discount;</span><br></pre></td></tr></table></figure><p>上面代码中 <code>Discount</code> 接口内部括号内代表参数类型定义，后面代表返回值类型，函数 <code>discount</code> 定义的参数和返回值类型必须与 <code>Discount</code> 接口内部定义的类型保持一致。</p><h3 id="构造函数型接口"><a href="#构造函数型接口" class="headerlink" title="构造函数型接口"></a>构造函数型接口</h3><p>在 <code>TS</code> 中存在对构造函数或类的实例化的类型约束，即在执行 <code>new</code> 操作的时候进行约束检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被约束实例化动作的类</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束实例化的接口</span></span><br><span class="line"><span class="keyword">interface</span> WithNameClazz &#123;</span><br><span class="line">  <span class="keyword">new</span> (name: <span class="built_in">string</span>): Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params">clazz: WithNameClazz, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> clazz(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = createAnimal(Animal, <span class="string">'hellop'</span>);</span><br></pre></td></tr></table></figure><p>上面代码的 <code>interface</code> 中，<code>new</code> 代表约束的动作为实例化操作，<code>name</code> 为参数，<code>string</code> 为参数的类型，而 <code>Animal</code> 代表返回值需要是一个 <code>Animal</code> 类的实例。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>“泛型” 是指在定义函数、接口和类的时候，不预先指定具体的类型，而在使用的时候再进行指定的一种特性。</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>在介绍泛型函数之前先创建一个普通的函数，参数为长度和值，返回一个长度为传入长度、内部元素都为传入值的数组。</p><figure class="highlight ts"><figcaption><span>为使用泛型定义的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">len: <span class="built_in">number</span>, val: <span class="built_in">any</span></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: <span class="built_in">any</span>[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result[i] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray(<span class="number">3</span>, <span class="string">'x'</span>)); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><p>在上面函数中我们类型都是提前进行定义，包括参数、返回值和函数内部变量，这样如果函数内给数组每一项赋值操作没有使用 <code>val</code> 参数传入的值，而是使用其他值，这样无法进行限定，下面使用泛型重新编写上面的函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">len: <span class="built_in">number</span>, val: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result[i] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="number">1</span>)); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面的 <code>T</code> 是泛型的占位符，代表 <code>Type</code> 的意思，也可以使用其他字母代替（类比函数的形参），真正定义类型的时候是在函数调用时传入的。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyArray&lt;T&gt; &#123;</span><br><span class="line">  list: T[] = [];</span><br><span class="line">  add(val: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">  getFirst(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = <span class="keyword">new</span> MyArray&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myArray.add(<span class="number">1</span>);</span><br><span class="line">myArray.add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray.getFirst());</span><br></pre></td></tr></table></figure><p>泛型类与泛型函数相似，都是通过占位符 <code>T</code> 占位，在真正实例化的时候传入类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>上面接口一节中接口内部属性及函数型接口等，成员类型也可以使用泛型进行约束，在某个具体的对象使用接口或类实现接口时传入具体类型，下面是一个函数型接口使用泛型的例子。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SUM&lt;T&gt; &#123;</span><br><span class="line">  (a: T, b: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum2: SUM&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="keyword">function</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>泛型占位符（上面为 <code>T</code>）只在约束的函数、类和接口内部可以使用，可类比函数的形参。</strong></p></blockquote><h3 id="默认泛型类型"><a href="#默认泛型类型" class="headerlink" title="默认泛型类型"></a>默认泛型类型</h3><p>默认泛型类型指的是定义泛型的默认值，被约束的函数、类或者接口在使用时不传入具体类型，则会使用默认类型，编译时会检查是否符合这个默认类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyArray&lt;T = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  list: T[] = [];</span><br><span class="line">  add(val: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = <span class="keyword">new</span> MyArray();</span><br><span class="line">myArray.add(<span class="number">1</span>);</span><br><span class="line">myArray.add(<span class="string">'a'</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="定义多个泛型"><a href="#定义多个泛型" class="headerlink" title="定义多个泛型"></a>定义多个泛型</h3><p>上面的泛型中都只使用了一个占位符 <code>T</code>，其实泛型是允许有多个的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt;(<span class="params">tuple: [A, B]</span>): [<span class="title">B</span>, <span class="title">A</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(swap&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;([<span class="string">'a'</span>, <span class="number">1</span>])); <span class="comment">// [1, 'a']</span></span><br></pre></td></tr></table></figure><p>上面方法中定义了两个泛型，函数参数为一个元组类型的数组，函数返回值为两项交换后的数组。</p><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><p>在函数或类中使用泛型，由于预先不知道泛型的具体类型，所以不能随便使用泛型约束变量的属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span>&gt;(<span class="params">val: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h3><p>如果一定要在函数或类中使用泛型约束变量的属性和方法时，可以预先通过接口定义使用的属性和方法，再通过泛型去继承这个接口即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> LengthWise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">LengthWise</span>&gt;(<span class="params">val: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger&lt;<span class="built_in">number</span>&gt;(<span class="string">'hello'</span>); <span class="comment">// 报错</span></span><br><span class="line">logger&lt;<span class="built_in">string</span>&gt;(<span class="string">'hello'</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="泛型的流程控制"><a href="#泛型的流程控制" class="headerlink" title="泛型的流程控制"></a>泛型的流程控制</h3><p>在定义泛型的时候能够加入逻辑分支，可以使泛型更加灵活。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  nameFish: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Water &#123;</span><br><span class="line">  nameWater: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  nameBird: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sky &#123;</span><br><span class="line">  nameSky: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Condition&lt;T&gt; = T <span class="keyword">extends</span> Fish ? Water : Sky;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> con: Condition&lt;Fish&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了四个接口 <code>Fish</code>、<code>Bird</code>、<code>Water</code> 和 <code>Sky</code>，定义一个 <code>Condition</code> 类型和泛型，如果泛型为 <code>Fish</code> 则继承 <code>Water</code>，否则继承 <code>Sky</code>，在变量 <code>con</code> 使用类型 <code>Condition</code> 时，传入 <code>Fish</code> 接口。</p><h3 id="泛型的别名"><a href="#泛型的别名" class="headerlink" title="泛型的别名"></a>泛型的别名</h3><p>泛型可以使用 <code>type</code> 关键字定义别名，还记得在基本数据类型一节数组的定义中有泛型的定义方式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br></pre></td></tr></table></figure><p>其实上面的 <code>Array</code> 就是定义泛型的别名，<code>&lt;string&gt;</code> 则是在调用这个泛型时传入的具体类型，看了下面例子就明白了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型别名</span></span><br><span class="line"><span class="keyword">type</span> Cart&lt;T&gt; = &#123; list: T[] &#125; | T[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型别名</span></span><br><span class="line"><span class="keyword">let</span> cart1: Cart&lt;<span class="built_in">string</span>&gt; = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">let</span> cart2: Cart&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  list: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>JS</code> 中有很多类数组对象，如 <code>arguments</code>、获取的 <code>DOM</code> 元素集合等等，每一种类数组对象 <code>TS</code> 都定义了对应的泛型别名，下面看两个案例。</p><figure class="highlight ts"><figcaption><span>arguments 对象的泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> params: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">    result += params[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>DOM 节点类数组对象的泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">let</span> children: HTMLCollection = root.children;</span><br><span class="line"><span class="keyword">let</span> childNodes: NodeListOf&lt;ChildNode&gt; = root.childNodes;</span><br></pre></td></tr></table></figure><p>上面用来定义 <code>arguments</code> 类数组对象的泛型别名为 <code>IArguments</code>，获取 <code>DOM</code> 节点的元素节点集合的泛型别名为 <code>HTMLCollection</code>，而全部子节点的泛型别名为 <code>NodeListOf&lt;ChildNode&gt;</code>，如果使用 <code>VSCode</code> 编辑器，可以将鼠标放在变量前面会自动提示对应的泛型别名。</p><blockquote class="pullquote info"><p><strong>接口和泛型别名的区别：</strong></p><ul><li><strong>接口会创建一个新的名称，而别名不会（只是用 <code>type</code> 关键字创建了一个变量）；</strong></li><li><strong>别名不能被继承和实现；</strong></li><li><strong>定义一个类型的时候使用接口，要使用联合类型或者元组类型时，类型别名会更合适。</strong></li></ul></blockquote><h2 id="结构类型系统"><a href="#结构类型系统" class="headerlink" title="结构类型系统"></a>结构类型系统</h2><p>如果传入的变量和声明的类型不匹配，<code>TS</code> 会进行兼容性检查，不是基于定义的类型名称来决定的，而是基于类型的组成结构。</p><h3 id="基本数据类型的兼容性"><a href="#基本数据类型的兼容性" class="headerlink" title="基本数据类型的兼容性"></a>基本数据类型的兼容性</h3><p>基本数据类型也有兼容性判断，如果赋值过程中右侧值的类型符合左侧值的类型，则不会报错，如果左侧类型定义含有 <code>toString</code> 方法的约束，则右侧值凡是可以通过 <code>toString</code> 转换成字符串的都不会报错，赋值时如果右侧值传入的属性多余左侧定义的值时也会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> str1: <span class="built_in">string</span>;</span><br><span class="line">num1 = str1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num2: &#123;</span><br><span class="line">  toString(): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str2: <span class="built_in">number</span>;</span><br><span class="line">num2 = str2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="string">'male'</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="枚举的兼容性"><a href="#枚举的兼容性" class="headerlink" title="枚举的兼容性"></a>枚举的兼容性</h3><p>默认的枚举类型与数字类型兼容，数字类型与枚举类型兼容，不同的枚举类型之间是不兼容的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  RED,</span><br><span class="line">  YELLOW,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容数字类型</span></span><br><span class="line"><span class="keyword">let</span> colorRed: <span class="built_in">number</span> = Colors.RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容枚举类型</span></span><br><span class="line"><span class="keyword">let</span> colorYello: Colors;</span><br><span class="line">colorYello = Colors.Red;</span><br><span class="line">colorYello = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="函数的兼容性"><a href="#函数的兼容性" class="headerlink" title="函数的兼容性"></a>函数的兼容性</h3><p>比较函数的兼容性时要先比较函数的参数，再比较函数的返回值。</p><h4 id="参数的兼容性"><a href="#参数的兼容性" class="headerlink" title="参数的兼容性"></a>参数的兼容性</h4><figure class="highlight ts"><figcaption><span>参数的类型比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SumFunc = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> sum: SumFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错的赋值</span></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错的赋值</span></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的类型检查可以兼容少传参数或不传参数，但是多传参数会报错。</p><h4 id="参数的双向协变"><a href="#参数的双向协变" class="headerlink" title="参数的双向协变"></a>参数的双向协变</h4><p>参数的双向协变是指变量定义的参数类型去兼容变量赋值定义的参数类型，或者变量赋值的参数类型去兼容定义的参数类型，只要有一个成立即可，所谓兼容必须是包含的关系。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogFunc = <span class="function">(<span class="params">val: <span class="built_in">number</span> | <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> log: LogFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量定义类型兼容赋值定义类型</span></span><br><span class="line">log = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量赋值类型兼容变量定义的类型</span></span><br><span class="line">log = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回值的兼容性"><a href="#返回值的兼容性" class="headerlink" title="返回值的兼容性"></a>返回值的兼容性</h4><figure class="highlight ts"><figcaption><span>返回值的类型比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetPerson = <span class="function"><span class="params">()</span> =&gt;</span> &#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> getPerson: GetPerson;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错的赋值</span></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span>, age: <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span>, age: <span class="number">20</span>, gender: <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错的赋值</span></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能调用 age 属性的方法</span></span><br><span class="line">getPerson().age.toFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>返回值可以兼容多返回的属性，属性少了会报错，因为可能会调用返回值缺失属性的方法。</p><h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">let</span> c1: Child = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Parent = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">let</span> c2: Child = <span class="keyword">new</span> Parent(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>父类和子类能不能赋值给限制了父类或子类泛型的变量，能不能赋值和是父类或子类没任何关联，主要看属性是否满足，而上面 <code>p2</code> 没有报错的原因是子类的实例继承了父类的属性，所以提供了父类泛型所要求的属性，而 <code>c2</code> 报错是因为父类的实例并没有提供子类泛型要求的属性。</p><h3 id="接口的兼容性"><a href="#接口的兼容性" class="headerlink" title="接口的兼容性"></a>接口的兼容性</h3><p>在检查参数类型时，并不是真正的比较接口类型，而是比较具体的属性是否兼容。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">a: Animal</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName(p); <span class="comment">// hello;</span></span><br></pre></td></tr></table></figure><p>上面的代码中定义了两个接口 <code>Animal</code> 和 <code>Person</code>，<code>Person</code> 定义的属性更多，当一个符合 <code>Person</code> 的对象传给参数用 <code>Animal</code> 约束的函数时，检测的是接口的属性，只要提供的属性不比约束的属性少，则不会报错。</p><h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><p>泛型在判断兼容性的时候会先判断具体类型，再进行兼容性的判断，即用到了就会比较，没用到就不会比较。</p><figure class="highlight ts"><figcaption><span>空接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>属性使用了泛型的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">x = y; <span class="comment">// 报错，因为 number 类型的属性不能赋值给 string 类型的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">interface</span> NotEmptyString&#123;</span><br><span class="line">  data: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NotEmptyNumber&#123;</span><br><span class="line">  data: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xString: NotEmptyString;</span><br><span class="line"><span class="keyword">let</span> yNumber: NotEmptyNumber;</span><br><span class="line">xString = yNumber; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>类型保护就是一些表达式在编译时，能通过类型信息确保某个具体作用域内变量的类型。</p><h3 id="typeof-和-instanceof-类型保护"><a href="#typeof-和-instanceof-类型保护" class="headerlink" title="typeof 和 instanceof 类型保护"></a>typeof 和 instanceof 类型保护</h3><figure class="highlight ts"><figcaption><span>typeof 类型保护</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val.repeat(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法因为使用 <code>typeof</code> 做了类型判断，所以分别在 <code>if</code> 判断的作用域内 <code>val</code> 的值会变成判断后对应的类型，可以调用类型对应的方法，而在判断的外面无法确认值的类型，调用方法编译时报错。</p><figure class="highlight ts"><figcaption><span>instanceof 类型保护</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bird &#123;</span><br><span class="line">  nameBird: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">  nameDog: stirng;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.nameBird;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.nameDog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>typeof</code> 类似，使用 <code>instanceof</code> 判断了函数 <code>getName</code> 是否是 <code>Bird</code> 和 <code>Dog</code> 类的实例，判断的作用域内可以获取判断结果对应类上定义的属性。</p><h3 id="null-类型保护"><a href="#null-类型保护" class="headerlink" title="null 类型保护"></a>null 类型保护</h3><p>之前我们提到过在 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性设置为 <code>true</code> 时，则会对 <code>null</code> 进行严格检查，此时下面代码将会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的报错就是由于对 <code>null</code> 的类型保护引起的，有如下解决方法。</p><figure class="highlight ts"><figcaption><span>方法一</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>方法二</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式第一种是通过设置初始值的方式来保证在调用字符串方法时 <code>str</code> 的值已经是一个字符串类型，第二种则是通过判断直接返回，没有走到调用字符串方法的代码，类型检查自然不会报错，下面还有一个稍微复杂的案例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str.tirm()); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  log();</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>str</code> 调用 <code>tirm</code> 方法的代码封装在了函数 <code>log</code> 内部，当 <code>log</code> 调用时 <code>str</code> 的值已经变为了字符串，但是还是报错了，原因是代码编译阶段由上至下一行一行解析，所以解析函数 <code>log</code> 的时候就已经在函数内部报错了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str!.tirm());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  log();</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在 <code>log</code> 函数中，<code>str</code> 调用 <code>tirm</code> 方法时加了一个 <code>!</code>，意思为强行调用，不管类型是否符合都会调用，相当于忽略了函数 <code>getFirstLetter</code> 的参数类型检查。</p><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>上面的强制调用方式虽然通能过编译，但是在运行时有报错的风险，应该慎用，在 <code>JS</code> 中有一个提案叫链判断运算符，针对上面情况，会先判断是否为字符串再去调用字符串方法，这样写起来比较繁琐，而链判断运算符就是用来解决这个问题，通过 <code>?.</code> 来调用。</p><figure class="highlight js"><figcaption><span>链判断运算符的几种用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a?.b;</span><br><span class="line"><span class="comment">// 如果 a 不含有 b 属性则返回 undefined，否则返回 a.b，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b;</span><br><span class="line"></span><br><span class="line">a?.[b];</span><br><span class="line"><span class="comment">// 如果 a 不含有键为 b 变量值的属性则返回 undefined，否则返回 a[b]，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[b];</span><br><span class="line"></span><br><span class="line">a?.b()</span><br><span class="line"><span class="comment">// 如果 a 不含 b 属性则返回 undefined，否则执行 a.b()</span></span><br><span class="line"><span class="comment">// 如果 a.b 不是一个函数抛出类型错误，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b();</span><br><span class="line"></span><br><span class="line">a?.()</span><br><span class="line"><span class="comment">// 如果 a 不是函数则返回 undefined，否则执行 a()，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a();</span><br></pre></td></tr></table></figure><h3 id="可辨识的联合类型"><a href="#可辨识的联合类型" class="headerlink" title="可辨识的联合类型"></a>可辨识的联合类型</h3><p>可辨识的联合类型是指，通过联合类型中的共同属性进行类型保护的一种技巧，通过同属性值的判断可以确定联合类型中的具体类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> WarningButton &#123;</span><br><span class="line">  <span class="keyword">class</span>: <span class="string">'warning'</span>;</span><br><span class="line">  name1: <span class="string">'modified'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> DangerButton &#123;</span><br><span class="line">  <span class="keyword">class</span>: <span class="string">'danger'</span>;</span><br><span class="line">  name2: <span class="string">'delete'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义联合类型</span></span><br><span class="line"><span class="keyword">type</span> Button = WarningButton | DangerButton;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getButton</span>(<span class="params">button: Button</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (button.class === <span class="string">'warning'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> button.name1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (button.class === <span class="string">'danger'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> button.name2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h3><p>在可辨识的联合类型中如果没有共同的属性，共同属性判断不同值区分的方法行不通，这时可以用 <code>in</code> 操作符和不同属性判断进行类型保护。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  talon: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'talon'</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.talon);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'leg'</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.leg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p><code>TS</code> 中的上面用到的类型保护大部分为表达式，其实可以不使用这些表达式，通过自定义类型保护函数的方式实现同样的效果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  talon: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型保护函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBird</span>(<span class="params">animal: Bird | Dog</span>): <span class="title">animal</span> <span class="title">is</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// return (animal as Bird).talon &gt; 0;</span></span><br><span class="line">  <span class="keyword">return</span> (&lt;Bird&gt;animal).talon &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isBird(animal)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.talon);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.leg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的自定义保护函数 <code>isBird</code> 中参数类型与 <code>getNumber</code> 参数一致，返回值的 <code>animal is Bird</code> 是一个类型谓词，语法为 <code>param is type</code>，代表返回是否满足 <code>Bird</code> 接口，由于 <code>animal</code> 并不知道自己符合哪一个接口，所以使用类型断言指定成了 <code>Bird</code>，<code>isBird</code> 代码中注释和非注释两种方式都可以实现类型断言，这样自定义类型检查函数 <code>isBird</code> 就可以在 <code>getNumber</code> 中使用并实现类型保护。</p><h2 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型表示为将多个类型合并为一个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取的是接口的并集</span></span><br><span class="line"><span class="keyword">type</span> BirdMan = Bird &amp; Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口必须包含两个接口所有的属性和方法</span></span><br><span class="line"><span class="keyword">let</span> birdMan: BirdMan = &#123;</span><br><span class="line">  name: <span class="string">'niao'</span>,</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fly'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="typeof-获取类型"><a href="#typeof-获取类型" class="headerlink" title="typeof 获取类型"></a>typeof 获取类型</h3><p>在 <code>TS</code> 使用时如果数据内容在变化，要不停的更改对应的接口，此时可以使用 <code>typeof</code> 关键字快速获取一个变量的类型。</p><figure class="highlight ts"><figcaption><span>先定义类型，后定义变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>先定义变量，后定义接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People = <span class="keyword">typeof</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">p: People</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取的类型定义 <code>People</code> 是根据 <code>p</code> 对象的属性和值生成，然后可以使用获取的类型去限制其他对象。</p><h3 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h3><p><code>TS</code> 中的索引访问操作符指可以通过 <code>[]</code> 获取一个类型的子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义嵌套类型接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 对象，包含 name 属性</span></span><br><span class="line">  job: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 成员为对象组成的数组，对象中含有 name 和 level 属性</span></span><br><span class="line">  hobbies: &#123; name: <span class="built_in">string</span>; level: <span class="built_in">number</span> &#125;[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Person 接口 job 对象中 name 属性的类型定义为 FEJob 的类型</span></span><br><span class="line"><span class="keyword">let</span> FEJob: Person[<span class="string">"job"</span>] = &#123;</span><br><span class="line">  name: <span class="string">"FE"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中任意一项中 level 属性的类型作为 hobbyLevel 的类型</span></span><br><span class="line"><span class="keyword">let</span> hobbyLevel: Person[<span class="string">'hobbies'</span>][<span class="number">0</span>][<span class="string">'level'</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p><code>TS</code> 中定义的关键字 <code>keyof</code> 是索引类型查询操作符，用来定义类型，当定义一个获取对象属性值的函数，传入的值为对象和属性名，这样属性名参数的类型定义为 <code>string</code> 不准确，因为很可能传入一个对象本身没有的属性字符串，<code>keyof</code> 就是用来解决类似这样问题的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">'male'</span> | <span class="string">'female'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 keyof 定义类型</span></span><br><span class="line"><span class="keyword">type</span> PersonKey = keyof Person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValueByKey</span>(<span class="params">p: Person, key: PersonKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>: person: Person = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getValueByKey(person, <span class="string">'name'</span>); <span class="comment">// hello</span></span><br><span class="line">getValueByKey(person, <span class="string">'say'</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>在某一个类型定义中使用 <code>in</code> 操作符和 <code>keyof</code> 操作符批量映射修改一个新的类型定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">'male'</span> | <span class="string">'female'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射 Person 接口定义的类型，把每一个属性都变成可选的</span></span><br><span class="line"><span class="keyword">type</span> PartPerson = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof Person]?: Person[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: PartPerson = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中 <code>keyof Person</code> 取到了 <code>Person</code> 接口的每一个属性的类型，<code>key</code> 通过运算符 <code>in</code>（批量映射）代表获取的每一个属性名，<code>?:</code> 代表可选，<code>Person[key]</code> 代表对应的值。</p><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p>在 <code>TS</code> 内部内置了一些工具类型来帮助我们更好、更方便的使用类型系统。</p><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p><code>Partial</code> 可以将传入类型定义的属性由非可选变为可选，功能跟映射类型一节实现的功能非常相似，只是具体被映射的类型是通过参数传入的，所以底层是使用泛型实现的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Partial</span></span><br><span class="line"><span class="keyword">let</span> p: Partial&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial 的原理</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]?: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p><code>Required</code> 可以将传入类型定义的属性变为必选，使用 <code>-?:</code> 替换原有的 <code>:</code> 也可以实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Required</span></span><br><span class="line"><span class="keyword">let</span> p: Required&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Required 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyRequired&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]-?: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p><code>Readonly</code> 可以将传入类型定义的属性每一项都加上 <code>readonly</code> 修饰符来实现属性的只读。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Readonly</span></span><br><span class="line"><span class="keyword">let</span> p: Readonly&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'world'</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Readonly 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [key <span class="keyword">in</span> keyof T]: T[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p><code>Pick</code> 可以摘取传入类型定义的属性中的某一项返回。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Pick</span></span><br><span class="line"><span class="keyword">let</span> p: Pick&lt;Person, <span class="string">'name'</span>&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> K]: T[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置条件类型"><a href="#内置条件类型" class="headerlink" title="内置条件类型"></a>内置条件类型</h3><p>还记得在泛型一节中提到了泛型的流程控制，在 <code>TS</code> 中内置了一些常用的条件类型。</p><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">Exclude&lt;T, U&gt; <span class="comment">// 从 T 可分配给的类型中排除 U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">Extract&lt;T, U&gt; <span class="comment">// 从 T 可分配的类型中提取 U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = Extract&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="number">10</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">NonNullable&lt;T&gt; <span class="comment">// 从 T 中排除 null 和 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = NonNullable&lt;<span class="built_in">string</span> | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="literal">null</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">ReturnType&lt;T&gt; <span class="comment">// 获取函数类型的返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">"hello"</span>, age: <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo = ReturnType&lt;<span class="keyword">typeof</span> getUserInfo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: UserInfo = &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">InstanceType&lt;T&gt; <span class="comment">// 获取构造函数类型的实例类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name</span>) &#123;&#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P = InstanceType&lt;<span class="keyword">typeof</span> Person&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: P = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'myName'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/16/20190416160637/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NodeJS 实现一个提交自动检测的 Git Hook</title>
      <link>https://www.overtaking.top/2019/04/09/20190409024640/</link>
      <guid>https://www.overtaking.top/2019/04/09/20190409024640/</guid>
      <pubDate>Mon, 08 Apr 2019 18:46:40 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/04/09/20190409024640/git-hooks-location.png&quot; title=&quot;Git Hook&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-Git-Hook&quot;&gt;&lt;a href=&quot;#什么是-Git-Hook&quot; class=&quot;headerlink&quot; title=&quot;什么是 Git Hook&quot;&gt;&lt;/a&gt;什么是 Git Hook&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;Git Hook&lt;/code&gt; 是能在 &lt;code&gt;Git&lt;/code&gt; 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 &lt;code&gt;.git/hooks&lt;/code&gt; 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 &lt;code&gt;.sample&lt;/code&gt;，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/09/20190409024640/git-hooks-location.png" title="Git Hook"><p><br></p><h2 id="什么是-Git-Hook"><a href="#什么是-Git-Hook" class="headerlink" title="什么是 Git Hook"></a>什么是 Git Hook</h2><blockquote class="pullquote info"><p><code>Git Hook</code> 是能在 <code>Git</code> 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 <code>.git/hooks</code> 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 <code>.sample</code>，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。</p></blockquote><a id="more"></a><h2 id="实现-Hook-功能介绍"><a href="#实现-Hook-功能介绍" class="headerlink" title="实现 Hook 功能介绍"></a>实现 Hook 功能介绍</h2><p>本次将使用 <code>NodeJS</code> 实现一个 <code>Git Hook</code>，功能为在提交代码之前检测功能如下：</p><ul><li>检测是否为 <code>Git</code> 项目；</li><li>检测邮箱是否符合规格；</li><li>检测代码是否含有冲突；</li><li>自动执行 <code>Eslint</code>，并检测问题。</li></ul><h2 id="需求的由来"><a href="#需求的由来" class="headerlink" title="需求的由来"></a>需求的由来</h2><p>在开始代码的编写之前，一定要清楚，团队开发时为什么需要这样的 <code>hook</code>，下面列举的场景，可能都会对团队项目持续集成的历史树造成污染，或在协同开发时对团队成员造成麻烦。</p><p><strong>邮箱错误：</strong>当团队 <code>Gitlab</code> 仓库对邮箱格式进行了严格的限制，必须为公司邮箱才可以进行推送，这样很可能导致邮箱配错时进行了提交，而推送时发现邮箱错了，要对本地的 <code>commit</code> 记录修正，再重新进行推送。</p><blockquote class="pullquote warning"><p><strong>容易造成邮箱设置错误的常见原因：</strong></p><ul><li><strong>维护不同团队的开源项目太多，不同项目需要配置不同的邮箱，很可能导致邮箱配置错误；</strong></li><li><strong>当团队中有外包开发人员，且由于权限问题同一套代码是存放在两个仓库，正式员工需要在本地项目中通过 <code>remote</code> 来同时指定两个仓库地址，并在本地代码修改后拉取外包仓库的代码进行合并，同时同步到正式仓库和外包仓库，如果正式仓库对推送过来的提交邮箱格式进行了严格的限制，并且外包提交记录的邮箱错误，就导致正式员工合并后的提交被正式仓库拒绝，如果使用 <code>rebase</code> 强行修正错误的邮箱，变基后的 <code>commit</code> 哈希发生变化可能与远端仓库不一致，需要进行强推到两个仓库，并全员的本地回滚到变基之前。</strong></li></ul></blockquote><p><strong>代码冲突：</strong>开发时和其他人同时修改了相同部分造成冲突，如果冲突不能及时被发现，提交并推送到远端是对远端仓库的污染，也可能其他开发人员正好拉取了这样的代码，会对团队造成麻烦。</p><blockquote class="pullquote danger"><p><strong>容易造成冲突未及时处理的原因：</strong></p><ul><li><strong>项目过大，文件较多；</strong></li><li><strong>编辑器不智能；</strong></li><li><strong>前端项目使用了路由懒加载，不切换到冲突代码所在的路由，项目不会报错。</strong></li></ul></blockquote><p><strong>Eslint：</strong>有些团队的项目对代码规范要求高，并为了减小线上 <code>Bug</code> 率，会在项目中集成 <code>Eslint</code> 对代码风格进行检查，通常都是在命令行手动执行检测命令，有些时候可能忘记执行命令进行检测，就将代码进行了提交和推送。</p><blockquote class="pullquote default"><p>为了规避上面的情况，所以才有了这次关于 <code>Git Hook</code> 的需求，以及下面的代码实现，目的是防患于未然，将大家在开发时容易犯的错误或对项目代码持续集成和管理的潜在风险扼杀在摇篮中。</p></blockquote><h2 id="目录结构及文件简介"><a href="#目录结构及文件简介" class="headerlink" title="目录结构及文件简介"></a>目录结构及文件简介</h2><p><pre>git-hooks<br>  |- default-events.js<br>  |- default-rules.js<br>  |- git-checker.js<br>  |- pre-commit.js</pre></p><ul><li><code>default-events.js</code>：用来编写默认的检测事件；</li><li><code>default-rules.js</code>：用来管理默认检测事件用到的规则（正则）；</li><li><code>git-checker.js</code>：用来构建 <code>Hook</code> 的核心逻辑；</li><li><code>pre-commit.js</code>：用来编写执行检测的调用逻辑。</li></ul><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在编写这个 <code>hook</code> 之前需要用到一个第三方模块 <a href="https://www.npmjs.com/package/husky" target="_blank">husky</a>，这个模块的作用是根据项目中 <code>package.json</code> 的配置来向 <code>.git/hooks</code> 中的脚本写入我们的逻辑，项目中需要安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky</span><br></pre></td></tr></table></figure><h2 id="代码设计思路分析"><a href="#代码设计思路分析" class="headerlink" title="代码设计思路分析"></a>代码设计思路分析</h2><p>设计这个 <code>hook</code> 时提供了 <code>Git</code> 目录检测、邮箱验证、冲突检测、和执行 <code>Eslint</code> 的功能，当然我们希望检测函数不是强制的，是可以选择性使用，而使用者也可以编写自己需要的检测函数来覆盖其他的场景。</p><p>我们希望项目中的 <code>husky</code> 配置如下：</p><figure class="highlight"><figcaption><span>使用 hook 项目的 package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "node git-hooks/pre-commit"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>husky</code> 帮我们执行了 <code>git-hooks/pre-commit.js</code> 文件，我们希望使用者的用法如下：</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/pre-commit.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GitChecker = <span class="built_in">require</span>(<span class="string">'./git-checker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commitChecker = <span class="keyword">new</span> GitChecker(<span class="string">'pre-commit'</span>, &#123;</span><br><span class="line">  <span class="comment">// default event names</span></span><br><span class="line">  defaultEventNames: [<span class="string">'isGit'</span>, <span class="string">'email'</span>, <span class="string">'conflict'</span>, <span class="string">'eslint'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// your costom rules</span></span><br><span class="line">  &#125;,</span><br><span class="line">  checkEvents: &#123;</span><br><span class="line">    <span class="comment">// your custom check events</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">commitChecker.checkStart();</span><br></pre></td></tr></table></figure><p>上面的用法通过创建实例来创建 <code>checker</code>，即 “检测者”，调用 <code>checkStart</code> 方法帮助我们检测，创建实例的参数为 <code>options</code>，类型为对象。</p><p>上面的用法既可以让用户通过配置 <code>options</code> 的 <code>defaultEventNames</code> 属性来选择性的使用默认的检测函数，又可以通过 <code>checkEvents</code> 属性来让使用者编写检测函数。</p><p><code>rules</code> 属性是来存放使用者编写检测函数时使用的正则，会和默认检测函数中的正则合并，我们专门用 <code>default-rules.js</code> 文件来管理默认检测函数中使用的正则。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-rules.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  emailCheck: <span class="regexp">/\S+((@youemail\.com)|(@enterprise\.com))(\n|\r\n)*$/</span>,</span><br><span class="line">  conflictCheck: <span class="string">'^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\s'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="GitChecker-类的实现"><a href="#GitChecker-类的实现" class="headerlink" title="GitChecker 类的实现"></a>GitChecker 类的实现</h2><p>我们需要一个工厂创造 “检测者”，取名为 <code>GitChecker</code>，在 <code>GitChecker</code> 中需要使用发布订阅模式，对检测函数进行注册，并在执行实例的 <code>checkStart</code> 方法时依次执行，代码如下。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/git-checker.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultRules = <span class="built_in">require</span>(<span class="string">'./default-rules'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultEvents = <span class="built_in">require</span>(<span class="string">'./default-events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 GitChecker 类并继承 EventEmitter，目的是继承 on 和 emit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitChecker</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止使用者 options 内部属性传错，进行初始化</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      rules = &#123;&#125;,</span><br><span class="line">      defaultEventNames = [],</span><br><span class="line">      checkEvents = &#123;&#125;</span><br><span class="line">    &#125; = options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并默认检测函数使用的正则和用户自定义检测函数使用的正则统一管理</span></span><br><span class="line">    <span class="keyword">this</span>.rules = <span class="built_in">Object</span>.assign(defaultRules, rules);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并用户选择使用的默认检测函数和自定义检测函数</span></span><br><span class="line">    <span class="keyword">this</span>.checkEvents = <span class="built_in">Object</span>.assign(</span><br><span class="line">      <span class="keyword">this</span>.getDefaultEvents(defaultEventNames),</span><br><span class="line">      checkEvents</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.type = type; <span class="comment">// git 操作类型</span></span><br><span class="line">    <span class="keyword">this</span>.isCommit = <span class="literal">true</span>; <span class="comment">// 当前是否可以被提交</span></span><br><span class="line">    <span class="keyword">this</span>.gitConfigEnvs = [<span class="string">'local'</span>, <span class="string">'global'</span>, <span class="string">'system'</span>]; <span class="comment">// 取邮箱时的环境</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将提交状态更改为禁止，绑定 this 是为了防止在检测函数内解构更改指向</span></span><br><span class="line">    <span class="keyword">this</span>.forbiddenCommit = <span class="keyword">this</span>.forbiddenCommit.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.init(); <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="comment">// 将检测函数常用方法挂载到实例上</span></span><br><span class="line">    <span class="keyword">this</span>.log = log;</span><br><span class="line">    <span class="keyword">this</span>.exec = exec;</span><br><span class="line">    <span class="keyword">this</span>.chalk = chalk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册当前类型 git 操作对应的检测函数</span></span><br><span class="line">    <span class="keyword">this</span>.register(<span class="keyword">this</span>.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getDefaultEvents(eventsNames) &#123;</span><br><span class="line">    <span class="keyword">return</span> eventsNames.reduce(<span class="function">(<span class="params">memo, eventName</span>) =&gt;</span> &#123;</span><br><span class="line">      memo[<span class="string">`<span class="subst">$&#123;eventName&#125;</span>CheckTask`</span>] = defaultEvents[<span class="string">`<span class="subst">$&#123;eventName&#125;</span>CheckTask`</span>];</span><br><span class="line">      <span class="keyword">return</span> memo;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  register(type) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.checkEvents).forEach(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 订阅事件，每一个函数传入当前实例，方便取实例上的属性和方法</span></span><br><span class="line">      <span class="keyword">this</span>.on(type, () =&gt; <span class="keyword">this</span>.checkEvents[event](<span class="keyword">this</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forbiddenCommit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isCommit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> checkStart() &#123;</span><br><span class="line">    log(chalk.green(<span class="string">'开始代码检测'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布执行检测函数</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.emit(<span class="keyword">this</span>.type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束后结束当前 git 操作进程</span></span><br><span class="line">    <span class="keyword">this</span>.checkEnd();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkEnd() &#123;</span><br><span class="line">    <span class="comment">// 如果当前状态为不可提交，则退出进程号不为 0，git 规定</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isCommit) process.exit(<span class="number">1</span>);</span><br><span class="line">    log(chalk.green(<span class="string">'检测通过'</span>));</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = GitChecker;</span><br></pre></td></tr></table></figure><p>在上面的设计中之所以将一些常用方法都挂载在了实例上，目的是为了让使用者编写自定义检测函数时不再需要引入依赖，和更方便的获取实例上的属性、方法，当然也方便了我自己编写默认检测函数。</p><h2 id="默认检测函数的实现"><a href="#默认检测函数的实现" class="headerlink" title="默认检测函数的实现"></a>默认检测函数的实现</h2><p>由于检测工厂 <code>GitChecker</code> 已经将自己创建的 “检测者” 塞入了检测函数的参数中去，那就可以把所有的默认检测函数放入一个 <code>default-events.js</code> 文件中统一管理。</p><h3 id="检测目录是否被-Git-管理"><a href="#检测目录是否被-Git-管理" class="headerlink" title="检测目录是否被 Git 管理"></a>检测目录是否被 Git 管理</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.isGitCheckTask = <span class="function">(<span class="params">&#123; exec, log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 git 命令，如果跑出异常证明不是一个 git 管理的项目</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(<span class="string">'git status'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    log(chalk.red(<span class="string">'错误：当前不是一个git项目目录'</span>));</span><br><span class="line">    forbiddenCommit(); <span class="comment">// 更改提交状态太为不能提交</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>检测是否为一个 <code>Git</code> 所管理的项目只需执行 <code>git status</code> 来检测一下文件变化，如果抛出异常则说明不被 <code>Git</code> 所管理。</p><h3 id="检测邮箱是否合规"><a href="#检测邮箱是否合规" class="headerlink" title="检测邮箱是否合规"></a>检测邮箱是否合规</h3><blockquote class="pullquote primary"><p>上一个方法使用了从参数解构的方式获取实例属性和方法，为了更便于理解这个方法正常使用参数。</p></blockquote><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">exports.emailCheckTask = <span class="function">(<span class="params">checker</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> checkEmailEnvs = <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取出正则和获取 git 邮箱的环境参数集合</span></span><br><span class="line">    <span class="keyword">const</span> gitConfigEnvs = checker.gitConfigEnvs;</span><br><span class="line">    <span class="keyword">const</span> rules = checker.rules;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取邮箱的 git 命令</span></span><br><span class="line">    <span class="keyword">const</span> command = <span class="string">`git config --<span class="subst">$&#123;gitConfigEnvs[i]&#125;</span> user.email`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取邮箱成功，则校验邮箱是否合规</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> userEmail = checker.exec(command).toString();</span><br><span class="line">      <span class="keyword">const</span> isValidate = rules.emailCheck.test(userEmail);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isValidate) &#123;</span><br><span class="line">        checker.log(checker.chalk.red(<span class="string">'错误：请使用正确的邮箱提交代码'</span>));</span><br><span class="line">        checker.log(checker.chalk.yellow(<span class="string">`你当前的邮箱是：<span class="subst">$&#123;userEmail&#125;</span>`</span>));</span><br><span class="line">        checker.forbiddenCommit();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checker.log(checker.chalk.green(<span class="string">'邮箱校验通过'</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === gitConfigEnvs.length) &#123;</span><br><span class="line">        checker.log(checker.chalk.red(<span class="string">'错误：请设置git的提交邮箱'</span>));</span><br><span class="line">        checker.forbiddenCommit();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checkEmailEnvs(i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  checkEmailEnvs(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>在 <code>Git</code> 中有三个参数设置邮箱，分别 <code>--local</code>、<code>--global</code>、<code>--system</code>，分别对应项目、用户和系统三个环境，顺序即为获取优先级，所以获取也是如此。</p></blockquote><p>该方法使用了递归的思想实现，从优先级最高的环境开始获取邮箱，如果取到邮箱则进行验证，没取到则选择优先级次之的环境获取，直到取到邮箱为止，若都取不到则提示用户设置邮箱，如果取到邮箱，校验不通过则提示用户当前邮箱，并提醒用户设置正确的邮箱。</p><h3 id="检测冲突"><a href="#检测冲突" class="headerlink" title="检测冲突"></a>检测冲突</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exports.conflictCheckTask = <span class="function">(<span class="params">checker</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对文件进行正则匹配的 git 命令</span></span><br><span class="line">  <span class="keyword">const</span> command = <span class="string">`git grep -n -P -E "<span class="subst">$&#123;rules.conflictCheck&#125;</span>"`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有成功匹配，则抛出异常，成功匹配打印冲突代码</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> conflicts = checker.exec(command, &#123; <span class="attr">encoding</span>: <span class="string">'utf-8'</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (conflicts) &#123;</span><br><span class="line">      checker.log(checker.chalk.red(<span class="string">'错误：发现冲突，请解决后再提交'</span>));</span><br><span class="line">      checker.log(checker.chalk.red(<span class="string">'错误代码：'</span>));</span><br><span class="line">      checker.log(checker.chalk.red(conflicts.trim()));</span><br><span class="line">      checker.forbiddenCommit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    checker.log(checker.chalk.green(<span class="string">'未发现冲突'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>在上面的 <code>Git</code> 命令中，<code>-n</code> 为显示匹配文件的行号，因为 <code>shell</code> 的正则支持不全，<code>-P</code> 和 <code>-E</code> 是为了支持正则扩展，保证正则生效。</p></blockquote><h3 id="执行-Eslint"><a href="#执行-Eslint" class="headerlink" title="执行 Eslint"></a>执行 Eslint</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.eslintCheckTask = <span class="function">(<span class="params">&#123; exec, log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(<span class="string">'lint-staged'</span>);</span><br><span class="line">    log(chalk.green(<span class="string">'Eslint 校验通过'</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    log(chalk.red(<span class="string">'错误：Eslint 校验不通过'</span>));</span><br><span class="line">    forbiddenCommit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><code>Eslint</code> 本身具备检测冲突的功能，检测冲突的函数更适用于没有集成 <code>Eslint</code> 的项目，如果项目已经集成了 <code>Eslint</code> 可以不适用检测冲突函数。</p></blockquote><h2 id="关于扩展"><a href="#关于扩展" class="headerlink" title="关于扩展"></a>关于扩展</h2><p>当需求变更，需要在 <code>push</code> 之间执行某些脚本应该怎么办，可以在 <code>git-hooks</code> 文件夹增加一个 <code>pre-push.js</code> 文件，文件内容如下。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/pre-push.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GitChecker = <span class="built_in">require</span>(<span class="string">'./git-checker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pushChecker = <span class="keyword">new</span> GitChecker(<span class="string">'pre-push'</span>, &#123;</span><br><span class="line">  defaultEventNames: [<span class="string">'isGit'</span>, <span class="string">'email'</span>], <span class="comment">// default event names</span></span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// your costom rules</span></span><br><span class="line">  &#125;,</span><br><span class="line">  checkEvents: &#123;</span><br><span class="line">    myHook: <span class="function">(<span class="params">&#123; log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      log(chalk.red(<span class="string">'check prev push'</span>));</span><br><span class="line">      forbiddenCommit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">commitChecker.checkStart();</span><br></pre></td></tr></table></figure><p>由于我们的 <code>hook</code> 依赖于 <code>husky</code>，所以项目 <code>package.json</code> 中的 <code>husky</code> 也有所修改如下。</p><figure class="highlight"><figcaption><span>使用 hook 项目的 package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "node git-hooks/pre-commit",</span><br><span class="line">      "pre-push": "node git-hooks/pre-push"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote class="pullquote success"><p>以上就是本次 <code>Git Hook</code> 的使用场景和实现，也希望通过本文，能让大家对 <code>Git Hook</code> 的相关知识有一定了解，另附赠 <code>Github</code> 地址 <a href="https://github.com/shenqiuhui/git-hooks/tree/master" target="_blank">https://github.com/shenqiuhui/git-hooks/tree/master</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/09/20190409024640/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之 Github 团队协作</title>
      <link>https://www.overtaking.top/2019/03/27/20190327025116/</link>
      <guid>https://www.overtaking.top/2019/03/27/20190327025116/</guid>
      <pubDate>Tue, 26 Mar 2019 18:51:16 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/03/27/20190327025116/github.jpeg&quot; title=&quot;Github 团队协作&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;Github-的由来&quot;&gt;&lt;a href=&quot;#Github-的由来&quot; class=&quot;headerlink&quot; title=&quot;Github 的由来&quot;&gt;&lt;/a&gt;Github 的由来&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; 的诞生是由于 &lt;code&gt;Git&lt;/code&gt; 的局限性，尽管当时 &lt;code&gt;Git&lt;/code&gt; 对于代码的管理以及团队协作方面已经非常出色，但是 &lt;code&gt;Git&lt;/code&gt; 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 &lt;code&gt;Git&lt;/code&gt; 特性的代码平台的诉求成为必然，&lt;code&gt;Github&lt;/code&gt; 就这样诞生了。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/27/20190327025116/github.jpeg" title="Github 团队协作"><p><br></p><h2 id="Github-的由来"><a href="#Github-的由来" class="headerlink" title="Github 的由来"></a>Github 的由来</h2><blockquote class="pullquote default"><p><code>Github</code> 的诞生是由于 <code>Git</code> 的局限性，尽管当时 <code>Git</code> 对于代码的管理以及团队协作方面已经非常出色，但是 <code>Git</code> 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 <code>Git</code> 特性的代码平台的诉求成为必然，<code>Github</code> 就这样诞生了。</p></blockquote><a id="more"></a><h2 id="如何在-Github-高效的搜索项目"><a href="#如何在-Github-高效的搜索项目" class="headerlink" title="如何在 Github 高效的搜索项目"></a>如何在 Github 高效的搜索项目</h2><p>如今 <code>Github</code> 已经非常火爆，也因此被戏称为 “世界最大的同性交友平台”，在 <code>Github</code> 上托管的仓库数量巨大，这对在 <code>Github</code> 上寻找需要的开源项目造成了困扰，其实在 <code>Github</code> 上搜索项目也有一定的技巧，下面我们就来说一下如何高效的找到自己需要的开源项目。</p><p>在登录 <code>Github</code> 后，让搜索项目的搜索框获取焦点并敲下回车键，会跳转到一个搜索页面，这个页面上点击 <code>Advanced search</code>（高级搜索）就会跳转到高级搜索页面。</p><ul><li><code>From these owners</code>：按照作者名搜索，格式 <code>user:username</code>；</li><li><code>In these repositories</code>：按照仓库名称搜索，格式 <code>repo:username/reponame</code>；</li><li><code>Created on the dates</code>：按照创建日期搜索，格式 <code>created:&lt;YYYY-MM-DD</code>；</li><li><code>Written in this language</code>：按照语言进行搜索，格式 <code>language:JavaScript</code>；</li><li><code>With this many stars</code>：按照星星数查找，格式 <code>stars:&gt;1000</code>；</li></ul><blockquote class="pullquote info"><p>上面列举只是常用的部分搜索方式和格式，具体可以查看 <a target="_blank" href="https://github.com/search/advanced">https://github.com/search/advanced</a>，也可以不通过高级搜索的页面直接将规则写在 <code>Github</code> 主页的搜索框内，多个搜索规则可同时使用，格式之间用空格隔开，当然也可以按照内容是否在哪一个文件中来搜索，如 <code>partcontent in readme</code>。</p></blockquote><h2 id="Organizations（组织）"><a href="#Organizations（组织）" class="headerlink" title="Organizations（组织）"></a>Organizations（组织）</h2><p>在 <code>Github</code> 中的仓库可以创建在个人仓库中，也可以创建在组织中，创建在个人仓库时项目的管理者只有项目的所有者，不方便团队层面的管理和协作，如果想要多人共同的管理项目可以通过组织的形式进行。</p><p><strong>创建组织步骤如下：</strong></p><ul><li>个人信息 <code>setting</code>；</li><li>进入界面点击左侧 <code>Organizations</code>；</li><li>点击右上角 <code>new organization</code>；</li><li>填好组织信息后点击下方 <code>Create organization</code>。</li></ul><p>添加后的组织会出现在用户 <code>setting</code> 页面的 <code>Organizations</code> 选项中，点击进入某个组织，可以添加 <code>Github</code> 中可以搜索到的成员进行协同开发，可以在组织下新建仓库，可以创建团队对仓库做更精细化的管理，也可以对团队里的每个成员针对仓库设置读写权限。</p><h2 id="怎样选择适合团队的工作流"><a href="#怎样选择适合团队的工作流" class="headerlink" title="怎样选择适合团队的工作流"></a>怎样选择适合团队的工作流</h2><p>一个团队在协作的时候一定会分工到所有人完成的工作变成一个产品的过程，“工作流” 对于研发团队来讲，可以理解成分支管理的流程。</p><h3 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h3><p>主干开发是围绕着一条主开发分支进行开发，团队所有成员的 <code>commit</code> 都及时的集成在这条主分支，让团队其他成员第一时间知道。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/master-flow.png" alt="主分支开发工作流" title>                </div>                <div class="image-caption">主分支开发工作流</div>            </figure><p><br></p><blockquote class="pullquote warning"><p><strong>适用团队：</strong></p><ul><li><strong>适用于开发团队系统设计和开发能力强，有快速迭代场景，并且有一套有效的特性切换的实施机制（发布系统），保证上线后无序修改代码就能够修改系统行为；</strong></li><li><strong>适用于组件开发的团队（一些基础服务的部门，专门造轮子），成员能力强，人员少，沟通顺畅，用户升级、切换组件成本低。</strong></li></ul></blockquote><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p><code>Git Flow</code> 工作流定义了一个围绕项目发布的严格分支模型，工作流虽然复杂，但提供了一个健壮的用于管理大型项目的框架，具体的工作流程如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/git-flow.png" alt="Git Flow 工作流" title>                </div>                <div class="image-caption">Git Flow 工作流</div>            </figure><p><br></p><ul><li><code>master</code>：专门用来存储正式发布的历史；</li><li><code>develop</code>：作为功能的集成分支，可以多团队同时在 <code>develop</code> 分支集成；</li><li><code>feature</code>：专门用来开发某一个新功能，仅仅只和 <code>develop</code> 交互；</li><li><code>release</code>：发布（提测）分支，当快要到达发既定发布时间，从 <code>develop</code> 分支分出用来 <code>bugfix</code>，上线和 <code>master</code> 进行合并，同时和 <code>develop</code> 进行合并；</li><li><code>hotfix</code>：上线后从 <code>master</code> 分出用来修复线上 <code>Bug</code>。</li></ul><blockquote class="pullquote success"><p><strong>适用团队：</strong></p><ul><li><strong>适用于对项目质量要求较高，不具备主干开发能力，有预定发布周期且需要严格执行发布流程的团队。</strong></li></ul></blockquote><h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p><code>Github Flow</code> 工作流就是基于 <code>master</code> 的某一个 <code>commit</code> 拉一条特性分支进行开发，在开发完毕后在重新集成到 <code>master</code> 的工作流。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/github-flow.png" alt="Github 工作流" title>                </div>                <div class="image-caption">Github 工作流</div>            </figure><p><br></p><blockquote class="pullquote primary"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，随时集成随时发布，分支集成时经历代码评审和自动化测试，通过后就可立即发布的应用。</strong></li></ul></blockquote><h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><p><code>Github Flow</code> 是在 <code>Github Flow</code> 的基础上做了一些优化，新增了平行的 <code>production</code> 分支，用于随时准备发布上线，也可以多一些针对不同测试环境的待测试分支。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/gitlab-flow.png" alt="Gitlab 工作流" title>                </div>                <div class="image-caption">Gitlab 工作流</div>            </figure><p><br></p><blockquote class="pullquote danger"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，需要逐个通过测试环境的验证才能发布的应用；</strong></li><li><strong>适用同一个时间节点项目发布出去会有多个版本同时存在的情况，如通信类型的项目不同版本配合不同的硬件。</strong></li></ul></blockquote><h2 id="Create-pull-request"><a href="#Create-pull-request" class="headerlink" title="Create pull request"></a>Create pull request</h2><p>在多人开发的项目或开源项目中，其他人拉出一条分支进行开发，在上线之前需要合并到 <code>master</code> 主分支，需要提交 <code>pull request</code>，在 <code>Github</code> 项目页面点击上面的 <code>Pull requests</code> 按钮，上面有两个选项：</p><ul><li><code>base</code>：目标分支；</li><li><code>compare</code>：合并的特性分支。</li></ul><p>在选好 <code>base</code>（目标分支） 和 <code>compare</code>（合并的特性分支） 后，点击下方 <code>Create pull request</code>，填写提交的描述信息后再次点击 <code>Create pull request</code>，此时会在下方显示与目标分支相比新增的提交信息并自动检查冲突。</p><blockquote class="pullquote info"><p><strong><code>pull request</code> 有三种模式：</strong></p><ul><li><strong><code>Create a merge commit</code>：直接将某一个特性分支通过 <code>merge</code> 的方式合并到 <code>master</code>；</strong></li><li><strong><code>Squash and merge</code>：会将特性分支的所有变更集组合成一个 <code>commit</code> 合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立；</strong></li><li><strong><code>Rebase and merge</code>：会将特性分支变更集直接合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立。</strong></li></ul></blockquote><p>选择 <code>pull request</code> 模式后，需要对这个 <code>pull request</code> 进行再次确认，填写确认信息并点击 <code>Confirm merge</code> 确认合并，在完成合并后 <code>Github</code> 会给我们提供删除特性分支的快捷按钮 <code>Delete branch</code>，一般会等到项目稳定后才会删除特性分支。</p><h2 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h2><p><code>Issues</code> 用于追踪需求和任务，在开源项目中使用者发现 <code>Bug</code> 或有新的需求都是通过 <code>Issues</code> 提出，在 <code>Issues</code> 的 <code>Labels</code> 中有开发者设置的代表当前处理状态的标签，通过 <code>Issue</code> 上的状态标签可以知道 <code>Issue</code> 的处理进度。</p><h3 id="创建-Issue"><a href="#创建-Issue" class="headerlink" title="创建 Issue"></a>创建 Issue</h3><p><strong>创建 <code>Issue</code> 的步骤：</strong></p><ul><li>点击项目的 <code>Issues</code> 进入 <code>Issues</code> 页面；</li><li>点击 <code>New Issue</code>;</li><li>填写 <code>Issues</code> 的标题及内容；</li><li>点击 <code>Submit new issue</code> 创建 <code>Issue</code>。</li></ul><h3 id="创建-Issue-模版"><a href="#创建-Issue-模版" class="headerlink" title="创建 Issue 模版"></a>创建 Issue 模版</h3><p><strong><code>Issues</code> 的类型不是单一的，项目的所有者是可以给项目的 <code>Issues</code> 添加分类模版的，操作如下：</strong></p><ul><li>进入项目的 <code>Setting</code> 页面；</li><li>点击 <code>Issues</code> 选项的 <code>Set up templates</code> 按钮进入设置页面；</li><li><p>通过下拉框选择 <code>Issues</code> 模版的类型，分类如下：</p><ul><li><code>Bug report</code>：用来提出项目中的 <code>Bug</code>；</li><li><code>Feature request</code>：用来提出新的需求和功能；</li><li><code>Custom issue template</code>：自定义的模版类型，由项目所有者创建时决定具体用途。</li></ul></li><li>点击 <code>Preview and edit</code> 对添加的 <code>Issue</code> 模版进行编辑，编辑后点击 <code>Close preview</code> 保存编辑的内容；</li><li>添加 <code>Issues</code> 模版后点击 <code>Propose changes</code>；</li><li>添加本次修改的记录，同时可以选择用 <code>master</code> 分支还是新创建分支来管理这些 <code>Issues</code>；</li><li>点击 <code>Commit changes</code> 则会生成模版，再次执行创建 <code>Issues</code> 的步骤时可以看到设置的模版，点击模版对应的 <code>Get started</code> 快速生成对应的模版。</li></ul><blockquote class="pullquote default"><p>在编辑模版后，模版会生成对应 <code>markdown</code> 文件被保存在项目中的 <code>.github/ISSUE_TEMPLATE</code> 路径下。</p></blockquote><p><code>Issues</code> 更大的好处是，在追踪需求和任务的同时，任何人都可以在下面对这个 <code>Issue</code> 中的内容进行评论交流，甚至可以直接 <code>@</code> 评论者、项目所有者、开发者、甚至是项目的整个团队，有助于快速解决 <code>Issue</code> 中提出的问题。</p><h2 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h2><p>在开源项目开发时可以为当前项目的某个正在进行的迭代创建 <code>Project</code>，创建的 <code>Project</code> 类似于一个看板的形式，可以非常便捷的管理正在进行修复的 <code>Issue</code> 和 <code>pull request</code>（需要在创建 <code>Issue</code> 和 <code>pull request</code> 时选中关联这个 <code>Project</code>）。</p><p><strong>创建 <code>Project</code> 步骤如下：</strong></p><ul><li>进入项目的 <code>Projects</code> 页面；</li><li>点击 <code>Create a project</code>；</li><li>填写项目的名称和描述并点击下方 <code>Create project</code>。</li></ul><p><strong>在看板中分别对应四个区域如下：</strong></p><ul><li><code>To do</code>：将要完成的任务；</li><li><code>In progress</code>：正在进行中的任务；</li><li><code>Needs review</code>：需要复盘的任务；</li><li><code>Reviewer approved</code>：已经审核通过的任务。</li></ul><p>任务可以通过拖动来改变当前的进度和状态，可以非常便捷的实现项目的任务进度监控和管理，有效的推进项目进程。</p><h2 id="分支保护"><a href="#分支保护" class="headerlink" title="分支保护"></a>分支保护</h2><p>在 <code>Github</code> 的项目中，可以对指定的分支定义规则来进行保护，防止强制推送、以及分支被删除等操作，目的是为了防止误操作对重要分支造成无法挽回的后果。</p><p>可以通过项目的 <code>Setting</code> 进入，选中左侧的 <code>Branches</code> 选项，点击 <code>Add rule</code> 来添加保护规则，<code>Branch name pattern</code> 内制定要保护的分支名字，<code>Rule settings</code> 中可以设置分支保护规则。</p><p><strong>可选规则（可根据需求多选）如下：</strong></p><ul><li><p><code>Require pull request reviews before merging</code>：选中该项后所有的提交合并都必须通过 <code>pull request</code> 进行，下面有三个子选项如下：</p><ul><li><code>Required approving reviews</code>：同意 <code>pull request</code> 的人数，就是说设置后必须有对应设置的人数的相关人员批准，才可以合并；</li><li><code>Dismiss stale pull request approvals when new commits are pushed</code>：勾选后在有新的 <code>pull request</code> 时会撤销旧的 <code>pull request</code>；</li><li><code>Require review from Code Owners</code>：勾选该项后，<code>pull request</code> 必须通过项目所有者的通过才能进行合并。</li></ul></li><li><p><code>Require status checks to pass before merging</code>：在合并前必须通过状态检查才能合并，状态检查如下：</p><ul><li><code>Require branches to be up to date before merging</code>：要求分支在合并之前是最新的。</li></ul></li><li><code>Require signed commits</code>：勾选该项后要求在提交时验证签名；</li><li><code>Include administrators</code>：加入管理员执行所有限制的配置。</li></ul><blockquote class="pullquote success"><p>上面的配置我们通过要保护分支的安全级别自行选择。</p></blockquote><h2 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h2><p><code>Wiki</code> 是 <code>Github</code> 提供的说明文档功能，点击项目上的 <code>Wiki</code> 选项进入文档页面，在项目从来没有编辑过稳当页面时，会默认出现 <code>Create the first page</code> 按钮，点击则会跳转编辑 <code>Wiki</code> 的页面，可以输入 <code>Wiki</code> 标题、内容和提交信息，内容支持 <code>Markdown</code> 语法编写。</p><p>当已经创建过一个 <code>Wiki page</code> 后再次进入项目的 <code>Wiki</code> 页面，会在右上角显示 <code>Edit</code> 和 <code>New page</code> 按钮，分别用于修改和新增 <code>Wiki page</code>，在左侧有所有 <code>Wiki page</code> 的列表，最下面是 <code>Wiki</code> 的仓库地址，也可以通过编辑器在本地创建 <code>Wiki page</code>，编写后通过 <code>Git</code> 推送到 <code>Wiki</code> 仓库。</p><p>在 <code>Wiki</code> 页面还有两个扩展功能，分别为 <code>Add a custom footer</code> 和 <code>Add a custom sidebar</code>，用于创建自定义底部和侧边栏（如编写目录等）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote warning"><p><code>Github</code> 管理项目实现协同开发是非常便捷的，在 <code>Github</code> 中每一个的操作的参与者和被参与者都会收到 <code>Github</code> 邮件进行通知，进入邮件链接也可以直接对项目变化进行 <code>code review</code>，在企业级项目中目前 <code>Gitlab</code> 的私有仓库更火爆，基本功能与 <code>Github</code> 大同小异，在基本功能的基础上增加了更高级的功能和内置的持续集成插件，有兴趣可以尝试探究一下。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/27/20190327025116/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之实战技及巧注意事项总结</title>
      <link>https://www.overtaking.top/2019/03/15/20190315115008/</link>
      <guid>https://www.overtaking.top/2019/03/15/20190315115008/</guid>
      <pubDate>Fri, 15 Mar 2019 03:50:08 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/03/15/20190315115008/git.png&quot; title=&quot;Git 实战技及注意事项&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 &lt;code&gt;Git&lt;/code&gt; 的基础上来详细总结一下这些注意事项。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/15/20190315115008/git.png" title="Git 实战技及注意事项"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Git</code> 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 <code>Git</code> 的基础上来详细总结一下这些注意事项。</p></blockquote><a id="more"></a><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><p>在日常开发时，我们经常都是在某一个分支下进行的，<code>commit</code> 操作也是在某些分支上进行，换句话说我们的每一个提交一般来讲都是与分支挂钩的，在 <code>Git</code> 中有一种情况，我们所修改的代码不与任何一个分支有关连，这种情况下叫做分离头指针。</p><p>那么如何操作才能实现分离头指针呢，在开发时我们可能会对某一个 <code>commit</code> 非常的感兴趣，并希望在这个 <code>commit</code> 下去做一些事情，可以执行下面命令实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br></pre></td></tr></table></figure><p>当切换分支后对某些文件做一些修改，并重新 <code>commit</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'分离头指针测试'</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>执行上面命令后我们发现新的 <code>commit</code> 信息后面不在对应某一个分支，而是 <code>HEAD</code>，这种情况下就代表着我们的 <code>Git</code> 目前已经处于分离头指针的状态了。</p><p>分离头指针是 “双刃剑” 有好处也有坏处，在分离头指针的状态下所有的 <code>commit</code> 在重新切换分支时，会被 <code>Git</code> 当作无用提交回收掉，因为这些提交没有跟任何分支有所联系。</p><blockquote class="pullquote warning"><p><em><strong>优点：尝试性的 <code>commit</code> 可以在分离头指针的状态下进行；</strong></em><br><em><strong>缺点：当发布需要到其他分支修复问题或紧急发布时，切分支后会导致分离头指针状态下的 <code>commit</code> 丢失。</strong></em></p></blockquote><p>在切换分支后，如果还想保留分离头指针状态下的提交，可以为这个提交创建一个新的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名 分离头指针状态的提交（哈希值）</span><br></pre></td></tr></table></figure><h2 id="修改本地-commit"><a href="#修改本地-commit" class="headerlink" title="修改本地 commit"></a>修改本地 commit</h2><h3 id="修改最近一次提交"><a href="#修改最近一次提交" class="headerlink" title="修改最近一次提交"></a>修改最近一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><code>--amend</code> 可以将暂存区新存入的内容同时提交到最近的一次 <code>commit</code> 中，而不会生成新的 <code>commit</code>，同时也可以修改 <code>commit</code> 时的提交信息。</p></blockquote><h3 id="修改任意一次提交"><a href="#修改任意一次提交" class="headerlink" title="修改任意一次提交"></a>修改任意一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i a4d56bb</span><br></pre></td></tr></table></figure><p>该操作为 <code>git rebase</code> 命令的交互模式，即输入 <code>-i</code> 命令，后面所输入的 <code>commit</code> 哈希值并不是要修改的 <code>commit</code>，而是要修改的 <code>commit</code> 的父级 <code>commit</code> 哈希值，在执行命令后会弹出修改的交互界面如下。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pick 52f3935 add css file</span><br><span class="line"><span class="deletion">- pick 91bd053 change css</span></span><br><span class="line"><span class="addition">+ reword 91bd053 change css</span></span><br><span class="line"></span><br><span class="line"># Rebase a4d56bb..91bd053 onto a4d56bb (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>从上面的信息来看第一条代表当前要修改的 <code>commit</code>，第二条代表该分支最新的 <code>commit</code>，下面注释为修改参数，由于要修改提交信息，所以此处将第一行的 <code>pick</code> 修改成 <code>reword</code> 并保存，保存后会弹出下一个修改提交信息的界面如下。</p><figure class="highlight diff"><figcaption><span>第二个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- css content</span></span><br><span class="line"><span class="addition">+ add css content</span></span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto a4d56bb</span><br><span class="line"># Last command done (1 command done):</span><br><span class="line">#    reword 9e4f711 add css content</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick c220cf2 change css</span><br><span class="line"># You are currently editing a commit while rebasing branch 'test' on 'a4d56bb'.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.css</span><br></pre></td></tr></table></figure><p>该界面上为 <code>commit</code> 的 <code>message</code>，修改后保存，就完成了对该 <code>commit</code> 的修改，值得注意的是，使用 <code>git log</code> 查看历史可以发现，修改 <code>commit</code> 时指定的父级 <code>commit</code> 后所有的 <code>commit</code> 哈希值都会发生变化。</p><figure class="highlight plain"><figcaption><span>commit 后的提示信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[detached HEAD de48b04] add css content</span><br><span class="line"> Date: Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 index.css</span><br><span class="line">Successfully rebased and updated refs/heads/test.</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>可以看出，其实使用 <code>git rebase</code> 命令修改 <code>commit</code> 的原理也是分离头指针，只是在分离头指针修改 <code>commit</code> 后又重新将当前分支的指针指回了最新的 <code>commit</code>。</p></blockquote><h3 id="将多个连续的-commit-合并成一个"><a href="#将多个连续的-commit-合并成一个" class="headerlink" title="将多个连续的 commit 合并成一个"></a>将多个连续的 commit 合并成一个</h3><p>将多个 <code>commit</code> 合并成一个的原理与修改任意一个 <code>commit</code> 的原理相同，都是通过 <code>git rebase</code> 命令的交互模式实现的（<code>-i</code>），参数为合并几个 <code>commit</code> 的父级 <code>commit</code> 哈希值。</p><figure class="highlight bash"><figcaption><span>查看历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># edd2400 (HEAD -&gt; test) add content to readme</span></span><br><span class="line"><span class="comment"># 50a015c add background css</span></span><br><span class="line"><span class="comment"># 15237d2 change css</span></span><br><span class="line"><span class="comment"># 4a8fd80 add css content</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><p>现在我们尝试将 <code>50a015c</code>、<code>15237d2</code> 和 <code>4a8fd80</code> 这三个 <code>commit</code> 合并成一个，与修改 <code>commit</code> 唯一不同的是被修改的 <code>commit</code> 参数不再是 <code>reword</code>，而是 <code>squash</code>，多个要合并的 <code>commit</code> 之中有一个目标 <code>commit</code>，这个 <code>commit</code> 的参数必须是 <code>pick</code>。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pick 4a8fd80 add css content</span><br><span class="line"><span class="deletion">- pick 15237d2 change css</span></span><br><span class="line"><span class="deletion">- pick 50a015c add background css</span></span><br><span class="line"><span class="addition">+ squash 15237d2 change css</span></span><br><span class="line"><span class="addition">+ squash 50a015c add background css</span></span><br><span class="line">pick edd2400 add content to readme</span><br><span class="line"></span><br><span class="line"># Rebase 5149bad..edd2400 onto 5149bad (4 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>对上面的交互界面保存后同样会弹出第二个交互界面，合并多个 <code>commit</code> 与修改单个 <code>commit</code> 不同的是，第二个界面会展示所有被合并 <code>commit</code> 的信息，我们可以为合并后的 <code>commit</code> 添加一个新的 <code>message</code>。</p><figure class="highlight diff"><figcaption><span>第二个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+ css changes</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"># This is the 1st commit message:</span><br><span class="line"></span><br><span class="line">add css content</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line"></span><br><span class="line">change css</span><br><span class="line"></span><br><span class="line"># This is the commit message #3:</span><br><span class="line"></span><br><span class="line">add background css</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 5149bad</span><br><span class="line"># Last commands done (3 commands done):</span><br><span class="line">#    squash 15237d2 change css</span><br><span class="line">#    squash 50a015c add background css</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick edd2400 add content to readme</span><br><span class="line"># You are currently rebasing branch 'test' on '5149bad'.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.css</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看合并提交后的历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2c84584 (HEAD -&gt; test) add content to readme</span></span><br><span class="line"><span class="comment"># ac001bc css changes</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><h3 id="将多个间隔的-commit-合并成一个"><a href="#将多个间隔的-commit-合并成一个" class="headerlink" title="将多个间隔的 commit 合并成一个"></a>将多个间隔的 commit 合并成一个</h3><p>上面的 <code>commit</code> 合并方式可能满足不了需求，有些时候我们想把对同一个文件的提交或同一类操作的提交合并成一个，但是在历史 <code>commit</code> 中要合并的树是间隔的，使用 <code>git rebase</code> 命令同样可以做到。</p><figure class="highlight bash"><figcaption><span>查看历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 23d6939 (HEAD -&gt; test) append content into readme</span></span><br><span class="line"><span class="comment"># 178ea29 link css in html</span></span><br><span class="line"><span class="comment"># 2c84584 add content to readme</span></span><br><span class="line"><span class="comment"># ac001bc css changes</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><p>在之前使用 <code>git rebase</code> 命令时都是将操作 <code>commit</code> 的父级 <code>commit</code> 作为参数，如果我们要操作的 <code>commit</code> 已经没有父级 <code>commit</code>，接下来在合并多个间隔的 <code>commit</code> 时来测试一下这样的情况，接下来将 <code>7f73a76</code> 和 <code>178ea29</code> 两个关于 <code>html</code> 文件的操作合并成一个。</p><figure class="highlight bash"><figcaption><span>执行命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f73a76</span><br></pre></td></tr></table></figure><p>由于我们要操作的 <code>commit</code> 已经没有了父级，所以我们就在执行命令时传入这个 <code>commit</code>，在弹出的第一个交互界面我么明显能看到其实上面是少了我们要操作的 <code>commit</code>，所以需要手动补上，而间隔的 <code>commit</code> 要移动到和合并的目标 <code>commit</code> 连续的位置。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ pick 7f73a76</span></span><br><span class="line"><span class="addition">+ squash 178ea29 link css in html</span></span><br><span class="line">pick 4a8fd80 add css content</span><br><span class="line">pick 5149bad new READ.md</span><br><span class="line">pick ac001bc css changes</span><br><span class="line">pick 2c84584 add content to readme</span><br><span class="line"><span class="deletion">- pick 178ea29 link css in html</span></span><br><span class="line">pick 23d6939 append content into readme</span><br><span class="line"></span><br><span class="line"># Rebase 7f73a76..23d6939 onto 7f73a76 (5 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>在保存后出现如下报错信息，是因为 <code>commit</code> 的父节点是我们新增上去导致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">The previous cherry-pick is now empty, possibly due to conflict resolution.</span><br><span class="line">If you wish to commit it anyway, use:</span><br><span class="line"></span><br><span class="line">    git commit --allow-empty</span><br><span class="line"></span><br><span class="line">Otherwise, please use &apos;git reset&apos;</span><br><span class="line">interactive rebase in progress; onto 7f73a76</span><br><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 7f73a76</span><br><span class="line">Next commands to do (5 remaining commands):</span><br><span class="line">   squash 178ea29 link css in html</span><br><span class="line">   pick 5149bad new READ.md</span><br><span class="line">You are currently rebasing branch &apos;test&apos; on &apos;7f73a76&apos;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">Could not apply 7f73a76...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>git status 提示信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 7f73a76</span><br><span class="line">Next commands to do (5 remaining commands):</span><br><span class="line">   squash 178ea29 link css in html</span><br><span class="line">   pick 5149bad new READ.md</span><br><span class="line">  (use &quot;git rebase --edit-todo&quot; to view and edit)</span><br><span class="line">You are currently rebasing branch &apos;test&apos; on &apos;7f73a76&apos;.</span><br><span class="line">  (all conflicts fixed: run &quot;git rebase --continue&quot;)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>想继续合并</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>想还原回合并之前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><p>如果在继续合并后没有出现第二个交互界面（与合并连续 <code>commit</code> 类似，用来新增合并后 <code>commit</code> 的信息），说明合并时出现冲突，此时需要解决冲突后将新的变更提交到暂存区，再重新执行合并命令。</p><figure class="highlight bash"><figcaption><span>查看合并后的历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4d4f771 (HEAD -&gt; test) append content into readme</span></span><br><span class="line"><span class="comment"># a83f526 add content to readme</span></span><br><span class="line"><span class="comment"># 463fd85 css changes</span></span><br><span class="line"><span class="comment"># 7e44e19 new READ.md</span></span><br><span class="line"><span class="comment"># 753ebcd about html changes</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：当前对 <code>commit</code> 的变更和合并操作只是对 <code>commit</code> 做了整理，并没有改变文件内容，并且这些操作仅限于要修改或合并的 <code>commit</code> 还没有共享到集成分支上去，如果已经推送到远端，进行上面操作会对其他协同开发的人员造成麻烦和困扰。</strong></em></p></blockquote><h3 id="删除后提交的-commit"><a href="#删除后提交的-commit" class="headerlink" title="删除后提交的 commit"></a>删除后提交的 commit</h3><p>在开发中有这样一种情景，就是我们在修改代码时提交了一个或者几个新的 <code>commit</code>，但是发现有更好的方案，想要删除这些 <code>commit</code>，这时可以通过将 <code>HEAD</code> 指针重新指向这些 <code>commit</code> 之前的提交，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>这样的操作会导致工作区、暂存区的代码都会到这个 <code>commit</code> 的状态，当然也有 “后悔药”，可以使用 <code>git reflog</code> 找到所有的 <code>commit</code> 版本号 包含已删除），再通过同样的方式将 <code>HEAD</code> 的指针指回去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard 已删除的版本号</span><br></pre></td></tr></table></figure><h2 id="忽略上传的文件"><a href="#忽略上传的文件" class="headerlink" title="忽略上传的文件"></a>忽略上传的文件</h2><p>在开发过程中，有些文件是不需要我们上传到远端的，可能因为这个文件对于开发项目来讲是无用的，如编辑器自动生成的 <code>.idea</code> 等，或者这个文件夹非常的大，如 <code>node_modules</code>，我们可以通过 <code>.gitignore</code> 文件来配置。</p><p>在 <code>.gitignore</code> 文件中有很多规则，在此不去讨论，在这里我们要说的是如果某些想要忽略的文件由于失误没有被写进 <code>.gitignore</code>，被推送到远端后，想忽略这个文件，并在下次推送的时候让远端不再有这个文件该怎么做。</p><figure class="highlight bash"><figcaption><span>先将要忽略的文件添加到 .gitignore，然后执行下面命令对之前添加的文件进行删除操作</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件名/文件夹</span><br></pre></td></tr></table></figure><h2 id="在开发当中处理紧急发布（CR）任务"><a href="#在开发当中处理紧急发布（CR）任务" class="headerlink" title="在开发当中处理紧急发布（CR）任务"></a>在开发当中处理紧急发布（CR）任务</h2><p>在开发时经常有这样一种场景，在上一版本代码上线以后，突然发现线上出现 <code>Bug</code> 需要修复并紧急上线，而这个时候刚好又在同一个分支上已经有了其他的新代码，此时需要将代码还原到线上版本，并保证当前开发代码不丢失，待问题修复后，将新开发的代码合并到修复后的代码上继续开发，当然根据实际情况的不同，复杂程度也会有所差别，下面是一些思路。</p><figure class="highlight bash"><figcaption><span>当前代码跟要修复代码在同一条分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复代码后合并到 dev 发布测试环境验证，通过后发布</span></span><br><span class="line"></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续开发</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>当前代码跟要修复的代码不在同一条分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 master 分支创建一条新分支</span></span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git checkout -b 修复问题分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复问题并提测</span></span><br><span class="line"></span><br><span class="line">git checkout 测试分支</span><br><span class="line">git merge 修复问题分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证通过后合并到 master 发布，继续回到开发新功能分支将修复代码集成进来并继续开发</span></span><br><span class="line"></span><br><span class="line">git checkout 开发分支</span><br><span class="line">git rebase 测试分支</span><br></pre></td></tr></table></figure><p>当然上面的思路仅供参考，因为不同的团队规则有所差异，问题的复杂度也不尽相同，在某些特殊时候可能要本地代码回退版本，需要借助 <code>git reset</code> 命令实现。</p><h2 id="non-fast-forwards-和-fast-forwards"><a href="#non-fast-forwards-和-fast-forwards" class="headerlink" title="non-fast-forwards 和 fast-forwards"></a>non-fast-forwards 和 fast-forwards</h2><p>在实际项目开发中我们将本地代码推送到远端的时候可能会遇到下面这样的报错信息。</p><figure class="highlight bash"><figcaption><span>推送代码时的错误信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to <span class="string">'git@github.yourRepository.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p><code>fast-forwards</code> 是指将本地分支推送到远端，<code>tree</code> 上两个分支拥有共同的 “祖先”，可以自动合并成一个 <code>tree</code>，而 <code>non-fast-forwards</code> 正好相反，两个分支的 <code>tree</code> 是完全独立的，没有任何联系，一般会造成这种现象的原因是推送的目标分支和我们当前分支拥有不同的代码，所以我们需要将推送的目标分支和本地分支的 <code>tree</code> 整理成 <code>fast-forwards</code> 的状态。</p><p>实现方式就是先拉取远端分支在本地进行处理（如果有冲突先处理冲突），变成 <code>fast-forwards</code> 状态后再进行推送，拉取远端分支可以使用 <code>fetch</code> 或 <code>pull</code>，区别在于 <code>fetch</code> 拉取回来的代码仍然是 <code>non-fast-forwards</code> 状态，需要手动 <code>merge</code> 进行合并或 <code>rebase</code> 操作（因为有些团队比较喜欢线性的提交记录以便追溯），而 <code>pull</code> 将 <code>fetch</code> 和 <code>merge</code> 这两个步骤合二为一。</p><blockquote class="pullquote info"><p><em><strong>注意：使用 <code>fetch</code> 拉取代码在进行 <code>merge</code> 时存在一种特殊情况，就是这个仓库的代码是第一次被拉取到本地（与本地分支没有共同的提交），且与本地代码的差异是新建仓库时添加 <code>README.md</code> 等文件造成的，则需要在 <code>merge</code> 时加上 <code>--allow-unrelated-histories</code> 参数去允许历史上完全独立的两棵树进行合并，达到 <code>fast-forwards</code> 的状态。</strong></em></p></blockquote><figure class="highlight bash"><figcaption><span>合并不相关的树</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 本地分支 --allow-unrelated-histories 远端分支</span><br></pre></td></tr></table></figure><p>执行命令后会弹出交互界面可以修改本次合并的 <code>message</code>。</p><h2 id="Git-多人单分支集成协作"><a href="#Git-多人单分支集成协作" class="headerlink" title="Git 多人单分支集成协作"></a>Git 多人单分支集成协作</h2><h3 id="多人协同开发时本地仓库与远端的同步"><a href="#多人协同开发时本地仓库与远端的同步" class="headerlink" title="多人协同开发时本地仓库与远端的同步"></a>多人协同开发时本地仓库与远端的同步</h3><p>在项目的开发迭代中，我们习惯每一个版本迭代都新建一个分支开发，并推送到远端，如果多个人同时要在这个分支开发该迭代的新功能，而以前又已经克隆过这个项目到本地，此时除了这条分支的创建者以外，其他人查看远端分支时是看不见这个新建分支的，需要执行以下命令对仓库进行同步并开发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步新分支信息</span></span><br><span class="line">git fetch 地址别名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新分支</span></span><br><span class="line">git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取新分支到本地</span></span><br><span class="line">git checkout -b 新分支名 地址别名/新分支名</span><br></pre></td></tr></table></figure><p>还有一种场景也需要通过上面的方式来同步仓库信息，就是在 <code>Github</code> 中帮助别人的项目修复 <code>Issue</code> 或贡献代码时，首先需要 <code>Fork</code> 别人的仓库，但是 <code>Fork</code> 过来的仓库代码并不会随着原作者仓库的代码更新而更新，为了在开发之前使 <code>Fork</code> 的仓库和原作者仓库代码及分支保持一致，执行上面命令，开发完毕后再通过给原作者提交 <code>push request</code> 的方式让原作者进行代码审核并合并到原始仓库。</p><h3 id="不同人修改不同文件的处理方式"><a href="#不同人修改不同文件的处理方式" class="headerlink" title="不同人修改不同文件的处理方式"></a>不同人修改不同文件的处理方式</h3><p>在实际开发中，两个人在一条分支开发，当 <code>A</code> 同学修改了 <code>a</code> 文件，<code>B</code> 同学修改了 <code>b</code> 文件时，此时 <code>B</code> 同学先进行了提交，<code>A</code> 同学并不知道的情况下，在 <code>A</code> 同学推送代码到远端时会变成 <code>non-fast-forwards</code> 状态（推送失败），并提示超前一个版本，落后一个版本，意思是本地代码有一个提交远端没有，远端代码有一个提交本地没有，一般情况下大多数的处理是选择先拉去远端代码进行合并，再推送到远端。</p><p>由于两个人修改的是不同文件，在拉取远端代码后合并会比较顺利，并不会产生冲突，但同时产生新的问题，就是多了一条关于合并的提交记录，如果想让提交的历史树更干净整洁，也有另一种做法，就是推送失败的一方主动将本地 <code>commit</code> 回退到与远端完全一致的 <code>commit</code> 版本，主动拉取代码与工作区合并，再重新提交到本地版本库并推送到远端。</p><figure class="highlight bash"><figcaption><span>撤销本地新的提交</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset 与远端相同的提交</span><br></pre></td></tr></table></figure><h3 id="不同的人修改相同文件不同区域的处理方式"><a href="#不同的人修改相同文件不同区域的处理方式" class="headerlink" title="不同的人修改相同文件不同区域的处理方式"></a>不同的人修改相同文件不同区域的处理方式</h3><p>我们将上面 <code>A</code>、<code>B</code> 两个同学的操作场景稍微做些改动，就是两个人同时操作了同一个文件的不同区域，此时如果 <code>B</code> 先提交到远端，<code>A</code> 不知情的情况下推送代码到远端，一样会变成 <code>non-fast-forwards</code>，同样可以通过上面的方式处理，<code>Git</code> 比较智能，可以将两个平行的修改过不同区域的文件进行合并，变成 <code>fast-forwards</code> 状态。</p><h3 id="不同的人修改相同文件相同区域的处理方式"><a href="#不同的人修改相同文件相同区域的处理方式" class="headerlink" title="不同的人修改相同文件相同区域的处理方式"></a>不同的人修改相同文件相同区域的处理方式</h3><p>依然沿用上面 <code>A</code>、<code>B</code> 同学的操作场景，不同的是这次两人修改了相同文件的相同区域，<code>B</code> 先提交到远端，<code>A</code> 在提交到远端时有因为状态为 <code>non-fast-forwards</code> 被拒绝，同样的方式处理时发现了新的问题，代码虽然成功拉合并，但是控制台报错了。</p><figure class="highlight bash"><figcaption><span>合并后报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Auto-merging yourfile</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> yourfile</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>由于两个人操作了同一个区域导致 <code>Git</code> 无法判断两个内容应该怎样去保留或替换，所以将合并失败的错误抛出让开发者认为的介入。</p><blockquote class="pullquote danger"><p><strong>在解决冲突时可能存在的情况：</strong></p><ul><li><em><strong>两人将都要保留的功能代码写在了相同文件的相同区域，这种情况需要都保留；</strong></em></li><li><em><strong>两个人开发功能重复了，需要进行沟通协商决定保留哪一个。</strong></em></li></ul></blockquote><p>在手动处理冲突对文件进行合并时，可以通过 <code>git status</code> 查看合并后的状态，如果这个人为的合并是需要的可以创建一个新的提交推送到远端，如果觉得没有处理好，可以执行下面命令还原到合并之前。</p><figure class="highlight bash"><figcaption><span>撤销合并</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><h3 id="不同的人同时变更文件名的处理方式"><a href="#不同的人同时变更文件名的处理方式" class="headerlink" title="不同的人同时变更文件名的处理方式"></a>不同的人同时变更文件名的处理方式</h3><p>在不同人同时修改同一个文件名时，<code>Git</code> 时无法处理的，当然会变成 <code>non-fast-forwards</code> 状态，在通过常规的处理后，本地会出现两个文件，分别为两人所更改的文件名，这时需要两个人进行协商，保留协商后的文件名，删除多余的文件并推送到远端让其他人进行同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm oldfilename</span><br><span class="line">git add newfilename</span><br><span class="line">git commit -m <span class="string">'merge message'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>在一个人修改文件名，其他人修改内容的情况下，<code>Git</code> 的文件内容都是通过 <a href="https://www.overtaking.top/2019/03/10/20190310233856/#tree%E3%80%81commit%E3%80%81blob-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank">blob</a> 对象进行存储，而非文件的形式，所以当多人协同某个人对文件名进行变更时 <code>Git</code> 可以非常智能的检测并同步。</p></blockquote><h3 id="禁止在已共享的集成分支使用强推"><a href="#禁止在已共享的集成分支使用强推" class="headerlink" title="禁止在已共享的集成分支使用强推"></a>禁止在已共享的集成分支使用强推</h3><p>“强推” 是指使用 <code>git push -f</code> 将本地分支推送到远端，之前在多人写作中远程分支拒绝推送的原因都是因为 <code>non-fast-forwards</code> 状态，我们可以理解为这是 <code>Git</code> 防止代码被推送到远端而产生冲突的一种保护机制，而 “强推” 就是忽略了 <code>non-fast-forwards</code> 状态强行将代码推送到远端。</p><blockquote class="pullquote danger"><p>在大部分团队中都是禁止在集成分支使用这条命令的，可能会在远端产生冲突只是原因之一，操作不正确也可能导致远端集成分支整个团队的提交历史丢失的严重后果，比如当前本地分支版本远远落后于远端，此时直接推送会进入 <code>non-fast-forwards</code> 状态，远端拒绝推送，而向远端 “强推”，远端在这个本地版本库 <code>HEAD</code> 指向的 <code>commit</code> 之后所有的提交历史都将丢失。</p></blockquote><h3 id="禁止在已共享的集成分支上做变基操作"><a href="#禁止在已共享的集成分支上做变基操作" class="headerlink" title="禁止在已共享的集成分支上做变基操作"></a>禁止在已共享的集成分支上做变基操作</h3><p>还记得前面 <a href="https://www.overtaking.top/2019/03/15/20190315115008/#修改本地-commit">修改本地 commit</a> 一节中强调 <code>rebase</code> 操作只适用于修改本地还未同步到远端的 <code>commit</code>，这是因为如果对已经同步到远端的进行了变基操作会导致 <code>commit</code> 的版本号发生变化，如果推送到远端，此时协同开发的人是基于远端旧的 <code>commit</code> 之上在做新的开发，会导致无法将本地代码推送到远端。</p><blockquote class="pullquote warning"><p>有些团队严令禁止对集成分支做变基操作，被称作 “<code>rebase</code> 黄金定律”，如果一定要对集成分支做变基操作的，一定要在当前远端最后的 <code>commit</code> 之后做变基操作。</p></blockquote><p>如果不幸真的有同事这样去做了，我们虽然会很恼火，但也还是有办法去解决这样的问题，可以直接执行下面命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>或者分为两步走，把远端变基后的分支 <code>fetch</code> 到本地，再再把本地的当前分支基于 <code>fetch</code> 下来的远端分支做 <code>rebase</code> 操作，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase 地址别名/分支名</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p>本文内容是自己在对 <code>Git</code> 的学习和工作中总结的笔记，另外想了解 <code>rebase</code> 和 <code>merge</code> 更详细的信息推荐阅读 <a href="https://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank">git rebase vs git merge 详解</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/15/20190315115008/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之 .git 内部刨析</title>
      <link>https://www.overtaking.top/2019/03/10/20190310233856/</link>
      <guid>https://www.overtaking.top/2019/03/10/20190310233856/</guid>
      <pubDate>Sun, 10 Mar 2019 15:38:56 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/03/10/20190310233856/git.jpg&quot; title=&quot;.git 内部刨析&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;HEAD-文件&quot;&gt;&lt;a href=&quot;#HEAD-文件&quot; class=&quot;headerlink&quot; title=&quot;HEAD 文件&quot;&gt;&lt;/a&gt;HEAD 文件&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;文件内容&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ref: refs/heads/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;ref&lt;/code&gt; 代表引用，&lt;code&gt;refs/heads/master&lt;/code&gt; 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支时，&lt;code&gt;HEAD&lt;/code&gt; 文件中的 &lt;code&gt;ref&lt;/code&gt; 值会随着切换的分支变化。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/10/20190310233856/git.jpg" title=".git 内部刨析"><p><br></p><h2 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h2><figure class="highlight plain"><figcaption><span>文件内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><code>ref</code> 代表引用，<code>refs/heads/master</code> 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支时，<code>HEAD</code> 文件中的 <code>ref</code> 值会随着切换的分支变化。</p></blockquote><a id="more"></a><h2 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h2><figure class="highlight bash"><figcaption><span>config 文件基本内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = <span class="literal">true</span></span><br><span class="line">bare = <span class="literal">false</span></span><br><span class="line">logallrefupdates = <span class="literal">true</span></span><br><span class="line">ignorecase = <span class="literal">true</span></span><br><span class="line">precomposeunicode = <span class="literal">true</span></span><br><span class="line">[user]</span><br><span class="line">name = yourname</span><br><span class="line">email = youremail</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><code>[core]</code> 代表当前 <code>Git</code> 管理中的主要配置，<code>[user]</code> 代表用户配置，随着 <code>Git</code> 管理的不断复杂，所有的配置项都将被存放在 <code>config</code> 文件中。</p></blockquote><h2 id="refs-文件夹"><a href="#refs-文件夹" class="headerlink" title="refs 文件夹"></a>refs 文件夹</h2><h3 id="分支-heads"><a href="#分支-heads" class="headerlink" title="分支 heads"></a>分支 heads</h3><p><code>heads</code> 文件夹存储的是本地所有分支文件，文件名与分之名一一对应，文件内容为当前分支所在的提交历史记录的 <code>commit</code> 对象。</p><figure class="highlight bash"><figcaption><span>查看 heads 文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/refs/heads</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  3 systemname  staff   96  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..</span></span><br><span class="line"><span class="comment"># -rw-r--r--  1 systemname  staff   41  2 24 17:31 master</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看分支文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/tags/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># ef5aaed0707989ebc069efcd842424f6315ab4e2</span></span><br><span class="line"></span><br><span class="line">git cat-file -t ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>其实使用 <code>git checkout</code> 命令切换分支时，就是在更改 <code>HEAD</code> 文件的引用内容，即上面提到的 <code>ref: refs/heads/branchname</code>，进而找到 <code>heads</code> 文件夹内对应的分支文件内的提交记录，将工作区代码还原到该提交记录的版本。</p></blockquote><h3 id="标签-tags"><a href="#标签-tags" class="headerlink" title="标签 tags"></a>标签 tags</h3><p>在项目开发中，经常会在某些阶段达到某一个 “里程碑”，比如版本从 <code>v0.0.1</code> 开发到 <code>v1.0.0</code>，可以专门为这个版本的 <code>commit</code> 打上一个标签，而 <code>refs/tags</code> 文件夹就是用来存放这些标签的（文件名与标签名相同），每一个标签文件内存储的是这个 “里程碑” 提交的历史记录的 <code>tag</code> 对象，<code>tag</code> 对象中存储着当前标签对应历史版本的 <code>commit</code> 对象。</p><figure class="highlight bash"><figcaption><span>查看 tags 文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/refs/tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  6 systemname  staff  192  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..</span></span><br><span class="line"><span class="comment"># -rw-r--r--  1 systemname  staff   41  2 15 18:33 1.0.0</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看标签文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/tags/1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ef5aaed0707989ebc069efcd842424f6315ab4e2</span></span><br><span class="line"></span><br><span class="line">git cat-file -p ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># object bcadbfea5e937e9b5eaed113dd8149c86124d72a</span></span><br><span class="line"><span class="comment"># type commit</span></span><br><span class="line"><span class="comment"># tag 1.0.0</span></span><br><span class="line"><span class="comment"># tagger yourusername &lt;youruseremail&gt; 1550212832 +0800</span></span><br><span class="line"></span><br><span class="line">git cat-file -t bcadbfea5e937e9b5eaed113dd8149c86124d72a</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>我们可以使用 <code>git cat-file</code> 命令查看。</p></blockquote><h2 id="objects-文件夹"><a href="#objects-文件夹" class="headerlink" title="objects 文件夹"></a>objects 文件夹</h2><h3 id="查看-objects-内部"><a href="#查看-objects-内部" class="headerlink" title="查看 objects 内部"></a>查看 objects 内部</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/objects</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  72 systemname  staff  2304  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  13 systemname  staff   416  3 14 15:43 ..</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   4 systemname  staff   128  2 24 17:29 00</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   3 systemname  staff    96  2 24 17:29 f9</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   2 systemname  staff    64  2 12 16:59 info</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   2 systemname  staff    64  2 12 16:59 pack</span></span><br></pre></td></tr></table></figure><p>在 <code>objects</code> 文件夹中，除了 <code>info</code> 和 <code>pack</code> 存储的都是十六进制命名的文件夹，在文件夹内部存储着以哈希值命名的文件，在 <code>Git</code> 中的策略是将十六进制文件名和哈希值的文件名进行组合，使用 <code>git cat-file</code> 可以查看该完整哈希值的对象类型，肯能为 <code>tree</code>、<code>blob</code>、<code>commit</code>。</p><blockquote class="pullquote default"><p><code>Git</code> 对象：</p><ul><li><code>tree</code>：树对象，存储内容为 <code>blob</code> 对象的哈希值和对应的文件名称；</li><li><code>blob</code>：存储文件内容，只要文件内容相同，则始终生成唯一一个 <code>blob</code> 对象；</li><li><code>commit</code>：存储提交的相关信息。</li></ul></blockquote><h3 id="tree、commit、blob-对象的关系"><a href="#tree、commit、blob-对象的关系" class="headerlink" title="tree、commit、blob 对象的关系"></a>tree、commit、blob 对象的关系</h3><p>在 <code>Git</code> 中最重要的就是这三个对象，以及他们之间的关系，这对于理解 <code>Git</code> 的原理非常有帮助，下面有一张关系图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/10/20190310233856/git-objects.png" alt="tree、commit、blob 关系图" title>                </div>                <div class="image-caption">tree、commit、blob 关系图</div>            </figure><p><br></p><p><code>commit</code> 对象中，<code>tree</code> 代表提交时所在的树，一个 <code>commit</code> 对象只会对应一棵树，<code>tree</code> 对象存储的只是当前 <code>commit</code> 时，所有文件目录的一个 “快照”，<code>tree</code> 对象中的 <code>tree</code> 对象代表该文件夹中还有文件夹，<code>tree</code> 中的 <code>blob</code> 对象代表文件，<code>blob</code> 对象中存储的是文件内容，<code>Git</code> 在这里存储时忽略文件名，只要文件内容一样就只会存储一份，大大的节约了存储空间。</p><blockquote class="pullquote info"><p><code>blob</code> 对象是在将文件增加到暂存区后创建的，<code>commit</code> 和 <code>tree</code> 对象在进行提交操作后创建。</p></blockquote><h2 id="hooks-文件夹"><a href="#hooks-文件夹" class="headerlink" title="hooks 文件夹"></a>hooks 文件夹</h2><p><code>hooks</code> 文件夹，默认存储了一系列的 <code>hook</code> 文件，用于在执行某些特定的 <code>Git</code> 命令时，在某个声明周期执行，内部可以编写 <code>shell</code> 脚本，也可以通过 <code>hasky</code> 等 <code>npm</code> 包来介入。</p><figure class="highlight bash"><figcaption><span>例如下面文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">pre-commit.sample <span class="comment"># 提交前执行</span></span><br><span class="line">pre-push.sample <span class="comment"># 推送前执行</span></span><br><span class="line">pre-rebase.sample <span class="comment"># 变基前执行</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>上面的文件默认扩展名为 <code>sample</code>，即默认不生效，要想在某个 <code>Git</code> 操作时可以执行对应的 <code>hook</code> 文件，只需要去掉对应 <code>hook</code> 文件的扩展名即可。</strong></em></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/10/20190310233856/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Webpack4 —— 基础篇</title>
      <link>https://www.overtaking.top/2018/10/02/20181002041434/</link>
      <guid>https://www.overtaking.top/2018/10/02/20181002041434/</guid>
      <pubDate>Mon, 01 Oct 2018 20:14:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;为什么需要构建工具？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转换 ES6+ 语法&lt;/li&gt;
&lt;li&gt;转换 JSX/ Vue 指令&lt;/li&gt;
&lt;li&gt;CSS 前缀补全/预处理器（less，sass）&lt;/li&gt;
&lt;li&gt;压缩混淆/图片压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么选择 Webpa
        
      
      </description>
      
      <content:encoded><![CDATA[<p>为什么需要构建工具？</p><ul><li>转换 ES6+ 语法</li><li>转换 JSX/ Vue 指令</li><li>CSS 前缀补全/预处理器（less，sass）</li><li>压缩混淆/图片压缩</li></ul><p>为什么选择 Webpack？</p><ul><li>社区生态丰富</li><li>配置灵活和插件化扩展</li><li>官方更新迭代速度快</li></ul><p>entry</p><p>两种场景：SPA，多页应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/pages/app.js'</span>,</span><br><span class="line">    adminApp: <span class="string">'./src/pages/adminApp.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/10/02/20181002041434/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 外观模式</title>
      <link>https://www.overtaking.top/2018/10/01/20181001165125/</link>
      <guid>https://www.overtaking.top/2018/10/01/20181001165125/</guid>
      <pubDate>Mon, 01 Oct 2018 08:51:25 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/10/01/20181001165125/facade.jpg&quot; title=&quot;外观模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/10/01/20181001165125/facade.jpg" title="外观模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li></ul><h2 id="外观模式简介"><a href="#外观模式简介" class="headerlink" title="外观模式简介"></a>外观模式简介</h2><p>“外观模式” 就是把一些复杂的流程封装成一个接口，提供给外部更简单的使用，在外观模式中存在三种角色如下。</p><ul><li>门面角色（<code>Facade</code>）：是 “外观模式” 的核心，它熟悉子系统的功能，并被客户角色调用，内部实现了客户角色需求功能的组合；</li><li>子系统角色（<code>System</code>）：实现了子系统的功能（多个），对于客户角色是未知的；</li><li>客户角色（<code>Client</code>）：通过调用 <code>Facede</code> 来完成要实现的功能。</li></ul><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/10/01/20181001165125/facade-uml.jpg" alt="外观模式 UML 图" title>                </div>                <div class="image-caption">外观模式 UML 图</div>            </figure><p><br></p><h2 id="外观模式的实现"><a href="#外观模式的实现" class="headerlink" title="外观模式的实现"></a>外观模式的实现</h2><p>上面已经介绍了 “外观模式” 的各个角色，下面是简单的代码实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统角色 Sum</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">  sum(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Minus</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minus</span> </span>&#123;</span><br><span class="line">  minus(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Multipy</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Multipy</span> </span>&#123;</span><br><span class="line">  multipy(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Divide</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Divide</span> </span>&#123;</span><br><span class="line">  divide(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门面角色 Calculator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sumObj = <span class="keyword">new</span> Sum();</span><br><span class="line">    <span class="keyword">this</span>.minusObj = <span class="keyword">new</span> Minus();</span><br><span class="line">    <span class="keyword">this</span>.multipyObj = <span class="keyword">new</span> Multipy();</span><br><span class="line">    <span class="keyword">this</span>.divideObj = <span class="keyword">new</span> Divide();</span><br><span class="line">  &#125;</span><br><span class="line">  sum(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sumObj.sum(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  minus(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minusObj.minus(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  multipy(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.multipyObj.multipy(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  divide(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.divideObj.divide(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户角色</span></span><br><span class="line"><span class="keyword">let</span> calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"><span class="built_in">console</span>.log(calculator.sum(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(calculator.minus(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(calculator.multipy(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(calculator.divide(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 0.5</span></span><br></pre></td></tr></table></figure><p>我们在上面代码中实现了一个计算器功能，计算器具备的功能为加、减、乘、除，我们把这四个功能分别拆分成为四个子系统，用门面类 <code>Calculator</code> 来进行连接，这样只需要调用 <code>Calculator</code> 的实例（客户角色）就可以调用四个子系统模块分别提供的功能，但是上面的代码实现功能比较简洁，并没达到 “外观模式” 的真正作用，就是可以随意组合各个子系统的功能。</p><figure class="highlight js"><figcaption><span>组合子系统功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统角色 CPU</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CPU 启动'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Memory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内存启动'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Disk</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span> </span>&#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'硬盘启动'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门面角色 Computer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">    <span class="keyword">this</span>.memory = <span class="keyword">new</span> Memory();</span><br><span class="line">    <span class="keyword">this</span>.disk = <span class="keyword">new</span> Disk();</span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="comment">// 组合子系统功能</span></span><br><span class="line">    <span class="keyword">this</span>.cpu.start();</span><br><span class="line">    <span class="keyword">this</span>.memory.start();</span><br><span class="line">    <span class="keyword">this</span>.disk.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户角色</span></span><br><span class="line"><span class="keyword">let</span> computer = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">computer.start();</span><br><span class="line"><span class="comment">// CPU 启动</span></span><br><span class="line"><span class="comment">// 内存启动</span></span><br><span class="line"><span class="comment">// 硬盘启动</span></span><br></pre></td></tr></table></figure><p>上面代码实现了一个计算机的启动过程，功能来自于各个子系统，也可以通过门面角色实现子系统功能的多种组合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“外观模式” 的作用是可以对复杂功能解耦合，分散到各个子系统，使子系统与子系统互相独立，并对各个子系统提供外界访问的功能组合模块，这样既提高了子系统的维护性，又增加了外界访问功能的扩展性，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/7.facade" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/10/01/20181001165125/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 代理模式</title>
      <link>https://www.overtaking.top/2018/09/29/20180929025641/</link>
      <guid>https://www.overtaking.top/2018/09/29/20180929025641/</guid>
      <pubDate>Fri, 28 Sep 2018 18:56:41 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/29/20180929025641/proxy.jpg&quot; title=&quot;代理模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/29/20180929025641/proxy.jpg" title="代理模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li></ul><h2 id="代理模式概念"><a href="#代理模式概念" class="headerlink" title="代理模式概念"></a>代理模式概念</h2><p>由于某些情况下一个对象不能直接引用另一个对象，所以需要代理对象在这两个对象之间起到中介作用或者实现控制，这样的模式叫 “代理模式”。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/29/20180929025641/proxy-uml.jpg" alt="代理模式 UML 图" title>                </div>                <div class="image-caption">代理模式 UML 图</div>            </figure><p><br></p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设无法客户端无法直接使用这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Google</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span>(url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span> is google`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能通过代理操作 Google 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.google = <span class="keyword">new</span> Google();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.google.get(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>();</span><br><span class="line"><span class="keyword">let</span> result = proxy.get(<span class="string">'http://www.google.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// http://www.google.com is google</span></span><br></pre></td></tr></table></figure><p>假设 <code>Google</code> 类我们无法直接使用，只有 <code>Proxy</code> 可以使用 <code>Google</code>，我们可以通过 <code>Proxy</code> 类去操作使用 <code>Google</code> 类，此时 <code>Proxy</code> 类就是一个代理。</p><h2 id="ES6-的-Proxy"><a href="#ES6-的-Proxy" class="headerlink" title="ES6 的 Proxy"></a>ES6 的 Proxy</h2><p>在 <code>ES6</code> 标准以后，<code>JavaScript</code> 提供了原生的代理模式 <code>Proxy</code> 类，可以代理其他对象，并在对象属性的获取和赋值时增加拦截。</p><figure class="highlight js"><figcaption><span>ES6 Proxy 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lucy = &#123;</span><br><span class="line">  name: <span class="string">'lucy'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  height: <span class="number">165</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lucyMother = <span class="keyword">new</span> <span class="built_in">Proxy</span>(lucy, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.age - <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'height'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.height + <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'boyfriend'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val.age &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'太老了'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val.salary &lt; <span class="number">20000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'太穷了'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.name); <span class="comment">// lucy</span></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.height); <span class="comment">// 170</span></span><br><span class="line"></span><br><span class="line">lucyMother.boyfriend = &#123;</span><br><span class="line">  age: <span class="number">42</span>,</span><br><span class="line">  salary: <span class="number">25000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 太老了</span></span><br><span class="line"></span><br><span class="line">lucyMother.boyfriend = &#123;</span><br><span class="line">  age: <span class="number">36</span>,</span><br><span class="line">  salary: <span class="number">18000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 太穷了</span></span><br></pre></td></tr></table></figure><p>上面是一个接地气的案例，创建一个对象存储 <code>lucy</code> 的基本信息，使用代理创建 <code>lucyMother</code> 为 <code>lucy</code> 找男朋友，通过代理对象获取 <code>lucy</code> 的基本信息时会虚报年龄和身高，而在设置男朋友对象时会检查是否符合要求。</p><h2 id="代理模式、适配器模式和装饰器模式"><a href="#代理模式、适配器模式和装饰器模式" class="headerlink" title="代理模式、适配器模式和装饰器模式"></a>代理模式、适配器模式和装饰器模式</h2><p>从代码实现来看，代理模式、适配器模式、装饰器模式非常的相似，非常容易混淆，但其实是有本质区别的。</p><blockquote class="pullquote info"><ul><li><strong>代理模式和适配器模式：代理模式不会改变原有的接口，代理类和被代理的类属性方法使用方式完全一致，而适配器模式是因为旧的接口无法使用，通过适配器创建新的接口去兼容旧的接口；</strong></li><li><strong>代理模式和装饰器模式：装饰器功能会保证被装饰类功能正常使用的情况下新增功能，而代理模式保证原有接口，但会改变原来的接口的功能；</strong></li><li><strong>适配器模式和装饰器模式：装饰器是对一个类的包装，而适配器更多是去建立提供接口的类与无法适配的类之间的联系。</strong></li></ul></blockquote><h2 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是浏览器事件注册的一种优化手段，如果同类型的元素非常多，且都有相同的事件，如列表，则不必给每一个元素注册这个事件，而是将事件注册给父元素，即将事件委托给父元素，避免了相同事件的重复注册，这种优化利用了 “代理模式”，又称事件代理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件委托<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ulList = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    ulList.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event.target.innerHTML);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中，委托给父元素的事件触发后，可以通过事件对象的属性 <code>target</code> 获取到具体触发事件的子元素。</p><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>图片懒加载是一个提高用户体验的功能，也是非常常见的，原因是浏览器向服务器请求资源图片是需要等待的，由于网络等因素的影响会导致等待的时间更长，此时我们需要一个 <code>loading</code> 图片来过渡，这就是图片懒加载的基本需求。</p><figure class="highlight js"><figcaption><span>node 服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/loading.gif'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendFile(path.resolve(<span class="string">'img'</span>, <span class="string">'loading.gif'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/img/:name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    res.sendFile(path.join(__dirname, req.path));</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面服务器模拟了懒加载图片响应慢的场景，<code>loading</code> 图片立即响应，其他图片则延迟 <code>3s</code> 响应。</p><figure class="highlight html"><figcaption><span>Dom 结构</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-src</span>=<span class="string">"/img/bg1.jpg"</span>&gt;</span>图片1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-src</span>=<span class="string">"/img/bg2.jpg"</span>&gt;</span>图片2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bgimg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>没有实现懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'menu'</span>);</span><br><span class="line"><span class="keyword">let</span> bgimg = <span class="built_in">document</span>.getElementById(<span class="string">'bgimg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> background = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  bgimg.appendChild(img)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">menu.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> src = event.target.dataset.src;</span><br><span class="line">  background.setSrc(src);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码是没有实现懒加载的，当点击按钮向服务器请求图片时，并没有加入 <code>loading</code> 图片过渡，之所以说图片懒加载应用了 “代理模式” 并不是指懒加载功能本身，而是我们的实现方式，编写的代码质量要高至少要遵循单一职责原则和开放封闭原则，就是说最好不要直接在上面伙计的函数中增加 <code>loading</code> 过渡的逻辑，而是把这个过渡功能交给代理对象去处理。</p><figure class="highlight js"><figcaption><span>使用代理对象实现 loading 过渡</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'menu'</span>);</span><br><span class="line"><span class="keyword">let</span> bgimg = <span class="built_in">document</span>.getElementById(<span class="string">'bgimg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求图片的对象</span></span><br><span class="line"><span class="keyword">let</span> background = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  bgimg.appendChild(img)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 loading 过度的代理对象</span></span><br><span class="line"><span class="keyword">let</span> proxyBackground = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    background.setSrc(<span class="keyword">this</span>.src);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      background.setSrc(<span class="string">'./img/loading.gif'</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听获取图片的事件中使用的是代理对象 proxyBackground</span></span><br><span class="line">menu.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> src = event.target.dataset.src;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止缓存</span></span><br><span class="line">  proxyBackground.setSrc(<span class="string">`<span class="subst">$&#123;src&#125;</span>?time=<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的实现方式就符合 “代理模式”，<code>background</code> 对象是提供基本功能，而<code>proxyBackground</code>（代理对象）增强了基本功能，却并没有改变接口的使用方式，依然通过 <code>setSrc</code> 方法去请求图片。</p><h3 id="防抖代理"><a href="#防抖代理" class="headerlink" title="防抖代理"></a>防抖代理</h3><p>防抖的作用是在做一个操作时不需要很频繁，如搜索查询，在连续输入时如果每次触发输入事件都向后端发送请求，性能是极差的，我们希望的是连续输入只在最后一次统一发送请求，这种处理叫做防抖处理，是前端优化的手段。</p><figure class="highlight html"><figcaption><span>未使用防抖代理处理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"ipt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">'ipt'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'发送请求了'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    ipt.addEventListener(<span class="string">'input'</span>, post);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码未使用防抖代理，每次输入都会打印 “发送请求了”。</p><figure class="highlight html"><figcaption><span>使用防抖代理优化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"ipt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">'ipt'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'发送请求了'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 代理函数去执行 post</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> debouncePost = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      clearInterval(timer);</span></span><br><span class="line"><span class="javascript">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        post();</span></span><br><span class="line"><span class="undefined">      &#125;, 500);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;)();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  ipt.addEventListener(<span class="string">'input'</span>, debouncePost);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用防抖代理函数优化后，保留了原有功能的基础上进行了增强，实现了连续输入停止 <code>500ms</code> 后统一发送一次请求，防抖的实现方式有很多种，包括并不限于函数式编程等，而上面代码使用了 “代理模式” 实现 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>使用 “代理模式” 的场景在后端会更多，比如代理跨域，<code>Nginx</code> 代理等等，还有一点需要注意的是，“代理模式” 并非单一的，对于同一个对象，可以有多个代理对象去增强不同的功能，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/6.proxy" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/29/20180929025641/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 装饰器模式</title>
      <link>https://www.overtaking.top/2018/09/28/20180928030105/</link>
      <guid>https://www.overtaking.top/2018/09/28/20180928030105/</guid>
      <pubDate>Thu, 27 Sep 2018 19:01:05 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/28/20180928030105/decorator.jpg&quot; title=&quot;装饰器模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/28/20180928030105/decorator.jpg" title="装饰器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li></ul><h2 id="装饰器模式概念"><a href="#装饰器模式概念" class="headerlink" title="装饰器模式概念"></a>装饰器模式概念</h2><p>“装饰器模式” 是结构型模式之一，在不改变原有对象结构的前提下，给对象添加新功能，也可以理解 “装饰器模式” 是将一个对象嵌入另一个对象之中，相当于一个对象被另一个对象包装，包装其他对象的对象被称为 “装饰器”。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/28/20180928030105/decorator-uml.jpg" alt="装饰器模式 UML 图" title>                </div>                <div class="image-caption">装饰器模式 UML 图</div>            </figure><p><br></p><h2 id="装饰器模式和适配器模式"><a href="#装饰器模式和适配器模式" class="headerlink" title="装饰器模式和适配器模式"></a>装饰器模式和适配器模式</h2><figure class="highlight js"><figcaption><span>装饰器模式案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Duck</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat(food) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>吃<span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器类 TangDuck，装饰 Duck 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TangDuck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duck = <span class="keyword">new</span> Duck(name);</span><br><span class="line">  &#125;</span><br><span class="line">  eat(food) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duck.eat(food);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'说谢谢'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tangDuck = <span class="keyword">new</span> TangDuck(<span class="string">'唐老鸭'</span>);</span><br><span class="line">tangDuck.eat(<span class="string">'苹果'</span>);</span><br><span class="line"><span class="comment">// 唐老鸭吃苹果</span></span><br><span class="line"><span class="comment">// 说谢谢</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>适配器模式案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Power</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line">  charge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'220V'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.power = <span class="keyword">new</span> Power();</span><br><span class="line">  &#125;</span><br><span class="line">  chargeTransform() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">this</span>.power.charge();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;v&#125;</span> =&gt; 12V`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 Power 的使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.adaptor = <span class="keyword">new</span> Adaptor(Power);</span><br><span class="line">  &#125;</span><br><span class="line">  use() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.adaptor.chargeTransform());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面分别是 “装饰器模式” 和 “适配器模式” 的案例，但直接看代码可能会将两者混淆，原因是 “适配器” 和 “装饰器” 的类都存在了一个被装饰或者适配转换的类的引用，不同的是，“装饰器” 仅仅是对某一个类进行包装，并不会改变原来类的结构，而 “适配器” 的作用更多是去建立一个类和另一个类之间的关系和转换。</p><h2 id="装饰器模式和继承"><a href="#装饰器模式和继承" class="headerlink" title="装饰器模式和继承"></a>装饰器模式和继承</h2><p>通过上一节，我们已经知道了什么是 “装饰器模式”，下面有一个更直观的例子，我们有一个基础类 <code>Coffee</code>，组成是咖啡加水，这个基础上可以加奶、糖、冰，希求是可以组合加入上面的其他原料，并计算出对应的价格，大家可能第一时间想到的是继承的方式实现。</p><figure class="highlight js"><figcaption><span>继承的实现方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;water&#125;</span> + 咖啡`</span></span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加奶咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加糖咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加糖加奶咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarMilkCoffee</span> <span class="keyword">extends</span> <span class="title">SugarCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加奶加糖咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkSugarCoffee</span> <span class="keyword">extends</span> <span class="title">MilkCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从继承的代码看，虽然可以实现给咖啡任意加入其他原料，但是每一种不同的排列组合都需要单独创建类，当原料种类众多时，则难以管理代码，下面是 “装饰器模式” 的实现。</p><figure class="highlight js"><figcaption><span>装饰器模式的实现方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;water&#125;</span> + 咖啡`</span></span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 冰`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line"><span class="keyword">let</span> milkCoffee = <span class="keyword">new</span> MilkCoffee(coffee);</span><br><span class="line"><span class="keyword">let</span> sugarCoffee = <span class="keyword">new</span> SugarCoffee(milkCoffee);</span><br><span class="line"><span class="keyword">let</span> iceCoffee = <span class="keyword">new</span> IceCoffee(sugarCoffee);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(milkCoffee.make(<span class="string">'水'</span>), milkCoffee.cost());</span><br><span class="line"><span class="built_in">console</span>.log(sugarCoffee.make(<span class="string">'水'</span>), sugarCoffee.cost());</span><br><span class="line"><span class="built_in">console</span>.log(iceCoffee.make(<span class="string">'水'</span>), iceCoffee.cost());</span><br></pre></td></tr></table></figure><p>从 “装饰器模式” 的实现代码来看，我们只需要创建和原料相同多的类就可以了，其他的方式加料只需要对上一个类进行包装即可，部分加料的顺序，当类的种类越多时，“装饰器” 的意义则体现的越明显。</p><blockquote class="pullquote info"><p><strong>装饰器模式有时候会优于继承，尤其是很多的类通过继承存在排列组合的关系时，则使用 “装饰器模式” 可以更好更高效的解决问题。</strong></p></blockquote><h2 id="装饰器模式和-AOP-编程"><a href="#装饰器模式和-AOP-编程" class="headerlink" title="装饰器模式和 AOP 编程"></a>装饰器模式和 AOP 编程</h2><p>在软件业，<code>AOP</code> 为 <code>Aspect Oriented Programming</code> 的缩写，意为面向切面编程，通过预编译方式和运行其动态代理实现程序功能统一维护的一种技术。</p><p>在 <code>JavaScript</code> 中的 <code>AOP</code> 就是在函数之前或之后添加一些额外的逻辑，而不需要修改函数本身逻辑。</p><figure class="highlight js"><figcaption><span>AOP 编程的案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给函数扩展 before 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给函数扩展 after 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params">money, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`花 <span class="subst">$&#123;money&#125;</span> 元钱买 <span class="subst">$&#123;goods&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 before 方法给函数增加前切面</span></span><br><span class="line">buy = buy.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'向媳妇要 1 元钱'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 before 方法给函数增加后切面</span></span><br><span class="line">buy = buy.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'还给媳妇 0.2 元钱'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0.8</span>, <span class="string">'盐'</span>);</span><br><span class="line"><span class="comment">// 向媳妇要 1 元钱</span></span><br><span class="line"><span class="comment">// 花 0.8 元钱买 盐</span></span><br><span class="line"><span class="comment">// 还给媳妇 0.2 元钱</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong><code>AOP</code> 编程是由 “装饰器模式” 进化而来，或者说 “装饰器模式” 属于 <code>AOP</code> 编程的一种。</strong></p></blockquote><h2 id="装饰器模式的应用"><a href="#装饰器模式的应用" class="headerlink" title="装饰器模式的应用"></a>装饰器模式的应用</h2><h3 id="监控埋点"><a href="#监控埋点" class="headerlink" title="监控埋点"></a>监控埋点</h3><p>埋点分析，是网站分析的一种常用的数据采集方法，埋点主要分为服务器层面的埋点和客户端层面的埋点，服务器层面的埋点主要是通过客户端的请求进行分析，客户端层面的埋点分为代码埋点、自动化埋点，第三方埋点（百度、友盟等）。</p><figure class="highlight html"><figcaption><span>一个埋点的简单案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>埋点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-name</span>=<span class="string">"wetermelon"</span> <span class="attr">id</span>=<span class="string">"wetermelon"</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-name</span>=<span class="string">"apple"</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> wetermelon = <span class="built_in">document</span>.getElementById(<span class="string">'wetermelon'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> apple = <span class="built_in">document</span>.getElementById(<span class="string">'apple'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加切面</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">        afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 事件处理函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">`你点击了<span class="subst">$&#123;<span class="keyword">this</span>.dataset.name&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    click = click.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 向服务器发送统计数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="javascript">      img.src = <span class="string">`http://localhost:3000/report?name=<span class="subst">$&#123;<span class="keyword">this</span>.dataset.name&#125;</span>`</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 给所有的</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'button'</span>)).forEach(<span class="function"><span class="params">button</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      button.addEventListener(<span class="string">'click'</span>, click);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>负责统计点击次数的服务</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储按钮的点击次数</span></span><br><span class="line"><span class="keyword">const</span> goods = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/report'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = req.query.name;</span><br><span class="line">  <span class="keyword">if</span> (goods[name]) &#123;</span><br><span class="line">    goods[name]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    goods[name] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.json(goods);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的埋点就是通过 <code>AOP</code> 的方式在点击事件后添加了切面，用来向服务器发送请求，符合 “单一职责原则”，可以使点击事件和埋点逻辑进行 “解耦”，服务器在接收到请求之后立即对点击次数进行统计并储存，也可以通过调用 <code>report</code> 接口来获取当前各个按钮的点击次数。</p><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>“装饰器模式” 的思想同样可以用在表单校验，通常表单校验逻辑是在 <code>submit</code> 事件触发时提交之前发生的，我们经常会将校验逻辑和提交逻辑写在一起，形成 “强耦合”，下面我们使用 <code>AOP</code> 的方式来实现表单校验，对校验逻辑和提交逻辑进行 “解耦”。</p><figure class="highlight html"><figcaption><span>应用于表单校验</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单校验<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">  密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit-btn"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submit-btn'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加切面函数</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> result = beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">        result &amp;&amp; _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 表单提交事件</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'提交表单'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 验证用户名</span></span></span><br><span class="line"><span class="javascript">    submit = submit.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>).value;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!username) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> alert(<span class="string">'请输入用户名'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 验证</span></span></span><br><span class="line"><span class="javascript">    submit = submit.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>).value;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!password) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> alert(<span class="string">'请输入密码'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    submitBtn.addEventListener(<span class="string">'click'</span>, submit);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 <code>JavaScript</code> 中 “装饰器模式” 和 <code>AOP</code> 编程非常相似，应用也非常多，如 <code>axios</code> 中对请求、响应的拦截方法，<code>Koa</code> 中间件，都包含这样的编程思想，而在 <code>ES6</code> 之后 <code>JavaScript</code> 已经支持了原生的 “装饰器” 语法，使用起来更方便，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/5.decorator" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/28/20180928030105/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 适配器模式</title>
      <link>https://www.overtaking.top/2018/09/27/20180927230432/</link>
      <guid>https://www.overtaking.top/2018/09/27/20180927230432/</guid>
      <pubDate>Thu, 27 Sep 2018 15:04:32 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/27/20180927230432/adapter.jpg&quot; title=&quot;适配器模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/27/20180927230432/adapter.jpg" title="适配器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li></ul><h2 id="适配器模式的概念"><a href="#适配器模式的概念" class="headerlink" title="适配器模式的概念"></a>适配器模式的概念</h2><p>“适配器模式” 是指类的使用者和类的接口定义格式不符合时，通过一个中间类进行转换。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/27/20180927230432/adapter-uml.jpg" alt="适配器模式 UML 图" title>                </div>                <div class="image-caption">适配器模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Power</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line">  charge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'220V'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.power = <span class="keyword">new</span> Power();</span><br><span class="line">  &#125;</span><br><span class="line">  chargeTransform() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">this</span>.power.charge();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;v&#125;</span> =&gt; 12V`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 Power 的使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.adaptor = <span class="keyword">new</span> Adaptor(Power);</span><br><span class="line">  &#125;</span><br><span class="line">  use() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.adaptor.chargeTransform());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> notepad = <span class="keyword">new</span> Notepad(Power);</span><br><span class="line">notepad.use(); <span class="comment">// 220V =&gt; 12V</span></span><br></pre></td></tr></table></figure><p>上面代码中有三个类，<code>Power</code> 类为电源，提供 <code>220V</code> 电压，<code>Notepad</code> 为我们的电子设备，使用电压 <code>22V</code>，明显两个类是不匹配的，此时的 <code>Adaptor</code> 就是一个适配器，作用是连接 <code>Power</code> 与 <code>Notepad</code>，将 <code>220V</code> 转换为 <code>22V</code>。</p><blockquote class="pullquote warning"><p><strong>适配器模式中，通常作为适配器的类内部会存储被转换类实例的引用。</strong></p></blockquote><h2 id="适配器模式的应用"><a href="#适配器模式的应用" class="headerlink" title="适配器模式的应用"></a>适配器模式的应用</h2><h3 id="适配参数和返回数据"><a href="#适配参数和返回数据" class="headerlink" title="适配参数和返回数据"></a>适配参数和返回数据</h3><p>在浏览器通过 <code>Ajax</code> 与服务端交互时，封装的请求方法会有默认参数，如果传入了参数则使用传入的参数，如果没有传入，则使用默认的参数，这是参数的适配。</p><p>在请求响应后，后端会返回给我们 <code>JSON</code> 格式的数据，我们在使用时希望转换成对象使用，这个转换的适配是数据接口的适配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    dataType: <span class="string">'JSON'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  initParams(options, defaultOptions); <span class="comment">// 适配参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数适配器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initParams</span>(<span class="params">options, defaultOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> options) &#123;</span><br><span class="line">    defaultOptions[attr] = options[attr] || defaultOptions[attr];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> defaultOptions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据适配器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tranformData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器</span></span><br><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">'www.pandashen.com'</span>,</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  success(json) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = tranformData(json); <span class="comment">// 适配返回数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="适配转换-Promise"><a href="#适配转换-Promise" class="headerlink" title="适配转换 Promise"></a>适配转换 Promise</h3><p>在 <code>NodeJS</code> 的 <code>fs</code> 模块中有很多异步的方法，比如 <code>readFile</code>，读取文件获取结果后想要继续读取下一个文件，以此类推就产生了 “回调地狱”，代码的可读性和维护性会变差，我们可以通过 “适配器模式” 将这些方法转化为 <code>Promise</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配成 Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="literal">null</span>, ...args, (err, data) =&gt; &#123;</span><br><span class="line">        err ? reject(err) : resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配后的方法</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line">readFile(<span class="string">'index.txt'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="适配技术栈变更后的旧代码"><a href="#适配技术栈变更后的旧代码" class="headerlink" title="适配技术栈变更后的旧代码"></a>适配技术栈变更后的旧代码</h3><p>在一些老项目是 <code>jQuery</code> 的技术栈，请求也使用的是自带的 <code>$.ajax</code>，如果一天项目中决定移除 <code>jQuery</code>，请求方法 <code>$.ajax</code> 自然也跟着移除了，假设我们想使用 <code>fetch</code> 来代替 <code>$.ajax</code>，则要修改大量的代码，这时 “适配器模式” 可以对 <code>fetch</code> 进行适配，让我们继续沿用 <code>$.ajax</code> 的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="built_in">window</span>.$ = &#123;</span><br><span class="line">  ajax(options) &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(options.url, &#123;</span><br><span class="line">      method: options.type || <span class="string">'GET'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringifily(options.data || &#123;&#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $.ajax 的旧代码</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'pandashen.com/info'</span>,</span><br><span class="line">  type: <span class="string">'POST'</span>,</span><br><span class="line">  dataType: <span class="string">'json'</span>,</span><br><span class="line">  data: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“适配器模式” 是很常用的设计模式之一，<code>Vue</code> 的 <code>computed</code> 计算属性和 <code>Koa</code> 兼容 <code>1.x</code> 版本和 <code>2.x</code> 版本中间件插件 <code>koa-convert</code> 都应用了 “适配器模式”，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/4.adapter" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/27/20180927230432/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 单例模式</title>
      <link>https://www.overtaking.top/2018/09/26/20180926201447/</link>
      <guid>https://www.overtaking.top/2018/09/26/20180926201447/</guid>
      <pubDate>Wed, 26 Sep 2018 12:14:47 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/26/20180926201447/single.jpg&quot; title=&quot;单例模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/26/20180926201447/single.jpg" title="单例模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li></ul><h2 id="普通单例模式"><a href="#普通单例模式" class="headerlink" title="普通单例模式"></a>普通单例模式</h2><p>“单例模式” 就是通过类创建实例后，每次创建和获取都返回同一个实例，下面是 “单例模式” 最基本的实现。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/26/20180926201447/singleton-uml.jpg" alt="单例模式 UML 图" title>                </div>                <div class="image-caption">单例模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>ES6 写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getInstance(name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>.instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = Person.getInstance(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = Person.getInstance(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>ES5 写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = Person.getInstance(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = Person.getInstance(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面分别用 <code>ES6</code> 和 <code>ES5</code> 的方式实现了一个基本的单例模式，创建 <code>Person</code> 的实例时需要通过 <code>getInstance</code> 静态方法，这样第一次会创建一个实例，再次调用时会将之前创建的实例返回，达到单例的目的。</p><blockquote class="pullquote danger"><p><strong>上面单例模式的缺点：</strong></p><p><strong>1、类的使用者必须要知道这是一个单例的类，创建和获取实例必须通过调用 <code>getInstance</code> 方法实现；</strong><br><strong>2、并不能真正阻止类的使用者通过 <code>new</code> 关键字创建出新的实例。</strong></p></blockquote><h2 id="透明单例模式"><a href="#透明单例模式" class="headerlink" title="透明单例模式"></a>透明单例模式</h2><p>“透明单例模式” 可以解决上面普通 “单例模式” 的不足，希望可以直接使用 <code>new</code> 关键字来创建类的实例，如果已经创建，再次通过 <code>new</code> 创建，则会返回之前创建的实例。</p><figure class="highlight js"><figcaption><span>透明单例模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> Person(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> Person(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>“透明单例模式” 的原理是创建一个自执行函数，内部创建一个私有变量 <code>instance</code> 用来存储创建的实例，并通过闭包返回一个构造函数，用变量 <code>Person</code> 接收，当使用 <code>new</code> 创建实例时，先检测私有变量 <code>instance</code> 是否有值，如果没值则创建实例，如果有值则直接返回 <code>instance</code>（利用 <code>new</code> 关键字和构造创建实例的原理实现）。</p><blockquote class="pullquote info"><p><strong>缺点：违反了单一职责原则（一个函数只做一件事），自执行函数返回的构造函数已经不止单纯用作构建实例，同时处理了单例的判断逻辑。</strong></p></blockquote><h2 id="单例与构建分离"><a href="#单例与构建分离" class="headerlink" title="单例与构建分离"></a>单例与构建分离</h2><p>针对上面 “透明单例模式” 的缺点，下面将构造函数单例处理与构建逻辑进行分离。</p><figure class="highlight js"><figcaption><span>单例逻辑与构建逻辑分离</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的构造函数</span></span><br><span class="line"><span class="keyword">const</span> CreatePerson = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> CreatePerson(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> CreatePerson(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码将单例的逻辑与构造函数的逻辑进行了分离，真正用于构造实例的类是 <code>Person</code>，用于处理单例逻辑的是自执行函数返回的函数，使用 <code>CreatePerson</code> 变量接收，这个函数也同时约定好被当做构造函数使用（通过 <code>new</code> 关键字调用和直接执行效果相同）。</p><blockquote class="pullquote primary"><p><strong>缺点：生成的新构造函数名字（<code>CreatePerson</code>）是固定的，用来创建实例的这个类（<code>Person</code>）也是固定的，不够灵活。</strong></p></blockquote><h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>下面支持不同的构造函数创建实例，并且可以使用原本构造函数的对应方法，就是把上面案例不灵活的地方变得灵活。</p><figure class="highlight js"><figcaption><span>封装变化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CreateSingle = <span class="function"><span class="keyword">function</span> (<span class="params">Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> SingleConstructor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      Constructor.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现原型继承</span></span><br><span class="line">  SingleConstructor.prototype = <span class="built_in">Object</span>.create(Constructor.prototype);</span><br><span class="line">  <span class="keyword">return</span> SingleConstructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dailog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dailog.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的构造函数并生成实例</span></span><br><span class="line"><span class="keyword">const</span> CreatePerson = CreateSingle(Person);</span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> CreatePerson(<span class="string">'hello'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> CreatePerson(<span class="string">'world'</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CreateDailog = CreateSingle(Dailog);</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> CreateDailog(<span class="string">'model'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> CreateDailog(<span class="string">'view'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面我们把创建单例的逻辑进行了封装变成了一个通用的逻辑，对于不同构造函数所创建实例，只需要传入这个构造函数并生成新的构造函数，需要注意的是，新的构造函数无法继承原构造函数的原型方法，所以通过继承实现的。</p><h2 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在编写代码时，我们有时候需要人为的创建命名空间，以防止变量的相互污染，这是可以使用 “单例模式” 来实现。</p><figure class="highlight js"><figcaption><span>创建命名空间的方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储工具方法</span></span><br><span class="line"><span class="keyword">const</span> utils = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间</span></span><br><span class="line">utils.define = <span class="function"><span class="keyword">function</span> (<span class="params">namespace, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取命名空间的数组</span></span><br><span class="line">  <span class="keyword">const</span> namespaces = namespace.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后一项为设定方法的属性名</span></span><br><span class="line">  <span class="keyword">const</span> methodName = namespaces.pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量存储当前命名空间的引用，默认为 utils（根命名空间）</span></span><br><span class="line">  <span class="keyword">let</span> current = utils;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; namespaces.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentNamespace = namespaces[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当某一个命名空间没有时，则创建这个命名空间（单例模式）</span></span><br><span class="line">    <span class="keyword">if</span> (!current[currentNamespace]) &#123;</span><br><span class="line">      current[currentNamespace] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则让当前命名空间指向已有的命名空间</span></span><br><span class="line">    current = current[currentNamespace];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将传入的函数设定给最后一级命名空间的属性上</span></span><br><span class="line">  current[methodName] = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>命名空间的创建和使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过命名空间定义方法</span></span><br><span class="line">utils.define(<span class="string">'dom.class.addClass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dom.class.addClass'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.define(<span class="string">'string.trim'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'string.trim'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.define(<span class="string">'event.prevent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'event.prevent'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">utils.dom.class.addClass(<span class="string">'title'</span>); <span class="comment">// dom.class.addClass</span></span><br><span class="line">utils.string.trim(<span class="string">' hello '</span>); <span class="comment">// string.trim</span></span><br><span class="line">utils.event.prevent(); <span class="comment">// event.prevent</span></span><br></pre></td></tr></table></figure><p>上面代码的设计希望通过 <code>utils</code> 对象的 <code>define</code> 方法按照传入的表示命名空间的字符串去创建方法，基本实现思路和逻辑是，当一个属性是第一次出现时，创建一个对象作为该命名空间，当再次出现时则不会重复创建命名空间（因为会出现覆盖的问题），而是沿用之前创建的命名空间。</p><h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p><code>LRU</code> 全称为 <code>Least Recently Used</code>，为最近使用的意思，缓存的方式为访问一个元素时，则将其标记为活跃，当存储时，如果超出容量则删除最不常用的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(capacity) &#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="keyword">this</span>.members = [];</span><br><span class="line">  &#125;</span><br><span class="line">  put(key, val) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldestIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> oldestAge = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.members.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> member = <span class="keyword">this</span>.members[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.age &gt; oldestAge) &#123;</span><br><span class="line">        oldestAge = member.age;</span><br><span class="line">        oldestIndex = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.key === key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.members[i] = &#123; key, val, <span class="attr">age</span>: <span class="number">0</span> &#125;;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        member.age++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.members.length &gt;= <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.members.splice(oldestIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.members.push(&#123; key, val, <span class="attr">age</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(key) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.members.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> member = <span class="keyword">this</span>.members[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.key === key) &#123;</span><br><span class="line">        member.age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> member.val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个创建 <code>LRU</code> 缓存的类，用数组管理成员，<code>put</code> 方法用于新增成员，<code>get</code> 方法用于访问成员，当访问成员时，成员的 <code>age</code> 清零，代表最近活跃，当新增元素时，如果该元素已存在，则做覆盖操作，如果不存在，则推入数组中，<code>age</code> 设置为零，其他成员 <code>age</code> 自增，若数组超出容量时，先找到 <code>age</code> 最大的元素删除，再讲新的元素推入数组，上面是一个直观但性能较差的实现，如果有兴趣可以使用链表进行优化。</p><figure class="highlight js"><figcaption><span>使用 LRU 缓存</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'1'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '1', val: 1, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'2'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '1', val: 1, age: 1 &#125;, &#123; key: '2', val: 2, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'3'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '2', val: 2, age: 1 &#125;, &#123; key: '3', val: 3, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'2'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '2', val: 'hello', age: 0 &#125;, &#123; key: '3', val: 3, age: 1 &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“单例模式” 是设计模式中非常好理解的一个，使用还是非常广泛的，在 <code>Redux</code> 等众多的第三方库中也有所体现，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/3.single" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/26/20180926201447/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 工厂模式</title>
      <link>https://www.overtaking.top/2018/09/25/20180925190503/</link>
      <guid>https://www.overtaking.top/2018/09/25/20180925190503/</guid>
      <pubDate>Tue, 25 Sep 2018 11:05:03 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/25/20180925190503/factory.jpg&quot; title=&quot;工厂模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/25/20180925190503/factory.jpg" title="工厂模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li></ul><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>“简单工厂模式” 是由一个工厂对象决定创建出哪一种产品类的实例。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/simple-factory-uml.jpg" alt="简单工厂模式 UML 图" title>                </div>                <div class="image-caption">简单工厂模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>直接创建子类实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  grow() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am growing!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建子类的实例</span></span><br><span class="line"><span class="keyword">let</span> apple = <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line"><span class="keyword">let</span> orange = <span class="keyword">new</span> Orange(<span class="string">'橘子'</span>, <span class="string">'酸'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>上面创建子类实例的方式是直接使用 <code>new</code> 关键字直接创建，这种创建方式使产生的实例和具体的类紧紧的耦合在一起，并依赖于类的具体实现，如果在子类可能随时发生变化的代码中，将对维护造成麻烦，使用 “简单工厂模式” 可以对产生的实例和具体的类进行解耦，且不必关心子类的具体实现和在未来是否发生变化。</p><figure class="highlight js"><figcaption><span>使用简单工厂模式创建子类的实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  grow() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am growing!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create(type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'apple'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'orange'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'no constructor!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简单工厂创建子类实例</span></span><br><span class="line"><span class="keyword">let</span> apple = Factory.create(<span class="string">'apple'</span>);</span><br><span class="line"><span class="keyword">let</span> orange = Factory.create(<span class="string">'orange'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>从上面代码看，我们只需要通过类型就可以得到某一个子类的实例，不需要知道子类是谁，以及具体实现，并在工厂 <code>Factory</code> 中做了错误处理，可以不必担心未来某一个子类发生变化或者被删除的问题。</p><figure class="highlight js"><figcaption><span>简单工厂经典案例 —— jQuery</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery 的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JQuery</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (selector) &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    <span class="keyword">let</span> elements = <span class="built_in">document</span>.querySelectorAll(selector);</span><br><span class="line">    <span class="keyword">this</span>.length = elements.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>[i] = elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>].innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂函数</span></span><br><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 li 标签并调用 html 方法</span></span><br><span class="line"><span class="keyword">let</span> html = $(<span class="string">'li'</span>).html();</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>简单工厂经典案例 —— React 虚拟 DOM</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟 DOM 的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(tagName, attrs, children) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tagName = tagName;</span><br><span class="line">    <span class="keyword">this</span>.attrs = attrs;</span><br><span class="line">    <span class="keyword">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在 React 对象上的简单工厂函数</span></span><br><span class="line">React.createElement = <span class="function"><span class="keyword">function</span> (<span class="params">tagName, attrs, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(tagName, attrs, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>简单工厂模式的缺点：不满足开放封闭原则，内部可以随意修改，新增、修改子类都需要修改工厂类内部代码，在扩展的过程中工厂类的代码将会越来越臃肿。</strong></p></blockquote><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>“工厂方法模式” 可以规避 “简单工厂模式” 的缺点，又称为多态性工厂模式，核心的工厂类不再负责创建出哪一种产品类的实例，而是将具体创建的工作交给子类去做。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/factory-method-uml.jpg" alt="工厂方法模式 UML 图" title>                </div>                <div class="image-caption">工厂方法模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>基本的工厂方法模式使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  create () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— OrangeFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrangeFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">let</span> apple = AppleFactory.create();</span><br><span class="line"><span class="keyword">let</span> orange = OrangeFactory.create();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>上面是一个基础的 “工厂方法模式” 使用，解决了 “简单工厂模式” 扩展的问题（遵循开放封闭原则），创建实例虽然不耦合具体的类，但是耦合工厂的子类，下面可以通过文件拆分进行解耦。</p><figure class="highlight js"><figcaption><span>plant.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Plant;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>factory.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  create () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Factory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>apple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plant = <span class="built_in">require</span>(<span class="string">'./plant'</span>);</span><br><span class="line"><span class="keyword">const</span> Factory = <span class="built_in">require</span>(<span class="string">'./factory'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = AppleFactory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>orange.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plant = <span class="built_in">require</span>(<span class="string">'./plant'</span>);</span><br><span class="line"><span class="keyword">const</span> Factory = <span class="built_in">require</span>(<span class="string">'./factory'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— OrangeFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrangeFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = OrangeFactory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>setting.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置文件，将要创建实例的类型与对应的工厂关联起来</span></span><br><span class="line"><span class="keyword">const</span> setting = &#123;</span><br><span class="line">  apple: <span class="string">'./apple'</span>,</span><br><span class="line">  orange: <span class="string">'./orange'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = setting;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>use.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setting = <span class="built_in">require</span>(<span class="string">'./setting'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apple = <span class="built_in">require</span>(setting[<span class="string">'apple'</span>]).create();</span><br><span class="line"><span class="keyword">let</span> orange = <span class="built_in">require</span>(setting[<span class="string">'orange'</span>]).create();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>使用上面这样的 “工厂方法模式”，扩展时只需要新增一个文件，在文件中定义具体创建实例的类和工厂类就可以了，一般会有一个配置文件将要创建实例的类型和对应的工厂关联起来，创建对应的实例只需通过类型和配置文件找到对应的工厂执行 <code>create</code> 方法即可。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>“抽象工厂模式” 是指当有多个抽象角色时，可以提供一个接口，不必指定 “产品” 具体的情况下，创建多个产品族中的产品对象。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/abatract-factory-uml.jpg" alt="抽象工厂模式 UML 图" title>                </div>                <div class="image-caption">抽象工厂模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 —— Icon</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类 —— Button</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— AppleIcon 苹果图标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleIcon</span> <span class="keyword">extends</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Mac 的图标'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— AppleButton 苹果按钮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleButton</span> <span class="keyword">extends</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Mac 的按钮'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— WindowsIcon Windows 图标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsIcon</span> <span class="keyword">extends</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Windows 的图标'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— WindowsButton Windows 按钮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsButton</span> <span class="keyword">extends</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Windows 的按钮'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;&#125; <span class="comment">// 创建图标</span></span><br><span class="line">  createButton() &#123;&#125; <span class="comment">// 创建按钮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory 用于创建苹果族产品实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppleIcon();</span><br><span class="line">  &#125;</span><br><span class="line">  createButton() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppleButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— WindowsFactory 用于创建 Windows 族产品实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowsIcon();</span><br><span class="line">  &#125;</span><br><span class="line">  createButton() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowsButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建苹果工厂实例</span></span><br><span class="line"><span class="keyword">let</span> appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建苹果族产品</span></span><br><span class="line">appleFactory.createIcon().render(); <span class="comment">// 绘制 Mac 的图标</span></span><br><span class="line">appleFactory.createButton().render(); <span class="comment">// 绘制 Mac 的按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Windows 工厂实例</span></span><br><span class="line"><span class="keyword">let</span> wondowsFactory = <span class="keyword">new</span> WindowsFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Windows 族产品</span></span><br><span class="line">wondowsFactory.createIcon().render(); <span class="comment">// 绘制 Windows 的图标</span></span><br><span class="line">wondowsFactory.createButton().render(); <span class="comment">// 绘制 Windows 的按钮</span></span><br></pre></td></tr></table></figure><p>在上面案例中，按照 “抽象工厂模式” 的说法，多个抽象角色指的是 <code>Apple</code> 和 <code>Windows</code>，<code>Icon</code> 和 <code>Button</code>，工厂分为 <code>AppleFactory</code> 和 <code>WindowsFactory</code> 两类，可以分别创建对应产品的 <code>Icon</code> 和 <code>Button</code> 实例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>上面几种工厂模式中，“简单工厂模式” 在框架开发中使用居多，“工厂方法模式” 更多在一些比较老的且复杂的项目中用作业务模块封装和抽象，“抽象工厂模式” 在前端并不常用，应用于后端偏多，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/2.factory" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/25/20180925190503/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— Router 4.0 的基本使用</title>
      <link>https://www.overtaking.top/2018/09/21/20180921182754/</link>
      <guid>https://www.overtaking.top/2018/09/21/20180921182754/</guid>
      <pubDate>Fri, 21 Sep 2018 10:27:54 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/21/20180921182754/react-router.png&quot; title=&quot;React Router&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-路由简介&quot;&gt;&lt;a href=&quot;#React-路由简介&quot; class=&quot;headerlink&quot; title=&quot;React 路由简介&quot;&gt;&lt;/a&gt;React 路由简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，&lt;code&gt;React&lt;/code&gt; 全家桶中也有配套的路由系统，在路由 &lt;code&gt;2.0&lt;/code&gt; 版本时叫做 &lt;code&gt;react-router&lt;/code&gt;，在路由 &lt;code&gt;4.0&lt;/code&gt; 时更名为 &lt;code&gt;react-router-dom&lt;/code&gt;，我们本次就针对较新版本的 &lt;code&gt;Router&lt;/code&gt; 系统进行介绍。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/21/20180921182754/react-router.png" title="React Router"><p><br></p><h2 id="React-路由简介"><a href="#React-路由简介" class="headerlink" title="React 路由简介"></a>React 路由简介</h2><blockquote class="pullquote info"><p>在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，<code>React</code> 全家桶中也有配套的路由系统，在路由 <code>2.0</code> 版本时叫做 <code>react-router</code>，在路由 <code>4.0</code> 时更名为 <code>react-router-dom</code>，我们本次就针对较新版本的 <code>Router</code> 系统进行介绍。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>为了方便演示如何 <code>Router</code>，我们使用 <code>create-react-app</code> 创建一个 <code>React</code> 项目，并删除 <code>src</code> 文件夹内多余文件，创建我们需要的文件 <code>index.js</code>，目录结构如下。</p><p><pre>react-router<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- src<br>  | |- pages<br>  | | |- Add.js<br>  | | |- Detail.js<br>  | | |- Home.js<br>  | | |- Index.js<br>  | | |- List.js<br>  | | |- Login.js<br>  | | |- Logo.js<br>  | | |- MenuLink.js<br>  | | |- Profile.js<br>  | | |- Protected.js<br>  | | |- User.js<br>  | |- App.js<br>  | |- index.css<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><p>其中主组件为 <code>App</code>，在 <code>index.js</code> 中渲染，<code>index.js</code> 代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>而 <code>App</code> 组件主要用来渲染菜单导航和路由组件，我们将在下面完善代码。</p><h2 id="HashRouter-和-BrowserRouter"><a href="#HashRouter-和-BrowserRouter" class="headerlink" title="HashRouter 和 BrowserRouter"></a>HashRouter 和 BrowserRouter</h2><p>在 <code>React Router</code> 中，给我们提供了一些路由相关的组件，其中最重要的就是实现路由的 <code>HashRouter</code> 和 <code>BrowserRouter</code>，我们知道浏览器的 <code>hash</code> 值发生变化会阻止页面的跳转，而 <code>HashRouter</code> 就是利用这个特性实现的，通过监听 <code>onhanshchange</code> 事件在 <code>hash</code> 值改变的时候做出响应，<code>BrowserRouter</code> 则是利用 <code>H5</code> 的新 <code>History API</code> 的 <code>pushState</code> 方法构造的的历史记录集合来实现的。</p><p>通常情况下，在开发的时候使用 <code>HashRouter</code> 更多，而在真正上线时替换成 <code>BrowserRouter</code>，两种 <code>Router</code> 在地址栏上的表现上区别只是是否含有 <code>#</code>，两种 <code>Router</code> 的使用如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— HashRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* 路由相关代码 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— BrowserRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* 路由相关代码 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>其实就是使用 <code>React Router</code> 中提供的这两种类型的路由组件对路由相关的 <code>JSX</code> 进行包裹。</p><h2 id="Route-和-Link-组件"><a href="#Route-和-Link-组件" class="headerlink" title="Route 和 Link 组件"></a>Route 和 Link 组件</h2><p><code>Route</code> 组件是用来定义路由跳转的切换组件的区域，通过 <code>path</code> 属性定义匹配的路由，<code>component</code> 属性来定义渲染的组件，渲染后就是一个 <code>div</code> 标签，<code>Link</code> 是用来点击跳转路由的，通常用来定义导航栏内容，通过 <code>to</code> 属性设置匹配的路由，需要与 <code>Route</code> 的 <code>path</code> 一一对应，点击后可切换到对应的路由组件，渲染后为一个 <code>a</code> 标签。</p><h3 id="创建路由跳转的组件"><a href="#创建路由跳转的组件" class="headerlink" title="创建路由跳转的组件"></a>创建路由跳转的组件</h3><p>下面我们来创建三个路由对应的组件，分别为首页、用户、个人中心，对应的组件分别为 <code>Home.js</code>、<code>User.js</code>、<code>Profile.js</code></p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Home.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;主页&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;用户&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Profile.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Profile</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;个人中心&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="配合使用-Route-和-Link"><a href="#配合使用-Route-和-Link" class="headerlink" title="配合使用 Route 和 Link"></a>配合使用 Route 和 Link</h3><p>使用 <code>Link</code> 和 <code>Route</code> 配合使用如下，点击 <code>Link</code> 会在类名 <code>container</code> 的元素种加载路由路径对应的组件。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ul className=<span class="string">"nav"</span>&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/profile"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div className="container"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/</span>home<span class="string">" component=&#123;Home&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user<span class="string">" component=&#123;User&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/profile<span class="string">" component=&#123;Profile&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/HashRouter&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>启动项目后上面的代码已经可以帮助我们实现页面路由的切换，但是上面的代码 <code>Link</code> 和 <code>Route</code> 组件混在一起，我们其实可以将 <code>App</code> 拆分成两个组件，一个用来存放 <code>Link</code> 部分，一个用来存放 <code>Route</code> 部分，创建 <code>Index</code> 组件，将 <code>Link</code> 的部分抽取出去，代码修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Index&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;a className=<span class="string">"navbar-brand"</span>&gt;管理系统&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;ul className=<span class="string">"nav"</span>&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/profile"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="container"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修改之后 <code>Index</code> 组件专门用来维护导航组件 <code>Link</code>，<code>App</code> 组件专门用来维护路由组件 <code>Route</code>，这样代码看起来就不那么混乱了。</p><h3 id="Route-组件的-exact-属性"><a href="#Route-组件的-exact-属性" class="headerlink" title="Route 组件的 exact 属性"></a>Route 组件的 exact 属性</h3><p>上面我们所定义的路由为一级路由，在路由匹配并成功加载对应组件后，如果组件又由多个组件组成，并有类似导航的操作（当然不仅限于导航）来控制其他的组件视图的切换，则需要匹配二级路由，这就出现了一个问题，我们以 <code>/user</code> 为例，假设添加一个新的路由 <code>/user/add</code>，那么 <code>React</code> 会由上到下依次匹配，<code>/user/add</code> 中包含 <code>/user</code>，因此会同时渲染两个组件，这不是我们希望的。</p><p>在 <code>React</code> 内部给我们提供了解决方案，就是给路由设置严格匹配，我们只需要让 <code>/user</code> 对应的 <code>Route</code> 组件添加 <code>exact</code> 属性，并将值设置为 <code>true</code> 即可，所以匹配 <code>/user/add</code> 时就不会出现 <code>/user</code> 对应的路由组件也被渲染的情况，当然也可以将 <code>exact</code> 简写到 <code>Route</code> 组件上省略赋值为 <code>true</code> 的过程。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 exact</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Index&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Switch-组件"><a href="#Switch-组件" class="headerlink" title="Switch 组件"></a>Switch 组件</h2><p>因为 <code>React</code> 的路由是由上至下依次进行匹配的，如果有两个同名路由进行匹配，会同时加载两个组件，这也是我们需要优化的，<code>React Router</code> 的 <code>Switch</code> 组件就是来做这件事的，只需要将多个 <code>Route</code> 组件包裹起来，就可以实现只要成功匹配一个路由就不再继续匹配。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Switch 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt; &#123;<span class="comment">/* 同名路由 */</span>&#125;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 <code>Switch</code> 组件优化后，启动项目就可以发现只渲染了一个 <code>User</code> 组件。</p><h2 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a>Redirect 组件</h2><p>在 <code>React</code> 开发中经常遇到路径输入错误的情况，通常情况有两种处理方式，第一种是跳转到一个 <code>404</code> 页面，第二种方式是将页面路由重定向到主页，而 <code>React Router</code> 提供的 <code>Redirect</code> 组件就是帮助我们在所有路由都匹配失败时重定向的，使用时通常放在最后一个 <code>Route</code> 组件的下面用来 “兜底”，使用 <code>to</code> 属性来定义重定向的路由。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Redirect 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt; &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：不能放在 <code>Route</code> 组件的上面，因为放在上面不会匹配任何的路由，而会直接重定向到设置的页面。</strong></em></p></blockquote><p>对于路由都没有匹配而返回 <code>404</code> 页面我们这里也简单说一下，但是这样的用法非常少，使用 <code>Redirect</code> 重定向到指定页面的方式会更多一些。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 匹配失败跳转 404 页面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> component=&#123;<span class="built_in">Error</span>&#125;/&gt; &#123;<span class="comment">/* Error 组件代表 404 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>由于其他的路由都匹配失败，最后会和 <code>/</code> 匹配，所以会显示 <code>Error</code> 组件，这里的 <code>Route</code> 的组件也必须放在最下面来 “兜底”。</p><h2 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h2><h3 id="实现二级路由"><a href="#实现二级路由" class="headerlink" title="实现二级路由"></a>实现二级路由</h3><p>在了解 <code>React Router</code> 的基本使用后，我们用同样的知识点来给 <code>User</code> 组件写一个二级路由，<code>User</code> 中有一个子导航，分别对应用户列表 <code>List</code> 组件和添加用户 <code>Add</code> 组件，代码的套路与之前相同。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="解决默认路径不匹配的问题"><a href="#解决默认路径不匹配的问题" class="headerlink" title="解决默认路径不匹配的问题"></a>解决默认路径不匹配的问题</h3><p>当通过 <code>React Router</code> 访问 <code>/user</code> 的时候，会先加载 <code>User</code> 组件，再加载 <code>User</code> 内部的组件包括子导航，但是 <code>/user</code> 的路径既没有和 <code>/user/add</code> 匹配，也没有和 <code>/user/list</code> 匹配，这样渲染了一个空的类名为 <code>sub-containe</code> 的 <code>div</code> 标签，我们应该让 <code>User</code> 组件加载时子路由默认可以匹配一个路由组件，解决方式如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— Redirect 组件重定向的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Redirect to="</span>/user/list<span class="string">"/&gt; &#123;/* 重定向到 List 组件 */&#125;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的方式是使用 <code>Redirect</code> 组件重定向的方式实现的，但是这样访问的 <code>/user</code>，路径会自动改变为 <code>/user/list</code>，感觉上有一些奇怪，当然还有另外的解决方式。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— Route 组件严格匹配</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser<span class="string">" exact component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的方式是当匹配到了 <code>/user</code> 的路由也加载默认要渲染的 <code>List</code> 组件实现的，但是为了防止向下继续匹配，可以添加 <code>exact</code> 设置严格匹配，进一步优化可以使用 <code>Switch</code> 组件，让路由成功匹配一次后不再向下匹配。</p><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>我们经常会遇到一个场景，就是在某些交互之后实现页面的自动跳转，而对于 <code>React</code> 搭建的单页面应用来说就是路由切换，在 <code>React</code> 中都最初是通过 <code>Link</code> 组件的点击手动实现的路由切换，那么怎么通过纯编程的方式在某些交互后自动切换路由呢，其实 <code>React Router</code> 的 <code>Route</code> 组件会给内部渲染的组件传递路由相关的三个参数 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>三个属性值均为对象，<code>history</code> 上存储了 <code>length</code> 属性代表当前支持存入历史记录的数量，也同样存储了 <code>location</code>，用来存储路由路径的相关信息，还有用来操作路由跳转的方法 <code>go</code>（传入数字代表前进或后退几页）、<code>goBack</code>（后退）、<code>goForward</code>（前进）、<code>replace</code>（用其他路由替换当前历史）、<code>push</code>，其中最常用的就是 <code>push</code> 方法，下面会着重介绍，<code>match</code> 中存储了一些路由匹配的相关信息，如 <code>url</code>，即浏览器输入的路径，真正匹配的路径 <code>path</code> 属性以及是代表否严格匹配的 <code>isExact</code> 属性，在 <code>match</code> 中最重要的是 <code>params</code> 属性，值为对象，用来存储路由参数，这个我们放在后面来说。</p><p>下面在 <code>Add</code> 组件中添加一输入框和按钮，当点击按钮是将输入框的数据存入 <code>localStorage</code> 中，并自动将路由跳转到 <code>/user/list</code>，即渲染 <code>List</code> 组件，然后将数据取出渲染到 <code>List</code> 组件中，这是一个很常见的需求，添加数据然后跳到详情页的场景，下面是 <code>Add</code> 组件中的实现。</p><figure class="highlight js"><figcaption><span>路径：&#126;react-router/src/pages/Add.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  input = React.createRef() <span class="comment">// 非受控组件取值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单提交事件</span></span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault(); <span class="comment">// 取消默认的页面跳转事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从 localStorage 获取已有数据</span></span><br><span class="line">    <span class="keyword">const</span> lists = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新数据</span></span><br><span class="line">    lists.push(&#123;</span><br><span class="line">      id: lists.length + <span class="number">1</span>,</span><br><span class="line">      username: <span class="keyword">this</span>.input.current.value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入 localStorage</span></span><br><span class="line">    localStorage.setItem(<span class="string">'lists'</span>, <span class="built_in">JSON</span>.stringify(lists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编程式导航，自动跳转到 List</span></span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/user/list'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;form className=<span class="string">"form"</span> onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">          &lt;label htmlFor=<span class="string">"username"</span> className=<span class="string">"control-label"</span>&gt;用户名&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input</span></span><br><span class="line"><span class="regexp">            className="form-control"</span></span><br><span class="line"><span class="regexp">            type="text"</span></span><br><span class="line"><span class="regexp">            id="username"</span></span><br><span class="line"><span class="regexp">            ref=&#123;this.input&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          &lt;br/&gt;</span><br><span class="line">          &lt;input type=<span class="string">"submit"</span> className=<span class="string">"btn btn-success"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们通过 <code>Route</code> 传递给渲染组件的 <code>history</code> 的 <code>push</code> 方法实现了路由的自动跳转，<code>push</code> 方法接收的参数就是将要跳转的路径字符串，<code>List</code> 组件代码如下。</p><figure class="highlight js"><figcaption><span>路径：&#126;react-router/src/pages/List.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">    <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                  &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;td&gt;&#123;username&#125;&lt;/</span>td&gt;</span><br><span class="line">                &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">              )</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tbody&gt;</span><br><span class="line">      &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>取出 <code>localStorage</code> 中的数据在 <code>List</code> 中渲染时有两点注意，第一是取出数据和设置状态应该在 <code>render</code> 渲染 <code>JSX</code> 之前，这样在没有执行 <code>render</code> 时会合并状态并只渲染一次，也就是说 <code>componentWillMount</code> “钩子” 和 <code>render</code> “钩子” 的 <code>return</code> 语句前更新状态都是可以的，如果在 <code>componentDidMount</code> “钩子” 中更新会导致组件渲染两次，在 <code>React</code> 开发中如果获取数据的过程是同步的（<code>localStorage</code> 取值是同步的），不需要渲染两次。</p><p>第二点是在使用表格元素 <code>table</code> 渲染时，必须要含有 <code>thead</code> 和 <code>tbody</code>，这是 <code>React</code> 规定的，不可以省略。</p><h2 id="路由参数的传递"><a href="#路由参数的传递" class="headerlink" title="路由参数的传递"></a>路由参数的传递</h2><p>现在在我们的 <code>List</code> 组件表格中，点击每一行都可以跳转到学生 <code>ID</code> 对应的详情 <code>Detail</code> 组件中，由于每一个学生的 <code>ID</code> 不同渲染的详情也不相同，此时需要将学生 <code>ID</code> 作为路由参数进行传递，并在 <code>Detail</code> 内渲染对应的内容，由于 <code>Detail</code> 组件的渲染与 <code>List</code> 组件是同一区域，所以仍然是二级路由，我们需要在 <code>User</code> 组件中进行添加。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— 增加 Detail 二级路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"><span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">'./Detail'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser<span class="string">" exact component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/detail/:id<span class="string">" component=&#123;Detail&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>React Router</code> 中，我们通过给路由后面添加 <code>/:paramname</code> 的方式添加参数，也可以通过 <code>/:paramname/:paramname</code> 传递多个参数（形参），由于在 <code>List</code> 中点击表格的的某行的单元格跳转路由，所以 <code>List</code> 组件修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">    <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                  &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                    &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;td&gt;&lt;Link to=&#123;`/u</span>ser/detail/$&#123;id&#125;<span class="string">`&#125;&gt;&#123;username&#125;&lt;/Link&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                  &lt;/tr&gt;</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">              &#125;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &lt;/tbody&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>List</code> 组件中，同样使用 <code>Link</code> 组件对要点击切换路由的节点进行包裹，并用 <code>to</code> 属性设置跳转的路由和路由参数（实参），现在点击就可以实现从 <code>List</code> 组件到 <code>Detail</code> 组件的切换，如果我们有些 <code>List</code> 的数据想在跳转到 <code>Detail</code> 组件时直接带过去，则可以使用另一种写法如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数和数据</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">      <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">      <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                  &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;td&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;Link to=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                      pathname: `/u</span>ser/detail/$&#123;id&#125;<span class="string">`,</span></span><br><span class="line"><span class="string">                      state: username</span></span><br><span class="line"><span class="string">                    &#125;&#125;&gt;&#123;username&#125;&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                  &lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;/tr&gt;</span></span><br><span class="line"><span class="string">              )</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &lt;/tbody&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>不同的是给 <code>to</code> 属性传入的值从一个代表路由的字符串变成了一个对象，而把路由的字符串作为了 <code>pathname</code> 属性的值，<code>state</code> 属性则代表了路由跳转传给渲染组件的数据，还记得渲染的组件使用 <code>Route</code> 组件包裹的，会传入 <code>history</code>、<code>loacltion</code> 和 <code>match</code> 三个属性，同样的，通过点击 <code>Link</code> 传递的路由参数和数据都可以在 <code>props</code> 上获取到，前者通过 <code>location.state</code> 或者 <code>history.location.state</code> 上获取到，后者可以通过 <code>match.params</code> 上获取到，那么 <code>Detail</code> 组件将传递过来的参数渲染，代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Detail.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Detail</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">user</span>: &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 有值说明是点击过来的，否则是地址栏输入的</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">this</span>.props.location.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由参数</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.match.params.id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是点击过来的直接将数据设置给 state，否则去 localStorage 取值设置给 state</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: &#123; id, <span class="attr">username</span>: data &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> user = users.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: &#123; id, <span class="attr">username</span>: user.username &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.user.id&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt; ------- &lt;/</span>span&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.user.username&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>这里有两点注意点，首先通过组件 <code>props.match.params</code> 获取的路由参数都是字符串格式，如果原本类型为数字，使用时应转换成数字类型，其次是传递的数据，也就是组件通过 <code>props.location.state</code> 获取的数据，只有在通过 <code>Link</code>组件点击过去才会存在，在地址栏输入为 <code>undefined</code>，所以防止用户刷新页面导致数据丢失，应该在两种情况下处理不同的获取数据的逻辑。</strong></em></p></blockquote><h2 id="withRouter-函数"><a href="#withRouter-函数" class="headerlink" title="withRouter 函数"></a>withRouter 函数</h2><p>在之前的编程式导航中我们使用了 <code>Route</code> 传递给渲染组件的 <code>props.history.push</code> 方法实现的，现在假设我们要对一个不是路由跳转的组件，通过点击事件来获取 <code>history</code>、<code>location</code> 和 <code>match</code> 属性，并使用 <code>history</code> 上的路由设置方法进行跳转路由，这应该如何实现呢？</p><p>其实 <code>React Route</code> 给我们提供了一个函数 <code>withRouter</code> 方法，在调用该方法时，则会返回一个新的组件，当然其实这是一个高阶组件的应用，<code>withRouter</code> 方法内部帮我们在传入的组件外层包装了一层 <code>Route</code> 组件，并传入了 <code>history</code>、<code>location</code> 和 <code>match</code> 属性作为参数，所以当我们使用返回的组件时可以通过 <code>props</code> 属性获取 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>下面针对我们之前的 <code>Index</code> 组件的内的 “管理系统” 的标签抽出一个新的组件，并将这个组件添加点击可以跳转到登录页 <code>Login</code> 组件的功能，<code>Login</code> 组件为一级路由，所以我们应该修改 <code>App</code> 组件，添加一个 <code>/login</code> 的路由，<code>Login</code> 和修改后的 <code>App</code> 组件如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Login 组件路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/Login'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;/&gt; &#123;<span class="comment">/* 添加登录页路由 */</span>&#125;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt; &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Login.js —— 添加登录和退出功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'login'</span>, <span class="string">'ok'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.removeItem(<span class="string">'login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>Login</code> 中顺便添加了两个按钮来模拟 “登录” 和 “退出”，并给按钮添加了事件，在登录时向 <code>localStorage</code> 中添加 <code>login</code> 属性，在退出时清除这个属性，以模拟登录状态。</p><p>抽取出 <code>Logo</code> 后的 <code>Index</code> 组件也应该添加一个新的导航为 “登录”，<code>Login</code> 组件和修改后的 <code>Index</code> 组件如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 抽出 Logo 组件并添加登录导航</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;Link to="/</span>home<span class="string">"&gt;首页&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/user<span class="string">"&gt;用户&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/profile<span class="string">"&gt;个人中心&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/login<span class="string">"&gt;登录&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Logo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  change = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"navbar-brand"</span> onClick=&#123;<span class="keyword">this</span>.change&#125;&gt;管理系统&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Logo);</span></span><br></pre></td></tr></table></figure><p>通过 <code>Logo</code> 案例的代码我们可以看出，其实最后导出的并不是 <code>Logo</code> 组件，而是使用 <code>withRouter</code> 函数包装后返回的高阶组件，<code>withRouter</code> 方法内部帮我们搞定了 <code>Logo</code> 组件的 <code>props</code> 没有 <code>history</code>、<code>location</code> 和 <code>match</code> 属性的问题。</p><h2 id="受保护的路由"><a href="#受保护的路由" class="headerlink" title="受保护的路由"></a>受保护的路由</h2><p>以前在点击个人中心时会直接渲染 <code>Profile</code> 组件，在给 <code>Login</code> 组件添加 “登录” 和 “退出” 之后，再次点击个人中心时，应该先对登录状态进行验证，如果 <code>localStorage</code> 中存在 <code>login</code> 属性，则渲染 <code>Profile</code> 的 <code>Route</code> 组件，否则重定向到登录页，如果在登录页点击登录后再重新跳回个人中心（从哪来回哪去）。</p><p>这就需要我对 <code>App</code> 组件路由部分的代码进行修改，使用高阶组件来添加登录验证逻辑，当然，这个高阶组件不是 <code>React Router</code> 提供的，需要我们自己来实现，这种做法被官方称作 “受保护的路由”。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加受保护的路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/Login'</span>;</span><br><span class="line"><span class="keyword">import</span> Protected <span class="keyword">from</span> <span class="string">'./pages/Protected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &#123;<span class="comment">/* 添加受保护的路由 */</span>&#125;</span><br><span class="line">            &lt;Protected path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;/&gt;</span><br><span class="line">            &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们重写了 <code>App</code> 组件中个人中心对应的路由，将原来的 <code>Route</code> 组件用高阶组件 <code>Protected</code> 代替，也就等于是将原本传入的参数 <code>path</code> 和 <code>component</code> 传入了高阶组件 <code>Protected</code>，下面来看一下高阶组件 <code>Protected</code> 的实现。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Protected.js —— 添加受保护的路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Protected</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> login = localStorage.getItem(<span class="string">'login'</span>);</span><br><span class="line">    <span class="keyword">return</span> login ?</span><br><span class="line">    &lt;Route &#123;...this.props&#125;/&gt; :</span><br><span class="line">    &lt;Redirect to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">'/login'</span>, <span class="attr">state</span>: &#123; <span class="string">'from'</span>: <span class="string">'/profile'</span> &#125;&#125;&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Protected</code> 获取登录状态，存在时直接渲染了 <code>Route</code> 组件，并将 <code>path</code> 和 <code>component</code> 参数传入，如果不存在则渲染 <code>Redirect</code> 组件重定向到登录页，传入的参数同 <code>Link</code> 组件的规则相同，<code>pathname</code> 代表重定向的路径，<code>state</code> 代表带过去的数据，我们这里添加了一个 <code>from</code> 属性，用来记录渲染登录页的来源，即个人中心。</p><p>接下来就是 <code>Login</code> 组件中在点击登录后验证是否存在 <code>state</code>，如果存在则返回存储的 <code>from</code> 对应的路由，即个人中心，不存在则跳回首页，<code>Login</code> 修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Login.js —— 完善登录功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'login'</span>, <span class="string">'ok'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一个路由传递的 state</span></span><br><span class="line">    <span class="keyword">const</span> prevPathDate = <span class="keyword">this</span>.props.location.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在 state 则返回来源对应的页面，否则回主页</span></span><br><span class="line">    <span class="keyword">if</span> (prevPathDate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(prevPathDate.from);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(<span class="string">'/home'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.removeItem(<span class="string">'login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样 “受保护的路由” 功能就实现了，其实就是在跳转路由之前起到了一个 “拦截” 的作用，经常的使用场景是权限管理，这是一个路由的应用，也是一个高阶组件的应用，这样的应用在大型复杂的 <code>React</code> 中会频繁使用，还是比较重要的。</p><h2 id="NavLink-组件"><a href="#NavLink-组件" class="headerlink" title="NavLink 组件"></a>NavLink 组件</h2><p>在实际项目开发中，我们经常遇到导航标签被选中时被添加一个代表 “激活” 的类名，用于添加与其他导航选项不同的样式，<code>React Router</code> 已经给我们提供了 <code>NavLink</code> 组件用于实现这个功能，<code>NavLink</code> 组件具备 <code>Link</code> 组件所有的功能，唯一不同的就是 <code>NavLink</code> 组件在被选中时不止发生路由跳转，还会给渲染后的 <code>a</code> 标签添加一个名为 <code>active</code> 的 <code>class</code> 属性，而我们只需要通过 <code>css</code> 去给类名 <code>active</code> 设置样式即可。</p><figure class="highlight css"><figcaption><span>路径：&#126;react-router/src/index.css —— 激活样式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好激活样式以后，我们只需要在 <code>Index</code> 组件中引入激活样式的 <code>css</code> 文件并将 <code>Link</code> 组件替换成 <code>NavLink</code> 组件即可。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入激活样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;NavLink to="/</span>home<span class="string">"&gt;首页&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/user<span class="string">"&gt;用户&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/profile<span class="string">"&gt;个人中心&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/login<span class="string">"&gt;登录&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="自定义导航组件实现激活"><a href="#自定义导航组件实现激活" class="headerlink" title="自定义导航组件实现激活"></a>自定义导航组件实现激活</h2><p><code>React Router</code> 在给我们提供的导航组件 <code>NavLink</code> 功能有限，只会给内部的 <code>a</code> 标签在选中时添加 <code>active</code> 类名，如果我们想实现给一个 <code>li</code> 标签添加 <code>active</code> 就需要我们自己封装一个组件来实现这个功能，其实还是通过高阶组件来实现的，首先我们定义这个高阶组件的名字为 <code>MenuLink</code>，将 <code>Index</code> 组件中的 <code>li</code> 标签和 <code>NavLink</code> 组件统一替换成 <code>MenuLink</code> 组件，代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"><span class="keyword">import</span> MenuLink <span class="keyword">from</span> <span class="string">'./MenuLink'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;MenuLink to="/</span>home<span class="string">"&gt;首页&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/user<span class="string">"&gt;用户&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/profile<span class="string">"&gt;个人中心&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/login<span class="string">"&gt;登录&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在实现 <code>MenuLink</code> 组件之前我们分析一下实现思路，首先我们依然模拟 <code>NavLink</code> 的方式给 <code>MenuLink</code> 传入了 <code>to</code> 属性，值为将要跳转的路由，所以我们应该在 <code>MenuLink</code> 组件中来接收这个路由，而 <code>MenuLink</code> 内部一定是包含 <code>li</code> 和 <code>Link</code> 组件的，我们可以将这个 <code>to</code> 属性传递给 <code>Link</code> 组件，如果想要通过激活状态给外层的 <code>li</code> 标签设置状态我们需要知道是否匹配了路由，并可以通过 <code>match</code> 属性获得，所以在 <code>li</code> 的外层应该有 <code>Route</code> 组件配合，因为只有 <code>Route</code> 组件才会将 <code>history</code>、<code>location</code> 和 <code>match</code> 作为参数传递给其内部渲染的组件。</p><p>这就要说到 <code>Route</code> 组件的渲染模式，在传入 <code>component</code> 属性时，只有匹配组件才会渲染内部组件，我们显然是需要时时刻刻都渲染内部的 <code>li</code> 和 <code>Link</code>，并通过点击 <code>Link</code> 渲染真正的路由组件，所以我们需要用到第二种渲染方式，就是通过 <code>children</code> 属性指定时刻需要渲染的组件，实现代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/MenuLink.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Route path=&#123;<span class="keyword">this</span>.props.to&#125; children=&#123;(&#123; match &#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;li className=&#123;match ? <span class="string">'active'</span> : <span class="string">''</span>&#125;&gt;</span><br><span class="line">            &lt;Link to=&#123;<span class="keyword">this</span>.props.to&#125;&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中由于 <code>children</code> 组件并不需要操作状态和使用生命周期 “钩子”，所以我们直接使用了函数组件实现，因为 <code>active</code> 类名添加给了 <code>li</code>，所以我们需要在 <code>MenuLink</code> 组件中引入样式文件 <code>index.css</code> 并将修改，代码如下。</p><figure class="highlight css"><figcaption><span>路径：&#126;react-router/src/index.css —— 激活样式修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-class">.active</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>本篇通过一个简单的案例使用了由 <code>React Router</code> 所提供的，开发中常用的功能，但美中不足的是并没有使用一些 <code>UI</code> 库或者 <code>CSS</code> 样式来美化，为了更明显的看到 <code>React Router</code> 各个功能使用后的效果，建议大家在实现上面代码的同时自己添加一些 <code>CSS</code> 样式。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/21/20180921182754/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— 组件间的参数传递</title>
      <link>https://www.overtaking.top/2018/09/19/20180919002629/</link>
      <guid>https://www.overtaking.top/2018/09/19/20180919002629/</guid>
      <pubDate>Tue, 18 Sep 2018 16:26:29 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/19/20180919002629/react-props-transmit.png&quot; title=&quot;React 组件间参数传递&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;单向数据流&quot;&gt;&lt;a href=&quot;#单向数据流&quot; class=&quot;headerlink&quot; title=&quot;单向数据流&quot;&gt;&lt;/a&gt;单向数据流&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;每一个可以组件化开发的前端框架如 &lt;code&gt;React&lt;/code&gt;、&lt;code&gt;Vue&lt;/code&gt;，组件间的参数传递都是一定会谈论的话题，而 &lt;code&gt;React&lt;/code&gt; 中数据传递是单向的，也被称为单向数据流，即数据只能从父组件传递到子组件，而子组件只需要通过 &lt;code&gt;props&lt;/code&gt; 属性渲染即可，如果顶层组件的某个属性的值改变了，&lt;code&gt;React&lt;/code&gt; 将由外向内遍历整个组件树，将使用了该属性的组件重新渲染。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/19/20180919002629/react-props-transmit.png" title="React 组件间参数传递"><p><br></p><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><blockquote class="pullquote default"><p>每一个可以组件化开发的前端框架如 <code>React</code>、<code>Vue</code>，组件间的参数传递都是一定会谈论的话题，而 <code>React</code> 中数据传递是单向的，也被称为单向数据流，即数据只能从父组件传递到子组件，而子组件只需要通过 <code>props</code> 属性渲染即可，如果顶层组件的某个属性的值改变了，<code>React</code> 将由外向内遍历整个组件树，将使用了该属性的组件重新渲染。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先使用 <code>create-react-app</code> 脚手架创建 <code>React</code> 项目，项目生成后删除 <code>src</code> 文件目录下的多余文件，留下 <code>index.js</code>，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app transfer-props</span><br></pre></td></tr></table></figure><p><strong>该项目最后的目录结构如下：</strong></p><p><pre>transfer-props<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- src<br>  | |- components<br>  | | |- App.js<br>  | | |- Child.js<br>  | | |- Parent.js<br>  | |- context.js<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><h2 id="父组件传参给子组件"><a href="#父组件传参给子组件" class="headerlink" title="父组件传参给子组件"></a>父组件传参给子组件</h2><p>创建一个最外层组件 <code>App</code>，并在 <code>index.js</code> 中进行渲染。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>App</code> 组件内部状态中含有 <code>users</code> 属性，值为数组，含有 <code>title</code> 属性，现在要将这两个参数传递给 <code>Parent</code> 组件，传参方式如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Parent</code> 组件中接收到参数，要根据参数中数组的数量来渲染下一个子组件 <code>Child</code>，<code>Child</code> 组件中需要使用父组件 <code>users</code> 数组的学生 <code>id</code>，传参如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; users, title &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">            users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              return (</span></span><br><span class="line"><span class="regexp">                &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 <code>Child</code> 组件，用来渲染学生的基本信息，在 <code>Parent</code> 中我们已经将参数传递，最后看看在 <code>Child</code> 中的接收。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Child.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id, name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;span&gt;&#123;id&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;&#123;name&#125;&lt;/</span>span&gt;</span><br><span class="line">        &lt;span&gt;&#123;age&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>注意：子组件接收父组件的 <code>props</code> 属性是只读的，不可以修改，修改会报错。</strong></em></p></blockquote><p>其实在这个过程中参数经历了三个组件，都是由父组件传向子组件，可以看出 <code>React</code> 单向数据流的特点，但是子组件是不可以通过某些操作直接修改父组件的数据的，下面来看看子组件如何修改父组件的数据。</p><h2 id="子组件修改父组件的数据"><a href="#子组件修改父组件的数据" class="headerlink" title="子组件修改父组件的数据"></a>子组件修改父组件的数据</h2><p>在 <code>React</code> 中如果要修改父组件的参数，可以给子组件传入一个修改父组件参数的函数，然后在子组件中执行这个函数，就可以实现父组件数据的更新。</p><p>我们创建一个与 <code>Parent</code> 组件平行的 <code>Input</code> 组件，两个组件都是 <code>App</code> 的直接子组件，在 <code>Input</code> 组件内通过某些操作给父组件的状态中的 <code>users</code> 属性新增一条数据。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">    <span class="keyword">this</span>.props.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 <code>Input</code> 组件，在修改时没有直接使用按钮的点击事件，而是添加了 <code>form</code> 标签并使用 <code>submit</code> 事件，是因为可以使用 <code>H5</code> 的自带的校验功能，但是使用 <code>form</code> 会自动提交页面，所以在执行 <code>submit</code> 事件时应取消默认事件，然后调用父组件传来的方法 <code>addStudent</code>，并传入输入框获取的值（非受控组件的取值方式），父组件 <code>App</code> 修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 push 添加</span></span><br><span class="line">    <span class="comment">// this.state.users.push(&#123; id: this.state.users.length + 1, ...val &#125;);</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">        &lt;Input addStudent=&#123;<span class="keyword">this</span>.addStudent&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>首先父组件 <code>App</code> 应该创建 <code>addStudent</code> 方法作为参数传递给子组件 <code>Input</code>，而在 <code>addStudent</code> 方法内部通过 <code>push</code> 和 <code>setState</code> 两种方式进行添加，发现都可以更新状态和视图，区别是 <code>push</code> 操作的原来的引用，而 <code>setState</code> 创建了新的引用空间。</p><blockquote class="pullquote info"><p><em><strong>注意：在 <code>React</code> 所有状态的更改都不建议操作原来的引用，通常做法都是通过 <code>setState</code> 返回一个新的 <code>state</code>（创建新的引用），使用解构赋值的方式来保留原始数据，用新数据覆盖旧数据，原因是在 <code>React</code> 类组件种有一个 <code>PureComponent</code> 纯组件类型，对 <code>shouldComponentUpdate</code> 生命周期 “钩子” 做了优化，使用了 <code>props</code> 和 <code>state</code> 的浅比较，所以在纯组件类型操作原来的引用是无法更新视图的。</strong></em></p></blockquote><h2 id="context-实现跨组件传参"><a href="#context-实现跨组件传参" class="headerlink" title="context 实现跨组件传参"></a>context 实现跨组件传参</h2><p>在上面的案例当中，父子组件关系的层级是三层，无论是普通的数据还是修改父组件的事件都是作为参数一级一级往下传的，如果组件的层级多了，当跨组件传参时是非常不方便的（通常三级还可以接受）。</p><p>跨组件传参是指父级组件与非直接子组件的传参、同级组件之间的传参，同级之间可以找到相同的父级，没有相同的父级就创造相同的父级，最后将问题统一到了父级组件与非直接子组件的传参传递。</p><p>在 <code>React</code> 中给我们提供了 <code>context</code> API 用来实现组件树数据的共享，分为新旧两个版本，这里旧版和新版的 API 都会介绍。</p><h3 id="旧版-context"><a href="#旧版-context" class="headerlink" title="旧版 context"></a>旧版 context</h3><p>在旧版的 <code>context</code> 需要配合属性类型检测的 <code>prop-types</code> 模块共同使用，需要在共同的父组件上定义一个方法 <code>getChildContext</code>，返回值为一个对象，对象中存储的是当前要传递给其他子组件的数据，同时还有一个静态属性 <code>childContextTypes</code>，值为一个对象，属性的值与 <code>getChildContext</code> 方法内返回的对象的属性一一对应，并用 <code>prop-types</code> 模块对每一个传递给子组件属性的数据类型进行定义，在使用父组件传递属性的子组件中需要定义静态属性 <code>contextTypes</code> 对所使用的属性的数据类型进行校验，需要父组件与 <code>childContextTypes</code> 内的定义一致，然后可以通过子组件实例的 <code>context</code> 属性获取，我们可以使用 <code>context</code> 将上面的案例修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>; <span class="comment">// 引入参数类型检测模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义参数类型</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    state: PropTypes.object,</span><br><span class="line">    addStudent: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上下文对象传给子组件的参数</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state: <span class="keyword">this</span>.state,</span><br><span class="line">      addStudent: <span class="keyword">this</span>.addStudent</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 不再需要传参 */</span>&#125;</span><br><span class="line">        &lt;Parent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">        &lt;Input&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面只是将 <code>APP</code> 组件中原本传给子组件的参数去掉，按照要求添加了 <code>getChildContext</code> 方法和 <code>childContextTypes</code> 静态属性。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型检测与父组件定义的类型对应</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    addStudent: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上下文对象上获取父组件的方法并执行</span></span><br><span class="line">    <span class="keyword">this</span>.context.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Input</code> 组件中定义 <code>contextTypes</code> 属性，将 <code>addStudent</code> 方法从原来的 <code>props</code> 获取改为了从 <code>context</code> 上获取。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类型检测与父组件定义的类型对应</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    state: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 从 context 对象上获取 state 并解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; users, title &#125; = <span class="keyword">this</span>.context.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">            users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              return (</span></span><br><span class="line"><span class="regexp">                &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Parent</code> 组件中同样定义 <code>contextTypes</code> 属性，将 <code>state</code> 属性从原来的 <code>props</code> 获取改为了从 <code>context</code> 上获取。</p><h3 id="新版-context"><a href="#新版-context" class="headerlink" title="新版 context"></a>新版 context</h3><p>新版 <code>context</code> 其实是 <code>React</code> 对象提供给我们的方法 <code>createContext</code> 实现的，方法在调用时返回一个对象，对象上有两个组件分别为 <code>Provider</code>（提供者）和 <code>Consumer</code>（消费者），由于两个配合使用的组件必须有同一次调用 <code>createContext</code> 时创建，所以我们单独创建文件 <code>context.js</code> 代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/context.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到处上下文对象的组件</span></span><br><span class="line"><span class="keyword">export</span> &#123; Provider, Consumer &#125;;</span><br></pre></td></tr></table></figure><p>还是之前的案例，我们可以使用新版 <code>context</code> 修改如下。</p><figure class="highlight js"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'../context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;&#123;</span><br><span class="line">        addStudent: <span class="keyword">this</span>.addStudent,</span><br><span class="line">        state: <span class="keyword">this</span>.state</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">          &lt;Input addStudent=&#123;<span class="keyword">this</span>.addStudent&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供参数的父组件 <code>App</code> 应该使用 <code>Provider</code> 进行包裹，将传入的参数以 <code>value</code> 为参数名（规定），传入 <code>context</code> 对象中。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">'../context.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">    <span class="keyword">this</span>.props.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (&#123; addStudent &#125;) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;form onSubmit=&#123;e =&gt; &#123;</span><br><span class="line">                <span class="comment">// 取消默认事件</span></span><br><span class="line">                e.preventDefault();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">                addStudent(&#123;</span><br><span class="line">                  name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">                  age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;&#125;&gt;</span><br><span class="line">                姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>form&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在使用 “提供者” 提供数据的 “消费者” 子组件中，应该引入与 <code>Provider</code> 对应的 <code>Consumer</code> 组件，用 <code>Consumer</code> 组件替换原本组件返回的 <code>JSX</code>，内部传入一个函数，函数的形参即为 <code>context</code> 对象，函数内部返回值为原本子组件返回的 <code>JSX</code>，子组件使用父组件的属性可直接从函数的形参获取或解构。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">'../context.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (&#123; users, title &#125;) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                  &#123;</span></span><br><span class="line"><span class="regexp">                    /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">                    users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                      return (</span></span><br><span class="line"><span class="regexp">                        &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">                      )</span><br><span class="line">                    &#125;)</span><br><span class="line">                  &#125;</span><br><span class="line">                &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>div&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Parent</code> 作为 <code>App</code> 的子组件，修改的方式同 <code>Input</code> 组件相同，如上面代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>关于 <code>React</code> 组件之间传参的各中放式上面基本介绍完了，但是这些传参方式并不能满足于所有的需求，如果是两个毫不相关的组件并且距离共同的父组件层级比较远，即使使用 <code>context</code> 的方式也会显得有些无力，组件间互相传参的需求比较多代码也会冗余和繁琐，因此就有了 <code>Redux</code>、<code>Mobx</code> 等数据状态管理工具，可以将各个组件的状态数据统一管理，各个组件的之间的参数都更容易获取，关于数据状态管理相关的内容我也会在后面的博客中继续更新，敬请期待吧 ^ ^。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/19/20180919002629/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— 生命周期详解</title>
      <link>https://www.overtaking.top/2018/09/15/20180915194439/</link>
      <guid>https://www.overtaking.top/2018/09/15/20180915194439/</guid>
      <pubDate>Sat, 15 Sep 2018 11:44:39 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/15/20180915194439/react-life-cycle.png&quot; title=&quot;React 生命周期&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;本篇文章主要内容针对 &lt;code&gt;React&lt;/code&gt; 类组件的生命周期展开，会详细介绍生命周期 “钩子” 的执行和用法，如果一点也不了解 &lt;code&gt;React&lt;/code&gt; 的同学建议先学习一下 &lt;code&gt;React&lt;/code&gt; 比较基础的内容，当然也可以看我的文章 &lt;a href=&quot;https://www.overtaking.top/2018/09/10/20180910025959/&quot; target=&quot;_blank&quot;&gt;React 基础篇 —— 带你走进 React 世界&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/15/20180915194439/react-life-cycle.png" title="React 生命周期"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>本篇文章主要内容针对 <code>React</code> 类组件的生命周期展开，会详细介绍生命周期 “钩子” 的执行和用法，如果一点也不了解 <code>React</code> 的同学建议先学习一下 <code>React</code> 比较基础的内容，当然也可以看我的文章 <a href="https://www.overtaking.top/2018/09/10/20180910025959/" target="_blank">React 基础篇 —— 带你走进 React 世界</a>。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先使用 <code>create-react-app</code> 脚手架创建一个 <code>React</code> 项目，脚手架工具的安装和项目创建命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app life-cycle</span><br></pre></td></tr></table></figure><p>创建项目后删除 <code>src</code> 目录中的无用文件，只留下 <code>index.js</code> 入口文件即可。</p><h2 id="类组件的生命周期"><a href="#类组件的生命周期" class="headerlink" title="类组件的生命周期"></a>类组件的生命周期</h2><h3 id="静态属性-defaultProps"><a href="#静态属性-defaultProps" class="headerlink" title="静态属性 defaultProps"></a>静态属性 defaultProps</h3><p><code>defaultProps</code> 是用来给 <code>React</code> 类组件设置参数初始值的，也是最早执行的，算不算生命周期说法不一，但是觉得有必要说一下，因为在 <code>React 15.x</code> 版本的时候可以用 <code>React.createClass</code> 创建类组件，组件中有与 <code>defaultProps</code> 静态属性作用相同的生命周期 “钩子” <code>getDefaultProps</code>，随着 <code>React 16.x</code> 版本废弃了 <code>React.createClass</code>，也就使用 <code>defaultProps</code> 属性替代了 <code>getDefaultProps</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>启动项目后，发现页面上成功的渲染了节点中的数字，这说明设置初始值生效了。</p><h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p><code>constructor</code> 是 <code>ES6</code> 中类的写法中给实例设置属性的钩子，在类的实例被创建时执行，下面是对比 <code>defaultProps</code> 静态属性执行顺序的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(props.number); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>从上面案例中可以看到当执行 <code>constructor</code> 时，<code>props</code> 对象中的 <code>num</code> 属性已经有值了，这也充分说明了说明 <code>constructor</code> 是晚于 <code>defaultProps</code> 执行的。</p><h3 id="状态对象-state"><a href="#状态对象-state" class="headerlink" title="状态对象 state"></a>状态对象 state</h3><p>在 <code>React</code> 中，每一个类组件都有一个属于自己的状态，可以使用 <code>setState</code> 方法更新状态，在 <code>React 15.x</code> 中，通过 <code>React.createClass</code> 创建类组件，使用对应的生命周期 “钩子” <code>getInitialState</code> 来创建，同样的，<code>React 16.x</code> 废弃了 <code>React.createClass</code>，创建 <code>state</code> 的过程自然由新的方式代替。</p><p>创建 <code>state</code> 的方式大概有两种，分别是在 <code>constructor</code> 中创建或者直接创建 <code>state</code> 属性，代码如下。</p><figure class="highlight jsx"><figcaption><span>第一种创建 state 的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 state 方式 2</span></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>第二种创建 state 的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.num); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 state</span></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>从上面可以看出直接创建 <code>state</code> 属性的方式与创建静态属性 <code>defaultProps</code> 类似，执行要早于 <code>constructor</code>。</p><h3 id="componentWillMount-钩子"><a href="#componentWillMount-钩子" class="headerlink" title="componentWillMount 钩子"></a>componentWillMount 钩子</h3><p><code>componentWillMount</code> 生命周期 “钩子” 在组件将要挂载时执行，也就是说在组件挂载前会调用 <code>componentWillMount</code>，整个组件的生命周期中只执行一次，一般用于发送当前组件需要的 <code>Ajax</code> 请求获取数据。</p><p>在 <code>React 16.3</code> 版本中标识了该 “钩子” 会被在未来版本中废弃，目前仍然可以使用，在 <code>componentWillMount</code> 的可以迁移到 <code>constructor</code>，但不能包含 <code>setState</code> 操作，因为 <code>constructor</code> 中无法调用 <code>setState</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="number">3</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br></pre></td></tr></table></figure><p>从上面的打印结果可以看出 <code>componentWillMount</code> “钩子” 的执行是晚于 <code>constructor</code> 的，从页面渲染 <code>3</code> 的结果来看，在 <code>componentWillMount</code> “钩子” 中已经可以使用 <code>setState</code> 更改状态了。</p><h3 id="render-钩子"><a href="#render-钩子" class="headerlink" title="render 钩子"></a>render 钩子</h3><p><code>render</code> 钩子的主要作用是返回组件内部要被渲染的 <code>JSX</code>，即所谓的挂载过程，将上面例子简单修改一下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br></pre></td></tr></table></figure><p>从打印结果可以看出 <code>constructor</code> 最先执行，其次是 <code>componentWillMount</code>，最后是 <code>render</code>，由于状态或属性的更新可能导致组件重新渲染，所以 <code>render</code> 可能会被执行多次。</p><h3 id="componentDidMount-钩子"><a href="#componentDidMount-钩子" class="headerlink" title="componentDidMount 钩子"></a>componentDidMount 钩子</h3><p><code>componentDidMount</code> 生命周期 “钩子” 在组件挂载后执行，一般会将一些依赖于 <code>DOM</code> 的操作放在该 “钩子” 内执行，整个生命周期只执行一次。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br></pre></td></tr></table></figure><p>执行顺序：<code>constructor</code> → <code>componentWillMount</code> → <code>render</code> → <code>componentDidMount</code>。</p><h3 id="componentWillUpdate-钩子"><a href="#componentWillUpdate-钩子" class="headerlink" title="componentWillUpdate 钩子"></a>componentWillUpdate 钩子</h3><p>在调用 <code>setState</code> 更新数据后会触发 <code>render</code> 钩子对组件重新渲染，在执行 <code>render</code> 前会调用 <code>componentWillUpdate</code> 钩子，即将要更新时执行（此时状态和页面都没更新），钩子默认有三个参数，分别为 <code>nextProps</code>、<code>nextState</code> 和 <code>nextContext</code>，即更新后的属性对象、状态对象和上下文对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextContext'</span>, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// nextContext &#123;&#125;</span></span><br><span class="line"><span class="comment">// render</span></span><br></pre></td></tr></table></figure><p>从执行点击事件后的结果来看，在重新渲染之前 <code>componentWillUpdate</code> 早于 <code>render</code> 执行，而在 <code>componentWillUpdate</code> 执行时 <code>state</code> 的状态还未更新。</p><h3 id="componentDidUpdate-钩子"><a href="#componentDidUpdate-钩子" class="headerlink" title="componentDidUpdate 钩子"></a>componentDidUpdate 钩子</h3><p>在调用 <code>setState</code> 更新数据后执行 <code>render</code> 钩子对组件重新渲染，渲染后会立即调用 <code>componentDidUpdate</code> 钩子，此时 <code>state</code> 状态和页面都已经更新，钩子默认有三个参数，分别为 <code>prevProps</code>、<code>prevState</code> 和 <code>prevContext</code>，即更新前的属性对象、状态对象和上下文对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevProps'</span>, prevProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevState'</span>, prevState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevContext'</span>, prevContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// prevProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// prevState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// prevContext &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>触发点击事件后的执行顺序为：<code>componentWillUpdate</code> → <code>render</code> → <code>componentDidUpdate</code>。</p><h3 id="shouldComponentUpdate-钩子"><a href="#shouldComponentUpdate-钩子" class="headerlink" title="shouldComponentUpdate 钩子"></a>shouldComponentUpdate 钩子</h3><p>在使用 <code>setState</code> 更改状态时，其实还会默默的执行 <code>shouldComponentUpdate</code> “钩子”，该钩子有返回值，不使用该 “钩子” 的情况下默认返回值为 <code>true</code>，若使用该 “钩子” 必须指定布尔类型的返回值 <code>true</code> 或 <code>false</code>，当返回值为 <code>true</code> 时代表更新状态和视图，否则不更新，只要使用 <code>setState</code> 就会触发该 “钩子”，该钩子有三个参数，与 <code>componentWillUpdate</code> “钩子” 相同。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextContext'</span>, nextContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// nextContext &#123;&#125;</span></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br></pre></td></tr></table></figure><p>当 <code>shouldComponentUpdate</code> “钩子” 返回值为 <code>true</code> 时，触发点击事件后的执行顺序为：<code>shouldComponentUpdate</code> → <code>componentWillUpdate</code> → <code>render</code> → <code>shouldComponentUpdate</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125; 不断更新</span></span><br></pre></td></tr></table></figure><p>当 <code>shouldComponentUpdate</code> “钩子” 返回值为 <code>false</code> 时，触发点击事件后只有 <code>shouldComponentUpdate</code> 执行了，并且随着触发点击事件的次数增加，<code>nextState</code> 参数的状态不断变化，但是 <code>state</code> 和页面都不更新。</p><h3 id="componentWillUnmount-钩子"><a href="#componentWillUnmount-钩子" class="headerlink" title="componentWillUnmount 钩子"></a>componentWillUnmount 钩子</h3><p><code>componentWillUnmount</code> “钩子” 会在组件卸载之前触发，卸载组件需调用 <code>ReactDOM</code> 的 <code>unmountComponentAtNode</code> 方法，并传入一个根节点，将会卸载这个根节点内部的所有组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 卸载组件</span></span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Kill&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUnmount</span></span><br></pre></td></tr></table></figure><p><code>componentWillUnmount</code> 钩子一般用来在卸载组件之前清除可能会调用 <code>setState</code> 的异步操作，为了防止在卸载组件后继续更新状态而报错。</p><h2 id="复合组件的生命周期"><a href="#复合组件的生命周期" class="headerlink" title="复合组件的生命周期"></a>复合组件的生命周期</h2><blockquote class="pullquote info"><p>上面着重介绍了单个类组件的生命周期，有的生命周期由于一个组件不容易演示，所以放在了这节中，这节也会将复合组件的生命周期执行顺序进行分析，并阐明一些使用的注意事项。</p></blockquote><h3 id="复合组件渲染生命周期的执行顺序"><a href="#复合组件渲染生命周期的执行顺序" class="headerlink" title="复合组件渲染生命周期的执行顺序"></a>复合组件渲染生命周期的执行顺序</h3><p>在复合组件中，父组件套着子组件，两个组件都有自己的生命周期，那么执行顺序会是怎么样的，看下面案例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-componentWillMount</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillMount</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-componentDidMount</span></span><br><span class="line"><span class="comment">// parent-componentDidMount</span></span><br></pre></td></tr></table></figure><p>从上面的执行顺序可以看出，在执行父组件生命周期的时候，执行 <code>render</code> 会渲染子组件，渲染子组件会将子组件的生命周期优先执行，等子组件完成渲染继续父组件的渲染，即继续执行父组件渲染后的生命周期。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num - <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-child&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击子组件更新按钮</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// clild-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击父组件更新按钮</span></span><br><span class="line"><span class="comment">// parent-componentWillUpdate</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// clild-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// parent-componentDidUpdate</span></span><br></pre></td></tr></table></figure><p>当子组件更新时，父组件不会重新渲染，只会执行子组件的生命周期，当父组件更新时，子组件也会重新渲染，此时当父组件执行 <code>render</code> 时会执行子组件更新相关的生命周期，在继续执行父组件更新相关的生命周期。</p><p>点击父组件更新按钮生命周期的执行顺序：<code>parent-componentWillUpdate</code> → <code>parent-render</code> → <code>child-componentWillUpdate</code> → <code>clild-render</code> → <code>child-componentDidUpdate</code> → <code>parent-componentDidUpdate</code>。</p><p>点击子组件更新按钮生命周期的执行顺序：<code>child-componentWillUpdate</code> → <code>clild-render</code> → <code>child-componentDidUpdate</code>。</p><blockquote class="pullquote warning"><p><em><strong>注意：如果更新父组件时，不希望子组件重新渲染，可以通过子组件的 <code>shouldComponentUpdate</code> “钩子” 将返回值设置为 <code>false</code> 的方式来控制。</strong></em></p></blockquote><h3 id="componentWillReceiveProps-钩子"><a href="#componentWillReceiveProps-钩子" class="headerlink" title="componentWillReceiveProps 钩子"></a>componentWillReceiveProps 钩子</h3><p>当传入组件的参数，即 <code>props</code> 发生变化时，<code>componentWillReceiveProps</code> “钩子” 执行，该钩子有一个参数，代表下一次更新的 <code>props</code> 对象，执行该 “钩子” 时，<code>props</code> 并没有更新，也就是说是在 <code>props</code> 变化之前执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillReceiveProps'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowProps, '</span><span class="keyword">this</span>.props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter n=&#123;<span class="keyword">this</span>.state.num&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-componentWillUpdate</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillReceiveProps</span></span><br><span class="line"><span class="comment">// nowProps &#123; n: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123; n: 1 &#125;</span></span><br><span class="line"><span class="comment">// child-shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// parent-componentDidUpdate</span></span><br></pre></td></tr></table></figure><p>点击父组件更新按钮后，父子组件生命周期的执行顺序如下：</p><p><code>parent-componentWillUpdate</code> → <code>parent-render</code> → <code>child-componentWillReceiveProps</code> → <code>child-shouldComponentUpdate</code> → <code>child-componentWillUpdate</code> → <code>child-render</code> → <code>child-componentDidUpdate</code> → <code>parent-componentDidUpdate</code>。</p><p>由此可以说明 <code>componentWillReceiveProps</code> 钩子在 <code>shouldComponentUpdate</code> 之前执行。</p><blockquote class="pullquote default"><p><em><strong>注意：<code>componentWillReceiveProps</code> “钩子” 在第一次渲染父子组件时不执行，在 <code>React 16.x</code> 版本中被标记为 “已废弃”。</strong></em></p></blockquote><h2 id="关于-setState-在生命周期中的使用"><a href="#关于-setState-在生命周期中的使用" class="headerlink" title="关于 setState 在生命周期中的使用"></a>关于 setState 在生命周期中的使用</h2><p>在 <code>React</code> 生命周期 “钩子” 中，只有 <code>componentWillMount</code>、<code>componentDidMount</code> 和 <code>componentWillReceiveProps</code> 中可以调用 <code>setState</code>。</p><p>原因是 <code>setState</code> 方法会触发 <code>render</code> “钩子” 执行，而 <code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>componentDidUpdate</code> 是在 <code>render</code> 后触发，包括在 <code>render</code> 中调用 <code>setState</code>，都会出现更新 “死循环” 的现象，最后造成堆栈溢出，而 <code>componentWillUnmount</code> “钩子” 执行时，组件将被卸载，在此时更新状态毫无意义。</p><blockquote class="pullquote warning"><p><em><strong>注意：在 <code>componentWillReceiveProps</code> 中使用 <code>setState</code>，其目的是为了将新更改的属性更新为该组件的状态，但 <code>React</code> 官方不建议这样使用。</strong></em></p></blockquote><h2 id="React-生命周期流程图"><a href="#React-生命周期流程图" class="headerlink" title="React 生命周期流程图"></a>React 生命周期流程图</h2><p>下面是一张关于目前版本比较常用的 <code>React</code> 生命周期 “钩子” 执行顺序的流程图，帮助大家快速理解 <code>React</code> 生命周期中各个钩子函数的执行过程。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/15/20180915194439/react-lifecycle-raw.png" alt="React 生命周期流程图" title>                </div>                <div class="image-caption">React 生命周期流程图</div>            </figure><p><br></p><h2 id="React-16-3-新增生命周期"><a href="#React-16-3-新增生命周期" class="headerlink" title="React 16.3 新增生命周期"></a>React 16.3 新增生命周期</h2><h3 id="getDerivedStateFromProps-静态方法"><a href="#getDerivedStateFromProps-静态方法" class="headerlink" title="getDerivedStateFromProps 静态方法"></a>getDerivedStateFromProps 静态方法</h3><p><code>getDerivedStateFromProps</code> 是一个类组件的静态方法，用来替代 <code>componentWillReceiveProps</code> “钩子”，在传入的属性变化之前执行，方法的参数与 <code>componentWillReceiveProps</code> 相同，是更新的属性对象，该方法要求必须返回一个状态对象的返回值，且使用该方法的组件必须含有 <code>state</code>，不能和 <code>componentWillMount</code> “钩子” 同时使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-getDerivedStateFromProps'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: nextProps.n &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter n=&#123;<span class="keyword">this</span>.state.num&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-getDerivedStateFromProps</span></span><br><span class="line"><span class="comment">// nextProps &#123; n: 1 &#125;</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>点击父组件的更新按钮钩子的执行顺序如下：<code>parent-render</code> → <code>child-render</code> → <code>child-getDerivedStateFromProps</code> → <code>child-componentDidUpdate</code>。</p><blockquote class="pullquote primary"><p><em><strong>注意：<code>getDerivedStateFromProps</code> 除了上面叙述的用法的注意事项，与 <code>componentWillReceiveProps</code> 相比还有两个优势，第一点是默认第一次渲染时也会执行该方法，第二点是不需要在通过调用 <code>setState</code> 将新的 <code>props</code> 转换成组件的状态，可以直接通过方法的返回值设置状态。</strong></em></p></blockquote><h3 id="getSnapshotBeforeUpdate-钩子"><a href="#getSnapshotBeforeUpdate-钩子" class="headerlink" title="getSnapshotBeforeUpdate 钩子"></a>getSnapshotBeforeUpdate 钩子</h3><p><code>getSnapshotBeforeUpdate</code> “钩子” 用于替代 <code>componentWillUpdate</code> “钩子”，不能与 <code>componentWillMount</code> “钩子” 同时使用，必须与 <code>componentDidUpdate</code> “钩子” 同时使用，需返回一个值或者 <code>null</code>，该值会传给 <code>componentWillUpdate</code> “钩子” 的第三个参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getSnapshotBeforeUpdate'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prop) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prop'</span>, prop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// getSnapshotBeforeUpdate</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// prop 123</span></span><br></pre></td></tr></table></figure><p>点击更新按钮执行顺序为：<code>render</code> → <code>getSnapshotBeforeUpdate</code> → <code>componentDidUpdate</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>以上就是关于 <code>React</code> 生命周期的内容，涵盖了在 <code>React</code> 开发中对生命周期大部分的应用，也是 <code>React</code> 知识体系中非常重要的部分，<code>React</code> 生命周期和 <code>Vue</code> 相比的特点是名字长，不容易记，希望大家在学习理解之后多巩固，孰能生巧。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/15/20180915194439/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— 带你走进 React 世界</title>
      <link>https://www.overtaking.top/2018/09/10/20180910025959/</link>
      <guid>https://www.overtaking.top/2018/09/10/20180910025959/</guid>
      <pubDate>Sun, 09 Sep 2018 18:59:59 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/10/20180910025959/react.png&quot; title=&quot;React 16&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-介绍&quot;&gt;&lt;a href=&quot;#React-介绍&quot; class=&quot;headerlink&quot; title=&quot;React 介绍&quot;&gt;&lt;/a&gt;React 介绍&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;code&gt;React&lt;/code&gt; 是前端最流行的框架之一，由 Facebook 产出，由于其独特的 &lt;code&gt;JSX&lt;/code&gt; 语法与组件化开发模式，将原本前端基于 &lt;code&gt;DOM&lt;/code&gt; 的编程方式变成了基于组件和数据编程，给前端带来的益处是颠覆性的，因为我们知道 &lt;code&gt;DOM&lt;/code&gt; 操作是 “昂贵” 的，&lt;code&gt;React&lt;/code&gt; 在提高应用性能的同时又大大提高了开发效率，所以受到很多前端开发者的支持，也就有了庞大的生态，如今 &lt;code&gt;React&lt;/code&gt; 已经成为前端工程师之必备技术栈。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/10/20180910025959/react.png" title="React 16"><p><br></p><h2 id="React-介绍"><a href="#React-介绍" class="headerlink" title="React 介绍"></a>React 介绍</h2><blockquote class="pullquote default"><p><code>React</code> 是前端最流行的框架之一，由 Facebook 产出，由于其独特的 <code>JSX</code> 语法与组件化开发模式，将原本前端基于 <code>DOM</code> 的编程方式变成了基于组件和数据编程，给前端带来的益处是颠覆性的，因为我们知道 <code>DOM</code> 操作是 “昂贵” 的，<code>React</code> 在提高应用性能的同时又大大提高了开发效率，所以受到很多前端开发者的支持，也就有了庞大的生态，如今 <code>React</code> 已经成为前端工程师之必备技术栈。</p></blockquote><a id="more"></a><h2 id="创建-React-项目"><a href="#创建-React-项目" class="headerlink" title="创建 React 项目"></a>创建 React 项目</h2><p>在创建 <code>React</code> 项目时，可以使用当下最流行的脚手架 <code>create-react-app</code> 和 <code>generator-react-webpack</code>，前者是由 Facebook 官方出品，后者是第三方构建工具。</p><h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><p><code>create-react-app</code> 适用于大部分项目，集成了对 <code>React</code>、<code>JSX</code>、<code>ES6</code> 和 <code>Flow</code> 的支持，支持热更新，默认情况下无需对 <code>Webpack</code> 进行配置，如果要单独配置 <code>Webpack</code>，需要执行命令弹出配置项，下面命令分别对应安装脚手架工具、构建项目和弹出配置项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹射 Webpack 配置文件</span></span><br><span class="line">npm run eject</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：创建 <code>React</code> 项目时，项目名称不能含大写字母，使用 <code>eject</code> 命令弹出配置项的过程不可逆。</strong></em></p></blockquote><h3 id="generator-react-webpack"><a href="#generator-react-webpack" class="headerlink" title="generator-react-webpack"></a>generator-react-webpack</h3><p><code>generator-react-webpack</code> 适用于构建大型项目，它是需要 <code>yeoman</code> 的支持，几乎具备了 <code>create-react-app</code> 的全部功能，不同的是默认可以对 <code>Webpack</code> 进行配置，生成项目需要手动创建项目根目录，安装脚手架工具和构建项目的命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架及依赖</span></span><br><span class="line">npm install -g yo generator-react-webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目根目录</span></span><br><span class="line">mkdir project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目目录</span></span><br><span class="line"><span class="built_in">cd</span> project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">yo react-webpack</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>我们本次使用 <code>create-react-app</code> 来构建一个项目，并弹出配置项，<code>src</code> 目录为我们主要的开发文件，必须含有一个入口文件 <code>index.js</code>，所以我们在构建项目后删除 <code>src</code> 中的无用文件，目录结构如下（可以通过 <code>npm run start</code> 启动项目）。</p><p><pre>react-demo<br>  |- config<br>  | |- jest<br>  | | |- cssTransform.js<br>  | | |- fileTransform.js<br>  | |- env.js.js<br>  | |- paths.js<br>  | |- webpack.config.dev.js<br>  | |- webpack.config.prod.js<br>  | |- webpackDevServer.config.js<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- scripts<br>  | |- build.js<br>  | |- start.js<br>  | |- test.js<br>  |- src<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><h2 id="探索-React"><a href="#探索-React" class="headerlink" title="探索 React"></a>探索 React</h2><h3 id="引入-React-变量必须大写"><a href="#引入-React-变量必须大写" class="headerlink" title="引入 React 变量必须大写"></a>引入 React 变量必须大写</h3><p><code>React</code> 的核心模块分为两个，分别为 <code>react</code> 和 <code>react-dom</code>，前者为 <code>React</code> 的核心逻辑，后者为 <code>React</code> 的渲染逻辑，在 <code>React</code> 中规定引入 <code>react</code> 模块的变量名必须大写。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染到页面</span></span><br><span class="line">ReactDOM.render(h1, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>如果向上面代码中将引入 <code>react</code> 的变量小写，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error1.png" alt="React 变量错写报错" title>                </div>                <div class="image-caption">React 变量错写报错</div>            </figure><p><br></p><p>该报错信息的意思是当前使用了 <code>JSX</code>，必须要有一个大写的 <code>React</code>，从而可以看出这是 <code>React</code> 所规定的，当将接收 <code>react</code> 的变量改成大写后，页面正常渲染。</p><h3 id="React-必须有-createElement-方法"><a href="#React-必须有-createElement-方法" class="headerlink" title="React 必须有 createElement 方法"></a>React 必须有 createElement 方法</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个大写的 React 对象</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>为了进一步验证，上面代码中创建一个名为 <code>React</code> 的对象，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error2.png" alt="React 没有 createElement 方法报错" title>                </div>                <div class="image-caption">React 没有 createElement 方法报错</div>            </figure><p><br></p><p>这个报错非常明显的在告诉我们，<code>React</code> 对象中缺少了 <code>createElement</code> 方法，我们将代码修改如下后发现报错信息消失。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个大写的 React 对象</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  createElement() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>页面 “白屏” 是因为并没有使用 <code>react-dom</code> 进行渲染，我们定义的 <code>h1</code> 是一个组件，同时也是 <code>JSX</code>，所以会调用 <code>createElement</code> 对 <code>JSX</code> 进行解析。</p><h3 id="解析后的-JSX-长什么样"><a href="#解析后的-JSX-长什么样" class="headerlink" title="解析后的 JSX 长什么样"></a>解析后的 JSX 长什么样</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 JSX 解析后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(h1);</span><br></pre></td></tr></table></figure><p>打开 Chorme 浏览器控制台查看打印结果如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/virtualDOM.png" alt="JSX 解析后的虚拟 DOM 结构" title>                </div>                <div class="image-caption">JSX 解析后的虚拟 DOM 结构</div>            </figure><p><br></p><p>从结果可以看出 <code>createElement</code> 方法最终将 <code>JSX</code> 解析成了一个对象结构，其中 <code>props</code> 带表属性对象，其中的 <code>children</code> 代表子元素，也就是文本节点 <code>hello world</code>，<code>type</code> 代表标签类型为 <code>h1</code>，这样用来表述 <code>DOM</code> 结构的对象被称为虚拟 <code>DOM</code>。</p><h3 id="模拟解析和渲染过程"><a href="#模拟解析和渲染过程" class="headerlink" title="模拟解析和渲染过程"></a>模拟解析和渲染过程</h3><p>在上面我们知道了 <code>React</code> 可以自动将 <code>JSX</code> 转换成虚拟 <code>DOM</code>，而 <code>ReactDOM</code> 的 <code>render</code> 方法将虚拟 <code>DOM</code> 渲染成了真实的 <code>DOM</code>，用法如下。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  hello</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染到页面</span></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>查看页面可以看到正常渲染了，现在就用前面对 <code>React</code> 的了解来简单模拟解析与渲染的过程，代码如下。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 React 对象和 createElement 方法</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  createElement(type, props, ...children) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; type, props, children &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  hello</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染的 render 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是字符串说明是文本节点，创建文本节点并插入到父元素中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> container.appendChild(<span class="built_in">document</span>.createTextNode(vnode));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是字符串说明是元素节点，解构元素类型、属性和子元素的数组</span></span><br><span class="line">  <span class="keyword">let</span> &#123; type, props, children &#125; = vnode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建元素</span></span><br><span class="line">  <span class="keyword">let</span> tag = <span class="built_in">document</span>.createElement(type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环添加属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    tag.getAttribute(key, props[key]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环子元素，并递归创建子元素</span></span><br><span class="line">  children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    render(child, tag);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将元素插入到容器中，root</span></span><br><span class="line">  container.appendChild(tag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染虚拟 DOM</span></span><br><span class="line">render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>通过上面实现的代码同样可以完成渲染，当然仅限于简单结构，<code>React</code> 内部的实现更为复杂，兼容了多种组件类型和复杂的 <code>DOM</code> 结构。</p><h3 id="JSX-最外层只能有一个元素"><a href="#JSX-最外层只能有一个元素" class="headerlink" title="JSX 最外层只能有一个元素"></a>JSX 最外层只能有一个元素</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在对上面代码中的 <code>JSX</code> 进行渲染时会有如下报错信息。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error3.png" alt="JSX 没有唯一父元素包裹报错" title>                </div>                <div class="image-caption">JSX 没有唯一父元素包裹报错</div>            </figure><p><br></p><p>上面的报错信息告诉我们 <code>JSX</code> 元素必须包裹在一个闭合的标签内，所以说在写 <code>JSX</code> 语法的时候我们必须保证最外层只有一个元素节点。</p><h2 id="React-的基本使用"><a href="#React-的基本使用" class="headerlink" title="React 的基本使用"></a>React 的基本使用</h2><p>在 <code>JSX</code> 全称为 <code>JavaScript XML</code>，但是和普通的 <code>HTML</code> 相比，有一些不同的用法，如元素属性 <code>class</code>、<code>for</code>、<code>style</code>、<code>dangerouslyInnerHTML</code> 以及注释写法等等。</p><h3 id="className-属性"><a href="#className-属性" class="headerlink" title="className 属性"></a>className 属性</h3><p>在 <code>JSX</code> 语法中，在标签中应使用 <code>className</code> 替代 <code>HTML</code> 中的 <code>class</code> 属性，因为在 JavaScript 中 <code>class</code> 为关键字。</p><figure class="highlight jsx"><figcaption><span>class 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"active"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><h3 id="htmlFor-属性"><a href="#htmlFor-属性" class="headerlink" title="htmlFor 属性"></a>htmlFor 属性</h3><p>在 <code>HTML</code> 中，通过点击 <code>label</code> 标签让 <code>input</code> 输入框获取焦点是很常见的，只需要让 <code>label</code> 标签 <code>for</code> 属性的值与 <code>input</code> 标签的 <code>id</code> 值相等即可，但是在 <code>JSX</code> 中这这样的写法会报错，必须将 <code>label</code> 标签的 <code>for</code> 属性使用 <code>htmlFor</code> 替代，代码如下。</p><figure class="highlight jsx"><figcaption><span>for 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;label htmlFor="username"&gt;用户名&lt;/</span>label&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h3><figure class="highlight jsx"><figcaption><span>style 属性错误的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: red;"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在 <code>JSX</code> 中关于 <code>style</code> 属性的写法发生了变化，如果用 <code>HTML</code> 中的写法会报错，错误信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error4.png" alt="JSX 中 style 属性错误写法报错" title>                </div>                <div class="image-caption">JSX 中 style 属性错误写法报错</div>            </figure><p><br></p><p>报错信息中明确的告诉我们 <code>style</code> 属性必须是一个含有代表样式键值的对象，而不是一个字符串，并给出正确的结构，正确的写法如下。</p><figure class="highlight jsx"><figcaption><span>style 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> '<span class="attr">red</span>'&#125;&#125;&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：在解析 <code>JSX</code> 的过程中，<code>&lt;</code> 和 <code>&gt;</code> 包裹 <code>JSX</code> 元素，元素属性中最外层的 <code>{</code> 和 <code>}</code> 包裹 <code>JS</code> 代码，而内层的 <code>{</code> 和 <code>}</code> 则代表一个 <code>JS</code> 对象，所以 <code>style</code> 是被两层 “花括号” 所包裹，并不是 <code>mustache</code> 语法。</strong></em></p></blockquote><h3 id="取值表达式"><a href="#取值表达式" class="headerlink" title="取值表达式"></a>取值表达式</h3><p>在 <code>JSX</code> 中，所有的 <code>JS</code> 代码都可以写在 <code>JSX</code> 元素起始和闭合标签中间的 <code>{</code> 和 <code>}</code> 内，会将执行结果渲染到该元素上。</p><figure class="highlight jsx"><figcaption><span>取值表达式的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &lt;p&gt;hello&lt;<span class="regexp">/p&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let el = (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;&#123;fn()&#125;&lt;/</span>h1&gt;</span><br><span class="line">    &lt;div&gt;&#123;str&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&#123;JSON.stringify(obj)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;div&gt;&#123;<span class="literal">true</span> ? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>nihao<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>启动项目可以看到页面上已经成功的渲染了 <code>hello</code>、<code>world</code>、<code>{ hello: &#39;world&#39; }</code> 和 <code>nihao</code>，上面三元运算符结果如果为 <code>null</code> 则不会渲染这个节点，<code>viod 0</code> 与 <code>null</code> 作用相同。</p><h3 id="dangerouslySetInnerHTML-属性"><a href="#dangerouslySetInnerHTML-属性" class="headerlink" title="dangerouslySetInnerHTML 属性"></a>dangerouslySetInnerHTML 属性</h3><p>在 <code>JSX</code> 中，如果想要把一个含有标签元素的字符串插入到某一个节点中，应该使用 <code>dangerouslySetInnerHTML</code> 替代原生 <code>JS</code> 中的 <code>innerHTML</code>。</p><figure class="highlight jsx"><figcaption><span>dangerouslySetInnerHTML 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'&lt;h1&gt;hello&lt;/h1&gt;'</span>;</span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> <span class="attr">str</span>&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>dangerouslySetInnerHTML</code> 属性的值为对象，将要插入的 <code>HTML</code> 字符串作为对象中 <code>__html</code> 属性的值即可，设置 <code>dangerouslySetInnerHTML</code> 属性的 <code>JSX</code> 元素中不能有任何的子元素。</p><blockquote class="pullquote danger"><p><em><strong>注意：<code>dangerouslySetInnerHTML</code> 属性非常危险，容易引发 <code>XSS</code> 攻击，轻易不要使用。</strong></em></p></blockquote><h3 id="JSX-中注释的写法"><a href="#JSX-中注释的写法" class="headerlink" title="JSX 中注释的写法"></a>JSX 中注释的写法</h3><p>在 <code>JSX</code> 的 <code>DOM</code> 结构中，如果需要对代码进行注释不能使用 <code>JS</code> 中的 <code>// 注释</code>，也不能使用 <code>HTML</code> 中的 <code>&lt;!-- 注释 --&gt;</code>，注释必须使用 <code>{ }</code> 包裹，写法如下。</p><figure class="highlight jsx"><figcaption><span>注释在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 name=<span class="string">"hi"</span>&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* 这是注释，支持多行 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;world&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="Fragment-组件"><a href="#Fragment-组件" class="headerlink" title="Fragment 组件"></a>Fragment 组件</h3><p>在 <code>React 16.3</code> 中提供了一个组件，类似于原生 <code>JS</code> 中的文档碎片，可以将多个元素包裹起来，却不会被渲染，用法如下。</p><figure class="highlight jsx"><figcaption><span>Fragment 组件的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;world&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="循环动态创建-JSX-结构"><a href="#循环动态创建-JSX-结构" class="headerlink" title="循环动态创建 JSX 结构"></a>循环动态创建 JSX 结构</h3><p>在 <code>React</code> 中不存在过多的 API，最大的特点就是 <code>JSX</code> 语法可以将 <code>JS</code> 与 <code>HTML</code> 混写，借助原生 <code>JS</code> 的方法实现功能，比如可以使用循环创建 <code>JSX</code> 结构。</p><figure class="highlight jsx"><figcaption><span>循环在 JSX 中的应用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><p><strong>上面成功的渲染除了一个列表，但是有两点需要注意：</strong></p><ul><li>第一点是循环一定要使用具有返回值的方法，如 <code>map</code>、<code>filter</code> 等；</li><li>第二点是每一个循环出来的 <code>JSX</code> 元素必须绑定一个 <code>key</code> 属性，可以使用数据的 <code>id</code>（优先），也可以使用数组的索引。</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote class="pullquote info"><p>在上面所有代码中的 <code>JSX</code> 都很不优雅，如果一个项目非常大，这样的混乱的结构是难以维护的，组件就是为了更好的维护和复用相同的 <code>JSX</code> 结构以及提高工作效率而存在的。</p></blockquote><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>在 <code>React</code> 中可以通过函数创建组件，函数名称就是组件名，必须大写，必须有返回值，可以为 <code>JSX</code>，也可以为 <code>null</code>，通过单闭合和双闭合两种方式调用组件，可以通过属性传参，并通过函数组件的第一个参数接收，实现代码如下。</p><figure class="highlight jsx"><figcaption><span>函数组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Build</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;props.content&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render((</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Build title="1" content="1xx"&gt;&lt;/</span>Build&gt; &#123;<span class="comment">/* 双闭合 */</span>&#125;</span><br><span class="line">    &lt;Build title=<span class="string">"2"</span> content=<span class="string">"2xx"</span>/&gt; &#123;<span class="comment">/* 单闭合 */</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">), window.root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><em><strong>缺点 1：在函数组件内部 <code>this</code> 为 <code>undefined</code>；</strong></em><br><em><strong>缺点 2：在函数组件内部没有状态，即只能使用通过属性传递的参数，却没有更改的能力；</strong></em><br><em><strong>缺点 3：函数组件没有生命周期，无法使用生命周期 “钩子” 完成一些操作。</strong></em></p></blockquote><p>由于函数组件的缺陷，所以更适合渲染一些静态的不需要数据变化的结构，如果想要让传入的属性变化可以通过不断执行 <code>React.render</code> 的方式不断更新传入组件参数的值，下面是一个时钟案例，通过函数组件实现时间的变化。</p><figure class="highlight jsx"><figcaption><span>函数组件多次渲染</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;当前时间&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;props.time&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 每秒渲染一次组件</span></span><br><span class="line"><span class="regexp">setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Clock time=&#123;new Date().toLocaleString()&#125;/</span>&gt;,</span><br><span class="line">    <span class="built_in">window</span>.root</span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>类组件解决了函数组件所有的缺陷，是通过类声明的。</p><figure class="highlight jsx"><figcaption><span>类组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constructor(props) &#123;</span></span><br><span class="line">  <span class="comment">//   super(props);</span></span><br><span class="line">  <span class="comment">//   this.state = &#123;</span></span><br><span class="line">  <span class="comment">//     time: new Date().toLocaleString();</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等价于 constructor 的写法，更简洁</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染组件</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的类组件中，我们同样使用了一个简单的时钟功能，可以看出类组件即有 <code>this</code>，又能创建和更新状态，也可以通过生命周期进行一些操作。</p><p>所有的类组件都需要继承 <code>React.Component</code>，这样就可以使用 <code>React.Component</code> 的原型方法 <code>setState</code> 对状态进行更新，每次更新，都会使组件重新渲染，但是只会重新渲染变化的 <code>DOM</code>，这是 <code>ReactDOM</code> 通过 <code>diff</code> 算法所做的优化。</p><h3 id="类组件中添加事件"><a href="#类组件中添加事件" class="headerlink" title="类组件中添加事件"></a>类组件中添加事件</h3><p>在平时开发中每个组件都会有一些对应的功能，这就需要事件的配合，在类组建中绑定事件大概有四种方式，我们还是用上面的时钟案例，给该组件添加一个按钮，在点击时卸载这个组件。</p><figure class="highlight jsx"><figcaption><span>方式 1：使用箭头函数直接绑定事件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ 卸载组件的方法</span></span><br><span class="line"><span class="regexp">          ReactDOM.unmountComponentAtNode(window.root);</span></span><br><span class="line"><span class="regexp">        &#125;&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>方式 2：使用 bind 绑定函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面两种方式都有一个共同的问题，箭头函数的方式在每次执行 <code>render</code> 时都会创建新的箭头函数，而将函数作为原型方法，通过 <code>bind</code> 是为了修正方法内部的 <code>this</code> 指向，但是每次执行 <code>render</code> 时，<code>bind</code> 也会返回一个新的函数。</p><figure class="highlight jsx"><figcaption><span>方式 3：在方式 2 的基础上提前生成函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.fn = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.fn&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>这样就解决了上面每次执行 <code>render</code> 就创建新函数的问题，但是这样的写法并不优雅，又产生了新的问题，所有的事件执行函数全都添加到了组件的实例上，而且代码会随着事件的增加而越来越乱。</p><figure class="highlight jsx"><figcaption><span>方式 4：使用 ES7 语法将原型方法使用箭头函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>ES7</code> 的新语法，既解决了事件处理函数方法内部 <code>this</code> 指向问题，又解决了每次执行 <code>render</code> 创建新函数的问题。</p><h3 id="卸载组件后不能再更新状态"><a href="#卸载组件后不能再更新状态" class="headerlink" title="卸载组件后不能再更新状态"></a>卸载组件后不能再更新状态</h3><p>还是上面的时钟案例，我们知道卸载一个组件应该使用 <code>ReactDOM.unmountComponentAtNode</code> 方法，参数一个组件，执行后会卸载这个组件内部所有的组件。</p><p>当真正点击时钟组件的按钮去卸载组件，组件虽然成功卸载了，但是控制台报错了，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error5.png" alt="卸载组件后更新状态报错" title>                </div>                <div class="image-caption">卸载组件后更新状态报错</div>            </figure><p><br></p><p>这个报错信息的意思是告诉我们在组件卸载后不能再通过 <code>setState</code> 更新状态，所以我们要在组件卸载之前先清空调用 <code>setState</code> 的定时器，代码修改如下。</p><figure class="highlight jsx"><figcaption><span>完整的时钟组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件将要卸载时清空定时器</span></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在这个组件中用到了两个生命周期 “钩子”，<code>componentDidMount</code> 钩子在组件挂载后执行，类似于原生 <code>JS</code> 的 <code>window.onload</code>，<code>componentWillUnmount</code> 钩子在组件将要卸载之前执行，后面会涉及更多生命周期钩子，我们会在这个 <code>React</code> 基础篇系列文章中一一说明。</p><h3 id="类组件的参数传递"><a href="#类组件的参数传递" class="headerlink" title="类组件的参数传递"></a>类组件的参数传递</h3><figure class="highlight jsx"><figcaption><span>类组件传参第一种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;this.props.age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 分别传入想要的属性</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>类组件传参第二种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 传入整个对象</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person &#123;...p&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面两种传参方式第一种是将对象中希望传入的属性传递给组件，第二种方式是将整个对象通过解构的方式直接传递给组件，而组件中可以在 <code>constructor</code> 中的第一个参数接收 <code>props</code>，也可以直接使用 <code>this.props</code>，因为 <code>React</code> 在组件创建实例调用 <code>super</code> 之前就已经将 <code>props</code> 作为了实例属性。</p><h3 id="组件参数的类型校验"><a href="#组件参数的类型校验" class="headerlink" title="组件参数的类型校验"></a>组件参数的类型校验</h3><p>在 <code>React</code> 组件传递参数时，是通过 <code>props</code> 取出传入的参数直接使用，传入的值类型并没有做任何的校验，这就可能造成传参时出现错误，在 <code>React</code> 生态中有一个第三方模块 <code>prop-types</code> 可以规定参数的类型，并对传入的参数进行校验，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prop-types</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用 prop-types 校验传给组件的参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123;</span><br><span class="line">  name: <span class="string">'panda'</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  gender: <span class="string">'男'</span>,</span><br><span class="line">  hobby: [<span class="string">'basketball'</span>, <span class="string">'swim'</span>],</span><br><span class="line">  pos: &#123; <span class="attr">x</span>: <span class="number">433</span>, <span class="attr">y</span>: <span class="number">822</span> &#125;,</span><br><span class="line">  salary: <span class="number">5000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义默认属性，React 自带</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name: <span class="string">'shen'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义属性类型</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired, <span class="comment">// 类型必须为字符串，必填项</span></span><br><span class="line">    age: PropTypes.number, <span class="comment">// 类型必须为数字</span></span><br><span class="line">    gender: PropTypes.oneOf([<span class="string">'男'</span>, <span class="string">'女'</span>]), <span class="comment">// 性别只能为男或女</span></span><br><span class="line">    hobby: PropTypes.arrayOf(PropTypes.string), <span class="comment">// 数组成员类型必须是字符串</span></span><br><span class="line">    pos: PropTypes.shape(&#123; <span class="comment">// 限制模型内部类型</span></span><br><span class="line">      x: PropTypes.number.isRequired,</span><br><span class="line">      y: PropTypes.number.isRequired</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数为原对象，第二个参数为当前属性，第三个参数为类</span></span><br><span class="line">    salary(obj, key, P) &#123;</span><br><span class="line">      <span class="comment">// 自行校验</span></span><br><span class="line">      <span class="keyword">if</span> (obj[key] &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'工资太低'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person &#123;...p&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>prop-types</code> 必须在类组件上添加一个静态属性 <code>propTypes</code>，在内部定义属性的类型，其中 <code>isRequired</code> 为必填项，如果没有传参会报错，在检测是会优先检测 <code>React</code> 的静态属性 <code>defaultProps</code>，即默认属性，如果 <code>defaultProps</code> 存在则视为已经有该参数。</p><p><code>oneOf</code> 方法参数为一个数组，传给组件对应的参数值必须是传给 <code>oneOf</code> 数组中的其中一项，否则会报错，<code>arrayOf</code> 方法用于限制数组成员的类型，<code>shape</code> 方法用于限属性值为对象的内部属性类型，参数为对象。</p><p>在 <code>propTypes</code> 静态属性中以传入的属性名作为方法名，则该方法为自定义校验该属性的函数，参数的前三项为原对象，属性名和所属类，可以在函数内部自行实现校验逻辑。</p><h3 id="setState-更新状态"><a href="#setState-更新状态" class="headerlink" title="setState 更新状态"></a>setState 更新状态</h3><p>在前面的时钟组件中已经简单的使用过 <code>setState</code>，在这里我们会对 <code>setState</code> 的用法通过一个计数器案例来做详细说明。</p><figure class="highlight jsx"><figcaption><span>计数器案例 1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的计数器中，当我们点击按钮时会执行 <code>handleClick</code>，而在 <code>handleClick</code> 内部调用了两次 <code>setState</code> 更新状态，但是我们启动项目后发现只有一次是有效的，这也说明了一个问题，<code>setState</code> 是异步执行的，最后一次执行的会覆盖前一次，其实在 <code>setState</code> 方法调用时支持传入一个回调函数，代码如下。</p><figure class="highlight jsx"><figcaption><span>计数器案例 2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>setState</code> 传入的回调会在更新状态成功后执行，所以将代码修改后两次 <code>setState</code> 都生效了，<code>render</code> 执行了两次，这样的写法如果调用 <code>setState</code> 次数多了就形成了 “回调地狱”，<code>setState</code> 还有另一种用法如下。</p><figure class="highlight jsx"><figcaption><span>计数器案例 3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123; <span class="attr">num</span>: prevState.num + <span class="number">1</span> &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123; <span class="attr">num</span>: prevState.num + <span class="number">1</span> &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>setState</code> 方法可直接传入一个函数，函数的参数为上一次更新的 <code>state</code>，也就是 <code>this.state</code>，此时执行 <code>setState</code> 只更新状态，不重新渲染，当最后一次更新状态后统一渲染一次。</p><blockquote class="pullquote info"><p><em><strong>更新组件有两种方式，一种是重新调用 <code>render</code> 并传入新的属性值，一种是通过组件调用 <code>setState</code> 重新设置状态。</strong></em></p></blockquote><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>对于组件的分类除了可以按照组件的创建方式分为函数组件和类组件，还有另外一种分类方式，就是受控组件和非受控组件，简单来说 “受控” 和 “非受控” 就是指是否受到状态的控制，这种分类方式多用于表单元素，同时也指对于表单元素数据的不同处理方式。</p><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>下面是一个受控组件的写法，输入框的初始值是通过 <code>value</code> 和 <code>defaultValue</code> 属性绑定的状态的值。</p><figure class="highlight jsx"><figcaption><span>受控组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg1: <span class="string">'hello'</span>,</span><br><span class="line">    msg2: <span class="string">'world'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.msg1&#125;/&gt; &#123;<span class="comment">/* 报错 */</span>&#125;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> defaultValue=&#123;<span class="keyword">this</span>.state.msg2&#125;/&gt; &#123;<span class="comment">/* 不报错 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面的代码中是两种绑定初始值的方式，使用 <code>defaultValue</code> 属性可以正常的将状态中的属性作为初始值绑定到页面的输入框内，但是随着输入的变化并没更新状态的作用，而使用 <code>value</code> 做了同样的绑定后，虽然页面正常显示初始值，但是控制台报错了，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error6.png" alt="受控组件赋初始值报错" title>                </div>                <div class="image-caption">受控组件赋初始值报错</div>            </figure><p><br></p><p>输入框的值可以通过输入改变，但受控组件要求状态的值要随着输入框内的值改变而更新，而报错信息告诉我们想要达到这样的目的必须要给表单元素绑定一个 <code>onChange</code> 事件，这个功能其实就是输入框与数据的双向绑定，修改后的实现如下。</p><figure class="highlight jsx"><figcaption><span>受控组件 —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeHandler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">msg</span>: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面的代码中在 <code>onChange</code> 事件中调用了 <code>setState</code> 并更新了状态，但是如果有多个输入框，要保证 <code>onChange</code> 事件的复用，实现不同的输入框输入时 <code>onChange</code> 事件时更新不同的状态，实现如下。</p><figure class="highlight jsx"><figcaption><span>受控组件 —— 多个输入框复用 onChange</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg1: <span class="string">'hello'</span>,</span><br><span class="line">    msg2: <span class="string">'world'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeHandler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = e.target.name;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; [val]: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"msg1"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg1&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg1&#125;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"msg2"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg2&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg2&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面通过给 <code>input</code> 标签添加和状态的变量名相同的 <code>name</code> 属性，在触发 <code>onChange</code> 事件时用 <code>name</code> 属性作为更新状态数据的键值。</p><blockquote class="pullquote default"><p><em><strong>受控组件的好处是，可以实时对输入框输入的值进行校验，并可以随着输入框的内容更新而更新状态，进而更新视图。</strong></em></p></blockquote><h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p>非受控组件与受控组件相比就是直接操作 <code>DOM</code> 来操作表单元素，直接操作 <code>DOM</code> 可以在 <code>componentDidMount</code> 生命周期内（DOM 完全挂载），写法如下。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— 直接操作 DOM（不建议）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>);</span><br><span class="line">    username.value = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(username.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;UnControl&gt;&lt;/</span>UnControl&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>当然在 <code>React</code> 中并不会这么写，<code>React</code> 专门给我们提供了操作 <code>DOM</code> 属性 <code>ref</code>，用法如下。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— ref 常用写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 打印输入框的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.userDom.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span> ref=&#123;dom =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.userDom = dom;</span><br><span class="line">        &#125;&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">UnControl</span>&gt;</span><span class="tag">&lt;/<span class="name">UnControl</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>ref</code> 属性的方式通常会在其中传入一个函数，这个函数的参数就是当前表单元素对应的 <code>DOM</code>，通常情况下会使用类组件的一个属性来存储这个 <code>DOM</code>，方便在其他的事件或生命周期 “钩子” 中使用。</p><p>在 <code>React 16.3</code> 中推出了操作非受控组件的新的 API <code>React.createRef</code> 方法，返回值是一个对象，将这个对象绑定在表单元素的 <code>ref</code> 上，则可以通过这个对象的 <code>current</code> 属性获取这个表单元素的 <code>DOM</code> 元素。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— React 16.3 新 API</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  userDom = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 打印输入框的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.userDom.current.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span> ref=&#123;<span class="keyword">this</span>.userDom&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">UnControl</span>&gt;</span><span class="tag">&lt;/<span class="name">UnControl</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>我们其实把 <code>React.createRef</code> 的返回值存储为了类组件的一个属性，并将这个属性传入 <code>ref</code>，这样可以在其他的事件或生命周期 “钩子” 中操作 <code>DOM</code>，如果存在多个这样的表单元素，许多次调用 <code>React.createRef</code>，并分别将存储返回值的类组件属性传入各个表单的 <code>ref</code> 中。</p><blockquote class="pullquote warning"><p><em><strong>非受控组件的好处是，操作 <code>DOM</code> 方便，可以与更多基于 <code>DOM</code> 操作的第三方库结合。</strong></em></p></blockquote><h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><p>复合组件指的就是存在父子关系的组件嵌套，在 <code>React</code> 中有两种形式的父子组件嵌套，第一种是直接将子组件在父组件中引入，并放在父组件 <code>render</code> 方法返回的 <code>JSX</code> 中。</p><figure class="highlight jsx"><figcaption><span>复合组件 —— 第一种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是父组件</span><br><span class="line">        &lt;Child/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件</span></span><br><span class="line"><span class="regexp">class Child extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;这是子组件&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>我们前面提到过组件可以通过单闭合或者双闭合的方式调用，第二种方式就是利用双闭合的调用方式，在父组件中引入子组件，把父组件中某些 <code>JSX</code> 放在双闭合的子组件标签中，作为参数传递给子组件，在子组件中通过 <code>props</code> 的 <code>children</code> 属性进行接收，并放入对应的位置。</p><figure class="highlight jsx"><figcaption><span>复合组件 —— 第二种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是父组件</span><br><span class="line">        &lt;Child&gt;</span><br><span class="line">          &lt;div&gt;父组件传递给子组件的 JSX&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Child&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件</span></span><br><span class="line"><span class="regexp">class Child extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        这是子组件</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>这是系列关于 <code>React</code> 基础的文章，本篇是关于 <code>React</code> 的一些基础知识，也包含了一些 <code>React 16</code> 版本的一些新增内容，比较适合不了解 <code>React</code> 框架的同学们从零开始入门，在后面会陆续更新关于复合组件参数传递、生命周期等内容。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/10/20180910025959/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Koa2 洋葱模型 —— compose 串联中间件的四种实现</title>
      <link>https://www.overtaking.top/2018/09/06/20180906170854/</link>
      <guid>https://www.overtaking.top/2018/09/06/20180906170854/</guid>
      <pubDate>Thu, 06 Sep 2018 09:08:54 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/06/20180906170854/compose-logo.png&quot; title=&quot;Koa 洋葱模型&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;Koa&lt;/code&gt; 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 &lt;code&gt;Express&lt;/code&gt; 支持了异步，所以编码时经常使用 &lt;code&gt;async/await&lt;/code&gt;，提高了可读性，使代码变得更优雅，上一篇文章 &lt;a href=&quot;https://www.overtaking.top/2018/09/02/20180902141819/&quot; target=&quot;_blank&quot;&gt;NodeJS 进阶 —— Koa 源码分析&lt;/a&gt;，也对 “洋葱模型” 和实现它的 &lt;code&gt;compose&lt;/code&gt; 进行分析，由于个人觉得 &lt;code&gt;compose&lt;/code&gt; 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 &lt;code&gt;compose&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/06/20180906170854/compose-logo.png" title="Koa 洋葱模型"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Koa</code> 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 <code>Express</code> 支持了异步，所以编码时经常使用 <code>async/await</code>，提高了可读性，使代码变得更优雅，上一篇文章 <a href="https://www.overtaking.top/2018/09/02/20180902141819/" target="_blank">NodeJS 进阶 —— Koa 源码分析</a>，也对 “洋葱模型” 和实现它的 <code>compose</code> 进行分析，由于个人觉得 <code>compose</code> 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 <code>compose</code>。</p></blockquote><a id="more"></a><h2 id="洋葱模型案例"><a href="#洋葱模型案例" class="headerlink" title="洋葱模型案例"></a>洋葱模型案例</h2><p>如果你已经使用 <code>Koa</code> 对 “洋葱模型” 这个词一定不陌生，它就是 <code>Koa</code> 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面的写法我们按照官方推荐，使用了 <code>async/await</code>，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 <code>next</code>，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 <code>Koa</code> 源码中，这一功能是靠一个 <code>compose</code> 方法实现的，我们本文四种实现 <code>compose</code> 的方式中实现同步和异步，并附带对应的案例来验证。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在真正创建 <code>compose</code> 方法之前应该先做些准备工作，比如创建一个 <code>app</code> 对象来顶替 <code>Koa</code> 创建出的实例对象，并添加 <code>use</code> 方法和管理中间件的数组 <code>middlewares</code>。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Koa 创建的实例</span></span><br><span class="line"><span class="keyword">const</span> app = &#123;</span><br><span class="line">  middlewares: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 use 方法</span></span><br><span class="line">app.use = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  app.middlewares.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.compose.....</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><p>上面的模块中导出了 <code>app</code> 对象，并创建了存储中间件函数的 <code>middlewares</code> 和添加中间件的 <code>use</code> 方法，因为无论用哪种方式实现 <code>compose</code> 这些都是需要的，只是 <code>compose</code> 逻辑的不同，所以后面的代码块中会只写 <code>compose</code> 方法。</p><h2 id="Koa-中-compose-的实现方式"><a href="#Koa-中-compose-的实现方式" class="headerlink" title="Koa 中 compose 的实现方式"></a>Koa 中 compose 的实现方式</h2><p>首先介绍的是 <code>Koa</code> 源码中的实现方式，在 <code>Koa</code> 源码中其实是通过 <code>koa-compose</code> 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 <code>compose</code> 的原理，所以 <code>ctx</code> 参数就被去掉了，因为我们不会使用它，重点是 <code>next</code> 参数。</p><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所有中间件都执行完跳出</span></span><br><span class="line">    <span class="keyword">if</span> (index === app.middlewares.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第 index 个中间件并执行</span></span><br><span class="line">    <span class="keyword">const</span> route = app.middlewares[index];</span><br><span class="line">    <span class="keyword">return</span> route(<span class="function"><span class="params">()</span> =&gt;</span> dispatch(++index));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出第一个中间件函数执行</span></span><br><span class="line">  dispatch(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是同步的实现，通过递归函数 <code>dispatch</code> 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 <code>dispatch</code>，传入的参数 <code>+1</code>，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 <code>1 3 5 6 4 2</code> 的情况执行，测试例子如下（同步上、异步下）。</p><figure class="highlight js"><figcaption><span>文件：sync-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">"./app"</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：async-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">"./app"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> fn(); <span class="comment">// 调用异步函数</span></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose();</span><br></pre></td></tr></table></figure><p>我们发现如果案例中按照 <code>Koa</code> 的推荐写法，即使用 <code>async</code> 函数，都会通过，但是在给 <code>use</code> 传参时可能会传入普通函数或 <code>async</code> 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 <code>Koa</code> 中 <code>compose</code> 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。</p><blockquote class="pullquote warning"><p><em><strong>注意：后面 <code>compose</code> 的其他实现方式中，都是使用 <code>sync-test.js</code> 和 <code>async-test.js</code> 验证，所以后面就不再重复了。</strong></em></p></blockquote><h3 id="升级为支持异步"><a href="#升级为支持异步" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所有中间件都执行完跳出，并返回一个 Promise</span></span><br><span class="line">    <span class="keyword">if</span> (index === app.middlewares.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第 index 个中间件并执行</span></span><br><span class="line">    <span class="keyword">const</span> route = app.middlewares[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行后返回成功态的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(<span class="function"><span class="params">()</span> =&gt;</span> dispatch(++index)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出第一个中间件函数执行</span></span><br><span class="line">  dispatch(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>async</code> 函数中 <code>await</code> 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 <code>async-test.js</code> 进行测试，发现结果为 <code>1 3 hello(3s后) 5 6 4 2</code>。</p><h2 id="Redux-旧版本-compose-的实现方式"><a href="#Redux-旧版本-compose-的实现方式" class="headerlink" title="Redux 旧版本 compose 的实现方式"></a>Redux 旧版本 compose 的实现方式</h2><h3 id="同步的实现-1"><a href="#同步的实现-1" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> app.middlewares.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> () =&gt; b(a), () =&gt; &#123;&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 <code>middlewares</code> 中存储的三个中间件函数分别为 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于使用的是 <code>reduceRight</code> 方法，所以是逆序归并，第一次 <code>a</code> 代表初始值（空函数），<code>b</code> 代表 <code>fn3</code>，而执行 <code>fn3</code> 返回了一个函数，这个函数再作为下一次归并的 <code>a</code>，而 <code>fn2</code> 作为 <code>b</code>，依次类推，过程如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)));</span><br></pre></td></tr></table></figure><p>由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 <code>fn1</code>，如果调用 <code>next</code> 则会执行 <code>fn2</code>，如果同样调用 <code>next</code> 则会执行 <code>fn3</code>，<code>fn3</code> 已经是最后一个中间件函数了，再次调 <code>next</code> 会执行我们最初传入的空函数，这也是为什么要将 <code>reduceRight</code> 的初始值设置成一个空函数，就是防止最后一个中间件调用 <code>next</code> 而报错。</p><p>经过测试上面的代码不会出现顺序错乱的情况，但是在 <code>compose</code> 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 <code>use</code> 的中间件函数既可以是普通函数，又可以是 <code>async</code> 函数，这就要我们的 <code>compose</code> 完全支持异步。</p><h3 id="升级为支持异步-1"><a href="#升级为支持异步-1" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">    app.middlewares.reduceRight(</span><br><span class="line">      (a, b) =&gt; <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(b(a)),</span><br><span class="line">      () =&gt; <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    )()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 <code>next</code> 后又调用了 <code>then</code>），都处理成了 Promise，保证了 <code>reduceRight</code> 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 <code>async</code> 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 <code>compose</code> 就可以调用 <code>then</code> 方法执行后续逻辑。</p><h2 id="Redux-新版本-compose-的实现方式"><a href="#Redux-新版本-compose-的实现方式" class="headerlink" title="Redux 新版本 compose 的实现方式"></a>Redux 新版本 compose 的实现方式</h2><h3 id="同步的实现-2"><a href="#同步的实现-2" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> app.middlewares.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> arg =&gt; a(<span class="function"><span class="params">()</span> =&gt;</span> b(arg)))(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Redux</code> 新版本中将 <code>compose</code> 的逻辑做了些改动，将原本的 <code>reduceRight</code> 换成 <code>reduce</code>，也就是说将逆序归并改为了正序，我们不一定和 <code>Redux</code> 源码完全相同，是根据相同的思路来实现串行中间件的需求。</p><p>个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于 <code>reduce</code> 并没有传入初始值，所以此时 <code>a</code> 为 <code>fn1</code>，<code>b</code> 为 <code>fn2</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 reduce 的返回值，下一次将作为 a</span></span><br><span class="line">arg =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(arg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 reduce 的返回值，下一次将作为 a</span></span><br><span class="line">arg =&gt; <span class="function">(<span class="params">arg =&gt; fn1((</span>) =&gt;</span> fn2(arg)))(<span class="function"><span class="params">()</span> =&gt;</span> fn3(arg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于...</span></span><br><span class="line">arg =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(arg)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行最后返回的函数连接中间件，返回值等价于...</span></span><br><span class="line">fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)));</span><br></pre></td></tr></table></figure><p>所以在调用 <code>reduce</code> 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 <code>fn3</code>，也就是第三个中间件，这样保证了在最后一个中间件调用 <code>next</code> 时不会报错。</p><h3 id="升级为支持异步-2"><a href="#升级为支持异步-2" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><p>下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">    app.middlewares.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> a(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(b(arg)));</span><br><span class="line">    &#125;)(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve())</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 <code>compose</code> 也返回 Promise。</p><h2 id="使用-async-函数实现"><a href="#使用-async-函数实现" class="headerlink" title="使用 async 函数实现"></a>使用 async 函数实现</h2><p>这个版本是我在之前在学习 <code>Koa</code> 源码时偶然在一位大佬的一篇分析 <code>Koa</code> 原理的文章中看到的（翻了半天实在没找到链接），在这里也拿出来和大家分享一下，由于是利用 <code>async</code> 函数实现的，所以默认就是支持异步的，因为 <code>async</code> 函数会返回一个 Promise。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自执行 async 函数返回 Promise</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义默认的 next，最后一个中间件内执行的 next</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="keyword">async</span> () =&gt; <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next</span></span><br><span class="line">    <span class="comment">// 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createNext</span>(<span class="params">middleware, oldNext</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> middleware(oldNext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向遍历中间件数组，先把 next 传给最后一个中间件函数</span></span><br><span class="line">    <span class="comment">// 将新的中间件函数存入 next 变量</span></span><br><span class="line">    <span class="comment">// 调用下一个中间件函数，将新生成的 next 传入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = app.middlewares.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      next = createNext(app.middlewares[i], next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>next</code> 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 <code>next</code>，而数组 <code>middlewares</code> 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 <code>createNext</code> 作用是返回一个新的可以执行数组中最后一个中间件的 <code>async</code> 函数，并传入了初始的 <code>next</code>，这个返回的 <code>async</code> 函数作为新的 <code>next</code>，再取到倒数第二个中间件，调用 <code>createNext</code>，又返回了一个 <code>async</code> 函数，函数内依然是倒数第二个中间件的执行，传入的 <code>next</code> 就是上次新生成的 <code>next</code>，这样依次类推到第一个中间件。</p><p>因此执行第一个中间件返回的 <code>next</code> 则会执行传入的上一个生成的 <code>next</code> 函数，就会执行第二个中间件，就会执行第二个中间件中的 <code>next</code>，就这样直到执行完最初定义的 <code>next</code>，通过案例的验证，执行结果与洋葱模型完全相同。</p><p>至于异步的问题，每次执行的 <code>next</code> 都是 <code>async</code> 函数，执行后返回的都是 Promise，而最外层的自执行 <code>async</code> 函数返回的也是 Promise，也就是说 <code>compose</code> 最后返回的是 Promise，因此完全支持异步。</p><blockquote class="pullquote info"><p><em><strong>这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>或许你看完这几种方式会觉得，还是 <code>Koa</code> 对于 <code>compose</code> 的实现方式最容易理解，你也可能和我一样在感慨 <code>Redux</code> 的两种实现方式和 <code>async</code> 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想，写出 <code>compose</code> 这种优雅又高逼格的代码，路漫漫其修远兮，愿你在技术的路上 “一去不复返”。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/06/20180906170854/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NodeJS 进阶 —— Koa 源码分析</title>
      <link>https://www.overtaking.top/2018/09/02/20180902141819/</link>
      <guid>https://www.overtaking.top/2018/09/02/20180902141819/</guid>
      <pubDate>Sun, 02 Sep 2018 06:18:19 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/02/20180902141819/koa-cover.png&quot; title=&quot;Koa 源码解析&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote success&quot;&gt;&lt;p&gt;&lt;code&gt;Koa 2.x&lt;/code&gt; 版本是当下最流行的 NodeJS 框架，同时社区涌现出一大批围绕 &lt;code&gt;Koa 2.x&lt;/code&gt; 的中间件以及基于 &lt;code&gt;Koa 2.x&lt;/code&gt; 封装的企业级框架，如 &lt;code&gt;egg.js&lt;/code&gt;，然而 &lt;code&gt;Koa&lt;/code&gt; 本身的代码却非常精简，精简到所有文件的代码去掉注释后还不足 &lt;code&gt;2000&lt;/code&gt; 行，本篇就围绕着这 &lt;code&gt;2000&lt;/code&gt; 行不到的代码抽出核心逻辑进行分析，并压缩成一版只有 &lt;code&gt;200&lt;/code&gt; 行不到的简易版 &lt;code&gt;Koa&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/02/20180902141819/koa-cover.png" title="Koa 源码解析"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><code>Koa 2.x</code> 版本是当下最流行的 NodeJS 框架，同时社区涌现出一大批围绕 <code>Koa 2.x</code> 的中间件以及基于 <code>Koa 2.x</code> 封装的企业级框架，如 <code>egg.js</code>，然而 <code>Koa</code> 本身的代码却非常精简，精简到所有文件的代码去掉注释后还不足 <code>2000</code> 行，本篇就围绕着这 <code>2000</code> 行不到的代码抽出核心逻辑进行分析，并压缩成一版只有 <code>200</code> 行不到的简易版 <code>Koa</code>。</p></blockquote><a id="more"></a><h2 id="Koa-分析过程"><a href="#Koa-分析过程" class="headerlink" title="Koa 分析过程"></a>Koa 分析过程</h2><p>在下面的内容中，我们将对 <code>Koa</code> 所使用的功能由简入深的分析，首先会给出使用案例，然后根据使用方式，分析实现原理，最后对分析的功能进行封装，封装过程会从零开始并一步一步完善，代码也是从少到多，会完整的看到一个简版 <code>Koa</code> 诞生的过程，在此之前我们打开 <a href="https://github.com/koajs/koa/tree/master/lib" target="_blank">Koa 源码地址</a>。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/koa-dir.png" alt="Koa 文件目录" title>                </div>                <div class="image-caption">Koa 文件目录</div>            </figure><p><br></p><p>通过上面对 <code>Koa</code> 源码目录的截图，发现只有 <code>4</code> 个核心文件，为了方便理解，封装简版 <code>Koa</code> 的文件目录结构也将严格与源码同步。</p><h2 id="搭建基本服务"><a href="#搭建基本服务" class="headerlink" title="搭建基本服务"></a>搭建基本服务</h2><p>在引入 <code>Koa</code> 时我们需要创建一个 <code>Koa</code> 的实例，而启动服务是通过 <code>listen</code> 监听一个端口号实现的，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过使用我们可以分析出 <code>Koa</code> 导出的应该是一个类，或者构造函数，鉴于 <code>Koa</code> 诞生的时间以及基于 <code>node v7.6.0</code> 以上版本的情况来分析，正是 <code>ES6</code> 开始 “横行霸道” 的时候，所以推测 <code>Koa</code> 导出的应该是一个类，打开源码一看，果然如此，所以我们也通过 <code>class</code> 的方式来实现。</p><p>而从启动服务的方式上看，<code>app.listen</code> 的调用方式与原生 <code>http</code> 模块提供的 <code>server.listen</code> 几乎相同，我们分析，<code>listen</code> 方法应该是对原生 <code>http</code> 模块的一个封装，启动服务的本质还是靠 <code>http</code> 模块来实现的。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 请求回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>上面的代码初步实现了我们上面分析出的需求，为了防止代码冗余，我们将创建服务的回调抽取成一个 <code>handleRequest</code> 的实例方法，内部的逻辑在后面完善，现在可以创建这个 <code>Koa</code> 类的实例，通过调用实例的 <code>listen</code> 方法启动一个服务器。</p><h2 id="上下文对象-ctx-的封装"><a href="#上下文对象-ctx-的封装" class="headerlink" title="上下文对象 ctx 的封装"></a>上下文对象 ctx 的封装</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>Koa</code> 还有一个很重要的特性，就是它的 <code>ctx</code> 上下文对象，我们可以调用 <code>ctx</code> 的 <code>request</code> 和 <code>response</code> 属性获取原 <code>req</code> 和 <code>res</code> 的属性和方法，也在 <code>ctx</code> 上增加了一些原生没有的属性和方法，总之 <code>ctx</code> 给我们要操作的属性和方法提供了多种调用方式，使用案例如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 原生的 req 对象的 url 属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(ctx.req.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.req.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.response.req.url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Koa 扩展的 url</span></span><br><span class="line">  <span class="built_in">console</span>.log(ctx.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.req.url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置状态码和响应内容</span></span><br><span class="line">  ctx.response.status = <span class="number">200</span>;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建-ctx-的引用关系"><a href="#创建-ctx-的引用关系" class="headerlink" title="创建 ctx 的引用关系"></a>创建 ctx 的引用关系</h3><p>从上面我们可以看出，<code>ctx</code> 为 <code>use</code> 方法的第一个参数，<code>request</code> 和 <code>response</code> 是 <code>ctx</code> 新增的，而通过这两个属性又都可以获取原生的 <code>req</code> 和 <code>res</code> 属性，<code>ctx</code> 本身也可以获取到原生的 <code>req</code> 和 <code>res</code>，我们可以分析出，<code>ctx</code> 是对这些属性做了一个集成，或者说特殊处理。</p><p>源码的文件目录中正好有与 <code>request</code>、<code>response</code> 名字相对应的文件，并且还有 <code>context</code> 名字的文件，我们其实可以分析出这三个文件就是用于封装 <code>ctx</code> 上下文对象使用的，而封装 <code>ctx</code> 中也会用到 <code>req</code> 和 <code>res</code>，所以核心逻辑应该在 <code>handleRequest</code> 中实现。</p><p>在使用案例中 <code>ctx</code> 是作为 <code>use</code> 方法中回调函数的参数，所以我们分析应该有一个数组统一管理调用 <code>use</code> 后传入的函数，<code>Koa</code> 应该有一个属性，值为数组，用来存储这些函数，下面是实现代码。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>首先，给实例创建了三个属性 <code>context</code>、<code>request</code> 和 <code>response</code> 分别继承了 <code>context.js</code>、<code>request.js</code> 和 <code>response.js</code> 导出的对象，之所以这么做而不是直接赋值是防止操作实例属性时 “污染” 原对象，而获取原模块导出对象的属性可以通过原型链进行查找，并不影响取值。</p><p>其次，给实例挂载了 <code>middlewares</code> 属性，值为数组，为了存储 <code>use</code> 方法调用时传入的函数，在 <code>handleRequest</code> 把创建 <code>ctx</code> 属性及引用的过程单独抽取成了 <code>createContext</code> 方法，并在 <code>handleRequest</code> 中调用，返回值为创建好的 <code>ctx</code> 对象，而在 <code>createContext</code> 中我们根据案例中的规则构建了 <code>ctx</code> 的属性相关的各种引用关系。</p><h3 id="实现-request-取值"><a href="#实现-request-取值" class="headerlink" title="实现 request 取值"></a>实现 request 取值</h3><p>上面构建的属性中，所有通过访问原生 <code>req</code> 或 <code>res</code> 的属性都能获取到，反之则是 <code>undefined</code>，这就需要我们去构建 <code>request.js</code>。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/request.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 url 和 path 添加 getter</span></span><br><span class="line"><span class="keyword">const</span> request = &#123;</span><br><span class="line">  <span class="keyword">get</span> url() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.req.url;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> path() &#123;</span><br><span class="line">    <span class="keyword">return</span> url.parse(<span class="keyword">this</span>.req.url).pathname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = request;</span><br></pre></td></tr></table></figure><p>上面我们只构造了两个属性 <code>url</code> 和 <code>path</code>，我们知道 <code>url</code> 是原生所自带的属性，我们在使用 <code>ctx.request.url</code> 获取是通过 <code>request</code> 对象设置的 <code>getter</code>，将 <code>ctx.request.req.url</code> 的值返回了。</p><p><code>path</code> 是原生 <code>req</code> 所没有的属性，但却是通过原生 <code>req</code> 的 <code>url</code> 属性和 <code>url</code> 模块共同构建出来的，所以我们同样用了给 <code>request</code> 对象设置 <code>getter</code> 的方式获取 <code>req</code> 的 <code>url</code> 属性，并使用 <code>url</code> 模块将转换对象中的 <code>pathname</code> 返回，此时就可以通过 <code>ctx.request.path</code> 来获取访问路径，至于源码中我们没有处理的 <code>req</code> 属性都是通过这样的方式建立的引用关系。</p><h3 id="实现-response-的取值和赋值"><a href="#实现-response-的取值和赋值" class="headerlink" title="实现 response 的取值和赋值"></a>实现 response 的取值和赋值</h3><p><code>Koa</code> 中 <code>response</code> 对象的真正作用是给客户端进行响应，使用时是通过访问属性获取，并通过重新赋值实现响应，但是现在 <code>response</code> 获取的属性都是 <code>undefined</code>，我们这里先不管响应给浏览器的问题，首先要让 <code>response</code> 下的某个属性有值才行，下面我们来实现 <code>response.js</code>。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/response.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 body 和 status 添加 getter 和 setter</span></span><br><span class="line"><span class="keyword">const</span> response = &#123;</span><br><span class="line">  <span class="keyword">get</span> body() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._body;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> body(val) &#123;</span><br><span class="line">    <span class="comment">// 只要给 body 赋值就代表响应成功</span></span><br><span class="line">    <span class="keyword">this</span>.status = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">this</span>._body = val;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> status() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.res.statusCode;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> status(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.res.statusCode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = response;</span><br></pre></td></tr></table></figure><p>这里选择了 <code>Koa</code> 在使用时，<code>response</code> 对象上比较重要的两个属性进行处理，因为这两个属性是服务器响应客户端所必须的，并模仿了 <code>request.js</code> 的方式给 <code>body</code> 和 <code>status</code> 设置了 <code>getter</code>，不同的是响应浏览器所做的其实是赋值操作，所以又给这两个属性添加了 <code>setter</code>，对于 <code>status</code> 来说，直接操作原生 <code>res</code> 对象的 <code>statusCode</code> 属性即可，因为同为赋值操作。</p><p>还有一点，响应是通过给 <code>body</code> 赋值实现，我们认为只要触发了 <code>body</code> 的 <code>setter</code> 就成功响应，所以在 <code>body</code> 的 <code>getter</code> 中将响应状态码设置为 <code>200</code>，至于 <code>body</code> 赋值是如何实现响应的，放在后面再说。</p><h3 id="ctx-代理-request、response-的属性"><a href="#ctx-代理-request、response-的属性" class="headerlink" title="ctx 代理 request、response 的属性"></a>ctx 代理 request、response 的属性</h3><p>上面实现了通过 <code>request</code> 和 <code>response</code> 对属性的操作，<code>Koa</code> 虽然给我们提供了多样的属性操作方式，但由于我们程序猿（媛）们都很 “懒”，几乎没有人会在开发的时候愿意多写代码，大部分情况都是通过 <code>ctx</code> 直接操作 <code>request</code> 和 <code>response</code> 上的属性，这就是我们现在的问题所在，这些属性通过 <code>ctx</code> 访问不到。</p><p>我们需要给 <code>ctx</code> 对象做一个代理，让 <code>ctx</code> 可以访问到 <code>request</code> 和 <code>response</code> 上的属性，这个场景何曾相识，不正是 <code>Vue</code> 创建实例时，将传入参数对象 <code>options</code> 的 <code>data</code> 属性代理给实例本身的场景吗，既然如此，我们也通过相似的方式实现，还记得上面引入的 <code>context</code> 模块作为实例的 <code>context</code> 属性所继承的对象，而剩下的最后一个核心文件 <code>context.js</code> 正是用来做这件事的，代码如下。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/context.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将传入对象属性代理给 ctx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineGetter</span>(<span class="params">property, key</span>) </span>&#123;</span><br><span class="line">  proto.__defineGetter__(key, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[property][key];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ctx 值时直接操作传入对象的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineSetter</span>(<span class="params">property, key</span>) </span>&#123;</span><br><span class="line">  proto.__defineSetter__(key, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[property][key] = val;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 request 的 url 和 path 代理给 ctx</span></span><br><span class="line">defineGetter(<span class="string">'request'</span>, <span class="string">'url'</span>);</span><br><span class="line">defineGetter(<span class="string">'request'</span>, <span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 response 的 body 和 status 代理给 ctx</span></span><br><span class="line">defineGetter(<span class="string">'response'</span>, <span class="string">'body'</span>);</span><br><span class="line">defineSetter(<span class="string">'response'</span>, <span class="string">'body'</span>);</span><br><span class="line">defineGetter(<span class="string">'response'</span>, <span class="string">'status'</span>);</span><br><span class="line">defineSetter(<span class="string">'response'</span>, <span class="string">'status'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = proto;</span><br></pre></td></tr></table></figure><p>在 <code>Vue</code> 中是使用 <code>Object.defineProperty</code> 来时实现的代理，而在 <code>Koa</code> 源码中借助了 <code>delegate</code> 第三方模块来实现的，并在添加代理时链式调用了 <code>delegate</code> 封装的方法，我们并没有直接使用 <code>delegate</code> 模块，而是将 <code>delegate</code> 内部的核心逻辑抽取出来在 <code>context.js</code> 中直接编写，这样方便大家理解原理，也可以清楚的知道是如何实现代理的。</p><p>我们封装了两个方法 <code>defineGetter</code> 和 <code>defineSetter</code> 分别来实现取值和设置值时，将传入的属性（第二个参数）代理给传入的对象（第一个参数），函数内是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__" target="_blank">Object.prototype.__defineGetter__</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__" target="_blank">Object.prototype.__defineSetter__</a> 实现的，点击方法名可查看官方 API。</p><h2 id="洋葱模型-——-实现中间件的串行"><a href="#洋葱模型-——-实现中间件的串行" class="headerlink" title="洋葱模型 —— 实现中间件的串行"></a>洋葱模型 —— 实现中间件的串行</h2><blockquote class="pullquote info"><p>现在已经实现了 <code>ctx</code> 上下文对象的创建，但是会发现我们封装 <code>ctx</code> 之前所写的案例 <code>use</code> 回调中的代码并不能执行，也不会报错，根本原因是 <code>use</code> 方法内传入的函数没有调用，在使用 <code>Koa</code> 的过程中会发现，我们往往使用多个 <code>use</code>，并且传入 <code>use</code> 的回调函数除了 <code>ctx</code> 还有第二个参数 <code>next</code>，而这个 <code>next</code> 也是一个函数，调用 <code>next</code> 则执行下一个 <code>use</code> 中的回调函数，否则就会 “卡住”，这种执行机制被取名为 “洋葱模型”，而这些被执行的函数被称为 “中间件”，下面我们就来分析这个 “洋葱模型” 并实现中间件的串行。</p></blockquote><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/onion-model.png" alt="洋葱模型执行过程" title>                </div>                <div class="image-caption">洋葱模型执行过程</div>            </figure><p><br></p><h3 id="洋葱模型分析"><a href="#洋葱模型分析" class="headerlink" title="洋葱模型分析"></a>洋葱模型分析</h3><p>下面来看看表述洋葱模型的一个经典案例，结果似乎让人匪夷所思，一时很难想到原因，不着急先看了再说。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>根据上面的执行特性我们不妨来分析以下，我们知道 <code>use</code> 方法执行时其实是把传入的回调函数放入了实例的 <code>middlewares</code> 数组中，而执行结果打印了 <code>1</code> 说明第一个回调函数被执行了，接着又打印了 <code>2</code> 说明第二个回调函数被执行了，根据上面的代码我们可以大胆的猜想，第一个回调函数调用的 <code>next</code> 肯定是一个函数，可能就是下一个回调函数，或者是 <code>next</code> 函数中执行了下一个回调函数，这样根据函数调用栈先进后出的原则，会在 <code>next</code> 执行完毕，即出栈后，继续执行上一个回调函数的代码。</p><h3 id="支持异步的中间件串行"><a href="#支持异步的中间件串行" class="headerlink" title="支持异步的中间件串行"></a>支持异步的中间件串行</h3><p>在实现中间件串行之前需要补充一点，中间件函数内调用 <code>next</code> 时，前面的代码出现异步，则会继续向下执行，等到异步执行结束后要执行的代码插入到同步代码中，这会导致执行顺序错乱，所以在官方推荐中告诉我们任何遇到异步的操作前都需要使用 <code>await</code> 进行等待（包括 <code>next</code>，因为下一个中间件中可能包含异步操作），这也间接的说明了传入 <code>use</code> 的回调函数只要有异步代码需要 <code>await</code>，所以应该是 <code>async</code> 函数，而了解 <code>ES7</code> 特性 <code>async/await</code> 的我们来说，一定能分析出 <code>next</code> 返回的应该是一个 Promise 实例，下面是我们在之前 <code>application.js</code> 基础上的实现。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>仔细想想我们其实在利用循环执行每一个 <code>middlewares</code> 中的函数，而且需要把下一个中间件函数的执行作为函数体的代码包装一层成为新的函数，并作为参数 <code>next</code> 传入，那么在上一个中间件函数内部调用 <code>next</code> 就相当于先执行了下一个中间件函数，而下一个中间件函数内部调用 <code>next</code>，又先执行了下一个的下一个中间件函数，依次类推。</p><p>直到执行到最后一个中间件函数，调用了 <code>next</code>，但是 <code>middlewares</code> 中已经没有下一个中间件函数了，这也是为什么我们要给下一个中间件函数外包了一层函数而不是直接将中间件函数传入的原因之一（另一个原因是解决传参问题，因为在执行时还要传入下一个中间件函数），但是防止递归 “死循环”，要配合一个终止条件，即指向 <code>middlewares</code> 索引的变量等于了 <code>middlewares</code> 的长度，最后只是相当于执行了一个只有一条判断语句的函数就 <code>return</code> 的函数，而并没有报错。</p><p>在这整个过程中如果有任意一个 <code>next</code> 没有被调用，就不会向下执行其他的中间件函数，这样就 “卡住了”，完全符合 <code>Koa</code> 中间件的执行规则，而 <code>await</code> 过后也就是下一个中间件优先执行完成，则会继续执行当前中间件 <code>next</code> 调用下面的代码，这也就是 <code>1、3、5、6、4、2</code> 的由来。</p><p>为了实现所描述的执行过程，将所有中间件串行的逻辑抽出了一个 <code>compose</code> 方法，但是我们没有使用普通的循环，而是使用递归实现的，首先在 <code>compose</code> 创建 <code>dispatch</code> 递归函数，参数为当前数组函数的索引，初始值为 <code>0</code>，函数逻辑是先取出第一个函数执行，并传入一个回调函数参数，回调函数参数中递归 <code>dispatch</code>，参数 <code>+1</code>，这样就会将整个中间件串行起来了。</p><p>但是上面的串行也只是同步串行，如果某个中间件内部需要等待异步，则调用的 <code>next</code> 函数必须返回一个 Promise 实例，有些中间件没有执行异步，则不需要 <code>async</code> 函数，也不会返回 Promise，而 <code>Koa</code> 规定只要遇到 <code>next</code> 就需要等待，则将取出每一个中间件函数执行后的结果使用 <code>Promise.resolve</code> 强行包装成一个成功态的 Promise，就对异步进行了兼容。</p><p>我们最后也希望 <code>compose</code> 返回一个 Promise 方便执行一些只有在中间件都执行后才会执行的逻辑，每次串行最后执行的都是一个只有一条判断逻辑就 <code>return</code> 了的函数（包含一个中间件也没有的情况），此时 <code>compose</code> 返回了 <code>undefined</code>，无法调用 <code>then</code> 方法，为了兼容这种情况也强行的使用相同的 “招数”，在判断条件的 <code>return</code> 关键字后面加上了 <code>Promise.resolve()</code>，直接返回了一个成功态的 Promise。</p><blockquote class="pullquote warning"><p><em><strong>注意：官方只是推荐我们在调用 <code>next</code> 的时候使用 <code>await</code> 等待，即使执行的 <code>next</code> 真的存在异步，也不是非 <code>await</code> 不可，我们完全可以使用 <code>return</code> 来代替 <code>await</code>，唯一的区别就是 <code>next</code> 调用后，下面的代码不会再执行了，类比 “洋葱模型”，形象地说就是 “下去了就上不来了”，这个完全可以根据我们的使用需要而定，如果 <code>next</code> 后面不再有任何逻辑，完全可以使用 <code>return</code> 替代。</strong></em></p></blockquote><h2 id="实现真正的响应"><a href="#实现真正的响应" class="headerlink" title="实现真正的响应"></a>实现真正的响应</h2><p>在对 <code>ctx</code> 实现属性代理后，我们通过 <code>ctx.body</code> 重新赋值其实只是改变了 <code>response.js</code> 导出对象的 <code>_body</code> 属性，而并没有实现真正的响应，看下面这个 <code>Koa</code> 的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = fs.createReadStream(<span class="string">'1.txt'</span>);</span><br><span class="line"></span><br><span class="line">  ctx.body = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'panda'</span>), <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实最后响应给客户端的值是 <code>panda</code>，正常在最后一个中间件执行后，由于异步定时器的代码没有执行完，<code>ctx.body</code> 最后的值应该是 <code>1.txt</code> 的可读流，这与客户端接收到的值相违背，通过这个猜想上的差异我们应该知道，<code>compose</code> 在串行执行中间件后为什么要返回一个 Promise 了，因为最后执行的只有判断语句的函数会等待我们例子中最后一个 <code>use</code> 传入的中间件函数执行完毕调用，也就是说在执行 <code>compose</code> 返回值的 <code>then</code> 时，<code>ctx.body</code> 的值已经是 <code>panda</code> 了。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">    <span class="comment">// 设置默认状态码（Koa 规定），必须在调用中间件之前</span></span><br><span class="line">    ctx.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取最后 body 的值</span></span><br><span class="line">      <span class="keyword">let</span> body = ctx.body;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器</span></span><br><span class="line">      <span class="keyword">if</span> (Buffer.isBuffer(body) || <span class="keyword">typeof</span> body === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 Buffer 类型的数据</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line">        res.end(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> body === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理对象类型</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) &#123;</span><br><span class="line">        <span class="comment">// 处理流类型的数据</span></span><br><span class="line">        body.pipe(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>处理 <code>response</code> 时，在 <code>body</code> 的 <code>setter</code> 中将状态码设置为了 <code>200</code>，就是说需要设置 <code>ctx.body</code> 去触发 <code>setter</code> 让响应成功，如果没有给 <code>ctx.body</code> 设置任何值，默认应该是无响应的，在官方文档也有默认状态码为 <code>404</code> 的明确说明，所以在 <code>handleRequest</code> 把状态码设置为了 <code>404</code>，但必须在 <code>compose</code> 执行之前才叫默认状态码，因为中间件中可能会操作 <code>ctx.body</code>，重新设置状态码。</p><p>在 <code>comose</code> 的 <code>then</code> 中，也就是在所有中间件执行后，我们取出 <code>ctx.body</code> 的值，即为最后生效的响应值，对该值进行了数据类型验证，如 Buffer、字符串、对象和流，并分别用不同的方式处理了响应，但本质都是调用的原生 <code>res</code> 对象的 <code>end</code> 方法。</p><h2 id="中间件错误处理"><a href="#中间件错误处理" class="headerlink" title="中间件错误处理"></a>中间件错误处理</h2><p>在上面的逻辑当中我们实现了很多 <code>Koa</code> 的核心逻辑，但是只考虑了顺利执行的情况，并没有考虑如果中间件中代码执行出现错误的问题，如下面案例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 error 监听</span></span><br><span class="line">app.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们之所以让 <code>compose</code> 方法在执行所有中间件后返回一个 Promise 还有一个更重要的意义，因为在 Promise 链式调用中，只要其中任何一个环节出现代码执行错误或抛出异常，都会直接执行出现错误的 <code>then</code> 方法中错误的回调或者最后的 <code>catch</code> 方法，对于 <code>Koa</code> 中间件的串行而言，最后一个 <code>then</code> 调用 <code>catch</code> 方法就是 <code>compose</code> 的返回值调用 <code>then</code> 后继续调用的 <code>catch</code>，<code>catch</code> 内可以捕获到任意一个中间件执行时出现的错误。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line"><span class="comment">// 继承 EventEmitter 后可以用创建的实例 app 添加 error 监听，可以通过 emit 触发监听</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    supper();</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认状态码（Koa 规定），必须在调用中间件之前</span></span><br><span class="line">    ctx.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取最后 body 的值</span></span><br><span class="line">      <span class="keyword">let</span> body = ctx.body;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器</span></span><br><span class="line">      <span class="keyword">if</span> (Buffer.isBuffer(body) || <span class="keyword">typeof</span> body === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 Buffer 类型的数据</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line">        res.end(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> body === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理对象类型</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) &#123;</span><br><span class="line">        <span class="comment">// 处理流类型的数据</span></span><br><span class="line">        body.pipe(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行 error 事件</span></span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 500 状态码</span></span><br><span class="line">      ctx.status = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回状态码对应的信息响应浏览器</span></span><br><span class="line">      res.end(httpServer.STATUS_CODES[ctx.status]);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>在使用的案例当中，使用 <code>app</code>（即 <code>Koa</code> 创建的实例）监听了一个 <code>error</code> 事件，当中间件执行错误时会触发该监听的回调，这让我们想起了 NodeJS 中一个重要的核心模块 <code>events</code>，这个模块帮我们提供了一个事件机制，通过 <code>on</code> 方法添加监听，通过 <code>emit</code> 触发监听，所以我们引入了 <code>events</code>，并让 <code>Koa</code> 类继承了 <code>events</code> 导入的 <code>EventEmitter</code> 类，此时 <code>Koa</code> 的实例就可以使用 <code>EventEmitter</code> 原型对象上的 <code>on</code> 和 <code>emit</code> 方法。</p><p>在 <code>compose</code> 执行后调用的 <code>catch</code> 中，通过实例调用了 <code>emit</code>，并传入了事件类型 <code>error</code> 和错误对象，这样就是实现了中间件的错误监听，只要中间件执行出错，就会执行案例中错误监听的回调。</p><h2 id="让引入的-Koa-直接指向-application-js"><a href="#让引入的-Koa-直接指向-application-js" class="headerlink" title="让引入的 Koa 直接指向 application.js"></a>让引入的 Koa 直接指向 application.js</h2><p>在上面我们实现了 <code>Koa</code> 大部分常用功能的核心逻辑，但还有一点美中不足，就是我们引入自己的简易版 <code>Koa</code> 时，默认会查找 <code>koa</code> 路径下的 <code>index.js</code>，想要执行我们的 <code>Koa</code> 必须要使用路径找到 <code>application.js</code>，代码如下。</p><figure class="highlight js"><figcaption><span>现在的引入方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa/application'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>希望的引入方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa'</span>);</span><br></pre></td></tr></table></figure><p>我们更希望像直接引入指定 <code>koa</code> 文件夹，就可以找到 <code>application.js</code> 文件并执行，这就需要我们在 <code>koa</code> 文件夹创建 <code>package.json</code> 文件，并在动一点小小的 “手脚” 如下。</p><figure class="highlight"><figcaption><span>文件路径：&#126koa/package.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  "main": "./application.js",</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Koa-原理图"><a href="#Koa-原理图" class="headerlink" title="Koa 原理图"></a>Koa 原理图</h2><p>在文章最后一节送给大家一张 <code>Koa</code> 执行的原理图，这张图片是准备写这篇文章时在 Google 上发现的，觉得把 <code>Koa</code> 的整个流程表达的非常清楚，所以这里拿来帮助大家理解 <code>Koa</code> 框架的原理和执行过程。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/koa-flow-chart.png" alt="Koa 原理图" title>                </div>                <div class="image-caption">Koa 原理图</div>            </figure><p><br></p><p>之所以没有在文章开篇放上这张图是因为觉得在完全没有了解过 <code>Koa</code> 的原理之前，可能有一部分小伙伴看这张图会懵，会打消学习的积极性，因为本篇的目的就是带着大家从零到有的，一步一步实现简易版 <code>Koa</code>，梳理 <code>Koa</code> 的核心逻辑，如果你已经看到了这里，是不是觉得这张图出现的不早不晚，刚刚好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>最后还是在这里做一个总结，在 <code>Koa</code> 中主要的部分有 <code>listen</code> 创建服务器、封装上下文对象 <code>ctx</code> 并代理属性、<code>use</code> 方法添加中间件、<code>compose</code> 串行执行中间、让 <code>Koa</code> 继承 <code>EventEmitter</code> 实现错误监听，而我个人觉得最重要的就是 <code>compose</code>，它是一个事件串行机制，也是实现 “洋葱模型” 的核心，如今 <code>compose</code> 已经不再只是一个方法名，而是一种编程思想，用于将多个程序串行在一起，或同步，或异步，在 <code>Koa</code> 中自不必多说，因为大家已经见识过了，<code>compose</code> 在 <code>Redux</code> 中也起着串联中间件的作用，如串联 <code>promise</code>、<code>redux-thunk</code>、<code>logger</code> 等，在 <code>Webpack</code> 源码依赖的核心模块 <code>tapable</code> 中也有所应用，在我们的学习过程中，这样优秀的编程思想是应该重点吸收的。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/02/20180902141819/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
