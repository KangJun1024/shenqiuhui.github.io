<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Shen&#39;s Blog</title>
    <link>https://www.overtaking.top/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 04 Jun 2019 10:41:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>React 基础篇 —— React Hooks</title>
      <link>https://www.overtaking.top/2019/05/07/20190507155411/</link>
      <guid>https://www.overtaking.top/2019/05/07/20190507155411/</guid>
      <pubDate>Tue, 07 May 2019 07:54:11 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/2019/05/07/20190507155411/react-hooks.jpeg&quot; title=&quot;React Hooks&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-Hooks-简介&quot;&gt;&lt;a href=&quot;#React-Hooks-简介&quot; cl
        
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/05/07/20190507155411/react-hooks.jpeg" title="React Hooks"><p><br></p><h2 id="React-Hooks-简介"><a href="#React-Hooks-简介" class="headerlink" title="React Hooks 简介"></a>React Hooks 简介</h2><blockquote class="pullquote default"><p><code>React Hooks</code> 是 <code>16.8</code> 版本中正式加入的特性，配合函数组件使用，在没有 <code>Hooks</code> 之前，函数组件使用场景非常有限，只适合编写纯展示性的 <code>UI</code> 组件，其余复杂的场景不得不使用类组件，而 <code>Hooks</code> 的主要作用是在函数组件中使用原本所不具备的 <code>React</code> 特性。</p></blockquote><h2 id="React-Hooks-产生的动机"><a href="#React-Hooks-产生的动机" class="headerlink" title="React Hooks 产生的动机"></a>React Hooks 产生的动机</h2><p>在业务开发中，数据主要存在两种形式，业务数据和 <code>UI</code> 数据，我们需要将这两种数据区分开，而有时数据又在组件之间存在共用关系，情况稍微复杂，参数传递的方式就无法满足需求，于是就会有状态管理进入到项目中（<code>Redux</code>、<code>Mobx</code>）等，会增加开发者的学习成本和项目的维护成本。</p><p>使用 <code>React</code> 的开发者都知道，<code>React</code> 主张组件化，就是把业务页面拆分成多个组件进行组合、嵌套、渲染。为了保证项目质量，开发者会花费大量精力在项目的模块化、状态数据最小化以及功能解耦上，而一部分组件会因为数据状态的共享耦合在一起，这时需要使用高阶组件、属性渲染、渲染回调等更高级的 <code>React</code> 特性去解耦，但是会增加代码的复杂程度、降低代码的可读性，在渲染时也会增加 <code>DOM</code> 的层级。</p><p>上面这些实际问题促成了 <code>React Hooks</code> 的诞生，而在有 <code>Hooks</code> 后官方也越来越推荐使用函数组件，主要原因总结如下。</p><ul><li>为了状态相关逻辑的提取和复用；</li><li>解决复杂组件代码变得难以理解的问题；</li><li>解决类组件带给开发者一些容易混淆的点，比如 <code>this</code> 指向问题；</li><li>由于 <code>JS</code> 解释器在解释 <code>class</code> 关键字时的性能问题，使用函数组件代替。</li></ul><blockquote class="pullquote info"><p><code>React</code> 没有重大变化，完全兼容类组件，可以让开发者不必完全重写现有代码，而是在后续开发中逐步尝试使用 <code>Hooks</code>。</p></blockquote><h2 id="React-Hooks-分类"><a href="#React-Hooks-分类" class="headerlink" title="React Hooks 分类"></a>React Hooks 分类</h2><p><strong><code>React</code> 官方主要给 <code>Hooks</code> 分为两大类：</strong></p><ul><li>基础 <code>Hooks API</code>：<code>useState</code>、<code>useEffect</code>、<code>useContext</code>；</li><li>其他 <code>Hooks API</code>：<code>useReducer</code>、<code>useCallback</code>、<code>useImperativeHandle</code>、<code>useMemo</code>、<code>useRef</code>、<code>useLayoutEffect</code>、<code>useDebugValue</code>。</li></ul><h2 id="React-Hooks-使用规则"><a href="#React-Hooks-使用规则" class="headerlink" title="React Hooks 使用规则"></a>React Hooks 使用规则</h2><p>为了保证 <code>Hooks</code> 在使用时不会出现不可预测的问题，官方制定了一定要遵循的两条使用规则（非建议），在此提前声明。</p><blockquote class="pullquote warning"><p><em><strong>1、只在函数组件内部最顶层调用 <code>Hook</code>，不要在循环、条件判断或者嵌套函数中调用；</strong></em><br><em><strong>2、只能在函数组件中调用 <code>Hook</code>（自定义 <code>Hook</code> 中可以调用 <code>Hook</code>），不要在其他 <code>JavaScript</code> 函数中调用。</strong></em></p></blockquote><h2 id="React-Hooks-API"><a href="#React-Hooks-API" class="headerlink" title="React Hooks API"></a>React Hooks API</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 方法用于在函数组件内部实现组件的状态管理，可以起到类组件中 <code>state</code> 一样的作用。</p><figure class="highlight jsx"><figcaption><span>类组件实现的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Components &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Components</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click!</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面是一个类组件实现的计数器，当前计数器的值在类组件的 <code>state</code> 中进行管理。</p><figure class="highlight jsx"><figcaption><span>Hooks 实现的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>使用 <code>React Hooks</code> 的 <code>useState</code> 实现的计数器和类组件实现的功能完全相同，从 <code>useState</code> 实现的代码可以看出 <code>useState</code> 是一个函数，传入的参数是状态的初始值，返回值是一个数组，数组的第一项是当前状态的值，数组的第二项是改变状态值的方法。</p><figure class="highlight jsx"><figcaption><span>实现每次加 2 的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> countAction = <span class="function">(<span class="params">preCount, n</span>) =&gt;</span> preCount + n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(countAction(count, 2))&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面计数器功能的实现逻辑比较简单，下面来看一个类组件实现的稍微复杂的案例，然后再通过 <code>useState</code> 进行重构。</p><figure class="highlight jsx"><figcaption><span>类组件实现的模态切换功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Modal &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Toggle 组件专门提供切换状态和切换方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 on 的值</span></span><br><span class="line">    <span class="keyword">this</span>.state.on = <span class="keyword">this</span>.props.initial;</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123; <span class="attr">on</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  toggle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">on</span>: !<span class="keyword">this</span>.state.on &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.on, <span class="keyword">this</span>.toggle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Toggle&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        (on, toggle) =&gt; (</span><br><span class="line">          &lt;Fragment&gt;</span><br><span class="line">            &lt;Button type=<span class="string">"primary"</span> onClick=&#123;toggle&#125;&gt;</span><br><span class="line">              Open Model</span><br><span class="line">            &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Modal visible=&#123;on&#125; onCancel=&#123;toggle&#125;/</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面代码中的类组件 <code>Toggle</code> 主要的作用就是管理模态框显示的状态和对状态的控制，选择使用 <code>children</code> 并传入一个函数，目的是函数可以在类组件内部通过 <code>children</code> 属性调用，并将 <code>Toggle</code> 内部的状态和方法作为参数传入，进而将功能提供给函数组件，这种高级的用法叫做 “渲染回调”，可以成功的将组件进行解耦，但是这样的方式缺点也显而易见，就是代码的逻辑抽象，可读性差，下面来使用 <code>useState</code> 进行重构。</p><figure class="highlight jsx"><figcaption><span>useState 重构切换模态的功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ on, setOn ] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Button type=<span class="string">"primary"</span> onClick=&#123;() =&gt; setOn(<span class="literal">true</span>)&#125;&gt;</span><br><span class="line">        Open Model</span><br><span class="line">      &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Modal visible=&#123;on&#125; onCancel=&#123;() =&gt; setOn(true)&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong>因为 <code>React Hooks</code> 的 <code>useState</code> 让函数组件具备了管理组件状态的能力，所以不需要单独实现 <code>Toggle</code> 组件，代码变得更精简、清晰，更函数式编程，更新粒度更细。</strong></p></blockquote><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>正如 <code>useEffect</code> 钩子的命名一样，是在函数组件中专门用来处理副作用的，这个副作用是指某些操作使用了函数组件作用域外的变量，而且这个操作的结果会影响函数组件外部的环境。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次渲染后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初次渲染后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Execute once'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 count 更改时才执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count changed'</span>);</span><br><span class="line">  &#125;, [ count ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count)&#125;&gt;</span><br><span class="line">        Click no change!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面案例是通过 <code>useState</code> 一节中的计数器案例改编，我们增加了每次点击计数器江计数器状态同步到页面标题上的功能，并使用 <code>useEffect</code> 实现，<code>useEffect</code> 函数的参数为回调函数，并在每次页面渲染之后执行（包含首次渲染和更新渲染）。</p><blockquote class="pullquote primary"><p><strong>可以使用 <code>useEffect</code> 替代类组件的生命周期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</strong></p></blockquote><p><code>useEffect</code> 还支持传入第二个参数，类型为数组，数组的值为被监听的状态（被 <code>useState</code> 监听），此时 <code>useEffect</code> 内部会做一次比较，数组中变量的值没发生变化时，传入对应 <code>useEffect</code> 的回调不会执行，当传入 <code>useEffect</code> 的数组为空时，则传入的回调只在函数组件首次渲染时执行一次，作用相当于类组件的声明周期 <code>componentDidMount</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Hooks 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HooksCom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times (hooks)`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 类组件</span></span><br><span class="line"><span class="regexp">class ClassCom extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123; count: 1 &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    document.title = `You clicked $&#123;this.state.count&#125; times (class)`;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidUpdate() &#123;</span></span><br><span class="line"><span class="regexp">    document.title = `You clicked $&#123;this.state.count&#125; times (class)`;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)&#125;&gt;</span><br><span class="line">          Click!</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;HooksCom /&gt;</span><br><span class="line">      &lt;ClassCom /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>通过上面案例，对于使用了 <code>componentDidMount</code> 生命周期的类组件和使用了 <code>useEffect</code> 的函数组件对于页面标题更改的对比，<code>useEffect</code> 的执行会晚于 <code>componentDidMount</code>。</strong></p></blockquote><p>在 <code>useEffect</code> 方法传入的回调中支持返回一个函数，这个函数会在组件卸载之前执行，或重新渲染需时要执行对应的 <code>useEffect</code> 时优先执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChatAPI = &#123;</span><br><span class="line">  handle: <span class="literal">null</span>,</span><br><span class="line">  isOnline: <span class="literal">false</span>,</span><br><span class="line">  login() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOnline = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.handle &amp;&amp; <span class="keyword">this</span>.handle(&#123; <span class="attr">isOnline</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  logout() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOnline = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.handle &amp;&amp; <span class="keyword">this</span>.handle(&#123; <span class="attr">isOnline</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  subscribeToFriendStatus(id, handle) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`订阅好友：<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">  &#125;,</span><br><span class="line">  unsubscribeToFriendStatus(id, handle) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`清理好友：<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.handle = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于渲染好友在线状态的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制好友在线的变量和方法</span></span><br><span class="line">  <span class="keyword">const</span> [ isOnline, setIsOnline ] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置好友状态的函数</span></span><br><span class="line">  <span class="keyword">const</span> handleStatusChange = <span class="function">(<span class="params">status</span>) =&gt;</span> setIsOnline(status.isOnline);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 订阅好友状态</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 清除好友状态</span></span><br><span class="line">      ChatAPI.unsubscribeToFriendStatus(props.friend.id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [ props.friend.id ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;计数器：&#123;props.friend.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;br/</span>&gt;</span><br><span class="line">      &lt;span&gt;</span><br><span class="line">        登录状态：</span><br><span class="line">        &#123;</span><br><span class="line">          isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ show, setShow ] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [ userId, setUserId ] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;用户ID：&#123;userId&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;br/</span>&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        show &amp;&amp; &lt;FriendStatus friend=&#123;&#123; id: userId, name: 'Hello' &#125;&#125;/&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setShow(!show)&#125;&gt;显示/关闭&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setUserId(userId + 1)&#125;&gt;增加用户ID&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;增加计数器&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;ChatAPI.login.bind(ChatAPI)&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;ChatAPI.logout.bind(ChatAPI)&#125;&gt;退出&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面是一个覆盖比较全的 <code>useEffect</code> 案例，用来实现组件 <code>FriendStatus</code> 内对用户的订阅和取消订阅，其中 <code>App</code> 组件中的 <code>show</code> 状态用来控制 <code>FriendStatus</code> 组件是否渲染，<code>显示/关闭</code> 按钮用来控制 <code>show</code> 的值，<code>FriendStatus</code> 默认登录状态显示 <code>Loading...</code>，<code>登录</code> 和 <code>退出</code> 按钮用来空登录状态的显示（<code>Online</code> 或 <code>Offline</code>），<code>增加用户ID</code> 和 <code>增加计数器</code> 按钮分别用来更改当前用户 <code>ID</code> 和计数器的值，计数器的 <code>count</code> 属性和 <code>setUserId</code> 通过 <code>Render Props</code> 的方式传递给 <code>FriendStatus</code>，我们将使用到的方法统一都放在 <code>ChatAPI</code> 对象上。</p><p>默认渲染 <code>FriendStatus</code> 在控制台发现 <code>useEffect</code> 执行了，并订阅了当前传入的用户，而点击 <code>显示/关闭</code> 按钮时发现取消订阅了用户，这说明组件卸载之前执行了 <code>useEffect</code> 回调内部返回的函数，点击增加计数器按钮，<code>FriendStatus</code> 组件发生了重新渲染，而 <code>useEffect</code> 内部并没有再次对用户进行订阅，原因是指定了 <code>useEffect</code> 的第二个参数，并将用户的 <code>ID</code> 作为元素存入数组内，也就是用户 <code>ID</code> 不发生变化的时候就不会重新执行这个 <code>useEffect</code> 去订阅用户，当点击 <code>增加用户ID</code> 按钮时，控制台首先取消订阅了上一个用户，又订阅了新的用户，这说明 <code>FriendStatus</code> 组件重新渲染时，如果需要执行 <code>useEffect</code>，则会优先执行回调内返回的取消订阅的函数。</p>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/05/07/20190507155411/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 获取对象属性名的方法和区别</title>
      <link>https://www.overtaking.top/2019/04/17/20190417112536/</link>
      <guid>https://www.overtaking.top/2019/04/17/20190417112536/</guid>
      <pubDate>Wed, 17 Apr 2019 03:25:36 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/2019/04/17/20190417112536/get-object-key.png&quot; title=&quot;JavaScript 获取对象属性名的方法和区别&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
        
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/17/20190417112536/get-object-key.png" title="JavaScript 获取对象属性名的方法和区别"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>JavaScript</code> 中想获取某一个对象的属性名，有多种方法可供选择。</p><ul><li><code>for in</code></li><li><code>Object.keys</code></li><li><code>Object.getOwnPropertyNames</code></li><li><code>Object.getOwnPropertySymbols</code></li><li><code>Reflect.ownKeys</code></li></ul><p>在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。</p><h2 id="创建对象案例"><a href="#创建对象案例" class="headerlink" title="创建对象案例"></a>创建对象案例</h2><p>下面来创建一个对象的案例让这些方法来获取属性，再通过结果来看区别。</p><figure class="highlight js"><figcaption><span>父类，继承自 Object.prototype</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'symbolParent'</span>)]: &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>子类，继承自 parent</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">  c: &#123;</span><br><span class="line">    value: <span class="number">4</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    value: <span class="number">5</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'symbolChild'</span>)]: &#123;</span><br><span class="line">    value: <span class="number">6</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面我们创建了一个对象 <code>parent</code>，上面创建了两个普通属性 <code>a</code>（可枚举）、<code>b</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolParent</code>，创建了一个对象 <code>child</code> 继承自 <code>parent</code>，上面创建了两个普通属性 <code>c</code>（可枚举）、<code>d</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolChild</code>。</p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>从结果来看，<code>for...in</code> 先遍历并获取到了自身的部分属性名，又获取到了继承的部分属性名。</p><blockquote class="pullquote info"><p><strong>总结：<code>for...in</code> 可以遍历自身和继承的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c"]</span></span><br></pre></td></tr></table></figure><p>从结果来看，<code>Object.keys</code> 返回了一个数组，里面存储获取的属性的键名，不能获取继承的属性名，只能获取自身的部分属性名，这种效果相当于 <code>for...in</code> 与 <code>hasOwnProperty</code> 方法的组合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.hasOwnProperty(k)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>总结：<code>Object.keys</code> 只能遍历自身的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c", "d"]</span></span><br></pre></td></tr></table></figure><p>从结果看，<code>Object.getOwnPropertyNames</code> 方法返回了一个数组，存储获取对象属性的键名。</p><blockquote class="pullquote danger"><p><strong>总结：<code>Object.getOwnPropertyNames</code> 只能遍历自身的（包含不可枚举）、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Symbol(symbolChild)]</span></span><br></pre></td></tr></table></figure><p>从结果看，<code>Object.getOwnPropertySymbols</code> 方法返回了一个数组，存储的都是 <code>Symbol</code> 类型的键，说明是专门用来处理 <code>Symbol</code> 类型的。</p><blockquote class="pullquote default"><p><strong>总结：<code>Object.getOwnPropertySymbols</code> 只能遍历自身 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c", "d", Symbol(symbolChild)]</span></span><br></pre></td></tr></table></figure><p><code>Reflect.ownKeys</code> 的返回值为数组，存储遍历到的属性名。</p><blockquote class="pullquote success"><p><strong>总结：<code>Reflect.ownKeys</code> 可以遍历自身的所有属性（包含不可枚举和 <code>Symbol</code> 类型）。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/17/20190417112536/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript 基础知识总结</title>
      <link>https://www.overtaking.top/2019/04/16/20190416160637/</link>
      <guid>https://www.overtaking.top/2019/04/16/20190416160637/</guid>
      <pubDate>Tue, 16 Apr 2019 08:06:37 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/2019/04/16/20190416160637/typescript.jpeg&quot; title=&quot;Typescript&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;TypeScript-简介&quot;&gt;&lt;a href=&quot;#TypeScript-简介&quot; class=
        
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/16/20190416160637/typescript.jpeg" title="Typescript"><p><br></p><h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><blockquote class="pullquote info"><p><code>TypeScript</code> 是由微软开发的开源编程语言（后面简称 <code>TS</code>），是 <code>JavaScript</code> 的超集（后面简称 <code>JS</code>），由于 <code>JS</code> 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 <code>Bug</code> 和风险，而 <code>TS</code> 更适合大型企业应用，是因为 <code>TS</code> 需要编译成 <code>JS</code> 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。</p></blockquote><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/04/16/20190416160637/ts-js.png" alt="TypeScript 与 JavaScript 关系图" title>                </div>                <div class="image-caption">TypeScript 与 JavaScript 关系图</div>            </figure><p><br></p><p><code>TS</code> 是前端开发工程化新的趋势，目前很多的开源项目内部都是用 <code>TS</code> 编写，也有很多大牛在推广 <code>TS</code>，目前使用 <code>TS</code> 开发的典型项目有 <code>VSCode</code>、<code>Angular6</code>、<code>Vue3</code> 和 <code>React16</code> 等。</p><h2 id="如何使用-TS"><a href="#如何使用-TS" class="headerlink" title="如何使用 TS"></a>如何使用 TS</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用 <code>TS</code> 之前应该先进行全局安装。</p><figure class="highlight bash"><figcaption><span>安装 TS 的命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure><p>全局安装后会提供 <code>tsc</code> 命令，<code>tsc -v</code> 可以查看当前安装 <code>TS</code> 版本。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>我们可以通过命令单独对文件进行编译，也可以编译整个项目的 <code>TS</code> 文件。</p><figure class="highlight bash"><figcaption><span>编译单个文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>块级作用域变量名检测，两个文件（无论 <code>JS</code> 还是 <code>TS</code>）不允许有相同的变量名。</strong></p></blockquote><p>编译整个项目的 <code>TS</code> 文件需要在项目中设置 <code>tsconfig.json</code> 的配置文件，快速生成配置文件命令如下。</p><figure class="highlight bash"><figcaption><span>生成 tsconfig.json 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>生成 <code>TS</code> 配置文件以后，编译命令 <code>tsc</code> 不需要再指定文件名，会默认读取 <code>tsconfig.json</code> 文件的配置进行编译，关于 <code>tsconfig.json</code> 属性详解请看 <code>TO DO</code>。</p><p>当 <code>TS</code> 文件发生变化时，可以通过 <code>--watch</code> 参数进行实时监听，并当 <code>TS</code> 文件变化时实时编译，也可以把命令配置在 <code>package.json</code> 中通过 <code>npm</code> 执行。</p><figure class="highlight"><figcaption><span>package.json 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "tsc",</span><br><span class="line">    "start": "tsc --watch"</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS-的数据类型"><a href="#TS-的数据类型" class="headerlink" title="TS 的数据类型"></a>TS 的数据类型</h2><p>在 <code>TS</code> 中提供了强大的类型系统，编译时帮助我们对代码中定义的数据类型和值进行检查，如果使用支持 <code>TS</code> 比较好的编辑器，如 <code>VSCode</code>，可以在代码编写时及时发现错误。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="基本数据类型定义"><a href="#基本数据类型定义" class="headerlink" title="基本数据类型定义"></a>基本数据类型定义</h4><p><code>TS</code> 中包含了 <code>JS</code>，所以 <code>TS</code> 也有 <code>6</code> 种基本数据类型，<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'panda'</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> merried: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = Symbol();</span><br></pre></td></tr></table></figure><p>上面声明变量的值与所定义的数据类型必须严格符合，否则编译时报错（编辑器默认就会报错，后面统一说成报错）。</p><p><code>undefined</code> 和 <code>null</code> 是其他基本类型的子类型，类型定义为 <code>undefined</code> 的变量只能赋值 <code>undefined</code>，类型定义为 <code>null</code> 的变量只能赋值 <code>null</code>，类型定义为其他的可以赋值为 <code>undefined</code> 和 <code>null</code>。</p><figure class="highlight ts"><figcaption><span>默认不会报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果想让其他类型的赋值也必须严格与其定义相对应，可以通过配置 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性实现，也被叫做严格类型检查模式。</p><figure class="highlight"><figcaption><span>tsconfig.json 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    "strictNullChecks": true</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类型-any"><a href="#数据类型-any" class="headerlink" title="数据类型 any"></a>数据类型 any</h4><p>希望定义的数据类型可以赋值任何值，可以将数据类型定义为 <code>any</code>，这样相当于没有使用类型校验，等同于直接使用 <code>JS</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span> = <span class="number">18</span>;</span><br><span class="line">value = <span class="string">'hello world'</span>;</span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line">value = <span class="literal">null</span>;</span><br><span class="line">value = <span class="literal">undefined</span>;</span><br><span class="line">value = Symbol();</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p>上面代码中的赋值操作不会报任何错误，因为变量的值类型定义为了 <code>any</code>。</p></blockquote><h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><p>在 <code>TS</code> 中，如果定义的变量没有定义类型，则会对变量的类型进行推测，同样可以在代码编译阶段按照推测的类型校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num = <span class="string">'hello'</span>; <span class="comment">// 报错，不能将类型“"hello"”分配给类型“number”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'world'</span>;</span><br><span class="line">str = <span class="number">1</span>; <span class="comment">// 报错，不能将类型“1”分配给类型“string”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value; <span class="comment">// let value: any</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>类型推论规则：</strong></p><ul><li><strong>从报错的结果可以看出，<code>TS</code> 中声明变量如果没有指定值的类型，则会默认将声明变量时赋值数据的类型定义为该变量的值类型；</strong></li><li><strong>当声明变量没有直接赋值时，<code>TS</code> 会将变量的值类型定义为 <code>any</code>。</strong></li></ul></blockquote><h4 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h4><p><code>TS</code> 也包含基本包装类，基本数据类型是没有方法的（只有对象可以调用对应原型上的方法），在基本数据类型调用方法时是先进行包装过程，把基本类型包装成对象类型。</p><figure class="highlight ts"><figcaption><span>基本数据类型调用方法的包装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num.toFixed(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Number(num).toFixed(2);</span></span><br></pre></td></tr></table></figure><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>有些时候定义的变量在不同场景会赋不同类型的值，我们想要指定这个变量只接受某几个固定类型的值，可以使用联合类型的方式。</p><figure class="highlight ts"><figcaption><span>联合类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">'hello'</span>;</span><br><span class="line">value = <span class="number">10</span>;</span><br><span class="line">value = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>被定义联合类型的变量可以指定符合联合类型中任意一种类型的值，定义时不同的数据类型用 <code>|</code> 隔开，当被赋值不符合联合类型时会报错。</p><blockquote class="pullquote warning"><p><strong>上面联合类型的写法如果多处相同会让代码冗余，在 <code>TS</code> 中提供了 <code>type</code> 关键字来声明类型，用法如下。</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冗余的写法</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> z: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后...</span></span><br><span class="line"><span class="keyword">type</span> MyType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">let</span> x: MyType = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> y: MyType = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> z: MyType = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>被定义联合类型的变量可以通过类型断言指定为更具体的类型，不可以指定联合类型中不包含的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">value = <span class="string">'hello'</span>;</span><br><span class="line">value = <span class="number">10</span>;</span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((value <span class="keyword">as</span> <span class="built_in">string</span>).length); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>断言的语法是将变量使用 <code>as</code> 关键字指定要断言的类型，上面代码中因为变量 <code>value</code> 值最后已经是布尔，而强行将 <code>value</code> 指定为 <code>string</code> 类型去获取 <code>length</code> 属性报错，因为布尔值无法调用 <code>length</code> 属性。</p><h4 id="值的联合"><a href="#值的联合" class="headerlink" title="值的联合"></a>值的联合</h4><p>值的联合（又叫字面量联合）与联合类型不同的是，联合类型只是指定了变量的值类型必须为哪几种，而值的联合则限定了变量的值，变量赋值必须是值的联合中的其中某一个，否则报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: <span class="number">1</span> | <span class="number">6</span> | <span class="number">10</span>;</span><br><span class="line">point = <span class="number">10</span>;</span><br><span class="line">point = <span class="string">'hello'</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> level: <span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'C'</span>;</span><br><span class="line">level = <span class="string">'B'</span>;</span><br><span class="line">level = <span class="string">'b'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 <code>TS</code> 中，数组是引用类型，定义一个数组类型时需要定义数组内部元素的类型。</p><figure class="highlight ts"><figcaption><span>普通数组类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: <span class="built_in">string</span>[] = [<span class="string">'Jim'</span>, <span class="string">'Peter'</span>];</span><br><span class="line"><span class="keyword">let</span> ages: <span class="built_in">number</span>[] = [<span class="number">18</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>泛型定义（泛型会在后面详细说明）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'Jim'</span>, <span class="string">'Peter'</span>];</span><br><span class="line"><span class="keyword">let</span> ages: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">18</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>上面两种方式定义的数组内元素类型必须统一，如果让数组内部元素类型不同该怎么办，在 <code>TS</code> 中有一种特殊的数组类型定义叫做 “元组类型”（<code>tuple</code>）。</p><figure class="highlight ts"><figcaption><span>元组类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Jim'</span>, <span class="number">18</span>];</span><br></pre></td></tr></table></figure><p><strong>元组类型和数组类型的特点如下表：</strong></p><table><thead><tr><th style="text-align:left">元组</th><th style="text-align:left">数组</th></tr></thead><tbody><tr><td style="text-align:left">元素可以是不同类型</td><td style="text-align:left">元素必须为相同类型</td></tr><tr><td style="text-align:left">有预定的长度</td><td style="text-align:left">没有预定的长度</td></tr><tr><td style="text-align:left">用于表示一个结构</td><td style="text-align:left">用于表示一个列表</td></tr></tbody></table><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型是 <code>JS</code> 中所不包含的数据类型，通过 <code>enum</code> 关键字定义，在业务需求中经常会出现某个业务类型对应固定的值，前后端交互的参数都是通过这个值进行约束和传递的。</p><h4 id="普通枚举"><a href="#普通枚举" class="headerlink" title="普通枚举"></a>普通枚举</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Gender &#123;</span><br><span class="line">  BOY,</span><br><span class="line">  GIRL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">  MONDAY = <span class="string">'1'</span>,</span><br><span class="line">  TUESDAY = <span class="string">'2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>编译后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Gender;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Gender</span>) </span>&#123;</span><br><span class="line">  Gender[Gender[<span class="string">"BOY"</span>] = <span class="number">0</span>] = <span class="string">"BOY"</span>;</span><br><span class="line">  Gender[Gender[<span class="string">"GIRL"</span>] = <span class="number">1</span>] = <span class="string">"GIRL"</span>;</span><br><span class="line">&#125;)(Gender || (Gender = &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Week;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Week</span>) </span>&#123;</span><br><span class="line">  Week[<span class="string">"MONDAY"</span>] = <span class="string">"1"</span>;</span><br><span class="line">  Week[<span class="string">"TUESDAY"</span>] = <span class="string">"2"</span>;</span><br><span class="line">&#125;)(Week || (Week = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>从编译结果来看，枚举类型编译成 <code>JS</code> 后帮助我们创建了一个类似于映射表的同名对象，所以可以在 <code>TS</code> 中通过对象属性的方式获取枚举的值。</p><figure class="highlight ts"><figcaption><span>获取枚举值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Gender.BOY); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Week.MONDAY); <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure><h4 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h4><p>常数枚举的的语法是在创建枚举的 <code>enum</code> 关键字前使用 <code>const</code> 声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  RED,</span><br><span class="line">  YELLOW,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [Colors.RED, Colors.YELLOW, Colors.BLUE];</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>编译后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">0</span> <span class="comment">/* RED */</span>, <span class="number">1</span> <span class="comment">/* YELLOW */</span>, <span class="number">2</span> <span class="comment">/* BLUE */</span>];</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>常数枚举与普通枚举的不同是，在编译阶段不会为枚举的类型创建对象，使用枚举类型值的位置直接编译成对应的枚举值。</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数类型定义"><a href="#参数类型定义" class="headerlink" title="参数类型定义"></a>参数类型定义</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在函数中经常会定义可选参数，即非必传，但是 <code>TS</code> 中函数如果按照上面方式定义在调用时不传会报错，可选参数的类型定义如下。</p><figure class="highlight ts"><figcaption><span>可选参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">people</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people(<span class="string">'jim'</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>?:</code> 替代 <code>:</code>，即代表该参数为可选参数，在 <code>TS</code> 中也支持使用默认参数和剩余参数，使用方式如下。</p><figure class="highlight ts"><figcaption><span>默认参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">sum: <span class="built_in">number</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>剩余参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">prefix: <span class="built_in">string</span>, ...args: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix + args.reduce(<span class="function">(<span class="params">sum, val</span>) =&gt;</span> sum + val, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="string">'$'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>在使用默认参数和剩余参数时，设置的参数初始值和传入的剩余参数与定义类型不符合，则会报错。</p><h4 id="返回值类型定义"><a href="#返回值类型定义" class="headerlink" title="返回值类型定义"></a>返回值类型定义</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊的返回值类型：</strong></p><ul><li><code>never</code>：是其他类型的子类型，代表不会出现的值，作为没有返回值的返回类型，函数无法执行完；</li><li><code>void</code>：表示没有任何类型，指函数没有返回值，函数可以正常执行完，如果一个函数没有返回值，则 <code>TS</code> 认为返回值为 <code>void</code> 类型。</li></ul><figure class="highlight ts"><figcaption><span>never 为返回值类型的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">nerver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">nerver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个函数返回值设置为 <code>never</code>，因为抛错和死循环导致都没有执行完毕，此时函数编译不会报错。</p><figure class="highlight ts"><figcaption><span>void 为返回值类型的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>fn2</code> 函数只在非严格检查模式下不会报错，非严格检查模式下返回值类型被定义为 <code>void</code> 的函数可以返回 <code>null</code> 和 <code>undefined</code>。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>之前的函数参数和返回值类型定义是函数声明的方式，声明函数同样有另外一种方式，函数表达式，即给变量赋值为函数，那如何为接收函数的变量定义类型呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fullName: <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">fullName = <span class="function"><span class="keyword">function</span> (<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>括号中 <code>x</code> 和 <code>y</code> 代表定义参数的类型，箭头后代表定义返回值的类型，也可以使用 <code>type</code> 关键字进行声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fn = <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fullName: Fn = <span class="function"><span class="keyword">function</span> (<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>赋值函数的参数类型必须与变量声明的函数参数类型严格一致，返回值同理。</strong></p></blockquote><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是强类型语言中的特性，在 <code>Java</code> 中代表多个同名函数参数不相同，而在 <code>TS</code> 中有所不同，代表为同一个函数提供多个参数类型及返回值定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">type</span> MyType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载限定函数 double</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">boolean</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: MyType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) <span class="keyword">return</span> val + val;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) <span class="keyword">return</span> <span class="number">2</span> * val;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) <span class="keyword">return</span> !val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double(<span class="string">'hello'</span>); <span class="comment">// hellohello</span></span><br><span class="line">double(<span class="number">5</span>); <span class="comment">// 10</span></span><br><span class="line">double(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>重载限定某个函数的方式只有函数声明、函数名、参数及返回值的类型，而没有函数体。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p><code>TS</code> 类的定义与 <code>JS</code> 相同，使用 <code>class</code> 关键字声明，但可以直接对属性、方法定义参数类型和返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  getName(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">'neil'</span>;</span><br><span class="line">p.getName(); <span class="comment">// neil</span></span><br></pre></td></tr></table></figure><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>在 <code>TS</code> 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为，并可以定义存取器的参数及返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  myName: <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">myName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(newVal: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// neil</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'jim'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// jim</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>上面都在类中定义属性，也可以使用参数属性进行简化，代码如下。</p><figure class="highlight ts"><figcaption><span>简化前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>简化后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> myName: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.myName); <span class="comment">// neil</span></span><br></pre></td></tr></table></figure><p><code>public</code> 修饰符写在 <code>constructor</code> 的参数前，代表创建一个与参数同名的公有属性。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>在 <code>TS</code> 中可以在类中定义只读属性，只需要通过 <code>readonly</code> 修饰符修饰即可，只在编译阶段进行检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> readonly myName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.myName); <span class="comment">// neil</span></span><br><span class="line">p.myName = <span class="string">'jim'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>不同类别的（非互斥）的修饰符可以同时修饰一个变量，使用空格隔开。</strong></p></blockquote><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>类与类之间通过 <code>extends</code> 关键字实现继承，子类继承父类后拥有父类的属性和方法，可以增强代码的复用性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  hobby: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, hobby: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">    <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">  &#125;</span><br><span class="line">  getHobby(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hobby;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child(<span class="string">'neil'</span>, <span class="number">20</span>, <span class="string">'swim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.getHobby()); <span class="comment">// swim</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getName()); <span class="comment">// neil</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getAge()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>在 <code>TS</code> 的类中有三种访问控制修饰符，分别为 <code>public</code>、<code>protected</code> 和 <code>private</code>。</p><ul><li><code>public</code>：公有的属性，所有地方都能访问；</li><li><code>protected</code>：受保护的的属性，只能在自己和自己的子类中被访问；</li><li><code>private</code>：私有属性，只有自己内部可以访问。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> money: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, money: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.money = money;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.money);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.money); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中 <code>name</code> 属性可以通过父类的实例访问、子类的实例访问，父类的 <code>getName</code> 方法访问，子类的 <code>getName</code> 方法访问，<code>age</code> 属性可以只能通过父类和子类的 <code>getAge</code> 方法访问，<code>money</code> 属性只能通过父类 <code>getMoney</code> 方法访问，其他不被允许的访问方式都会报错。</p><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>在 <code>TS</code> 中给类定义私有属性和方法的修饰符为 <code>static</code>，与 <code>JS</code> 的类相同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Father &#123;</span><br><span class="line">  <span class="keyword">static</span> myName: <span class="built_in">string</span> = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">static</span> getMyName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Father.myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Father.myName); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.getMyName()); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种抽象的概念，使用 <code>abstract</code> 关键字定义，无法被实例化（无法使用 <code>new</code>），只能被继承。</p><p>抽象类的内部包含抽象方法和抽象属性，同样使用 <code>abstract</code> 关键字定义，抽象方法不能在抽象类中实现，具体实现细节只能在抽象类的子类中实现，而且必须实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">abstract</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">abstract</span> speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'喵喵喵'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>继承抽象类的子类中必须包含所有抽象类中所定义的内容，继承中这种子类覆盖抽象类所定义抽象方法的行为叫做 “重写”，多个子类创建不同的抽象方法的现象被叫做 “多态”。</strong></p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口是 <code>TS</code> 中的核心之一，主要有两个作用：</strong></p><ul><li>用于描述或约束一种对象结构，描述属性的名称和值的类型；</li><li>用来表示行为的抽象，让类去实现接口。</li></ul><h3 id="接口的定义和使用"><a href="#接口的定义和使用" class="headerlink" title="接口的定义和使用"></a>接口的定义和使用</h3><p><code>TS</code> 中使用 <code>interface</code> 关键字来定义接口，接口成员可以是属性或方法名，多个成员可以使用分号、逗号或换行隔开，主要定义属性的名称和值的类型。</p><figure class="highlight ts"><figcaption><span>定义接口，使用接口创建对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: UserInterface = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面 <code>UserInterface</code> 接口创建的对象 <code>user</code>，属性和值的类型必须与定义的接口严格对应。</p><figure class="highlight ts"><figcaption><span>让类去实现定义的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Flyable &#123;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bird <span class="keyword">implements</span> Flyable &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bird fly'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让类实现一个接口使用 <code>implements</code> 关键字，接口在定义方法时与抽象类非常类似，只需要定义方法和类型，不需要具体实现，在实现接口的类中对方法进行具体实现。</p><figure class="highlight ts"><figcaption><span>一个类实现多个接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> Speakable &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Eatable &#123;</span><br><span class="line">  food: <span class="built_in">string</span>;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Speakable, Eatable &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>;</span><br><span class="line">  food: <span class="string">'cake'</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat cake'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong>继承与实现接口的区别是，一个类可以实现多个接口，一个接口可以被多个类实现，而一个父类（包含抽象类）可以被多个类所继承，一个子类只能继承一个父类（单继承）。</strong></p></blockquote><h3 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h3><p>接口中可以定义只读属性，这样通过接口创建的对象的值在修改时会报错，可以在定义接口属性是加上 <code>readonly</code> 修饰符实现。</p><figure class="highlight ts"><figcaption><span>接口的只读属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>;</span><br><span class="line">  name: <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// 1</span></span><br><span class="line">p.name = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h3><p>在上面接口定义时，创建的对象和实现接口类的属性方法都必须与接口定义的属性名、类型一致，其实在接口定义时也可以定义一些非必须的可选属性，在使用接口创建对象或使用类实现接口时，这样的属性不定义不会报错。</p><figure class="highlight ts"><figcaption><span>接口的可选属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Person = &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  name: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义接口的可选属性与函数定义可选参数类似，都是使用 <code>?:</code> 替代原本的 <code>:</code> 即代表可选。</p><h3 id="接口的未知属性"><a href="#接口的未知属性" class="headerlink" title="接口的未知属性"></a>接口的未知属性</h3><p>当接口中存在可选属性时，也只是满足某些属性可以在使用接口时（对象、类），可选属性可以不创建，但是如果对象和类上扩展了未知的其他任意属性，则编译会报错，此时定义接口未知属性，可以解决编译时报错的问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  [proName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong><code>proName</code> 名字是任意的，可以随意取，<code>string</code> 代表属性的类型，<code>any</code> 代表属性值的类型，上面的写法不固定，可以根据需求定义，只需满足 <code>[name: type]: type</code> 的结构即可。</strong></p></blockquote><p>根据上面的未知属性格式可以衍生出 “可索引接口” 专门用来限制长度未知的数组、属性名和属性个数未知的对象。</p><p><strong>可索引接口限制数组和对象：</strong></p><figure class="highlight ts"><figcaption><span>限制数组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userArr: UserInterface = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">userArr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">1</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面的数组 <code>userArr</code> 内的的索引为数字类型，满足可索引接口的要求，但是使用 <code>UserInterface</code> 约束后，所有项必须是字符串，如果改成其他类型则会报错。</p><figure class="highlight ts"><figcaption><span>限制对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userObj: UserInterface = &#123;</span><br><span class="line">  jim: <span class="string">'1'</span>,</span><br><span class="line">  bob: <span class="string">'2'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的对象 <code>userObj</code> 使用 <code>UserInterface</code> 约束后，键和值必须都为字符串，否则报错。</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口的继承同类的继承相同，使用 <code>extends</code> 关键字实现，下面是一段接口继承的代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父接口</span></span><br><span class="line"><span class="keyword">interface</span> Speakable &#123;</span><br><span class="line">  speak(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子接口</span></span><br><span class="line"><span class="keyword">interface</span> SpeakChinese <span class="keyword">extends</span> Speakable &#123;</span><br><span class="line">  speakChinese(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现接口</span></span><br><span class="line"><span class="keyword">class</span> ChinesePerson <span class="keyword">implements</span> SpeakChinese &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'speak'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  speakChinese() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你好'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>当类实现的接口继承了其他的接口，那这个类的内部需要同时实现子接口和父接口的属性和方法。</strong></p></blockquote><h3 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h3><p>函数型接口专门对函数或方法传入的参数和返回值进行约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Discount &#123;</span><br><span class="line">  (price: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dFun: Discount = discount;</span><br></pre></td></tr></table></figure><p>上面代码中 <code>Discount</code> 接口内部括号内代表参数类型定义，后面代表返回值类型，函数 <code>discount</code> 定义的参数和返回值类型必须与 <code>Discount</code> 接口内部定义的类型保持一致。</p><h3 id="构造函数型接口"><a href="#构造函数型接口" class="headerlink" title="构造函数型接口"></a>构造函数型接口</h3><p>在 <code>TS</code> 中存在对构造函数或类的实例化的类型约束，即在执行 <code>new</code> 操作的时候进行约束检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被约束实例化动作的类</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束实例化的接口</span></span><br><span class="line"><span class="keyword">interface</span> WithNameClazz &#123;</span><br><span class="line">  <span class="keyword">new</span>(name: <span class="built_in">string</span>): Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params">clazz: WithNameClazz, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> clazz(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = createAnimal(Animal, <span class="string">'hellop'</span>);</span><br></pre></td></tr></table></figure><p>上面代码的 <code>interface</code> 中，<code>new</code> 代表约束的动作为实例化操作，<code>name</code> 为参数，<code>string</code> 为参数的类型，而 <code>Animal</code> 代表返回值需要是一个 <code>Animal</code> 类的实例。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>“泛型” 是指在定义函数、接口和类的时候，不预先指定具体的类型，而在使用的时候再进行指定的一种特性。</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>在介绍泛型函数之前先创建一个普通的函数，参数为长度和值，返回一个长度为传入长度、内部元素都为传入值的数组。</p><figure class="highlight ts"><figcaption><span>为使用泛型定义的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">len: <span class="built_in">number</span>, val: <span class="built_in">any</span></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: <span class="built_in">any</span>[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result[i] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray(<span class="number">3</span>, <span class="string">'x'</span>)); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><p>在上面函数中我们类型都是提前进行定义，包括参数、返回值和函数内部变量，这样如果函数内给数组每一项赋值操作没有使用 <code>val</code> 参数传入的值，而是使用其他值，这样无法进行限定，下面使用泛型重新编写上面的函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">len: <span class="built_in">number</span>, val: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result[i] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="number">1</span>)); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面的 <code>T</code> 是泛型的占位符，代表 <code>Type</code> 的意思，也可以使用其他字母代替（类比函数的形参），真正定义类型的时候是在函数调用时传入的。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyArray&lt;T&gt; &#123;</span><br><span class="line">  list: T[] = [];</span><br><span class="line">  add(val: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">  getFirst(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = <span class="keyword">new</span> MyArray&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myArray.add(<span class="number">1</span>);</span><br><span class="line">myArray.add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray.getFirst());</span><br></pre></td></tr></table></figure><p>泛型类与泛型函数相似，都是通过占位符 <code>T</code> 占位，在真正实例化的时候传入类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>上面接口一节中接口内部属性及函数型接口等，成员类型也可以使用泛型进行约束，在某个具体的对象使用接口或类实现接口时传入具体类型，下面是一个函数型接口使用泛型的例子。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SUM&lt;T&gt; &#123;</span><br><span class="line">  (a: T, b: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum2: SUM&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="keyword">function</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>泛型占位符（上面为 <code>T</code>）只在约束的函数、类和接口内部可以使用，可类比函数的形参。</strong></p></blockquote><h3 id="默认泛型类型"><a href="#默认泛型类型" class="headerlink" title="默认泛型类型"></a>默认泛型类型</h3><p>默认泛型类型指的是定义泛型的默认值，被约束的函数、类或者接口在使用时不传入具体类型，则会使用默认类型，编译时会检查是否符合这个默认类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyArray&lt;T = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  list: T[] = [];</span><br><span class="line">  add(val: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = <span class="keyword">new</span> MyArray();</span><br><span class="line">myArray.add(<span class="number">1</span>);</span><br><span class="line">myArray.add(<span class="string">'a'</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="定义多个泛型"><a href="#定义多个泛型" class="headerlink" title="定义多个泛型"></a>定义多个泛型</h3><p>上面的泛型中都只使用了一个占位符 <code>T</code>，其实泛型是允许有多个的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt;(<span class="params">tuple: [A, B]</span>): [<span class="title">B</span>, <span class="title">A</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(swap&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;([<span class="string">'a'</span>, <span class="number">1</span>])); <span class="comment">// [1, 'a']</span></span><br></pre></td></tr></table></figure><p>上面方法中定义了两个泛型，函数参数为一个元组类型的数组，函数返回值为两项交换后的数组。</p><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><p>在函数或类中使用泛型，由于预先不知道泛型的具体类型，所以不能随便使用泛型约束变量的属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span>&gt;(<span class="params">val: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h3><p>如果一定要在函数或类中使用泛型约束变量的属性和方法时，可以预先通过接口定义使用的属性和方法，再通过泛型去继承这个接口即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> LengthWise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">LengthWise</span>&gt;(<span class="params">val: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger&lt;<span class="built_in">number</span>&gt;(<span class="string">'hello'</span>); <span class="comment">// 报错</span></span><br><span class="line">logger&lt;<span class="built_in">string</span>&gt;(<span class="string">'hello'</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="泛型的流程控制"><a href="#泛型的流程控制" class="headerlink" title="泛型的流程控制"></a>泛型的流程控制</h3><p>在定义泛型的时候能够加入逻辑分支，可以使泛型更加灵活。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  nameFish: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Water &#123;</span><br><span class="line">  nameWater: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  nameBird: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sky &#123;</span><br><span class="line">  nameSky: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Condition&lt;T&gt; = T <span class="keyword">extends</span> Fish ? Water : Sky;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> con: Condition&lt;Fish&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了四个接口 <code>Fish</code>、<code>Bird</code>、<code>Water</code> 和 <code>Sky</code>，定义一个 <code>Condition</code> 类型和泛型，如果泛型为 <code>Fish</code> 则继承 <code>Water</code>，否则继承 <code>Sky</code>，在变量 <code>con</code> 使用类型 <code>Condition</code> 时，传入 <code>Fish</code> 接口。</p><h3 id="泛型的别名"><a href="#泛型的别名" class="headerlink" title="泛型的别名"></a>泛型的别名</h3><p>泛型可以使用 <code>type</code> 关键字定义别名，还记得在基本数据类型一节数组的定义中有泛型的定义方式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br></pre></td></tr></table></figure><p>其实上面的 <code>Array</code> 就是定义泛型的别名，<code>&lt;string&gt;</code> 则是在调用这个泛型时传入的具体类型，看了下面例子就明白了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型别名</span></span><br><span class="line"><span class="keyword">type</span> Cart&lt;T&gt; = &#123; list: T[] &#125; | T[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型别名</span></span><br><span class="line"><span class="keyword">let</span> cart1: Cart&lt;<span class="built_in">string</span>&gt; = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">let</span> cart2: Cart&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  list: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>JS</code> 中有很多类数组对象，如 <code>arguments</code>、获取的 <code>DOM</code> 元素集合等等，每一种类数组对象 <code>TS</code> 都定义了对应的泛型别名，下面看两个案例。</p><figure class="highlight ts"><figcaption><span>arguments 对象的泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> params: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">    result += params[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>DOM 节点类数组对象的泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">let</span> children: HTMLCollection = root.children;</span><br><span class="line"><span class="keyword">let</span> childNodes: NodeListOf&lt;ChildNode&gt; = root.childNodes;</span><br></pre></td></tr></table></figure><p>上面用来定义 <code>arguments</code> 类数组对象的泛型别名为 <code>IArguments</code>，获取 <code>DOM</code> 节点的元素节点集合的泛型别名为 <code>HTMLCollection</code>，而全部子节点的泛型别名为 <code>NodeListOf&lt;ChildNode&gt;</code>，如果使用 <code>VSCode</code> 编辑器，可以将鼠标放在变量前面会自动提示对应的泛型别名。</p><blockquote class="pullquote info"><p><strong>接口和泛型别名的区别：</strong></p><ul><li><strong>接口会创建一个新的名称，而别名不会（只是用 <code>type</code> 关键字创建了一个变量）；</strong></li><li><strong>别名不能被继承和实现；</strong></li><li><strong>定义一个类型的时候使用接口，要使用联合类型或者元组类型时，类型别名会更合适。</strong></li></ul></blockquote><h2 id="结构类型系统"><a href="#结构类型系统" class="headerlink" title="结构类型系统"></a>结构类型系统</h2><p>如果传入的变量和声明的类型不匹配，<code>TS</code> 会进行兼容性检查，不是基于定义的类型名称来决定的，而是基于类型的组成结构。</p><h3 id="基本数据类型的兼容性"><a href="#基本数据类型的兼容性" class="headerlink" title="基本数据类型的兼容性"></a>基本数据类型的兼容性</h3><p>基本数据类型也有兼容性判断，如果赋值过程中右侧值的类型符合左侧值的类型，则不会报错，如果左侧类型定义含有 <code>toString</code> 方法的约束，则右侧值凡是可以通过 <code>toString</code> 转换成字符串的都不会报错，赋值时如果右侧值传入的属性多余左侧定义的值时也会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> str1: <span class="built_in">string</span>;</span><br><span class="line">num1 = str1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num2: &#123;</span><br><span class="line">  toString(): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str2: <span class="built_in">number</span>;</span><br><span class="line">num2 = str2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="string">'male'</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="枚举的兼容性"><a href="#枚举的兼容性" class="headerlink" title="枚举的兼容性"></a>枚举的兼容性</h3><p>默认的枚举类型与数字类型兼容，数字类型与枚举类型兼容，不同的枚举类型之间是不兼容的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  RED,</span><br><span class="line">  YELLOW,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容数字类型</span></span><br><span class="line"><span class="keyword">let</span> colorRed: <span class="built_in">number</span> = Colors.RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容枚举类型</span></span><br><span class="line"><span class="keyword">let</span> colorYello: Colors;</span><br><span class="line">colorYello = Colors.Red;</span><br><span class="line">colorYello = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="函数的兼容性"><a href="#函数的兼容性" class="headerlink" title="函数的兼容性"></a>函数的兼容性</h3><p>比较函数的兼容性时要先比较函数的参数，再比较函数的返回值。</p><h4 id="参数的兼容性"><a href="#参数的兼容性" class="headerlink" title="参数的兼容性"></a>参数的兼容性</h4><figure class="highlight ts"><figcaption><span>参数的类型比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SumFunc = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> sum: SumFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错的赋值</span></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错的赋值</span></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的类型检查可以兼容少传参数或不传参数，但是多传参数会报错。</p><h4 id="参数的双向协变"><a href="#参数的双向协变" class="headerlink" title="参数的双向协变"></a>参数的双向协变</h4><p>参数的双向协变是指变量定义的参数类型去兼容变量赋值定义的参数类型，或者变量赋值的参数类型去兼容定义的参数类型，只要有一个成立即可，所谓兼容必须是包含的关系。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogFunc = <span class="function">(<span class="params">val: <span class="built_in">number</span> | <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> log: LogFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量定义类型兼容赋值定义类型</span></span><br><span class="line">log = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量赋值类型兼容变量定义的类型</span></span><br><span class="line">log = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回值的兼容性"><a href="#返回值的兼容性" class="headerlink" title="返回值的兼容性"></a>返回值的兼容性</h4><figure class="highlight ts"><figcaption><span>返回值的类型比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetPerson = <span class="function"><span class="params">()</span> =&gt;</span> &#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> getPerson: GetPerson;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错的赋值</span></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span>, age: <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span>, age: <span class="number">20</span>, gender: <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错的赋值</span></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能调用 age 属性的方法</span></span><br><span class="line">getPerson().age.toFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>返回值可以兼容多返回的属性，属性少了会报错，因为可能会调用返回值缺失属性的方法。</p><h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">let</span> c1: Child = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Parent = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">let</span> c2: Child = <span class="keyword">new</span> Parent(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>父类和子类能不能赋值给限制了父类或子类泛型的变量，能不能赋值和是父类或子类没任何关联，主要看属性是否满足，而上面 <code>p2</code> 没有报错的原因是子类的实例继承了父类的属性，所以提供了父类泛型所要求的属性，而 <code>c2</code> 报错是因为父类的实例并没有提供子类泛型要求的属性。</p><h3 id="接口的兼容性"><a href="#接口的兼容性" class="headerlink" title="接口的兼容性"></a>接口的兼容性</h3><p>在检查参数类型时，并不是真正的比较接口类型，而是比较具体的属性是否兼容。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">a: Animal</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName(p); <span class="comment">// hello;</span></span><br></pre></td></tr></table></figure><p>上面的代码中定义了两个接口 <code>Animal</code> 和 <code>Person</code>，<code>Person</code> 定义的属性更多，当一个符合 <code>Person</code> 的对象传给参数用 <code>Animal</code> 约束的函数时，检测的是接口的属性，只要提供的属性不比约束的属性少，则不会报错。</p><h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><p>泛型在判断兼容性的时候会先判断具体类型，再进行兼容性的判断，即用到了就会比较，没用到就不会比较。</p><figure class="highlight ts"><figcaption><span>空接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>属性使用了泛型的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">x = y; <span class="comment">// 报错，因为 number 类型的属性不能赋值给 string 类型的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">interface</span> NotEmptyString&#123;</span><br><span class="line">  data: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NotEmptyNumber&#123;</span><br><span class="line">  data: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xString: NotEmptyString;</span><br><span class="line"><span class="keyword">let</span> yNumber: NotEmptyNumber;</span><br><span class="line">xString = yNumber; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>类型保护就是一些表达式在编译时，能通过类型信息确保某个具体作用域内变量的类型。</p><h3 id="typeof-和-instanceof-类型保护"><a href="#typeof-和-instanceof-类型保护" class="headerlink" title="typeof 和 instanceof 类型保护"></a>typeof 和 instanceof 类型保护</h3><figure class="highlight ts"><figcaption><span>typeof 类型保护</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val.repeat(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法因为使用 <code>typeof</code> 做了类型判断，所以分别在 <code>if</code> 判断的作用域内 <code>val</code> 的值会变成判断后对应的类型，可以调用类型对应的方法，而在判断的外面无法确认值的类型，调用方法编译时报错。</p><figure class="highlight ts"><figcaption><span>instanceof 类型保护</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bird &#123;</span><br><span class="line">  nameBird: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">  nameDog: stirng;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.nameBird;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.nameDog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>typeof</code> 类似，使用 <code>instanceof</code> 判断了函数 <code>getName</code> 是否是 <code>Bird</code> 和 <code>Dog</code> 类的实例，判断的作用域内可以获取判断结果对应类上定义的属性。</p><h3 id="null-类型保护"><a href="#null-类型保护" class="headerlink" title="null 类型保护"></a>null 类型保护</h3><p>之前我们提到过在 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性设置为 <code>true</code> 时，则会对 <code>null</code> 进行严格检查，此时下面代码将会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的报错就是由于对 <code>null</code> 的类型保护引起的，有如下解决方法。</p><figure class="highlight ts"><figcaption><span>方法一</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>方法二</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式第一种是通过设置初始值的方式来保证在调用字符串方法时 <code>str</code> 的值已经是一个字符串类型，第二种则是通过判断直接返回，没有走到调用字符串方法的代码，类型检查自然不会报错，下面还有一个稍微复杂的案例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str.tirm()); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  log();</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>str</code> 调用 <code>tirm</code> 方法的代码封装在了函数 <code>log</code> 内部，当 <code>log</code> 调用时 <code>str</code> 的值已经变为了字符串，但是还是报错了，原因是代码编译阶段由上至下一行一行解析，所以解析函数 <code>log</code> 的时候就已经在函数内部报错了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str!.tirm());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  log();</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在 <code>log</code> 函数中，<code>str</code> 调用 <code>tirm</code> 方法时加了一个 <code>!</code>，意思为强行调用，不管类型是否符合都会调用，相当于忽略了函数 <code>getFirstLetter</code> 的参数类型检查。</p><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>上面的强制调用方式虽然通能过编译，但是在运行时有报错的风险，应该慎用，在 <code>JS</code> 中有一个提案叫链判断运算符，针对上面情况，会先判断是否为字符串再去调用字符串方法，这样写起来比较繁琐，而链判断运算符就是用来解决这个问题，通过 <code>?.</code> 来调用。</p><figure class="highlight js"><figcaption><span>链判断运算符的几种用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a?.b;</span><br><span class="line"><span class="comment">// 如果 a 不含有 b 属性则返回 undefined，否则返回 a.b，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b;</span><br><span class="line"></span><br><span class="line">a?.[b];</span><br><span class="line"><span class="comment">// 如果 a 不含有键为 b 变量值的属性则返回 undefined，否则返回 a[b]，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[b];</span><br><span class="line"></span><br><span class="line">a?.b()</span><br><span class="line"><span class="comment">// 如果 a 不含 b 属性则返回 undefined，否则执行 a.b()</span></span><br><span class="line"><span class="comment">// 如果 a.b 不是一个函数抛出类型错误，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b();</span><br><span class="line"></span><br><span class="line">a?.()</span><br><span class="line"><span class="comment">// 如果 a 不是函数则返回 undefined，否则执行 a()，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a();</span><br></pre></td></tr></table></figure><h3 id="可辨识的联合类型"><a href="#可辨识的联合类型" class="headerlink" title="可辨识的联合类型"></a>可辨识的联合类型</h3><p>可辨识的联合类型是指，通过联合类型中的共同属性进行类型保护的一种技巧，通过同属性值的判断可以确定联合类型中的具体类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> WarningButton &#123;</span><br><span class="line">  <span class="keyword">class</span>: <span class="string">'warning'</span>;</span><br><span class="line">  name1: <span class="string">'modified'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> DangerButton &#123;</span><br><span class="line">  <span class="keyword">class</span>: <span class="string">'danger'</span>;</span><br><span class="line">  name2: <span class="string">'delete'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义联合类型</span></span><br><span class="line"><span class="keyword">type</span> Button = WarningButton | DangerButton;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getButton</span>(<span class="params">button: Button</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (button.class === <span class="string">'warning'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> button.name1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (button.class === <span class="string">'danger'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> button.name2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h3><p>在可辨识的联合类型中如果没有共同的属性，共同属性判断不同值区分的方法行不通，这时可以用 <code>in</code> 操作符和不同属性判断进行类型保护。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  talon: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'talon'</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.talon);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'leg'</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.leg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p><code>TS</code> 中的上面用到的类型保护大部分为表达式，其实可以不使用这些表达式，通过自定义类型保护函数的方式实现同样的效果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  talon: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型保护函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBird</span>(<span class="params">animal: Bird | Dog</span>): <span class="title">animal</span> <span class="title">is</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// return (animal as Bird).talon &gt; 0;</span></span><br><span class="line">  <span class="keyword">return</span> (&lt;Bird&gt;animal).talon &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isBird(animal)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.talon);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.leg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的自定义保护函数 <code>isBird</code> 中参数类型与 <code>getNumber</code> 参数一致，返回值的 <code>animal is Bird</code> 是一个类型谓词，语法为 <code>param is type</code>，代表返回是否满足 <code>Bird</code> 接口，由于 <code>animal</code> 并不知道自己符合哪一个接口，所以使用类型断言指定成了 <code>Bird</code>，<code>isBird</code> 代码中注释和非注释两种方式都可以实现类型断言，这样自定义类型检查函数 <code>isBird</code> 就可以在 <code>getNumber</code> 中使用并实现类型保护。</p><h2 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型表示为将多个类型合并为一个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取的是接口的并集</span></span><br><span class="line"><span class="keyword">type</span> BirdMan = Bird &amp; Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口必须包含两个接口所有的属性和方法</span></span><br><span class="line"><span class="keyword">let</span> birdMan: BirdMan = &#123;</span><br><span class="line">  name: <span class="string">'niao'</span>,</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fly'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="typeof-获取类型"><a href="#typeof-获取类型" class="headerlink" title="typeof 获取类型"></a>typeof 获取类型</h3><p>在 <code>TS</code> 使用时如果数据内容在变化，要不停的更改对应的接口，此时可以使用 <code>typeof</code> 关键字快速获取一个变量的类型。</p><figure class="highlight ts"><figcaption><span>先定义类型，后定义变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>先定义变量，后定义接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People = <span class="keyword">typeof</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">p: People</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取的类型定义 <code>People</code> 是根据 <code>p</code> 对象的属性和值生成，然后可以使用获取的类型去限制其他对象。</p><h3 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h3><p><code>TS</code> 中的索引访问操作符指可以通过 <code>[]</code> 获取一个类型的子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义嵌套类型接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 对象，包含 name 属性</span></span><br><span class="line">  job: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 成员为对象组成的数组，对象中含有 name 和 level 属性</span></span><br><span class="line">  hobbies: &#123; name: <span class="built_in">string</span>; level: <span class="built_in">number</span> &#125;[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Person 接口 job 对象中 name 属性的类型定义为 FEJob 的类型</span></span><br><span class="line"><span class="keyword">let</span> FEJob: Person[<span class="string">"job"</span>] = &#123;</span><br><span class="line">  name: <span class="string">"FE"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中任意一项中 level 属性的类型作为 hobbyLevel 的类型</span></span><br><span class="line"><span class="keyword">let</span> hobbyLevel: Person[<span class="string">'hobbies'</span>][<span class="number">0</span>][<span class="string">'level'</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p><code>TS</code> 中定义的关键字 <code>keyof</code> 是索引类型查询操作符，用来定义类型，当定义一个获取对象属性值的函数，传入的值为对象和属性名，这样属性名参数的类型定义为 <code>string</code> 不准确，因为很可能传入一个对象本身没有的属性字符串，<code>keyof</code> 就是用来解决类似这样问题的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">'male'</span> | <span class="string">'female'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 keyof 定义类型</span></span><br><span class="line"><span class="keyword">type</span> PersonKey = keyof Person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValueByKey</span>(<span class="params">p: Person, key: PersonKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>: person: Person = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getValueByKey(person, <span class="string">'name'</span>); <span class="comment">// hello</span></span><br><span class="line">getValueByKey(person, <span class="string">'say'</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>在某一个类型定义中使用 <code>in</code> 操作符和 <code>keyof</code> 操作符批量映射修改一个新的类型定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">'male'</span> | <span class="string">'female'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射 Person 接口定义的类型，把每一个属性都变成可选的</span></span><br><span class="line"><span class="keyword">type</span> PartPerson = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof Person]?: Person[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: PartPerson = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中 <code>keyof Person</code> 取到了 <code>Person</code> 接口的每一个属性的类型，<code>key</code> 通过运算符 <code>in</code>（批量映射）代表获取的每一个属性名，<code>?:</code> 代表可选，<code>Person[key]</code> 代表对应的值。</p><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p>在 <code>TS</code> 内部内置了一些工具类型来帮助我们更好、更方便的使用类型系统。</p><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p><code>Partial</code> 可以将传入类型定义的属性由非可选变为可选，功能跟映射类型一节实现的功能非常相似，只是具体被映射的类型是通过参数传入的，所以底层是使用泛型实现的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Partial</span></span><br><span class="line"><span class="keyword">let</span> p: Partial&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial 的原理</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]?: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p><code>Required</code> 可以将传入类型定义的属性变为必选，使用 <code>-?:</code> 替换原有的 <code>:</code> 也可以实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Required</span></span><br><span class="line"><span class="keyword">let</span> p: Required&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Required 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyRequired&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]-?: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p><code>Readonly</code> 可以将传入类型定义的属性每一项都加上 <code>readonly</code> 修饰符来实现属性的只读。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Readonly</span></span><br><span class="line"><span class="keyword">let</span> p: Readonly&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'world'</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Readonly 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [key <span class="keyword">in</span> keyof T]: T[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p><code>Pick</code> 可以摘取传入类型定义的属性中的某一项返回。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Pick</span></span><br><span class="line"><span class="keyword">let</span> p: Pick&lt;Person, <span class="string">'name'</span>&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> K]: T[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置条件类型"><a href="#内置条件类型" class="headerlink" title="内置条件类型"></a>内置条件类型</h3><p>还记得在泛型一节中提到了泛型的流程控制，在 <code>TS</code> 中内置了一些常用的条件类型。</p><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">Exclude&lt;T, U&gt; <span class="comment">// 从 T 可分配给的类型中排除 U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">Extract&lt;T, U&gt; <span class="comment">// 从 T 可分配的类型中提取 U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = Extract&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="number">10</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">NonNullable&lt;T&gt; <span class="comment">// 从 T 中排除 null 和 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = NonNullable&lt;<span class="built_in">string</span> | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="literal">null</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">ReturnType&lt;T&gt; <span class="comment">// 获取函数类型的返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">"hello"</span>, age: <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo = ReturnType&lt;<span class="keyword">typeof</span> getUserInfo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: UserInfo = &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">InstanceType&lt;T&gt; <span class="comment">// 获取构造函数类型的实例类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name</span>) &#123;&#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P = InstanceType&lt;<span class="keyword">typeof</span> Person&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: P = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'myName'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/16/20190416160637/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NodeJS 实现一个提交自动检测的 Git Hook</title>
      <link>https://www.overtaking.top/2019/04/09/20190409024640/</link>
      <guid>https://www.overtaking.top/2019/04/09/20190409024640/</guid>
      <pubDate>Mon, 08 Apr 2019 18:46:40 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/2019/04/09/20190409024640/git-hooks-location.png&quot; title=&quot;Git Hook&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-Git-Hook&quot;&gt;&lt;a href=&quot;#什么是-Git-Hook&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/09/20190409024640/git-hooks-location.png" title="Git Hook"><p><br></p><h2 id="什么是-Git-Hook"><a href="#什么是-Git-Hook" class="headerlink" title="什么是 Git Hook"></a>什么是 Git Hook</h2><blockquote class="pullquote info"><p><code>Git Hook</code> 是能在 <code>Git</code> 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 <code>.git/hooks</code> 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 <code>.sample</code>，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。</p></blockquote><h2 id="实现-Hook-功能介绍"><a href="#实现-Hook-功能介绍" class="headerlink" title="实现 Hook 功能介绍"></a>实现 Hook 功能介绍</h2><p>本次将使用 <code>NodeJS</code> 实现一个 <code>Git Hook</code>，功能为在提交代码之前检测功能如下：</p><ul><li>检测是否为 <code>Git</code> 项目；</li><li>检测邮箱是否符合规格；</li><li>检测代码是否含有冲突；</li><li>自动执行 <code>Eslint</code>，并检测问题。</li></ul><h2 id="需求的由来"><a href="#需求的由来" class="headerlink" title="需求的由来"></a>需求的由来</h2><p>在开始代码的编写之前，一定要清楚，团队开发时为什么需要这样的 <code>hook</code>，下面列举的场景，可能都会对团队项目持续集成的历史树造成污染，或在协同开发时对团队成员造成麻烦。</p><p><strong>邮箱错误：</strong>当团队 <code>Gitlab</code> 仓库对邮箱格式进行了严格的限制，必须为公司邮箱才可以进行推送，这样很可能导致邮箱配错时进行了提交，而推送时发现邮箱错了，要对本地的 <code>commit</code> 记录修正，再重新进行推送。</p><blockquote class="pullquote warning"><p><strong>容易造成邮箱设置错误的常见原因：</strong></p><ul><li><strong>维护不同团队的开源项目太多，不同项目需要配置不同的邮箱，很可能导致邮箱配置错误；</strong></li><li><strong>当团队中有外包开发人员，且由于权限问题同一套代码是存放在两个仓库，正式员工需要在本地项目中通过 <code>remote</code> 来同时指定两个仓库地址，并在本地代码修改后拉取外包仓库的代码进行合并，同时同步到正式仓库和外包仓库，如果正式仓库对推送过来的提交邮箱格式进行了严格的限制，并且外包提交记录的邮箱错误，就导致正式员工合并后的提交被正式仓库拒绝，如果使用 <code>rebase</code> 强行修正错误的邮箱，变基后的 <code>commit</code> 哈希发生变化可能与远端仓库不一致，需要进行强推到两个仓库，并全员的本地回滚到变基之前。</strong></li></ul></blockquote><p><strong>代码冲突：</strong>开发时和其他人同时修改了相同部分造成冲突，如果冲突不能及时被发现，提交并推送到远端是对远端仓库的污染，也可能其他开发人员正好拉取了这样的代码，会对团队造成麻烦。</p><blockquote class="pullquote danger"><p><strong>容易造成冲突未及时处理的原因：</strong></p><ul><li><strong>项目过大，文件较多；</strong></li><li><strong>编辑器不智能；</strong></li><li><strong>前端项目使用了路由懒加载，不切换到冲突代码所在的路由，项目不会报错。</strong></li></ul></blockquote><p><strong>Eslint：</strong>有些团队的项目对代码规范要求高，并为了减小线上 <code>Bug</code> 率，会在项目中集成 <code>Eslint</code> 对代码风格进行检查，通常都是在命令行手动执行检测命令，有些时候可能忘记执行命令进行检测，就将代码进行了提交和推送。</p><blockquote class="pullquote default"><p>为了规避上面的情况，所以才有了这次关于 <code>Git Hook</code> 的需求，以及下面的代码实现，目的是防患于未然，将大家在开发时容易犯的错误或对项目代码持续集成和管理的潜在风险扼杀在摇篮中。</p></blockquote><h2 id="目录结构及文件简介"><a href="#目录结构及文件简介" class="headerlink" title="目录结构及文件简介"></a>目录结构及文件简介</h2><p><pre>git-hooks<br>  |- default-events.js<br>  |- default-rules.js<br>  |- git-checker.js<br>  |- pre-commit.js</pre></p><ul><li><code>default-events.js</code>：用来编写默认的检测事件；</li><li><code>default-rules.js</code>：用来管理默认检测事件用到的规则（正则）；</li><li><code>git-checker.js</code>：用来构建 <code>Hook</code> 的核心逻辑；</li><li><code>pre-commit.js</code>：用来编写执行检测的调用逻辑。</li></ul><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在编写这个 <code>hook</code> 之前需要用到一个第三方模块 <a href="https://www.npmjs.com/package/husky" target="_blank">husky</a>，这个模块的作用是根据项目中 <code>package.json</code> 的配置来向 <code>.git/hooks</code> 中的脚本写入我们的逻辑，项目中需要安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky</span><br></pre></td></tr></table></figure><h2 id="代码设计思路分析"><a href="#代码设计思路分析" class="headerlink" title="代码设计思路分析"></a>代码设计思路分析</h2><p>设计这个 <code>hook</code> 时提供了 <code>Git</code> 目录检测、邮箱验证、冲突检测、和执行 <code>Eslint</code> 的功能，当然我们希望检测函数不是强制的，是可以选择性使用，而使用者也可以编写自己需要的检测函数来覆盖其他的场景。</p><p>我们希望项目中的 <code>husky</code> 配置如下：</p><figure class="highlight"><figcaption><span>使用 hook 项目的 package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "node git-hooks/pre-commit"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>husky</code> 帮我们执行了 <code>git-hooks/pre-commit.js</code> 文件，我们希望使用者的用法如下：</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/pre-commit.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GitChecker = <span class="built_in">require</span>(<span class="string">'./git-checker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commitChecker = <span class="keyword">new</span> GitChecker(<span class="string">'pre-commit'</span>, &#123;</span><br><span class="line">  <span class="comment">// default event names</span></span><br><span class="line">  defaultEventNames: [<span class="string">'isGit'</span>, <span class="string">'email'</span>, <span class="string">'conflict'</span>, <span class="string">'eslint'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// your costom rules</span></span><br><span class="line">  &#125;,</span><br><span class="line">  checkEvents: &#123;</span><br><span class="line">    <span class="comment">// your custom check events</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">commitChecker.checkStart();</span><br></pre></td></tr></table></figure><p>上面的用法通过创建实例来创建 <code>checker</code>，即 “检测者”，调用 <code>checkStart</code> 方法帮助我们检测，创建实例的参数为 <code>options</code>，类型为对象。</p><p>上面的用法既可以让用户通过配置 <code>options</code> 的 <code>defaultEventNames</code> 属性来选择性的使用默认的检测函数，又可以通过 <code>checkEvents</code> 属性来让使用者编写检测函数。</p><p><code>rules</code> 属性是来存放使用者编写检测函数时使用的正则，会和默认检测函数中的正则合并，我们专门用 <code>default-rules.js</code> 文件来管理默认检测函数中使用的正则。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-rules.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  emailCheck: <span class="regexp">/\S+((@youemail\.com)|(@enterprise\.com))(\n|\r\n)*$/</span>,</span><br><span class="line">  conflictCheck: <span class="string">'^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\s'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="GitChecker-类的实现"><a href="#GitChecker-类的实现" class="headerlink" title="GitChecker 类的实现"></a>GitChecker 类的实现</h2><p>我们需要一个工厂创造 “检测者”，取名为 <code>GitChecker</code>，在 <code>GitChecker</code> 中需要使用发布订阅模式，对检测函数进行注册，并在执行实例的 <code>checkStart</code> 方法时依次执行，代码如下。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/git-checker.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultRules = <span class="built_in">require</span>(<span class="string">'./default-rules'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultEvents = <span class="built_in">require</span>(<span class="string">'./default-events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 GitChecker 类并继承 EventEmitter，目的是继承 on 和 emit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitChecker</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止使用者 options 内部属性传错，进行初始化</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      rules = &#123;&#125;,</span><br><span class="line">      defaultEventNames = [],</span><br><span class="line">      checkEvents = &#123;&#125;</span><br><span class="line">    &#125; = options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并默认检测函数使用的正则和用户自定义检测函数使用的正则统一管理</span></span><br><span class="line">    <span class="keyword">this</span>.rules = <span class="built_in">Object</span>.assign(defaultRules, rules);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并用户选择使用的默认检测函数和自定义检测函数</span></span><br><span class="line">    <span class="keyword">this</span>.checkEvents = <span class="built_in">Object</span>.assign(</span><br><span class="line">      <span class="keyword">this</span>.getDefaultEvents(defaultEventNames),</span><br><span class="line">      checkEvents</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.type = type; <span class="comment">// git 操作类型</span></span><br><span class="line">    <span class="keyword">this</span>.isCommit = <span class="literal">true</span>; <span class="comment">// 当前是否可以被提交</span></span><br><span class="line">    <span class="keyword">this</span>.gitConfigEnvs = [<span class="string">'local'</span>, <span class="string">'global'</span>, <span class="string">'system'</span>]; <span class="comment">// 取邮箱时的环境</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将提交状态更改为禁止，绑定 this 是为了防止在检测函数内解构更改指向</span></span><br><span class="line">    <span class="keyword">this</span>.forbiddenCommit = <span class="keyword">this</span>.forbiddenCommit.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.init(); <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="comment">// 将检测函数常用方法挂载到实例上</span></span><br><span class="line">    <span class="keyword">this</span>.log = log;</span><br><span class="line">    <span class="keyword">this</span>.exec = exec;</span><br><span class="line">    <span class="keyword">this</span>.chalk = chalk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册当前类型 git 操作对应的检测函数</span></span><br><span class="line">    <span class="keyword">this</span>.register(<span class="keyword">this</span>.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getDefaultEvents(eventsNames) &#123;</span><br><span class="line">    <span class="keyword">return</span> eventsNames.reduce(<span class="function">(<span class="params">memo, eventName</span>) =&gt;</span> &#123;</span><br><span class="line">      memo[<span class="string">`<span class="subst">$&#123;eventName&#125;</span>CheckTask`</span>] = defaultEvents[<span class="string">`<span class="subst">$&#123;eventName&#125;</span>CheckTask`</span>];</span><br><span class="line">      <span class="keyword">return</span> memo;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  register(type) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.checkEvents).forEach(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 订阅事件，每一个函数传入当前实例，方便取实例上的属性和方法</span></span><br><span class="line">      <span class="keyword">this</span>.on(type, () =&gt; <span class="keyword">this</span>.checkEvents[event](<span class="keyword">this</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forbiddenCommit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isCommit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> checkStart() &#123;</span><br><span class="line">    log(chalk.green(<span class="string">'开始代码检测'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布执行检测函数</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.emit(<span class="keyword">this</span>.type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束后结束当前 git 操作进程</span></span><br><span class="line">    <span class="keyword">this</span>.checkEnd();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkEnd() &#123;</span><br><span class="line">    <span class="comment">// 如果当前状态为不可提交，则退出进程号不为 0，git 规定</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isCommit) process.exit(<span class="number">1</span>);</span><br><span class="line">    log(chalk.green(<span class="string">'检测通过'</span>));</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = GitChecker;</span><br></pre></td></tr></table></figure><p>在上面的设计中之所以将一些常用方法都挂载在了实例上，目的是为了让使用者编写自定义检测函数时不再需要引入依赖，和更方便的获取实例上的属性、方法，当然也方便了我自己编写默认检测函数。</p><h2 id="默认检测函数的实现"><a href="#默认检测函数的实现" class="headerlink" title="默认检测函数的实现"></a>默认检测函数的实现</h2><p>由于检测工厂 <code>GitChecker</code> 已经将自己创建的 “检测者” 塞入了检测函数的参数中去，那就可以把所有的默认检测函数放入一个 <code>default-events.js</code> 文件中统一管理。</p><h3 id="检测目录是否被-Git-管理"><a href="#检测目录是否被-Git-管理" class="headerlink" title="检测目录是否被 Git 管理"></a>检测目录是否被 Git 管理</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.isGitCheckTask = <span class="function">(<span class="params">&#123; exec, log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 git 命令，如果跑出异常证明不是一个 git 管理的项目</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(<span class="string">'git status'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    log(chalk.red(<span class="string">'错误：当前不是一个git项目目录'</span>));</span><br><span class="line">    forbiddenCommit(); <span class="comment">// 更改提交状态太为不能提交</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>检测是否为一个 <code>Git</code> 所管理的项目只需执行 <code>git status</code> 来检测一下文件变化，如果抛出异常则说明不被 <code>Git</code> 所管理。</p><h3 id="检测邮箱是否合规"><a href="#检测邮箱是否合规" class="headerlink" title="检测邮箱是否合规"></a>检测邮箱是否合规</h3><blockquote class="pullquote primary"><p>上一个方法使用了从参数解构的方式获取实例属性和方法，为了更便于理解这个方法正常使用参数。</p></blockquote><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">exports.emailCheckTask = <span class="function">(<span class="params">checker</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> checkEmailEnvs = <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取出正则和获取 git 邮箱的环境参数集合</span></span><br><span class="line">    <span class="keyword">const</span> gitConfigEnvs = checker.gitConfigEnvs;</span><br><span class="line">    <span class="keyword">const</span> rules = checker.rules;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取邮箱的 git 命令</span></span><br><span class="line">    <span class="keyword">const</span> command = <span class="string">`git config --<span class="subst">$&#123;gitConfigEnvs[i]&#125;</span> user.email`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取邮箱成功，则校验邮箱是否合规</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> userEmail = checker.exec(command).toString();</span><br><span class="line">      <span class="keyword">const</span> isValidate = rules.emailCheck.test(userEmail);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isValidate) &#123;</span><br><span class="line">        checker.log(checker.chalk.red(<span class="string">'错误：请使用正确的邮箱提交代码'</span>));</span><br><span class="line">        checker.log(checker.chalk.yellow(<span class="string">`你当前的邮箱是：<span class="subst">$&#123;userEmail&#125;</span>`</span>));</span><br><span class="line">        checker.forbiddenCommit();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checker.log(checker.chalk.green(<span class="string">'邮箱校验通过'</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === gitConfigEnvs.length) &#123;</span><br><span class="line">        checker.log(checker.chalk.red(<span class="string">'错误：请设置git的提交邮箱'</span>));</span><br><span class="line">        checker.forbiddenCommit();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checkEmailEnvs(i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  checkEmailEnvs(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>在 <code>Git</code> 中有三个参数设置邮箱，分别 <code>--local</code>、<code>--global</code>、<code>--system</code>，分别对应项目、用户和系统三个环境，顺序即为获取优先级，所以获取也是如此。</p></blockquote><p>该方法使用了递归的思想实现，从优先级最高的环境开始获取邮箱，如果取到邮箱则进行验证，没取到则选择优先级次之的环境获取，直到取到邮箱为止，若都取不到则提示用户设置邮箱，如果取到邮箱，校验不通过则提示用户当前邮箱，并提醒用户设置正确的邮箱。</p><h3 id="检测冲突"><a href="#检测冲突" class="headerlink" title="检测冲突"></a>检测冲突</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exports.conflictCheckTask = <span class="function">(<span class="params">checker</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对文件进行正则匹配的 git 命令</span></span><br><span class="line">  <span class="keyword">const</span> command = <span class="string">`git grep -n -P -E "<span class="subst">$&#123;rules.conflictCheck&#125;</span>"`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有成功匹配，则抛出异常，成功匹配打印冲突代码</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> conflicts = checker.exec(command, &#123; <span class="attr">encoding</span>: <span class="string">'utf-8'</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (conflicts) &#123;</span><br><span class="line">      checker.log(checker.chalk.red(<span class="string">'错误：发现冲突，请解决后再提交'</span>));</span><br><span class="line">      checker.log(checker.chalk.red(<span class="string">'错误代码：'</span>));</span><br><span class="line">      checker.log(checker.chalk.red(conflicts.trim()));</span><br><span class="line">      checker.forbiddenCommit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    checker.log(checker.chalk.green(<span class="string">'未发现冲突'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>在上面的 <code>Git</code> 命令中，<code>-n</code> 为显示匹配文件的行号，因为 <code>shell</code> 的正则支持不全，<code>-P</code> 和 <code>-E</code> 是为了支持正则扩展，保证正则生效。</p></blockquote><h3 id="执行-Eslint"><a href="#执行-Eslint" class="headerlink" title="执行 Eslint"></a>执行 Eslint</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.eslintCheckTask = <span class="function">(<span class="params">&#123; exec, log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(<span class="string">'lint-staged'</span>);</span><br><span class="line">    log(chalk.green(<span class="string">'Eslint 校验通过'</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    log(chalk.red(<span class="string">'错误：Eslint 校验不通过'</span>));</span><br><span class="line">    forbiddenCommit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><code>Eslint</code> 本身具备检测冲突的功能，检测冲突的函数更适用于没有集成 <code>Eslint</code> 的项目，如果项目已经集成了 <code>Eslint</code> 可以不适用检测冲突函数。</p></blockquote><h2 id="关于扩展"><a href="#关于扩展" class="headerlink" title="关于扩展"></a>关于扩展</h2><p>当需求变更，需要在 <code>push</code> 之间执行某些脚本应该怎么办，可以在 <code>git-hooks</code> 文件夹增加一个 <code>pre-push.js</code> 文件，文件内容如下。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/pre-push.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GitChecker = <span class="built_in">require</span>(<span class="string">'./git-checker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pushChecker = <span class="keyword">new</span> GitChecker(<span class="string">'pre-push'</span>, &#123;</span><br><span class="line">  defaultEventNames: [<span class="string">'isGit'</span>, <span class="string">'email'</span>], <span class="comment">// default event names</span></span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// your costom rules</span></span><br><span class="line">  &#125;,</span><br><span class="line">  checkEvents: &#123;</span><br><span class="line">    myHook: <span class="function">(<span class="params">&#123; log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      log(chalk.red(<span class="string">'check prev push'</span>));</span><br><span class="line">      forbiddenCommit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">commitChecker.checkStart();</span><br></pre></td></tr></table></figure><p>由于我们的 <code>hook</code> 依赖于 <code>husky</code>，所以项目 <code>package.json</code> 中的 <code>husky</code> 也有所修改如下。</p><figure class="highlight"><figcaption><span>使用 hook 项目的 package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "node git-hooks/pre-commit",</span><br><span class="line">      "pre-push": "node git-hooks/pre-push"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote class="pullquote success"><p>以上就是本次 <code>Git Hook</code> 的使用场景和实现，也希望通过本文，能让大家对 <code>Git Hook</code> 的相关知识有一定了解，另附赠 <code>Github</code> 地址 <a href="https://github.com/shenqiuhui/git-hooks/tree/master" target="_blank">https://github.com/shenqiuhui/git-hooks/tree/master</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/09/20190409024640/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之 Github 团队协作</title>
      <link>https://www.overtaking.top/2019/03/27/20190327025116/</link>
      <guid>https://www.overtaking.top/2019/03/27/20190327025116/</guid>
      <pubDate>Tue, 26 Mar 2019 18:51:16 GMT</pubDate>
      <description>
      
        
        
          &lt;img src=&quot;/2019/03/27/20190327025116/github.jpeg&quot; title=&quot;Github 团队协作&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;Github-的由来&quot;&gt;&lt;a href=&quot;#Github-的由来&quot; class=&quot;headerli
        
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/27/20190327025116/github.jpeg" title="Github 团队协作"><p><br></p><h2 id="Github-的由来"><a href="#Github-的由来" class="headerlink" title="Github 的由来"></a>Github 的由来</h2><blockquote class="pullquote default"><p><code>Github</code> 的诞生是由于 <code>Git</code> 的局限性，尽管当时 <code>Git</code> 对于代码的管理以及团队协作方面已经非常出色，但是 <code>Git</code> 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 <code>Git</code> 特性的代码平台的诉求成为必然，<code>Github</code> 就这样诞生了。</p></blockquote><h2 id="如何在-Github-高效的搜索项目"><a href="#如何在-Github-高效的搜索项目" class="headerlink" title="如何在 Github 高效的搜索项目"></a>如何在 Github 高效的搜索项目</h2><p>如今 <code>Github</code> 已经非常火爆，也因此被戏称为 “世界最大的同性交友平台”，在 <code>Github</code> 上托管的仓库数量巨大，这对在 <code>Github</code> 上寻找需要的开源项目造成了困扰，其实在 <code>Github</code> 上搜索项目也有一定的技巧，下面我们就来说一下如何高效的找到自己需要的开源项目。</p><p>在登录 <code>Github</code> 后，让搜索项目的搜索框获取焦点并敲下回车键，会跳转到一个搜索页面，这个页面上点击 <code>Advanced search</code>（高级搜索）就会跳转到高级搜索页面。</p><ul><li><code>From these owners</code>：按照作者名搜索，格式 <code>user:username</code>；</li><li><code>In these repositories</code>：按照仓库名称搜索，格式 <code>repo:username/reponame</code>；</li><li><code>Created on the dates</code>：按照创建日期搜索，格式 <code>created:&lt;YYYY-MM-DD</code>；</li><li><code>Written in this language</code>：按照语言进行搜索，格式 <code>language:JavaScript</code>；</li><li><code>With this many stars</code>：按照星星数查找，格式 <code>stars:&gt;1000</code>；</li></ul><blockquote class="pullquote info"><p>上面列举只是常用的部分搜索方式和格式，具体可以查看 <a target="_blank" href="https://github.com/search/advanced">https://github.com/search/advanced</a>，也可以不通过高级搜索的页面直接将规则写在 <code>Github</code> 主页的搜索框内，多个搜索规则可同时使用，格式之间用空格隔开，当然也可以按照内容是否在哪一个文件中来搜索，如 <code>partcontent in readme</code>。</p></blockquote><h2 id="Organizations（组织）"><a href="#Organizations（组织）" class="headerlink" title="Organizations（组织）"></a>Organizations（组织）</h2><p>在 <code>Github</code> 中的仓库可以创建在个人仓库中，也可以创建在组织中，创建在个人仓库时项目的管理者只有项目的所有者，不方便团队层面的管理和协作，如果想要多人共同的管理项目可以通过组织的形式进行。</p><p><strong>创建组织步骤如下：</strong></p><ul><li>个人信息 <code>setting</code>；</li><li>进入界面点击左侧 <code>Organizations</code>；</li><li>点击右上角 <code>new organization</code>；</li><li>填好组织信息后点击下方 <code>Create organization</code>。</li></ul><p>添加后的组织会出现在用户 <code>setting</code> 页面的 <code>Organizations</code> 选项中，点击进入某个组织，可以添加 <code>Github</code> 中可以搜索到的成员进行协同开发，可以在组织下新建仓库，可以创建团队对仓库做更精细化的管理，也可以对团队里的每个成员针对仓库设置读写权限。</p><h2 id="怎样选择适合团队的工作流"><a href="#怎样选择适合团队的工作流" class="headerlink" title="怎样选择适合团队的工作流"></a>怎样选择适合团队的工作流</h2><p>一个团队在协作的时候一定会分工到所有人完成的工作变成一个产品的过程，“工作流” 对于研发团队来讲，可以理解成分支管理的流程。</p><h3 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h3><p>主干开发是围绕着一条主开发分支进行开发，团队所有成员的 <code>commit</code> 都及时的集成在这条主分支，让团队其他成员第一时间知道。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/master-flow.png" alt="主分支开发工作流" title>                </div>                <div class="image-caption">主分支开发工作流</div>            </figure><p><br></p><blockquote class="pullquote warning"><p><strong>适用团队：</strong></p><ul><li><strong>适用于开发团队系统设计和开发能力强，有快速迭代场景，并且有一套有效的特性切换的实施机制（发布系统），保证上线后无序修改代码就能够修改系统行为；</strong></li><li><strong>适用于组件开发的团队（一些基础服务的部门，专门造轮子），成员能力强，人员少，沟通顺畅，用户升级、切换组件成本低。</strong></li></ul></blockquote><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p><code>Git Flow</code> 工作流定义了一个围绕项目发布的严格分支模型，工作流虽然复杂，但提供了一个健壮的用于管理大型项目的框架，具体的工作流程如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/git-flow.png" alt="Git Flow 工作流" title>                </div>                <div class="image-caption">Git Flow 工作流</div>            </figure><p><br></p><ul><li><code>master</code>：专门用来存储正式发布的历史；</li><li><code>develop</code>：作为功能的集成分支，可以多团队同时在 <code>develop</code> 分支集成；</li><li><code>feature</code>：专门用来开发某一个新功能，仅仅只和 <code>develop</code> 交互；</li><li><code>release</code>：发布（提测）分支，当快要到达发既定发布时间，从 <code>develop</code> 分支分出用来 <code>bugfix</code>，上线和 <code>master</code> 进行合并，同时和 <code>develop</code> 进行合并；</li><li><code>hotfix</code>：上线后从 <code>master</code> 分出用来修复线上 <code>Bug</code>。</li></ul><blockquote class="pullquote success"><p><strong>适用团队：</strong></p><ul><li><strong>适用于对项目质量要求较高，不具备主干开发能力，有预定发布周期且需要严格执行发布流程的团队。</strong></li></ul></blockquote><h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p><code>Github Flow</code> 工作流就是基于 <code>master</code> 的某一个 <code>commit</code> 拉一条特性分支进行开发，在开发完毕后在重新集成到 <code>master</code> 的工作流。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/github-flow.png" alt="Github 工作流" title>                </div>                <div class="image-caption">Github 工作流</div>            </figure><p><br></p><blockquote class="pullquote primary"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，随时集成随时发布，分支集成时经历代码评审和自动化测试，通过后就可立即发布的应用。</strong></li></ul></blockquote><h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><p><code>Github Flow</code> 是在 <code>Github Flow</code> 的基础上做了一些优化，新增了平行的 <code>production</code> 分支，用于随时准备发布上线，也可以多一些针对不同测试环境的待测试分支。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/gitlab-flow.png" alt="Gitlab 工作流" title>                </div>                <div class="image-caption">Gitlab 工作流</div>            </figure><p><br></p><blockquote class="pullquote danger"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，需要逐个通过测试环境的验证才能发布的应用；</strong></li><li><strong>适用同一个时间节点项目发布出去会有多个版本同时存在的情况，如通信类型的项目不同版本配合不同的硬件。</strong></li></ul></blockquote><h2 id="Create-pull-request"><a href="#Create-pull-request" class="headerlink" title="Create pull request"></a>Create pull request</h2><p>在多人开发的项目或开源项目中，其他人拉出一条分支进行开发，在上线之前需要合并到 <code>master</code> 主分支，需要提交 <code>pull request</code>，在 <code>Github</code> 项目页面点击上面的 <code>Pull requests</code> 按钮，上面有两个选项：</p><ul><li><code>base</code>：目标分支；</li><li><code>compare</code>：合并的特性分支。</li></ul><p>在选好 <code>base</code>（目标分支） 和 <code>compare</code>（合并的特性分支） 后，点击下方 <code>Create pull request</code>，填写提交的描述信息后再次点击 <code>Create pull request</code>，此时会在下方显示与目标分支相比新增的提交信息并自动检查冲突。</p><blockquote class="pullquote info"><p><strong><code>pull request</code> 有三种模式：</strong></p><ul><li><strong><code>Create a merge commit</code>：直接将某一个特性分支通过 <code>merge</code> 的方式合并到 <code>master</code>；</strong></li><li><strong><code>Squash and merge</code>：会将特性分支的所有变更集组合成一个 <code>commit</code> 合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立；</strong></li><li><strong><code>Rebase and merge</code>：会将特性分支变更集直接合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立。</strong></li></ul></blockquote><p>选择 <code>pull request</code> 模式后，需要对这个 <code>pull request</code> 进行再次确认，填写确认信息并点击 <code>Confirm merge</code> 确认合并，在完成合并后 <code>Github</code> 会给我们提供删除特性分支的快捷按钮 <code>Delete branch</code>，一般会等到项目稳定后才会删除特性分支。</p><h2 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h2><p><code>Issues</code> 用于追踪需求和任务，在开源项目中使用者发现 <code>Bug</code> 或有新的需求都是通过 <code>Issues</code> 提出，在 <code>Issues</code> 的 <code>Labels</code> 中有开发者设置的代表当前处理状态的标签，通过 <code>Issue</code> 上的状态标签可以知道 <code>Issue</code> 的处理进度。</p><h3 id="创建-Issue"><a href="#创建-Issue" class="headerlink" title="创建 Issue"></a>创建 Issue</h3><p><strong>创建 <code>Issue</code> 的步骤：</strong></p><ul><li>点击项目的 <code>Issues</code> 进入 <code>Issues</code> 页面；</li><li>点击 <code>New Issue</code>;</li><li>填写 <code>Issues</code> 的标题及内容；</li><li>点击 <code>Submit new issue</code> 创建 <code>Issue</code>。</li></ul><h3 id="创建-Issue-模版"><a href="#创建-Issue-模版" class="headerlink" title="创建 Issue 模版"></a>创建 Issue 模版</h3><p><strong><code>Issues</code> 的类型不是单一的，项目的所有者是可以给项目的 <code>Issues</code> 添加分类模版的，操作如下：</strong></p><ul><li>进入项目的 <code>Setting</code> 页面；</li><li>点击 <code>Issues</code> 选项的 <code>Set up templates</code> 按钮进入设置页面；</li><li><p>通过下拉框选择 <code>Issues</code> 模版的类型，分类如下：</p><ul><li><code>Bug report</code>：用来提出项目中的 <code>Bug</code>；</li><li><code>Feature request</code>：用来提出新的需求和功能；</li><li><code>Custom issue template</code>：自定义的模版类型，由项目所有者创建时决定具体用途。</li></ul></li><li>点击 <code>Preview and edit</code> 对添加的 <code>Issue</code> 模版进行编辑，编辑后点击 <code>Close preview</code> 保存编辑的内容；</li><li>添加 <code>Issues</code> 模版后点击 <code>Propose changes</code>；</li><li>添加本次修改的记录，同时可以选择用 <code>master</code> 分支还是新创建分支来管理这些 <code>Issues</code>；</li><li>点击 <code>Commit changes</code> 则会生成模版，再次执行创建 <code>Issues</code> 的步骤时可以看到设置的模版，点击模版对应的 <code>Get started</code> 快速生成对应的模版。</li></ul><blockquote class="pullquote default"><p>在编辑模版后，模版会生成对应 <code>markdown</code> 文件被保存在项目中的 <code>.github/ISSUE_TEMPLATE</code> 路径下。</p></blockquote><p><code>Issues</code> 更大的好处是，在追踪需求和任务的同时，任何人都可以在下面对这个 <code>Issue</code> 中的内容进行评论交流，甚至可以直接 <code>@</code> 评论者、项目所有者、开发者、甚至是项目的整个团队，有助于快速解决 <code>Issue</code> 中提出的问题。</p><h2 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h2><p>在开源项目开发时可以为当前项目的某个正在进行的迭代创建 <code>Project</code>，创建的 <code>Project</code> 类似于一个看板的形式，可以非常便捷的管理正在进行修复的 <code>Issue</code> 和 <code>pull request</code>（需要在创建 <code>Issue</code> 和 <code>pull request</code> 时选中关联这个 <code>Project</code>）。</p><p><strong>创建 <code>Project</code> 步骤如下：</strong></p><ul><li>进入项目的 <code>Projects</code> 页面；</li><li>点击 <code>Create a project</code>；</li><li>填写项目的名称和描述并点击下方 <code>Create project</code>。</li></ul><p><strong>在看板中分别对应四个区域如下：</strong></p><ul><li><code>To do</code>：将要完成的任务；</li><li><code>In progress</code>：正在进行中的任务；</li><li><code>Needs review</code>：需要复盘的任务；</li><li><code>Reviewer approved</code>：已经审核通过的任务。</li></ul><p>任务可以通过拖动来改变当前的进度和状态，可以非常便捷的实现项目的任务进度监控和管理，有效的推进项目进程。</p><h2 id="分支保护"><a href="#分支保护" class="headerlink" title="分支保护"></a>分支保护</h2><p>在 <code>Github</code> 的项目中，可以对指定的分支定义规则来进行保护，防止强制推送、以及分支被删除等操作，目的是为了防止误操作对重要分支造成无法挽回的后果。</p><p>可以通过项目的 <code>Setting</code> 进入，选中左侧的 <code>Branches</code> 选项，点击 <code>Add rule</code> 来添加保护规则，<code>Branch name pattern</code> 内制定要保护的分支名字，<code>Rule settings</code> 中可以设置分支保护规则。</p><p><strong>可选规则（可根据需求多选）如下：</strong></p><ul><li><p><code>Require pull request reviews before merging</code>：选中该项后所有的提交合并都必须通过 <code>pull request</code> 进行，下面有三个子选项如下：</p><ul><li><code>Required approving reviews</code>：同意 <code>pull request</code> 的人数，就是说设置后必须有对应设置的人数的相关人员批准，才可以合并；</li><li><code>Dismiss stale pull request approvals when new commits are pushed</code>：勾选后在有新的 <code>pull request</code> 时会撤销旧的 <code>pull request</code>；</li><li><code>Require review from Code Owners</code>：勾选该项后，<code>pull request</code> 必须通过项目所有者的通过才能进行合并。</li></ul></li><li><p><code>Require status checks to pass before merging</code>：在合并前必须通过状态检查才能合并，状态检查如下：</p><ul><li><code>Require branches to be up to date before merging</code>：要求分支在合并之前是最新的。</li></ul></li><li><code>Require signed commits</code>：勾选该项后要求在提交时验证签名；</li><li><code>Include administrators</code>：加入管理员执行所有限制的配置。</li></ul><blockquote class="pullquote success"><p>上面的配置我们通过要保护分支的安全级别自行选择。</p></blockquote><h2 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h2><p><code>Wiki</code> 是 <code>Github</code> 提供的说明文档功能，点击项目上的 <code>Wiki</code> 选项进入文档页面，在项目从来没有编辑过稳当页面时，会默认出现 <code>Create the first page</code> 按钮，点击则会跳转编辑 <code>Wiki</code> 的页面，可以输入 <code>Wiki</code> 标题、内容和提交信息，内容支持 <code>Markdown</code> 语法编写。</p><p>当已经创建过一个 <code>Wiki page</code> 后再次进入项目的 <code>Wiki</code> 页面，会在右上角显示 <code>Edit</code> 和 <code>New page</code> 按钮，分别用于修改和新增 <code>Wiki page</code>，在左侧有所有 <code>Wiki page</code> 的列表，最下面是 <code>Wiki</code> 的仓库地址，也可以通过编辑器在本地创建 <code>Wiki page</code>，编写后通过 <code>Git</code> 推送到 <code>Wiki</code> 仓库。</p><p>在 <code>Wiki</code> 页面还有两个扩展功能，分别为 <code>Add a custom footer</code> 和 <code>Add a custom sidebar</code>，用于创建自定义底部和侧边栏（如编写目录等）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote warning"><p><code>Github</code> 管理项目实现协同开发是非常便捷的，在 <code>Github</code> 中每一个的操作的参与者和被参与者都会收到 <code>Github</code> 邮件进行通知，进入邮件链接也可以直接对项目变化进行 <code>code review</code>，在企业级项目中目前 <code>Gitlab</code> 的私有仓库更火爆，基本功能与 <code>Github</code> 大同小异，在基本功能的基础上增加了更高级的功能和内置的持续集成插件，有兴趣可以尝试探究一下。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/27/20190327025116/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之实战技及巧注意事项总结</title>
      <link>https://www.overtaking.top/2019/03/15/20190315115008/</link>
      <guid>https://www.overtaking.top/2019/03/15/20190315115008/</guid>
      <pubDate>Fri, 15 Mar 2019 03:50:08 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/03/15/20190315115008/git.png&quot; title=&quot;Git 实战技及注意事项&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 &lt;code&gt;Git&lt;/code&gt; 的基础上来详细总结一下这些注意事项。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/15/20190315115008/git.png" title="Git 实战技及注意事项"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Git</code> 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 <code>Git</code> 的基础上来详细总结一下这些注意事项。</p></blockquote><a id="more"></a><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><p>在日常开发时，我们经常都是在某一个分支下进行的，<code>commit</code> 操作也是在某些分支上进行，换句话说我们的每一个提交一般来讲都是与分支挂钩的，在 <code>Git</code> 中有一种情况，我们所修改的代码不与任何一个分支有关连，这种情况下叫做分离头指针。</p><p>那么如何操作才能实现分离头指针呢，在开发时我们可能会对某一个 <code>commit</code> 非常的感兴趣，并希望在这个 <code>commit</code> 下去做一些事情，可以执行下面命令实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br></pre></td></tr></table></figure><p>当切换分支后对某些文件做一些修改，并重新 <code>commit</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'分离头指针测试'</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>执行上面命令后我们发现新的 <code>commit</code> 信息后面不在对应某一个分支，而是 <code>HEAD</code>，这种情况下就代表着我们的 <code>Git</code> 目前已经处于分离头指针的状态了。</p><p>分离头指针是 “双刃剑” 有好处也有坏处，在分离头指针的状态下所有的 <code>commit</code> 在重新切换分支时，会被 <code>Git</code> 当作无用提交回收掉，因为这些提交没有跟任何分支有所联系。</p><blockquote class="pullquote warning"><p><em><strong>优点：尝试性的 <code>commit</code> 可以在分离头指针的状态下进行；</strong></em><br><em><strong>缺点：当发布需要到其他分支修复问题或紧急发布时，切分支后会导致分离头指针状态下的 <code>commit</code> 丢失。</strong></em></p></blockquote><p>在切换分支后，如果还想保留分离头指针状态下的提交，可以为这个提交创建一个新的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名 分离头指针状态的提交（哈希值）</span><br></pre></td></tr></table></figure><h2 id="修改本地-commit"><a href="#修改本地-commit" class="headerlink" title="修改本地 commit"></a>修改本地 commit</h2><h3 id="修改最近一次提交"><a href="#修改最近一次提交" class="headerlink" title="修改最近一次提交"></a>修改最近一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><code>--amend</code> 可以将暂存区新存入的内容同时提交到最近的一次 <code>commit</code> 中，而不会生成新的 <code>commit</code>，同时也可以修改 <code>commit</code> 时的提交信息。</p></blockquote><h3 id="修改任意一次提交"><a href="#修改任意一次提交" class="headerlink" title="修改任意一次提交"></a>修改任意一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i a4d56bb</span><br></pre></td></tr></table></figure><p>该操作为 <code>git rebase</code> 命令的交互模式，即输入 <code>-i</code> 命令，后面所输入的 <code>commit</code> 哈希值并不是要修改的 <code>commit</code>，而是要修改的 <code>commit</code> 的父级 <code>commit</code> 哈希值，在执行命令后会弹出修改的交互界面如下。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pick 52f3935 add css file</span><br><span class="line"><span class="deletion">- pick 91bd053 change css</span></span><br><span class="line"><span class="addition">+ reword 91bd053 change css</span></span><br><span class="line"></span><br><span class="line"># Rebase a4d56bb..91bd053 onto a4d56bb (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>从上面的信息来看第一条代表当前要修改的 <code>commit</code>，第二条代表该分支最新的 <code>commit</code>，下面注释为修改参数，由于要修改提交信息，所以此处将第一行的 <code>pick</code> 修改成 <code>reword</code> 并保存，保存后会弹出下一个修改提交信息的界面如下。</p><figure class="highlight diff"><figcaption><span>第二个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- css content</span></span><br><span class="line"><span class="addition">+ add css content</span></span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto a4d56bb</span><br><span class="line"># Last command done (1 command done):</span><br><span class="line">#    reword 9e4f711 add css content</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick c220cf2 change css</span><br><span class="line"># You are currently editing a commit while rebasing branch 'test' on 'a4d56bb'.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.css</span><br></pre></td></tr></table></figure><p>该界面上为 <code>commit</code> 的 <code>message</code>，修改后保存，就完成了对该 <code>commit</code> 的修改，值得注意的是，使用 <code>git log</code> 查看历史可以发现，修改 <code>commit</code> 时指定的父级 <code>commit</code> 后所有的 <code>commit</code> 哈希值都会发生变化。</p><figure class="highlight plain"><figcaption><span>commit 后的提示信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[detached HEAD de48b04] add css content</span><br><span class="line"> Date: Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 index.css</span><br><span class="line">Successfully rebased and updated refs/heads/test.</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>可以看出，其实使用 <code>git rebase</code> 命令修改 <code>commit</code> 的原理也是分离头指针，只是在分离头指针修改 <code>commit</code> 后又重新将当前分支的指针指回了最新的 <code>commit</code>。</p></blockquote><h3 id="将多个连续的-commit-合并成一个"><a href="#将多个连续的-commit-合并成一个" class="headerlink" title="将多个连续的 commit 合并成一个"></a>将多个连续的 commit 合并成一个</h3><p>将多个 <code>commit</code> 合并成一个的原理与修改任意一个 <code>commit</code> 的原理相同，都是通过 <code>git rebase</code> 命令的交互模式实现的（<code>-i</code>），参数为合并几个 <code>commit</code> 的父级 <code>commit</code> 哈希值。</p><figure class="highlight bash"><figcaption><span>查看历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># edd2400 (HEAD -&gt; test) add content to readme</span></span><br><span class="line"><span class="comment"># 50a015c add background css</span></span><br><span class="line"><span class="comment"># 15237d2 change css</span></span><br><span class="line"><span class="comment"># 4a8fd80 add css content</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><p>现在我们尝试将 <code>50a015c</code>、<code>15237d2</code> 和 <code>4a8fd80</code> 这三个 <code>commit</code> 合并成一个，与修改 <code>commit</code> 唯一不同的是被修改的 <code>commit</code> 参数不再是 <code>reword</code>，而是 <code>squash</code>，多个要合并的 <code>commit</code> 之中有一个目标 <code>commit</code>，这个 <code>commit</code> 的参数必须是 <code>pick</code>。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pick 4a8fd80 add css content</span><br><span class="line"><span class="deletion">- pick 15237d2 change css</span></span><br><span class="line"><span class="deletion">- pick 50a015c add background css</span></span><br><span class="line"><span class="addition">+ squash 15237d2 change css</span></span><br><span class="line"><span class="addition">+ squash 50a015c add background css</span></span><br><span class="line">pick edd2400 add content to readme</span><br><span class="line"></span><br><span class="line"># Rebase 5149bad..edd2400 onto 5149bad (4 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>对上面的交互界面保存后同样会弹出第二个交互界面，合并多个 <code>commit</code> 与修改单个 <code>commit</code> 不同的是，第二个界面会展示所有被合并 <code>commit</code> 的信息，我们可以为合并后的 <code>commit</code> 添加一个新的 <code>message</code>。</p><figure class="highlight diff"><figcaption><span>第二个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+ css changes</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"># This is the 1st commit message:</span><br><span class="line"></span><br><span class="line">add css content</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line"></span><br><span class="line">change css</span><br><span class="line"></span><br><span class="line"># This is the commit message #3:</span><br><span class="line"></span><br><span class="line">add background css</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 5149bad</span><br><span class="line"># Last commands done (3 commands done):</span><br><span class="line">#    squash 15237d2 change css</span><br><span class="line">#    squash 50a015c add background css</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick edd2400 add content to readme</span><br><span class="line"># You are currently rebasing branch 'test' on '5149bad'.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.css</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看合并提交后的历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2c84584 (HEAD -&gt; test) add content to readme</span></span><br><span class="line"><span class="comment"># ac001bc css changes</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><h3 id="将多个间隔的-commit-合并成一个"><a href="#将多个间隔的-commit-合并成一个" class="headerlink" title="将多个间隔的 commit 合并成一个"></a>将多个间隔的 commit 合并成一个</h3><p>上面的 <code>commit</code> 合并方式可能满足不了需求，有些时候我们想把对同一个文件的提交或同一类操作的提交合并成一个，但是在历史 <code>commit</code> 中要合并的树是间隔的，使用 <code>git rebase</code> 命令同样可以做到。</p><figure class="highlight bash"><figcaption><span>查看历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 23d6939 (HEAD -&gt; test) append content into readme</span></span><br><span class="line"><span class="comment"># 178ea29 link css in html</span></span><br><span class="line"><span class="comment"># 2c84584 add content to readme</span></span><br><span class="line"><span class="comment"># ac001bc css changes</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><p>在之前使用 <code>git rebase</code> 命令时都是将操作 <code>commit</code> 的父级 <code>commit</code> 作为参数，如果我们要操作的 <code>commit</code> 已经没有父级 <code>commit</code>，接下来在合并多个间隔的 <code>commit</code> 时来测试一下这样的情况，接下来将 <code>7f73a76</code> 和 <code>178ea29</code> 两个关于 <code>html</code> 文件的操作合并成一个。</p><figure class="highlight bash"><figcaption><span>执行命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f73a76</span><br></pre></td></tr></table></figure><p>由于我们要操作的 <code>commit</code> 已经没有了父级，所以我们就在执行命令时传入这个 <code>commit</code>，在弹出的第一个交互界面我么明显能看到其实上面是少了我们要操作的 <code>commit</code>，所以需要手动补上，而间隔的 <code>commit</code> 要移动到和合并的目标 <code>commit</code> 连续的位置。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ pick 7f73a76</span></span><br><span class="line"><span class="addition">+ squash 178ea29 link css in html</span></span><br><span class="line">pick 4a8fd80 add css content</span><br><span class="line">pick 5149bad new READ.md</span><br><span class="line">pick ac001bc css changes</span><br><span class="line">pick 2c84584 add content to readme</span><br><span class="line"><span class="deletion">- pick 178ea29 link css in html</span></span><br><span class="line">pick 23d6939 append content into readme</span><br><span class="line"></span><br><span class="line"># Rebase 7f73a76..23d6939 onto 7f73a76 (5 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>在保存后出现如下报错信息，是因为 <code>commit</code> 的父节点是我们新增上去导致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">The previous cherry-pick is now empty, possibly due to conflict resolution.</span><br><span class="line">If you wish to commit it anyway, use:</span><br><span class="line"></span><br><span class="line">    git commit --allow-empty</span><br><span class="line"></span><br><span class="line">Otherwise, please use &apos;git reset&apos;</span><br><span class="line">interactive rebase in progress; onto 7f73a76</span><br><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 7f73a76</span><br><span class="line">Next commands to do (5 remaining commands):</span><br><span class="line">   squash 178ea29 link css in html</span><br><span class="line">   pick 5149bad new READ.md</span><br><span class="line">You are currently rebasing branch &apos;test&apos; on &apos;7f73a76&apos;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">Could not apply 7f73a76...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>git status 提示信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 7f73a76</span><br><span class="line">Next commands to do (5 remaining commands):</span><br><span class="line">   squash 178ea29 link css in html</span><br><span class="line">   pick 5149bad new READ.md</span><br><span class="line">  (use &quot;git rebase --edit-todo&quot; to view and edit)</span><br><span class="line">You are currently rebasing branch &apos;test&apos; on &apos;7f73a76&apos;.</span><br><span class="line">  (all conflicts fixed: run &quot;git rebase --continue&quot;)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>想继续合并</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>想还原回合并之前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><p>如果在继续合并后没有出现第二个交互界面（与合并连续 <code>commit</code> 类似，用来新增合并后 <code>commit</code> 的信息），说明合并时出现冲突，此时需要解决冲突后将新的变更提交到暂存区，再重新执行合并命令。</p><figure class="highlight bash"><figcaption><span>查看合并后的历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4d4f771 (HEAD -&gt; test) append content into readme</span></span><br><span class="line"><span class="comment"># a83f526 add content to readme</span></span><br><span class="line"><span class="comment"># 463fd85 css changes</span></span><br><span class="line"><span class="comment"># 7e44e19 new READ.md</span></span><br><span class="line"><span class="comment"># 753ebcd about html changes</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：当前对 <code>commit</code> 的变更和合并操作只是对 <code>commit</code> 做了整理，并没有改变文件内容，并且这些操作仅限于要修改或合并的 <code>commit</code> 还没有共享到集成分支上去，如果已经推送到远端，进行上面操作会对其他协同开发的人员造成麻烦和困扰。</strong></em></p></blockquote><h3 id="删除后提交的-commit"><a href="#删除后提交的-commit" class="headerlink" title="删除后提交的 commit"></a>删除后提交的 commit</h3><p>在开发中有这样一种情景，就是我们在修改代码时提交了一个或者几个新的 <code>commit</code>，但是发现有更好的方案，想要删除这些 <code>commit</code>，这时可以通过将 <code>HEAD</code> 指针重新指向这些 <code>commit</code> 之前的提交，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>这样的操作会导致工作区、暂存区的代码都会到这个 <code>commit</code> 的状态，当然也有 “后悔药”，可以使用 <code>git reflog</code> 找到所有的 <code>commit</code> 版本号 包含已删除），再通过同样的方式将 <code>HEAD</code> 的指针指回去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard 已删除的版本号</span><br></pre></td></tr></table></figure><h2 id="忽略上传的文件"><a href="#忽略上传的文件" class="headerlink" title="忽略上传的文件"></a>忽略上传的文件</h2><p>在开发过程中，有些文件是不需要我们上传到远端的，可能因为这个文件对于开发项目来讲是无用的，如编辑器自动生成的 <code>.idea</code> 等，或者这个文件夹非常的大，如 <code>node_modules</code>，我们可以通过 <code>.gitignore</code> 文件来配置。</p><p>在 <code>.gitignore</code> 文件中有很多规则，在此不去讨论，在这里我们要说的是如果某些想要忽略的文件由于失误没有被写进 <code>.gitignore</code>，被推送到远端后，想忽略这个文件，并在下次推送的时候让远端不再有这个文件该怎么做。</p><figure class="highlight bash"><figcaption><span>先将要忽略的文件添加到 .gitignore，然后执行下面命令对之前添加的文件进行删除操作</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件名/文件夹</span><br></pre></td></tr></table></figure><h2 id="在开发当中处理紧急发布（CR）任务"><a href="#在开发当中处理紧急发布（CR）任务" class="headerlink" title="在开发当中处理紧急发布（CR）任务"></a>在开发当中处理紧急发布（CR）任务</h2><p>在开发时经常有这样一种场景，在上一版本代码上线以后，突然发现线上出现 <code>Bug</code> 需要修复并紧急上线，而这个时候刚好又在同一个分支上已经有了其他的新代码，此时需要将代码还原到线上版本，并保证当前开发代码不丢失，待问题修复后，将新开发的代码合并到修复后的代码上继续开发，当然根据实际情况的不同，复杂程度也会有所差别，下面是一些思路。</p><figure class="highlight bash"><figcaption><span>当前代码跟要修复代码在同一条分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复代码后合并到 dev 发布测试环境验证，通过后发布</span></span><br><span class="line"></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续开发</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>当前代码跟要修复的代码不在同一条分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 master 分支创建一条新分支</span></span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git checkout -b 修复问题分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复问题并提测</span></span><br><span class="line"></span><br><span class="line">git checkout 测试分支</span><br><span class="line">git merge 修复问题分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证通过后合并到 master 发布，继续回到开发新功能分支将修复代码集成进来并继续开发</span></span><br><span class="line"></span><br><span class="line">git checkout 开发分支</span><br><span class="line">git rebase 测试分支</span><br></pre></td></tr></table></figure><p>当然上面的思路仅供参考，因为不同的团队规则有所差异，问题的复杂度也不尽相同，在某些特殊时候可能要本地代码回退版本，需要借助 <code>git reset</code> 命令实现。</p><h2 id="non-fast-forwards-和-fast-forwards"><a href="#non-fast-forwards-和-fast-forwards" class="headerlink" title="non-fast-forwards 和 fast-forwards"></a>non-fast-forwards 和 fast-forwards</h2><p>在实际项目开发中我们将本地代码推送到远端的时候可能会遇到下面这样的报错信息。</p><figure class="highlight bash"><figcaption><span>推送代码时的错误信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to <span class="string">'git@github.yourRepository.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p><code>fast-forwards</code> 是指将本地分支推送到远端，<code>tree</code> 上两个分支拥有共同的 “祖先”，可以自动合并成一个 <code>tree</code>，而 <code>non-fast-forwards</code> 正好相反，两个分支的 <code>tree</code> 是完全独立的，没有任何联系，一般会造成这种现象的原因是推送的目标分支和我们当前分支拥有不同的代码，所以我们需要将推送的目标分支和本地分支的 <code>tree</code> 整理成 <code>fast-forwards</code> 的状态。</p><p>实现方式就是先拉取远端分支在本地进行处理（如果有冲突先处理冲突），变成 <code>fast-forwards</code> 状态后再进行推送，拉取远端分支可以使用 <code>fetch</code> 或 <code>pull</code>，区别在于 <code>fetch</code> 拉取回来的代码仍然是 <code>non-fast-forwards</code> 状态，需要手动 <code>merge</code> 进行合并或 <code>rebase</code> 操作（因为有些团队比较喜欢线性的提交记录以便追溯），而 <code>pull</code> 将 <code>fetch</code> 和 <code>merge</code> 这两个步骤合二为一。</p><blockquote class="pullquote info"><p><em><strong>注意：使用 <code>fetch</code> 拉取代码在进行 <code>merge</code> 时存在一种特殊情况，就是这个仓库的代码是第一次被拉取到本地（与本地分支没有共同的提交），且与本地代码的差异是新建仓库时添加 <code>README.md</code> 等文件造成的，则需要在 <code>merge</code> 时加上 <code>--allow-unrelated-histories</code> 参数去允许历史上完全独立的两棵树进行合并，达到 <code>fast-forwards</code> 的状态。</strong></em></p></blockquote><figure class="highlight bash"><figcaption><span>合并不相关的树</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 本地分支 --allow-unrelated-histories 远端分支</span><br></pre></td></tr></table></figure><p>执行命令后会弹出交互界面可以修改本次合并的 <code>message</code>。</p><h2 id="Git-多人单分支集成协作"><a href="#Git-多人单分支集成协作" class="headerlink" title="Git 多人单分支集成协作"></a>Git 多人单分支集成协作</h2><h3 id="多人协同开发时本地仓库与远端的同步"><a href="#多人协同开发时本地仓库与远端的同步" class="headerlink" title="多人协同开发时本地仓库与远端的同步"></a>多人协同开发时本地仓库与远端的同步</h3><p>在项目的开发迭代中，我们习惯每一个版本迭代都新建一个分支开发，并推送到远端，如果多个人同时要在这个分支开发该迭代的新功能，而以前又已经克隆过这个项目到本地，此时除了这条分支的创建者以外，其他人查看远端分支时是看不见这个新建分支的，需要执行以下命令对仓库进行同步并开发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步新分支信息</span></span><br><span class="line">git fetch 地址别名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新分支</span></span><br><span class="line">git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取新分支到本地</span></span><br><span class="line">git checkout -b 新分支名 地址别名/新分支名</span><br></pre></td></tr></table></figure><p>还有一种场景也需要通过上面的方式来同步仓库信息，就是在 <code>Github</code> 中帮助别人的项目修复 <code>Issue</code> 或贡献代码时，首先需要 <code>Fork</code> 别人的仓库，但是 <code>Fork</code> 过来的仓库代码并不会随着原作者仓库的代码更新而更新，为了在开发之前使 <code>Fork</code> 的仓库和原作者仓库代码及分支保持一致，执行上面命令，开发完毕后再通过给原作者提交 <code>push request</code> 的方式让原作者进行代码审核并合并到原始仓库。</p><h3 id="不同人修改不同文件的处理方式"><a href="#不同人修改不同文件的处理方式" class="headerlink" title="不同人修改不同文件的处理方式"></a>不同人修改不同文件的处理方式</h3><p>在实际开发中，两个人在一条分支开发，当 <code>A</code> 同学修改了 <code>a</code> 文件，<code>B</code> 同学修改了 <code>b</code> 文件时，此时 <code>B</code> 同学先进行了提交，<code>A</code> 同学并不知道的情况下，在 <code>A</code> 同学推送代码到远端时会变成 <code>non-fast-forwards</code> 状态（推送失败），并提示超前一个版本，落后一个版本，意思是本地代码有一个提交远端没有，远端代码有一个提交本地没有，一般情况下大多数的处理是选择先拉去远端代码进行合并，再推送到远端。</p><p>由于两个人修改的是不同文件，在拉取远端代码后合并会比较顺利，并不会产生冲突，但同时产生新的问题，就是多了一条关于合并的提交记录，如果想让提交的历史树更干净整洁，也有另一种做法，就是推送失败的一方主动将本地 <code>commit</code> 回退到与远端完全一致的 <code>commit</code> 版本，主动拉取代码与工作区合并，再重新提交到本地版本库并推送到远端。</p><figure class="highlight bash"><figcaption><span>撤销本地新的提交</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset 与远端相同的提交</span><br></pre></td></tr></table></figure><h3 id="不同的人修改相同文件不同区域的处理方式"><a href="#不同的人修改相同文件不同区域的处理方式" class="headerlink" title="不同的人修改相同文件不同区域的处理方式"></a>不同的人修改相同文件不同区域的处理方式</h3><p>我们将上面 <code>A</code>、<code>B</code> 两个同学的操作场景稍微做些改动，就是两个人同时操作了同一个文件的不同区域，此时如果 <code>B</code> 先提交到远端，<code>A</code> 不知情的情况下推送代码到远端，一样会变成 <code>non-fast-forwards</code>，同样可以通过上面的方式处理，<code>Git</code> 比较智能，可以将两个平行的修改过不同区域的文件进行合并，变成 <code>fast-forwards</code> 状态。</p><h3 id="不同的人修改相同文件相同区域的处理方式"><a href="#不同的人修改相同文件相同区域的处理方式" class="headerlink" title="不同的人修改相同文件相同区域的处理方式"></a>不同的人修改相同文件相同区域的处理方式</h3><p>依然沿用上面 <code>A</code>、<code>B</code> 同学的操作场景，不同的是这次两人修改了相同文件的相同区域，<code>B</code> 先提交到远端，<code>A</code> 在提交到远端时有因为状态为 <code>non-fast-forwards</code> 被拒绝，同样的方式处理时发现了新的问题，代码虽然成功拉合并，但是控制台报错了。</p><figure class="highlight bash"><figcaption><span>合并后报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Auto-merging yourfile</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> yourfile</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>由于两个人操作了同一个区域导致 <code>Git</code> 无法判断两个内容应该怎样去保留或替换，所以将合并失败的错误抛出让开发者认为的介入。</p><blockquote class="pullquote danger"><p><strong>在解决冲突时可能存在的情况：</strong></p><ul><li><em><strong>两人将都要保留的功能代码写在了相同文件的相同区域，这种情况需要都保留；</strong></em></li><li><em><strong>两个人开发功能重复了，需要进行沟通协商决定保留哪一个。</strong></em></li></ul></blockquote><p>在手动处理冲突对文件进行合并时，可以通过 <code>git status</code> 查看合并后的状态，如果这个人为的合并是需要的可以创建一个新的提交推送到远端，如果觉得没有处理好，可以执行下面命令还原到合并之前。</p><figure class="highlight bash"><figcaption><span>撤销合并</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><h3 id="不同的人同时变更文件名的处理方式"><a href="#不同的人同时变更文件名的处理方式" class="headerlink" title="不同的人同时变更文件名的处理方式"></a>不同的人同时变更文件名的处理方式</h3><p>在不同人同时修改同一个文件名时，<code>Git</code> 时无法处理的，当然会变成 <code>non-fast-forwards</code> 状态，在通过常规的处理后，本地会出现两个文件，分别为两人所更改的文件名，这时需要两个人进行协商，保留协商后的文件名，删除多余的文件并推送到远端让其他人进行同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm oldfilename</span><br><span class="line">git add newfilename</span><br><span class="line">git commit -m <span class="string">'merge message'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>在一个人修改文件名，其他人修改内容的情况下，<code>Git</code> 的文件内容都是通过 <a href="https://www.overtaking.top/2019/03/10/20190310233856/#tree%E3%80%81commit%E3%80%81blob-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank">blob</a> 对象进行存储，而非文件的形式，所以当多人协同某个人对文件名进行变更时 <code>Git</code> 可以非常智能的检测并同步。</p></blockquote><h3 id="禁止在已共享的集成分支使用强推"><a href="#禁止在已共享的集成分支使用强推" class="headerlink" title="禁止在已共享的集成分支使用强推"></a>禁止在已共享的集成分支使用强推</h3><p>“强推” 是指使用 <code>git push -f</code> 将本地分支推送到远端，之前在多人写作中远程分支拒绝推送的原因都是因为 <code>non-fast-forwards</code> 状态，我们可以理解为这是 <code>Git</code> 防止代码被推送到远端而产生冲突的一种保护机制，而 “强推” 就是忽略了 <code>non-fast-forwards</code> 状态强行将代码推送到远端。</p><blockquote class="pullquote danger"><p>在大部分团队中都是禁止在集成分支使用这条命令的，可能会在远端产生冲突只是原因之一，操作不正确也可能导致远端集成分支整个团队的提交历史丢失的严重后果，比如当前本地分支版本远远落后于远端，此时直接推送会进入 <code>non-fast-forwards</code> 状态，远端拒绝推送，而向远端 “强推”，远端在这个本地版本库 <code>HEAD</code> 指向的 <code>commit</code> 之后所有的提交历史都将丢失。</p></blockquote><h3 id="禁止在已共享的集成分支上做变基操作"><a href="#禁止在已共享的集成分支上做变基操作" class="headerlink" title="禁止在已共享的集成分支上做变基操作"></a>禁止在已共享的集成分支上做变基操作</h3><p>还记得前面 <a href="https://www.overtaking.top/2019/03/15/20190315115008/#修改本地-commit">修改本地 commit</a> 一节中强调 <code>rebase</code> 操作只适用于修改本地还未同步到远端的 <code>commit</code>，这是因为如果对已经同步到远端的进行了变基操作会导致 <code>commit</code> 的版本号发生变化，如果推送到远端，此时协同开发的人是基于远端旧的 <code>commit</code> 之上在做新的开发，会导致无法将本地代码推送到远端。</p><blockquote class="pullquote warning"><p>有些团队严令禁止对集成分支做变基操作，被称作 “<code>rebase</code> 黄金定律”，如果一定要对集成分支做变基操作的，一定要在当前远端最后的 <code>commit</code> 之后做变基操作。</p></blockquote><p>如果不幸真的有同事这样去做了，我们虽然会很恼火，但也还是有办法去解决这样的问题，可以直接执行下面命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>或者分为两步走，把远端变基后的分支 <code>fetch</code> 到本地，再再把本地的当前分支基于 <code>fetch</code> 下来的远端分支做 <code>rebase</code> 操作，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase 地址别名/分支名</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p>本文内容是自己在对 <code>Git</code> 的学习和工作中总结的笔记，另外想了解 <code>rebase</code> 和 <code>merge</code> 更详细的信息推荐阅读 <a href="https://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank">git rebase vs git merge 详解</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/15/20190315115008/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之 .git 内部刨析</title>
      <link>https://www.overtaking.top/2019/03/10/20190310233856/</link>
      <guid>https://www.overtaking.top/2019/03/10/20190310233856/</guid>
      <pubDate>Sun, 10 Mar 2019 15:38:56 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/03/10/20190310233856/git.jpg&quot; title=&quot;.git 内部刨析&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;HEAD-文件&quot;&gt;&lt;a href=&quot;#HEAD-文件&quot; class=&quot;headerlink&quot; title=&quot;HEAD 文件&quot;&gt;&lt;/a&gt;HEAD 文件&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;文件内容&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ref: refs/heads/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;ref&lt;/code&gt; 代表引用，&lt;code&gt;refs/heads/master&lt;/code&gt; 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支时，&lt;code&gt;HEAD&lt;/code&gt; 文件中的 &lt;code&gt;ref&lt;/code&gt; 值会随着切换的分支变化。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/10/20190310233856/git.jpg" title=".git 内部刨析"><p><br></p><h2 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h2><figure class="highlight plain"><figcaption><span>文件内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><code>ref</code> 代表引用，<code>refs/heads/master</code> 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支时，<code>HEAD</code> 文件中的 <code>ref</code> 值会随着切换的分支变化。</p></blockquote><a id="more"></a><h2 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h2><figure class="highlight bash"><figcaption><span>config 文件基本内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = <span class="literal">true</span></span><br><span class="line">bare = <span class="literal">false</span></span><br><span class="line">logallrefupdates = <span class="literal">true</span></span><br><span class="line">ignorecase = <span class="literal">true</span></span><br><span class="line">precomposeunicode = <span class="literal">true</span></span><br><span class="line">[user]</span><br><span class="line">name = yourname</span><br><span class="line">email = youremail</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><code>[core]</code> 代表当前 <code>Git</code> 管理中的主要配置，<code>[user]</code> 代表用户配置，随着 <code>Git</code> 管理的不断复杂，所有的配置项都将被存放在 <code>config</code> 文件中。</p></blockquote><h2 id="refs-文件夹"><a href="#refs-文件夹" class="headerlink" title="refs 文件夹"></a>refs 文件夹</h2><h3 id="分支-heads"><a href="#分支-heads" class="headerlink" title="分支 heads"></a>分支 heads</h3><p><code>heads</code> 文件夹存储的是本地所有分支文件，文件名与分之名一一对应，文件内容为当前分支所在的提交历史记录的 <code>commit</code> 对象。</p><figure class="highlight bash"><figcaption><span>查看 heads 文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/refs/heads</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  3 systemname  staff   96  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..</span></span><br><span class="line"><span class="comment"># -rw-r--r--  1 systemname  staff   41  2 24 17:31 master</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看分支文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/tags/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># ef5aaed0707989ebc069efcd842424f6315ab4e2</span></span><br><span class="line"></span><br><span class="line">git cat-file -t ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>其实使用 <code>git checkout</code> 命令切换分支时，就是在更改 <code>HEAD</code> 文件的引用内容，即上面提到的 <code>ref: refs/heads/branchname</code>，进而找到 <code>heads</code> 文件夹内对应的分支文件内的提交记录，将工作区代码还原到该提交记录的版本。</p></blockquote><h3 id="标签-tags"><a href="#标签-tags" class="headerlink" title="标签 tags"></a>标签 tags</h3><p>在项目开发中，经常会在某些阶段达到某一个 “里程碑”，比如版本从 <code>v0.0.1</code> 开发到 <code>v1.0.0</code>，可以专门为这个版本的 <code>commit</code> 打上一个标签，而 <code>refs/tags</code> 文件夹就是用来存放这些标签的（文件名与标签名相同），每一个标签文件内存储的是这个 “里程碑” 提交的历史记录的 <code>tag</code> 对象，<code>tag</code> 对象中存储着当前标签对应历史版本的 <code>commit</code> 对象。</p><figure class="highlight bash"><figcaption><span>查看 tags 文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/refs/tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  6 systemname  staff  192  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..</span></span><br><span class="line"><span class="comment"># -rw-r--r--  1 systemname  staff   41  2 15 18:33 1.0.0</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看标签文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/tags/1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ef5aaed0707989ebc069efcd842424f6315ab4e2</span></span><br><span class="line"></span><br><span class="line">git cat-file -p ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># object bcadbfea5e937e9b5eaed113dd8149c86124d72a</span></span><br><span class="line"><span class="comment"># type commit</span></span><br><span class="line"><span class="comment"># tag 1.0.0</span></span><br><span class="line"><span class="comment"># tagger yourusername &lt;youruseremail&gt; 1550212832 +0800</span></span><br><span class="line"></span><br><span class="line">git cat-file -t bcadbfea5e937e9b5eaed113dd8149c86124d72a</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>我们可以使用 <code>git cat-file</code> 命令查看。</p></blockquote><h2 id="objects-文件夹"><a href="#objects-文件夹" class="headerlink" title="objects 文件夹"></a>objects 文件夹</h2><h3 id="查看-objects-内部"><a href="#查看-objects-内部" class="headerlink" title="查看 objects 内部"></a>查看 objects 内部</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/objects</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  72 systemname  staff  2304  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  13 systemname  staff   416  3 14 15:43 ..</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   4 systemname  staff   128  2 24 17:29 00</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   3 systemname  staff    96  2 24 17:29 f9</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   2 systemname  staff    64  2 12 16:59 info</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   2 systemname  staff    64  2 12 16:59 pack</span></span><br></pre></td></tr></table></figure><p>在 <code>objects</code> 文件夹中，除了 <code>info</code> 和 <code>pack</code> 存储的都是十六进制命名的文件夹，在文件夹内部存储着以哈希值命名的文件，在 <code>Git</code> 中的策略是将十六进制文件名和哈希值的文件名进行组合，使用 <code>git cat-file</code> 可以查看该完整哈希值的对象类型，肯能为 <code>tree</code>、<code>blob</code>、<code>commit</code>。</p><blockquote class="pullquote default"><p><code>Git</code> 对象：</p><ul><li><code>tree</code>：树对象，存储内容为 <code>blob</code> 对象的哈希值和对应的文件名称；</li><li><code>blob</code>：存储文件内容，只要文件内容相同，则始终生成唯一一个 <code>blob</code> 对象；</li><li><code>commit</code>：存储提交的相关信息。</li></ul></blockquote><h3 id="tree、commit、blob-对象的关系"><a href="#tree、commit、blob-对象的关系" class="headerlink" title="tree、commit、blob 对象的关系"></a>tree、commit、blob 对象的关系</h3><p>在 <code>Git</code> 中最重要的就是这三个对象，以及他们之间的关系，这对于理解 <code>Git</code> 的原理非常有帮助，下面有一张关系图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/10/20190310233856/git-objects.png" alt="tree、commit、blob 关系图" title>                </div>                <div class="image-caption">tree、commit、blob 关系图</div>            </figure><p><br></p><p><code>commit</code> 对象中，<code>tree</code> 代表提交时所在的树，一个 <code>commit</code> 对象只会对应一棵树，<code>tree</code> 对象存储的只是当前 <code>commit</code> 时，所有文件目录的一个 “快照”，<code>tree</code> 对象中的 <code>tree</code> 对象代表该文件夹中还有文件夹，<code>tree</code> 中的 <code>blob</code> 对象代表文件，<code>blob</code> 对象中存储的是文件内容，<code>Git</code> 在这里存储时忽略文件名，只要文件内容一样就只会存储一份，大大的节约了存储空间。</p><blockquote class="pullquote info"><p><code>blob</code> 对象是在将文件增加到暂存区后创建的，<code>commit</code> 和 <code>tree</code> 对象在进行提交操作后创建。</p></blockquote><h2 id="hooks-文件夹"><a href="#hooks-文件夹" class="headerlink" title="hooks 文件夹"></a>hooks 文件夹</h2><p><code>hooks</code> 文件夹，默认存储了一系列的 <code>hook</code> 文件，用于在执行某些特定的 <code>Git</code> 命令时，在某个声明周期执行，内部可以编写 <code>shell</code> 脚本，也可以通过 <code>hasky</code> 等 <code>npm</code> 包来介入。</p><figure class="highlight bash"><figcaption><span>例如下面文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">pre-commit.sample <span class="comment"># 提交前执行</span></span><br><span class="line">pre-push.sample <span class="comment"># 推送前执行</span></span><br><span class="line">pre-rebase.sample <span class="comment"># 变基前执行</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>上面的文件默认扩展名为 <code>sample</code>，即默认不生效，要想在某个 <code>Git</code> 操作时可以执行对应的 <code>hook</code> 文件，只需要去掉对应 <code>hook</code> 文件的扩展名即可。</strong></em></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/10/20190310233856/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— Router 4.0 的基本使用</title>
      <link>https://www.overtaking.top/2018/09/21/20180921182754/</link>
      <guid>https://www.overtaking.top/2018/09/21/20180921182754/</guid>
      <pubDate>Fri, 21 Sep 2018 10:27:54 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/21/20180921182754/react-router.png&quot; title=&quot;React Router&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-路由简介&quot;&gt;&lt;a href=&quot;#React-路由简介&quot; class=&quot;headerlink&quot; title=&quot;React 路由简介&quot;&gt;&lt;/a&gt;React 路由简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，&lt;code&gt;React&lt;/code&gt; 全家桶中也有配套的路由系统，在路由 &lt;code&gt;2.0&lt;/code&gt; 版本时叫做 &lt;code&gt;react-router&lt;/code&gt;，在路由 &lt;code&gt;4.0&lt;/code&gt; 时更名为 &lt;code&gt;react-router-dom&lt;/code&gt;，我们本次就针对较新版本的 &lt;code&gt;Router&lt;/code&gt; 系统进行介绍。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/21/20180921182754/react-router.png" title="React Router"><p><br></p><h2 id="React-路由简介"><a href="#React-路由简介" class="headerlink" title="React 路由简介"></a>React 路由简介</h2><blockquote class="pullquote info"><p>在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，<code>React</code> 全家桶中也有配套的路由系统，在路由 <code>2.0</code> 版本时叫做 <code>react-router</code>，在路由 <code>4.0</code> 时更名为 <code>react-router-dom</code>，我们本次就针对较新版本的 <code>Router</code> 系统进行介绍。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>为了方便演示如何 <code>Router</code>，我们使用 <code>create-react-app</code> 创建一个 <code>React</code> 项目，并删除 <code>src</code> 文件夹内多余文件，创建我们需要的文件 <code>index.js</code>，目录结构如下。</p><p><pre>react-router<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- src<br>  | |- pages<br>  | | |- Add.js<br>  | | |- Detail.js<br>  | | |- Home.js<br>  | | |- Index.js<br>  | | |- List.js<br>  | | |- Login.js<br>  | | |- Logo.js<br>  | | |- MenuLink.js<br>  | | |- Profile.js<br>  | | |- Protected.js<br>  | | |- User.js<br>  | |- App.js<br>  | |- index.css<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><p>其中主组件为 <code>App</code>，在 <code>index.js</code> 中渲染，<code>index.js</code> 代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>而 <code>App</code> 组件主要用来渲染菜单导航和路由组件，我们将在下面完善代码。</p><h2 id="HashRouter-和-BrowserRouter"><a href="#HashRouter-和-BrowserRouter" class="headerlink" title="HashRouter 和 BrowserRouter"></a>HashRouter 和 BrowserRouter</h2><p>在 <code>React Router</code> 中，给我们提供了一些路由相关的组件，其中最重要的就是实现路由的 <code>HashRouter</code> 和 <code>BrowserRouter</code>，我们知道浏览器的 <code>hash</code> 值发生变化会阻止页面的跳转，而 <code>HashRouter</code> 就是利用这个特性实现的，通过监听 <code>onhanshchange</code> 事件在 <code>hash</code> 值改变的时候做出响应，<code>BrowserRouter</code> 则是利用 <code>H5</code> 的新 <code>History API</code> 的 <code>pushState</code> 方法构造的的历史记录集合来实现的。</p><p>通常情况下，在开发的时候使用 <code>HashRouter</code> 更多，而在真正上线时替换成 <code>BrowserRouter</code>，两种 <code>Router</code> 在地址栏上的表现上区别只是是否含有 <code>#</code>，两种 <code>Router</code> 的使用如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— HashRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* 路由相关代码 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— BrowserRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* 路由相关代码 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>其实就是使用 <code>React Router</code> 中提供的这两种类型的路由组件对路由相关的 <code>JSX</code> 进行包裹。</p><h2 id="Route-和-Link-组件"><a href="#Route-和-Link-组件" class="headerlink" title="Route 和 Link 组件"></a>Route 和 Link 组件</h2><p><code>Route</code> 组件是用来定义路由跳转的切换组件的区域，通过 <code>path</code> 属性定义匹配的路由，<code>component</code> 属性来定义渲染的组件，渲染后就是一个 <code>div</code> 标签，<code>Link</code> 是用来点击跳转路由的，通常用来定义导航栏内容，通过 <code>to</code> 属性设置匹配的路由，需要与 <code>Route</code> 的 <code>path</code> 一一对应，点击后可切换到对应的路由组件，渲染后为一个 <code>a</code> 标签。</p><h3 id="创建路由跳转的组件"><a href="#创建路由跳转的组件" class="headerlink" title="创建路由跳转的组件"></a>创建路由跳转的组件</h3><p>下面我们来创建三个路由对应的组件，分别为首页、用户、个人中心，对应的组件分别为 <code>Home.js</code>、<code>User.js</code>、<code>Profile.js</code></p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Home.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;主页&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;用户&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Profile.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Profile</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;个人中心&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="配合使用-Route-和-Link"><a href="#配合使用-Route-和-Link" class="headerlink" title="配合使用 Route 和 Link"></a>配合使用 Route 和 Link</h3><p>使用 <code>Link</code> 和 <code>Route</code> 配合使用如下，点击 <code>Link</code> 会在类名 <code>container</code> 的元素种加载路由路径对应的组件。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ul className=<span class="string">"nav"</span>&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/profile"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div className="container"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/</span>home<span class="string">" component=&#123;Home&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user<span class="string">" component=&#123;User&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/profile<span class="string">" component=&#123;Profile&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/HashRouter&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>启动项目后上面的代码已经可以帮助我们实现页面路由的切换，但是上面的代码 <code>Link</code> 和 <code>Route</code> 组件混在一起，我们其实可以将 <code>App</code> 拆分成两个组件，一个用来存放 <code>Link</code> 部分，一个用来存放 <code>Route</code> 部分，创建 <code>Index</code> 组件，将 <code>Link</code> 的部分抽取出去，代码修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Index&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;a className=<span class="string">"navbar-brand"</span>&gt;管理系统&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;ul className=<span class="string">"nav"</span>&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/profile"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="container"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修改之后 <code>Index</code> 组件专门用来维护导航组件 <code>Link</code>，<code>App</code> 组件专门用来维护路由组件 <code>Route</code>，这样代码看起来就不那么混乱了。</p><h3 id="Route-组件的-exact-属性"><a href="#Route-组件的-exact-属性" class="headerlink" title="Route 组件的 exact 属性"></a>Route 组件的 exact 属性</h3><p>上面我们所定义的路由为一级路由，在路由匹配并成功加载对应组件后，如果组件又由多个组件组成，并有类似导航的操作（当然不仅限于导航）来控制其他的组件视图的切换，则需要匹配二级路由，这就出现了一个问题，我们以 <code>/user</code> 为例，假设添加一个新的路由 <code>/user/add</code>，那么 <code>React</code> 会由上到下依次匹配，<code>/user/add</code> 中包含 <code>/user</code>，因此会同时渲染两个组件，这不是我们希望的。</p><p>在 <code>React</code> 内部给我们提供了解决方案，就是给路由设置严格匹配，我们只需要让 <code>/user</code> 对应的 <code>Route</code> 组件添加 <code>exact</code> 属性，并将值设置为 <code>true</code> 即可，所以匹配 <code>/user/add</code> 时就不会出现 <code>/user</code> 对应的路由组件也被渲染的情况，当然也可以将 <code>exact</code> 简写到 <code>Route</code> 组件上省略赋值为 <code>true</code> 的过程。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 exact</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Index&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Switch-组件"><a href="#Switch-组件" class="headerlink" title="Switch 组件"></a>Switch 组件</h2><p>因为 <code>React</code> 的路由是由上至下依次进行匹配的，如果有两个同名路由进行匹配，会同时加载两个组件，这也是我们需要优化的，<code>React Router</code> 的 <code>Switch</code> 组件就是来做这件事的，只需要将多个 <code>Route</code> 组件包裹起来，就可以实现只要成功匹配一个路由就不再继续匹配。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Switch 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt; &#123;<span class="comment">/* 同名路由 */</span>&#125;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 <code>Switch</code> 组件优化后，启动项目就可以发现只渲染了一个 <code>User</code> 组件。</p><h2 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a>Redirect 组件</h2><p>在 <code>React</code> 开发中经常遇到路径输入错误的情况，通常情况有两种处理方式，第一种是跳转到一个 <code>404</code> 页面，第二种方式是将页面路由重定向到主页，而 <code>React Router</code> 提供的 <code>Redirect</code> 组件就是帮助我们在所有路由都匹配失败时重定向的，使用时通常放在最后一个 <code>Route</code> 组件的下面用来 “兜底”，使用 <code>to</code> 属性来定义重定向的路由。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Redirect 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt; &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：不能放在 <code>Route</code> 组件的上面，因为放在上面不会匹配任何的路由，而会直接重定向到设置的页面。</strong></em></p></blockquote><p>对于路由都没有匹配而返回 <code>404</code> 页面我们这里也简单说一下，但是这样的用法非常少，使用 <code>Redirect</code> 重定向到指定页面的方式会更多一些。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 匹配失败跳转 404 页面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> component=&#123;<span class="built_in">Error</span>&#125;/&gt; &#123;<span class="comment">/* Error 组件代表 404 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>由于其他的路由都匹配失败，最后会和 <code>/</code> 匹配，所以会显示 <code>Error</code> 组件，这里的 <code>Route</code> 的组件也必须放在最下面来 “兜底”。</p><h2 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h2><h3 id="实现二级路由"><a href="#实现二级路由" class="headerlink" title="实现二级路由"></a>实现二级路由</h3><p>在了解 <code>React Router</code> 的基本使用后，我们用同样的知识点来给 <code>User</code> 组件写一个二级路由，<code>User</code> 中有一个子导航，分别对应用户列表 <code>List</code> 组件和添加用户 <code>Add</code> 组件，代码的套路与之前相同。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="解决默认路径不匹配的问题"><a href="#解决默认路径不匹配的问题" class="headerlink" title="解决默认路径不匹配的问题"></a>解决默认路径不匹配的问题</h3><p>当通过 <code>React Router</code> 访问 <code>/user</code> 的时候，会先加载 <code>User</code> 组件，再加载 <code>User</code> 内部的组件包括子导航，但是 <code>/user</code> 的路径既没有和 <code>/user/add</code> 匹配，也没有和 <code>/user/list</code> 匹配，这样渲染了一个空的类名为 <code>sub-containe</code> 的 <code>div</code> 标签，我们应该让 <code>User</code> 组件加载时子路由默认可以匹配一个路由组件，解决方式如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— Redirect 组件重定向的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Redirect to="</span>/user/list<span class="string">"/&gt; &#123;/* 重定向到 List 组件 */&#125;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的方式是使用 <code>Redirect</code> 组件重定向的方式实现的，但是这样访问的 <code>/user</code>，路径会自动改变为 <code>/user/list</code>，感觉上有一些奇怪，当然还有另外的解决方式。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— Route 组件严格匹配</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser<span class="string">" exact component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的方式是当匹配到了 <code>/user</code> 的路由也加载默认要渲染的 <code>List</code> 组件实现的，但是为了防止向下继续匹配，可以添加 <code>exact</code> 设置严格匹配，进一步优化可以使用 <code>Switch</code> 组件，让路由成功匹配一次后不再向下匹配。</p><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>我们经常会遇到一个场景，就是在某些交互之后实现页面的自动跳转，而对于 <code>React</code> 搭建的单页面应用来说就是路由切换，在 <code>React</code> 中都最初是通过 <code>Link</code> 组件的点击手动实现的路由切换，那么怎么通过纯编程的方式在某些交互后自动切换路由呢，其实 <code>React Router</code> 的 <code>Route</code> 组件会给内部渲染的组件传递路由相关的三个参数 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>三个属性值均为对象，<code>history</code> 上存储了 <code>length</code> 属性代表当前支持存入历史记录的数量，也同样存储了 <code>location</code>，用来存储路由路径的相关信息，还有用来操作路由跳转的方法 <code>go</code>（传入数字代表前进或后退几页）、<code>goBack</code>（后退）、<code>goForward</code>（前进）、<code>replace</code>（用其他路由替换当前历史）、<code>push</code>，其中最常用的就是 <code>push</code> 方法，下面会着重介绍，<code>match</code> 中存储了一些路由匹配的相关信息，如 <code>url</code>，即浏览器输入的路径，真正匹配的路径 <code>path</code> 属性以及是代表否严格匹配的 <code>isExact</code> 属性，在 <code>match</code> 中最重要的是 <code>params</code> 属性，值为对象，用来存储路由参数，这个我们放在后面来说。</p><p>下面在 <code>Add</code> 组件中添加一输入框和按钮，当点击按钮是将输入框的数据存入 <code>localStorage</code> 中，并自动将路由跳转到 <code>/user/list</code>，即渲染 <code>List</code> 组件，然后将数据取出渲染到 <code>List</code> 组件中，这是一个很常见的需求，添加数据然后跳到详情页的场景，下面是 <code>Add</code> 组件中的实现。</p><figure class="highlight js"><figcaption><span>路径：&#126;react-router/src/pages/Add.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  input = React.createRef() <span class="comment">// 非受控组件取值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单提交事件</span></span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault(); <span class="comment">// 取消默认的页面跳转事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从 localStorage 获取已有数据</span></span><br><span class="line">    <span class="keyword">const</span> lists = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新数据</span></span><br><span class="line">    lists.push(&#123;</span><br><span class="line">      id: lists.length + <span class="number">1</span>,</span><br><span class="line">      username: <span class="keyword">this</span>.input.current.value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入 localStorage</span></span><br><span class="line">    localStorage.setItem(<span class="string">'lists'</span>, <span class="built_in">JSON</span>.stringify(lists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编程式导航，自动跳转到 List</span></span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/user/list'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;form className=<span class="string">"form"</span> onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">          &lt;label htmlFor=<span class="string">"username"</span> className=<span class="string">"control-label"</span>&gt;用户名&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input</span></span><br><span class="line"><span class="regexp">            className="form-control"</span></span><br><span class="line"><span class="regexp">            type="text"</span></span><br><span class="line"><span class="regexp">            id="username"</span></span><br><span class="line"><span class="regexp">            ref=&#123;this.input&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          &lt;br/&gt;</span><br><span class="line">          &lt;input type=<span class="string">"submit"</span> className=<span class="string">"btn btn-success"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们通过 <code>Route</code> 传递给渲染组件的 <code>history</code> 的 <code>push</code> 方法实现了路由的自动跳转，<code>push</code> 方法接收的参数就是将要跳转的路径字符串，<code>List</code> 组件代码如下。</p><figure class="highlight js"><figcaption><span>路径：&#126;react-router/src/pages/List.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">    <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                  &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;td&gt;&#123;username&#125;&lt;/</span>td&gt;</span><br><span class="line">                &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">              )</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tbody&gt;</span><br><span class="line">      &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>取出 <code>localStorage</code> 中的数据在 <code>List</code> 中渲染时有两点注意，第一是取出数据和设置状态应该在 <code>render</code> 渲染 <code>JSX</code> 之前，这样在没有执行 <code>render</code> 时会合并状态并只渲染一次，也就是说 <code>componentWillMount</code> “钩子” 和 <code>render</code> “钩子” 的 <code>return</code> 语句前更新状态都是可以的，如果在 <code>componentDidMount</code> “钩子” 中更新会导致组件渲染两次，在 <code>React</code> 开发中如果获取数据的过程是同步的（<code>localStorage</code> 取值是同步的），不需要渲染两次。</p><p>第二点是在使用表格元素 <code>table</code> 渲染时，必须要含有 <code>thead</code> 和 <code>tbody</code>，这是 <code>React</code> 规定的，不可以省略。</p><h2 id="路由参数的传递"><a href="#路由参数的传递" class="headerlink" title="路由参数的传递"></a>路由参数的传递</h2><p>现在在我们的 <code>List</code> 组件表格中，点击每一行都可以跳转到学生 <code>ID</code> 对应的详情 <code>Detail</code> 组件中，由于每一个学生的 <code>ID</code> 不同渲染的详情也不相同，此时需要将学生 <code>ID</code> 作为路由参数进行传递，并在 <code>Detail</code> 内渲染对应的内容，由于 <code>Detail</code> 组件的渲染与 <code>List</code> 组件是同一区域，所以仍然是二级路由，我们需要在 <code>User</code> 组件中进行添加。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— 增加 Detail 二级路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"><span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">'./Detail'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser<span class="string">" exact component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/detail/:id<span class="string">" component=&#123;Detail&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>React Router</code> 中，我们通过给路由后面添加 <code>/:paramname</code> 的方式添加参数，也可以通过 <code>/:paramname/:paramname</code> 传递多个参数（形参），由于在 <code>List</code> 中点击表格的的某行的单元格跳转路由，所以 <code>List</code> 组件修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">    <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                  &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                    &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;td&gt;&lt;Link to=&#123;`/u</span>ser/detail/$&#123;id&#125;<span class="string">`&#125;&gt;&#123;username&#125;&lt;/Link&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                  &lt;/tr&gt;</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">              &#125;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &lt;/tbody&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>List</code> 组件中，同样使用 <code>Link</code> 组件对要点击切换路由的节点进行包裹，并用 <code>to</code> 属性设置跳转的路由和路由参数（实参），现在点击就可以实现从 <code>List</code> 组件到 <code>Detail</code> 组件的切换，如果我们有些 <code>List</code> 的数据想在跳转到 <code>Detail</code> 组件时直接带过去，则可以使用另一种写法如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数和数据</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">      <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">      <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                  &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;td&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;Link to=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                      pathname: `/u</span>ser/detail/$&#123;id&#125;<span class="string">`,</span></span><br><span class="line"><span class="string">                      state: username</span></span><br><span class="line"><span class="string">                    &#125;&#125;&gt;&#123;username&#125;&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                  &lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;/tr&gt;</span></span><br><span class="line"><span class="string">              )</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &lt;/tbody&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>不同的是给 <code>to</code> 属性传入的值从一个代表路由的字符串变成了一个对象，而把路由的字符串作为了 <code>pathname</code> 属性的值，<code>state</code> 属性则代表了路由跳转传给渲染组件的数据，还记得渲染的组件使用 <code>Route</code> 组件包裹的，会传入 <code>history</code>、<code>loacltion</code> 和 <code>match</code> 三个属性，同样的，通过点击 <code>Link</code> 传递的路由参数和数据都可以在 <code>props</code> 上获取到，前者通过 <code>location.state</code> 或者 <code>history.location.state</code> 上获取到，后者可以通过 <code>match.params</code> 上获取到，那么 <code>Detail</code> 组件将传递过来的参数渲染，代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Detail.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Detail</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">user</span>: &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 有值说明是点击过来的，否则是地址栏输入的</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">this</span>.props.location.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由参数</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.match.params.id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是点击过来的直接将数据设置给 state，否则去 localStorage 取值设置给 state</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: &#123; id, <span class="attr">username</span>: data &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> user = users.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: &#123; id, <span class="attr">username</span>: user.username &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.user.id&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt; ------- &lt;/</span>span&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.user.username&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>这里有两点注意点，首先通过组件 <code>props.match.params</code> 获取的路由参数都是字符串格式，如果原本类型为数字，使用时应转换成数字类型，其次是传递的数据，也就是组件通过 <code>props.location.state</code> 获取的数据，只有在通过 <code>Link</code>组件点击过去才会存在，在地址栏输入为 <code>undefined</code>，所以防止用户刷新页面导致数据丢失，应该在两种情况下处理不同的获取数据的逻辑。</strong></em></p></blockquote><h2 id="withRouter-函数"><a href="#withRouter-函数" class="headerlink" title="withRouter 函数"></a>withRouter 函数</h2><p>在之前的编程式导航中我们使用了 <code>Route</code> 传递给渲染组件的 <code>props.history.push</code> 方法实现的，现在假设我们要对一个不是路由跳转的组件，通过点击事件来获取 <code>history</code>、<code>location</code> 和 <code>match</code> 属性，并使用 <code>history</code> 上的路由设置方法进行跳转路由，这应该如何实现呢？</p><p>其实 <code>React Route</code> 给我们提供了一个函数 <code>withRouter</code> 方法，在调用该方法时，则会返回一个新的组件，当然其实这是一个高阶组件的应用，<code>withRouter</code> 方法内部帮我们在传入的组件外层包装了一层 <code>Route</code> 组件，并传入了 <code>history</code>、<code>location</code> 和 <code>match</code> 属性作为参数，所以当我们使用返回的组件时可以通过 <code>props</code> 属性获取 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>下面针对我们之前的 <code>Index</code> 组件的内的 “管理系统” 的标签抽出一个新的组件，并将这个组件添加点击可以跳转到登录页 <code>Login</code> 组件的功能，<code>Login</code> 组件为一级路由，所以我们应该修改 <code>App</code> 组件，添加一个 <code>/login</code> 的路由，<code>Login</code> 和修改后的 <code>App</code> 组件如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Login 组件路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/Login'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;/&gt; &#123;<span class="comment">/* 添加登录页路由 */</span>&#125;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt; &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Login.js —— 添加登录和退出功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'login'</span>, <span class="string">'ok'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.removeItem(<span class="string">'login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>Login</code> 中顺便添加了两个按钮来模拟 “登录” 和 “退出”，并给按钮添加了事件，在登录时向 <code>localStorage</code> 中添加 <code>login</code> 属性，在退出时清除这个属性，以模拟登录状态。</p><p>抽取出 <code>Logo</code> 后的 <code>Index</code> 组件也应该添加一个新的导航为 “登录”，<code>Login</code> 组件和修改后的 <code>Index</code> 组件如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 抽出 Logo 组件并添加登录导航</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;Link to="/</span>home<span class="string">"&gt;首页&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/user<span class="string">"&gt;用户&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/profile<span class="string">"&gt;个人中心&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/login<span class="string">"&gt;登录&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Logo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  change = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"navbar-brand"</span> onClick=&#123;<span class="keyword">this</span>.change&#125;&gt;管理系统&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Logo);</span></span><br></pre></td></tr></table></figure><p>通过 <code>Logo</code> 案例的代码我们可以看出，其实最后导出的并不是 <code>Logo</code> 组件，而是使用 <code>withRouter</code> 函数包装后返回的高阶组件，<code>withRouter</code> 方法内部帮我们搞定了 <code>Logo</code> 组件的 <code>props</code> 没有 <code>history</code>、<code>location</code> 和 <code>match</code> 属性的问题。</p><h2 id="受保护的路由"><a href="#受保护的路由" class="headerlink" title="受保护的路由"></a>受保护的路由</h2><p>以前在点击个人中心时会直接渲染 <code>Profile</code> 组件，在给 <code>Login</code> 组件添加 “登录” 和 “退出” 之后，再次点击个人中心时，应该先对登录状态进行验证，如果 <code>localStorage</code> 中存在 <code>login</code> 属性，则渲染 <code>Profile</code> 的 <code>Route</code> 组件，否则重定向到登录页，如果在登录页点击登录后再重新跳回个人中心（从哪来回哪去）。</p><p>这就需要我对 <code>App</code> 组件路由部分的代码进行修改，使用高阶组件来添加登录验证逻辑，当然，这个高阶组件不是 <code>React Router</code> 提供的，需要我们自己来实现，这种做法被官方称作 “受保护的路由”。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加受保护的路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/Login'</span>;</span><br><span class="line"><span class="keyword">import</span> Protected <span class="keyword">from</span> <span class="string">'./pages/Protected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &#123;<span class="comment">/* 添加受保护的路由 */</span>&#125;</span><br><span class="line">            &lt;Protected path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;/&gt;</span><br><span class="line">            &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们重写了 <code>App</code> 组件中个人中心对应的路由，将原来的 <code>Route</code> 组件用高阶组件 <code>Protected</code> 代替，也就等于是将原本传入的参数 <code>path</code> 和 <code>component</code> 传入了高阶组件 <code>Protected</code>，下面来看一下高阶组件 <code>Protected</code> 的实现。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Protected.js —— 添加受保护的路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Protected</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> login = localStorage.getItem(<span class="string">'login'</span>);</span><br><span class="line">    <span class="keyword">return</span> login ?</span><br><span class="line">    &lt;Route &#123;...this.props&#125;/&gt; :</span><br><span class="line">    &lt;Redirect to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">'/login'</span>, <span class="attr">state</span>: &#123; <span class="string">'from'</span>: <span class="string">'/profile'</span> &#125;&#125;&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Protected</code> 获取登录状态，存在时直接渲染了 <code>Route</code> 组件，并将 <code>path</code> 和 <code>component</code> 参数传入，如果不存在则渲染 <code>Redirect</code> 组件重定向到登录页，传入的参数同 <code>Link</code> 组件的规则相同，<code>pathname</code> 代表重定向的路径，<code>state</code> 代表带过去的数据，我们这里添加了一个 <code>from</code> 属性，用来记录渲染登录页的来源，即个人中心。</p><p>接下来就是 <code>Login</code> 组件中在点击登录后验证是否存在 <code>state</code>，如果存在则返回存储的 <code>from</code> 对应的路由，即个人中心，不存在则跳回首页，<code>Login</code> 修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Login.js —— 完善登录功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'login'</span>, <span class="string">'ok'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一个路由传递的 state</span></span><br><span class="line">    <span class="keyword">const</span> prevPathDate = <span class="keyword">this</span>.props.location.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在 state 则返回来源对应的页面，否则回主页</span></span><br><span class="line">    <span class="keyword">if</span> (prevPathDate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(prevPathDate.from);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(<span class="string">'/home'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.removeItem(<span class="string">'login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样 “受保护的路由” 功能就实现了，其实就是在跳转路由之前起到了一个 “拦截” 的作用，经常的使用场景是权限管理，这是一个路由的应用，也是一个高阶组件的应用，这样的应用在大型复杂的 <code>React</code> 中会频繁使用，还是比较重要的。</p><h2 id="NavLink-组件"><a href="#NavLink-组件" class="headerlink" title="NavLink 组件"></a>NavLink 组件</h2><p>在实际项目开发中，我们经常遇到导航标签被选中时被添加一个代表 “激活” 的类名，用于添加与其他导航选项不同的样式，<code>React Router</code> 已经给我们提供了 <code>NavLink</code> 组件用于实现这个功能，<code>NavLink</code> 组件具备 <code>Link</code> 组件所有的功能，唯一不同的就是 <code>NavLink</code> 组件在被选中时不止发生路由跳转，还会给渲染后的 <code>a</code> 标签添加一个名为 <code>active</code> 的 <code>class</code> 属性，而我们只需要通过 <code>css</code> 去给类名 <code>active</code> 设置样式即可。</p><figure class="highlight css"><figcaption><span>路径：&#126;react-router/src/index.css —— 激活样式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好激活样式以后，我们只需要在 <code>Index</code> 组件中引入激活样式的 <code>css</code> 文件并将 <code>Link</code> 组件替换成 <code>NavLink</code> 组件即可。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入激活样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;NavLink to="/</span>home<span class="string">"&gt;首页&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/user<span class="string">"&gt;用户&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/profile<span class="string">"&gt;个人中心&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/login<span class="string">"&gt;登录&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="自定义导航组件实现激活"><a href="#自定义导航组件实现激活" class="headerlink" title="自定义导航组件实现激活"></a>自定义导航组件实现激活</h2><p><code>React Router</code> 在给我们提供的导航组件 <code>NavLink</code> 功能有限，只会给内部的 <code>a</code> 标签在选中时添加 <code>active</code> 类名，如果我们想实现给一个 <code>li</code> 标签添加 <code>active</code> 就需要我们自己封装一个组件来实现这个功能，其实还是通过高阶组件来实现的，首先我们定义这个高阶组件的名字为 <code>MenuLink</code>，将 <code>Index</code> 组件中的 <code>li</code> 标签和 <code>NavLink</code> 组件统一替换成 <code>MenuLink</code> 组件，代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"><span class="keyword">import</span> MenuLink <span class="keyword">from</span> <span class="string">'./MenuLink'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;MenuLink to="/</span>home<span class="string">"&gt;首页&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/user<span class="string">"&gt;用户&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/profile<span class="string">"&gt;个人中心&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/login<span class="string">"&gt;登录&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在实现 <code>MenuLink</code> 组件之前我们分析一下实现思路，首先我们依然模拟 <code>NavLink</code> 的方式给 <code>MenuLink</code> 传入了 <code>to</code> 属性，值为将要跳转的路由，所以我们应该在 <code>MenuLink</code> 组件中来接收这个路由，而 <code>MenuLink</code> 内部一定是包含 <code>li</code> 和 <code>Link</code> 组件的，我们可以将这个 <code>to</code> 属性传递给 <code>Link</code> 组件，如果想要通过激活状态给外层的 <code>li</code> 标签设置状态我们需要知道是否匹配了路由，并可以通过 <code>match</code> 属性获得，所以在 <code>li</code> 的外层应该有 <code>Route</code> 组件配合，因为只有 <code>Route</code> 组件才会将 <code>history</code>、<code>location</code> 和 <code>match</code> 作为参数传递给其内部渲染的组件。</p><p>这就要说到 <code>Route</code> 组件的渲染模式，在传入 <code>component</code> 属性时，只有匹配组件才会渲染内部组件，我们显然是需要时时刻刻都渲染内部的 <code>li</code> 和 <code>Link</code>，并通过点击 <code>Link</code> 渲染真正的路由组件，所以我们需要用到第二种渲染方式，就是通过 <code>children</code> 属性指定时刻需要渲染的组件，实现代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/MenuLink.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Route path=&#123;<span class="keyword">this</span>.props.to&#125; children=&#123;(&#123; match &#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;li className=&#123;match ? <span class="string">'active'</span> : <span class="string">''</span>&#125;&gt;</span><br><span class="line">            &lt;Link to=&#123;<span class="keyword">this</span>.props.to&#125;&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中由于 <code>children</code> 组件并不需要操作状态和使用生命周期 “钩子”，所以我们直接使用了函数组件实现，因为 <code>active</code> 类名添加给了 <code>li</code>，所以我们需要在 <code>MenuLink</code> 组件中引入样式文件 <code>index.css</code> 并将修改，代码如下。</p><figure class="highlight css"><figcaption><span>路径：&#126;react-router/src/index.css —— 激活样式修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-class">.active</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>本篇通过一个简单的案例使用了由 <code>React Router</code> 所提供的，开发中常用的功能，但美中不足的是并没有使用一些 <code>UI</code> 库或者 <code>CSS</code> 样式来美化，为了更明显的看到 <code>React Router</code> 各个功能使用后的效果，建议大家在实现上面代码的同时自己添加一些 <code>CSS</code> 样式。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/21/20180921182754/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— 组件间的参数传递</title>
      <link>https://www.overtaking.top/2018/09/19/20180919002629/</link>
      <guid>https://www.overtaking.top/2018/09/19/20180919002629/</guid>
      <pubDate>Tue, 18 Sep 2018 16:26:29 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/19/20180919002629/react-props-transmit.png&quot; title=&quot;React 组件间参数传递&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;单向数据流&quot;&gt;&lt;a href=&quot;#单向数据流&quot; class=&quot;headerlink&quot; title=&quot;单向数据流&quot;&gt;&lt;/a&gt;单向数据流&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;每一个可以组件化开发的前端框架如 &lt;code&gt;React&lt;/code&gt;、&lt;code&gt;Vue&lt;/code&gt;，组件间的参数传递都是一定会谈论的话题，而 &lt;code&gt;React&lt;/code&gt; 中数据传递是单向的，也被称为单向数据流，即数据只能从父组件传递到子组件，而子组件只需要通过 &lt;code&gt;props&lt;/code&gt; 属性渲染即可，如果顶层组件的某个属性的值改变了，&lt;code&gt;React&lt;/code&gt; 将由外向内遍历整个组件树，将使用了该属性的组件重新渲染。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/19/20180919002629/react-props-transmit.png" title="React 组件间参数传递"><p><br></p><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><blockquote class="pullquote default"><p>每一个可以组件化开发的前端框架如 <code>React</code>、<code>Vue</code>，组件间的参数传递都是一定会谈论的话题，而 <code>React</code> 中数据传递是单向的，也被称为单向数据流，即数据只能从父组件传递到子组件，而子组件只需要通过 <code>props</code> 属性渲染即可，如果顶层组件的某个属性的值改变了，<code>React</code> 将由外向内遍历整个组件树，将使用了该属性的组件重新渲染。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先使用 <code>create-react-app</code> 脚手架创建 <code>React</code> 项目，项目生成后删除 <code>src</code> 文件目录下的多余文件，留下 <code>index.js</code>，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app transfer-props</span><br></pre></td></tr></table></figure><p><strong>该项目最后的目录结构如下：</strong></p><p><pre>transfer-props<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- src<br>  | |- components<br>  | | |- App.js<br>  | | |- Child.js<br>  | | |- Parent.js<br>  | |- context.js<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><h2 id="父组件传参给子组件"><a href="#父组件传参给子组件" class="headerlink" title="父组件传参给子组件"></a>父组件传参给子组件</h2><p>创建一个最外层组件 <code>App</code>，并在 <code>index.js</code> 中进行渲染。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>App</code> 组件内部状态中含有 <code>users</code> 属性，值为数组，含有 <code>title</code> 属性，现在要将这两个参数传递给 <code>Parent</code> 组件，传参方式如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Parent</code> 组件中接收到参数，要根据参数中数组的数量来渲染下一个子组件 <code>Child</code>，<code>Child</code> 组件中需要使用父组件 <code>users</code> 数组的学生 <code>id</code>，传参如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; users, title &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">            users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              return (</span></span><br><span class="line"><span class="regexp">                &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 <code>Child</code> 组件，用来渲染学生的基本信息，在 <code>Parent</code> 中我们已经将参数传递，最后看看在 <code>Child</code> 中的接收。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Child.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id, name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;span&gt;&#123;id&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;&#123;name&#125;&lt;/</span>span&gt;</span><br><span class="line">        &lt;span&gt;&#123;age&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>注意：子组件接收父组件的 <code>props</code> 属性是只读的，不可以修改，修改会报错。</strong></em></p></blockquote><p>其实在这个过程中参数经历了三个组件，都是由父组件传向子组件，可以看出 <code>React</code> 单向数据流的特点，但是子组件是不可以通过某些操作直接修改父组件的数据的，下面来看看子组件如何修改父组件的数据。</p><h2 id="子组件修改父组件的数据"><a href="#子组件修改父组件的数据" class="headerlink" title="子组件修改父组件的数据"></a>子组件修改父组件的数据</h2><p>在 <code>React</code> 中如果要修改父组件的参数，可以给子组件传入一个修改父组件参数的函数，然后在子组件中执行这个函数，就可以实现父组件数据的更新。</p><p>我们创建一个与 <code>Parent</code> 组件平行的 <code>Input</code> 组件，两个组件都是 <code>App</code> 的直接子组件，在 <code>Input</code> 组件内通过某些操作给父组件的状态中的 <code>users</code> 属性新增一条数据。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">    <span class="keyword">this</span>.props.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 <code>Input</code> 组件，在修改时没有直接使用按钮的点击事件，而是添加了 <code>form</code> 标签并使用 <code>submit</code> 事件，是因为可以使用 <code>H5</code> 的自带的校验功能，但是使用 <code>form</code> 会自动提交页面，所以在执行 <code>submit</code> 事件时应取消默认事件，然后调用父组件传来的方法 <code>addStudent</code>，并传入输入框获取的值（非受控组件的取值方式），父组件 <code>App</code> 修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 push 添加</span></span><br><span class="line">    <span class="comment">// this.state.users.push(&#123; id: this.state.users.length + 1, ...val &#125;);</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">        &lt;Input addStudent=&#123;<span class="keyword">this</span>.addStudent&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>首先父组件 <code>App</code> 应该创建 <code>addStudent</code> 方法作为参数传递给子组件 <code>Input</code>，而在 <code>addStudent</code> 方法内部通过 <code>push</code> 和 <code>setState</code> 两种方式进行添加，发现都可以更新状态和视图，区别是 <code>push</code> 操作的原来的引用，而 <code>setState</code> 创建了新的引用空间。</p><blockquote class="pullquote info"><p><em><strong>注意：在 <code>React</code> 所有状态的更改都不建议操作原来的引用，通常做法都是通过 <code>setState</code> 返回一个新的 <code>state</code>（创建新的引用），使用解构赋值的方式来保留原始数据，用新数据覆盖旧数据，原因是在 <code>React</code> 类组件种有一个 <code>PureComponent</code> 纯组件类型，对 <code>shouldComponentUpdate</code> 生命周期 “钩子” 做了优化，使用了 <code>props</code> 和 <code>state</code> 的浅比较，所以在纯组件类型操作原来的引用是无法更新视图的。</strong></em></p></blockquote><h2 id="context-实现跨组件传参"><a href="#context-实现跨组件传参" class="headerlink" title="context 实现跨组件传参"></a>context 实现跨组件传参</h2><p>在上面的案例当中，父子组件关系的层级是三层，无论是普通的数据还是修改父组件的事件都是作为参数一级一级往下传的，如果组件的层级多了，当跨组件传参时是非常不方便的（通常三级还可以接受）。</p><p>跨组件传参是指父级组件与非直接子组件的传参、同级组件之间的传参，同级之间可以找到相同的父级，没有相同的父级就创造相同的父级，最后将问题统一到了父级组件与非直接子组件的传参传递。</p><p>在 <code>React</code> 中给我们提供了 <code>context</code> API 用来实现组件树数据的共享，分为新旧两个版本，这里旧版和新版的 API 都会介绍。</p><h3 id="旧版-context"><a href="#旧版-context" class="headerlink" title="旧版 context"></a>旧版 context</h3><p>在旧版的 <code>context</code> 需要配合属性类型检测的 <code>prop-types</code> 模块共同使用，需要在共同的父组件上定义一个方法 <code>getChildContext</code>，返回值为一个对象，对象中存储的是当前要传递给其他子组件的数据，同时还有一个静态属性 <code>childContextTypes</code>，值为一个对象，属性的值与 <code>getChildContext</code> 方法内返回的对象的属性一一对应，并用 <code>prop-types</code> 模块对每一个传递给子组件属性的数据类型进行定义，在使用父组件传递属性的子组件中需要定义静态属性 <code>contextTypes</code> 对所使用的属性的数据类型进行校验，需要父组件与 <code>childContextTypes</code> 内的定义一致，然后可以通过子组件实例的 <code>context</code> 属性获取，我们可以使用 <code>context</code> 将上面的案例修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>; <span class="comment">// 引入参数类型检测模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义参数类型</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    state: PropTypes.object,</span><br><span class="line">    addStudent: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上下文对象传给子组件的参数</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state: <span class="keyword">this</span>.state,</span><br><span class="line">      addStudent: <span class="keyword">this</span>.addStudent</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 不再需要传参 */</span>&#125;</span><br><span class="line">        &lt;Parent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">        &lt;Input&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面只是将 <code>APP</code> 组件中原本传给子组件的参数去掉，按照要求添加了 <code>getChildContext</code> 方法和 <code>childContextTypes</code> 静态属性。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型检测与父组件定义的类型对应</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    addStudent: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上下文对象上获取父组件的方法并执行</span></span><br><span class="line">    <span class="keyword">this</span>.context.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Input</code> 组件中定义 <code>contextTypes</code> 属性，将 <code>addStudent</code> 方法从原来的 <code>props</code> 获取改为了从 <code>context</code> 上获取。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js —— 旧版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类型检测与父组件定义的类型对应</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    state: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 从 context 对象上获取 state 并解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; users, title &#125; = <span class="keyword">this</span>.context.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">            users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">              return (</span></span><br><span class="line"><span class="regexp">                &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Parent</code> 组件中同样定义 <code>contextTypes</code> 属性，将 <code>state</code> 属性从原来的 <code>props</code> 获取改为了从 <code>context</code> 上获取。</p><h3 id="新版-context"><a href="#新版-context" class="headerlink" title="新版 context"></a>新版 context</h3><p>新版 <code>context</code> 其实是 <code>React</code> 对象提供给我们的方法 <code>createContext</code> 实现的，方法在调用时返回一个对象，对象上有两个组件分别为 <code>Provider</code>（提供者）和 <code>Consumer</code>（消费者），由于两个配合使用的组件必须有同一次调用 <code>createContext</code> 时创建，所以我们单独创建文件 <code>context.js</code> 代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/context.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到处上下文对象的组件</span></span><br><span class="line"><span class="keyword">export</span> &#123; Provider, Consumer &#125;;</span><br></pre></td></tr></table></figure><p>还是之前的案例，我们可以使用新版 <code>context</code> 修改如下。</p><figure class="highlight js"><figcaption><span>路径：&#126;transfer-props/src/components/App.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span>;</span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'./Input'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'../context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="string">'28'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'shen'</span>, <span class="attr">age</span>: <span class="string">'18'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'学生信息'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加学生信息事件</span></span><br><span class="line">  addStudent = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 setState 添加</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: [</span><br><span class="line">        ...this.state.users,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="keyword">this</span>.state.users.length + <span class="number">1</span>, ...val &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;&#123;</span><br><span class="line">        addStudent: <span class="keyword">this</span>.addStudent,</span><br><span class="line">        state: <span class="keyword">this</span>.state</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Parent &#123;...this.state&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br><span class="line">          &lt;Input addStudent=&#123;<span class="keyword">this</span>.addStudent&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供参数的父组件 <code>App</code> 应该使用 <code>Provider</code> 进行包裹，将传入的参数以 <code>value</code> 为参数名（规定），传入 <code>context</code> 对象中。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Input.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">'../context.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  name = React.createRef();</span><br><span class="line">  age = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取消默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">    <span class="keyword">this</span>.props.addStudent(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">      age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (&#123; addStudent &#125;) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;form onSubmit=&#123;e =&gt; &#123;</span><br><span class="line">                <span class="comment">// 取消默认事件</span></span><br><span class="line">                e.preventDefault();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行父组件方法，取出输入框的值构造成对象作为参数传入</span></span><br><span class="line">                addStudent(&#123;</span><br><span class="line">                  name: <span class="keyword">this</span>.name.current.value,</span><br><span class="line">                  age: <span class="keyword">this</span>.age.current.value</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;&#125;&gt;</span><br><span class="line">                姓名：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.name&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                年龄：&lt;input type=<span class="string">"text"</span> required ref=&#123;<span class="keyword">this</span>.age&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;button type=<span class="string">"submit"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>form&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在使用 “提供者” 提供数据的 “消费者” 子组件中，应该引入与 <code>Provider</code> 对应的 <code>Consumer</code> 组件，用 <code>Consumer</code> 组件替换原本组件返回的 <code>JSX</code>，内部传入一个函数，函数的形参即为 <code>context</code> 对象，函数内部返回值为原本子组件返回的 <code>JSX</code>，子组件使用父组件的属性可直接从函数的形参获取或解构。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;transfer-props/src/components/Parent.js —— 新版 context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">'../context.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (&#123; users, title &#125;) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">              &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;&#123;title&#125;&lt;<span class="regexp">/h1&gt; &#123;/</span>* 显示标题 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">                &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                  &#123;</span></span><br><span class="line"><span class="regexp">                    /</span><span class="regexp">/ 循环创建 Child 组件</span></span><br><span class="line"><span class="regexp">                    users.map(item =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                      return (</span></span><br><span class="line"><span class="regexp">                        &lt;Child &#123;...item&#125; key=&#123;item.id&#125;&gt;&lt;/</span>Child&gt;</span><br><span class="line">                      )</span><br><span class="line">                    &#125;)</span><br><span class="line">                  &#125;</span><br><span class="line">                &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>div&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Parent</code> 作为 <code>App</code> 的子组件，修改的方式同 <code>Input</code> 组件相同，如上面代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>关于 <code>React</code> 组件之间传参的各中放式上面基本介绍完了，但是这些传参方式并不能满足于所有的需求，如果是两个毫不相关的组件并且距离共同的父组件层级比较远，即使使用 <code>context</code> 的方式也会显得有些无力，组件间互相传参的需求比较多代码也会冗余和繁琐，因此就有了 <code>Redux</code>、<code>Mobx</code> 等数据状态管理工具，可以将各个组件的状态数据统一管理，各个组件的之间的参数都更容易获取，关于数据状态管理相关的内容我也会在后面的博客中继续更新，敬请期待吧 ^ ^。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/19/20180919002629/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— 生命周期详解</title>
      <link>https://www.overtaking.top/2018/09/15/20180915194439/</link>
      <guid>https://www.overtaking.top/2018/09/15/20180915194439/</guid>
      <pubDate>Sat, 15 Sep 2018 11:44:39 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/15/20180915194439/react-life-cycle.png&quot; title=&quot;React 生命周期&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;本篇文章主要内容针对 &lt;code&gt;React&lt;/code&gt; 类组件的生命周期展开，会详细介绍生命周期 “钩子” 的执行和用法，如果一点也不了解 &lt;code&gt;React&lt;/code&gt; 的同学建议先学习一下 &lt;code&gt;React&lt;/code&gt; 比较基础的内容，当然也可以看我的文章 &lt;a href=&quot;https://www.overtaking.top/2018/09/10/20180910025959/&quot; target=&quot;_blank&quot;&gt;React 基础篇 —— 带你走进 React 世界&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/15/20180915194439/react-life-cycle.png" title="React 生命周期"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>本篇文章主要内容针对 <code>React</code> 类组件的生命周期展开，会详细介绍生命周期 “钩子” 的执行和用法，如果一点也不了解 <code>React</code> 的同学建议先学习一下 <code>React</code> 比较基础的内容，当然也可以看我的文章 <a href="https://www.overtaking.top/2018/09/10/20180910025959/" target="_blank">React 基础篇 —— 带你走进 React 世界</a>。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先使用 <code>create-react-app</code> 脚手架创建一个 <code>React</code> 项目，脚手架工具的安装和项目创建命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app life-cycle</span><br></pre></td></tr></table></figure><p>创建项目后删除 <code>src</code> 目录中的无用文件，只留下 <code>index.js</code> 入口文件即可。</p><h2 id="类组件的生命周期"><a href="#类组件的生命周期" class="headerlink" title="类组件的生命周期"></a>类组件的生命周期</h2><h3 id="静态属性-defaultProps"><a href="#静态属性-defaultProps" class="headerlink" title="静态属性 defaultProps"></a>静态属性 defaultProps</h3><p><code>defaultProps</code> 是用来给 <code>React</code> 类组件设置参数初始值的，也是最早执行的，算不算生命周期说法不一，但是觉得有必要说一下，因为在 <code>React 15.x</code> 版本的时候可以用 <code>React.createClass</code> 创建类组件，组件中有与 <code>defaultProps</code> 静态属性作用相同的生命周期 “钩子” <code>getDefaultProps</code>，随着 <code>React 16.x</code> 版本废弃了 <code>React.createClass</code>，也就使用 <code>defaultProps</code> 属性替代了 <code>getDefaultProps</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>启动项目后，发现页面上成功的渲染了节点中的数字，这说明设置初始值生效了。</p><h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p><code>constructor</code> 是 <code>ES6</code> 中类的写法中给实例设置属性的钩子，在类的实例被创建时执行，下面是对比 <code>defaultProps</code> 静态属性执行顺序的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(props.number); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>从上面案例中可以看到当执行 <code>constructor</code> 时，<code>props</code> 对象中的 <code>num</code> 属性已经有值了，这也充分说明了说明 <code>constructor</code> 是晚于 <code>defaultProps</code> 执行的。</p><h3 id="状态对象-state"><a href="#状态对象-state" class="headerlink" title="状态对象 state"></a>状态对象 state</h3><p>在 <code>React</code> 中，每一个类组件都有一个属于自己的状态，可以使用 <code>setState</code> 方法更新状态，在 <code>React 15.x</code> 中，通过 <code>React.createClass</code> 创建类组件，使用对应的生命周期 “钩子” <code>getInitialState</code> 来创建，同样的，<code>React 16.x</code> 废弃了 <code>React.createClass</code>，创建 <code>state</code> 的过程自然由新的方式代替。</p><p>创建 <code>state</code> 的方式大概有两种，分别是在 <code>constructor</code> 中创建或者直接创建 <code>state</code> 属性，代码如下。</p><figure class="highlight jsx"><figcaption><span>第一种创建 state 的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 state 方式 2</span></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>第二种创建 state 的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.num); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 state</span></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>从上面可以看出直接创建 <code>state</code> 属性的方式与创建静态属性 <code>defaultProps</code> 类似，执行要早于 <code>constructor</code>。</p><h3 id="componentWillMount-钩子"><a href="#componentWillMount-钩子" class="headerlink" title="componentWillMount 钩子"></a>componentWillMount 钩子</h3><p><code>componentWillMount</code> 生命周期 “钩子” 在组件将要挂载时执行，也就是说在组件挂载前会调用 <code>componentWillMount</code>，整个组件的生命周期中只执行一次，一般用于发送当前组件需要的 <code>Ajax</code> 请求获取数据。</p><p>在 <code>React 16.3</code> 版本中标识了该 “钩子” 会被在未来版本中废弃，目前仍然可以使用，在 <code>componentWillMount</code> 的可以迁移到 <code>constructor</code>，但不能包含 <code>setState</code> 操作，因为 <code>constructor</code> 中无法调用 <code>setState</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="number">3</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br></pre></td></tr></table></figure><p>从上面的打印结果可以看出 <code>componentWillMount</code> “钩子” 的执行是晚于 <code>constructor</code> 的，从页面渲染 <code>3</code> 的结果来看，在 <code>componentWillMount</code> “钩子” 中已经可以使用 <code>setState</code> 更改状态了。</p><h3 id="render-钩子"><a href="#render-钩子" class="headerlink" title="render 钩子"></a>render 钩子</h3><p><code>render</code> 钩子的主要作用是返回组件内部要被渲染的 <code>JSX</code>，即所谓的挂载过程，将上面例子简单修改一下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br></pre></td></tr></table></figure><p>从打印结果可以看出 <code>constructor</code> 最先执行，其次是 <code>componentWillMount</code>，最后是 <code>render</code>，由于状态或属性的更新可能导致组件重新渲染，所以 <code>render</code> 可能会被执行多次。</p><h3 id="componentDidMount-钩子"><a href="#componentDidMount-钩子" class="headerlink" title="componentDidMount 钩子"></a>componentDidMount 钩子</h3><p><code>componentDidMount</code> 生命周期 “钩子” 在组件挂载后执行，一般会将一些依赖于 <code>DOM</code> 的操作放在该 “钩子” 内执行，整个生命周期只执行一次。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br></pre></td></tr></table></figure><p>执行顺序：<code>constructor</code> → <code>componentWillMount</code> → <code>render</code> → <code>componentDidMount</code>。</p><h3 id="componentWillUpdate-钩子"><a href="#componentWillUpdate-钩子" class="headerlink" title="componentWillUpdate 钩子"></a>componentWillUpdate 钩子</h3><p>在调用 <code>setState</code> 更新数据后会触发 <code>render</code> 钩子对组件重新渲染，在执行 <code>render</code> 前会调用 <code>componentWillUpdate</code> 钩子，即将要更新时执行（此时状态和页面都没更新），钩子默认有三个参数，分别为 <code>nextProps</code>、<code>nextState</code> 和 <code>nextContext</code>，即更新后的属性对象、状态对象和上下文对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextContext'</span>, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// nextContext &#123;&#125;</span></span><br><span class="line"><span class="comment">// render</span></span><br></pre></td></tr></table></figure><p>从执行点击事件后的结果来看，在重新渲染之前 <code>componentWillUpdate</code> 早于 <code>render</code> 执行，而在 <code>componentWillUpdate</code> 执行时 <code>state</code> 的状态还未更新。</p><h3 id="componentDidUpdate-钩子"><a href="#componentDidUpdate-钩子" class="headerlink" title="componentDidUpdate 钩子"></a>componentDidUpdate 钩子</h3><p>在调用 <code>setState</code> 更新数据后执行 <code>render</code> 钩子对组件重新渲染，渲染后会立即调用 <code>componentDidUpdate</code> 钩子，此时 <code>state</code> 状态和页面都已经更新，钩子默认有三个参数，分别为 <code>prevProps</code>、<code>prevState</code> 和 <code>prevContext</code>，即更新前的属性对象、状态对象和上下文对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevProps'</span>, prevProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevState'</span>, prevState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prevContext'</span>, prevContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// prevProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// prevState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// prevContext &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>触发点击事件后的执行顺序为：<code>componentWillUpdate</code> → <code>render</code> → <code>componentDidUpdate</code>。</p><h3 id="shouldComponentUpdate-钩子"><a href="#shouldComponentUpdate-钩子" class="headerlink" title="shouldComponentUpdate 钩子"></a>shouldComponentUpdate 钩子</h3><p>在使用 <code>setState</code> 更改状态时，其实还会默默的执行 <code>shouldComponentUpdate</code> “钩子”，该钩子有返回值，不使用该 “钩子” 的情况下默认返回值为 <code>true</code>，若使用该 “钩子” 必须指定布尔类型的返回值 <code>true</code> 或 <code>false</code>，当返回值为 <code>true</code> 时代表更新状态和视图，否则不更新，只要使用 <code>setState</code> 就会触发该 “钩子”，该钩子有三个参数，与 <code>componentWillUpdate</code> “钩子” 相同。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextContext'</span>, nextContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123;&#125;</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125;</span></span><br><span class="line"><span class="comment">// nextContext &#123;&#125;</span></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br></pre></td></tr></table></figure><p>当 <code>shouldComponentUpdate</code> “钩子” 返回值为 <code>true</code> 时，触发点击事件后的执行顺序为：<code>shouldComponentUpdate</code> → <code>componentWillUpdate</code> → <code>render</code> → <code>shouldComponentUpdate</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextState'</span>, nextState);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// nextState &#123; num: 1 &#125; 不断更新</span></span><br></pre></td></tr></table></figure><p>当 <code>shouldComponentUpdate</code> “钩子” 返回值为 <code>false</code> 时，触发点击事件后只有 <code>shouldComponentUpdate</code> 执行了，并且随着触发点击事件的次数增加，<code>nextState</code> 参数的状态不断变化，但是 <code>state</code> 和页面都不更新。</p><h3 id="componentWillUnmount-钩子"><a href="#componentWillUnmount-钩子" class="headerlink" title="componentWillUnmount 钩子"></a>componentWillUnmount 钩子</h3><p><code>componentWillUnmount</code> “钩子” 会在组件卸载之前触发，卸载组件需调用 <code>ReactDOM</code> 的 <code>unmountComponentAtNode</code> 方法，并传入一个根节点，将会卸载这个根节点内部的所有组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 卸载组件</span></span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Kill&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentWillUnmount</span></span><br></pre></td></tr></table></figure><p><code>componentWillUnmount</code> 钩子一般用来在卸载组件之前清除可能会调用 <code>setState</code> 的异步操作，为了防止在卸载组件后继续更新状态而报错。</p><h2 id="复合组件的生命周期"><a href="#复合组件的生命周期" class="headerlink" title="复合组件的生命周期"></a>复合组件的生命周期</h2><blockquote class="pullquote info"><p>上面着重介绍了单个类组件的生命周期，有的生命周期由于一个组件不容易演示，所以放在了这节中，这节也会将复合组件的生命周期执行顺序进行分析，并阐明一些使用的注意事项。</p></blockquote><h3 id="复合组件渲染生命周期的执行顺序"><a href="#复合组件渲染生命周期的执行顺序" class="headerlink" title="复合组件渲染生命周期的执行顺序"></a>复合组件渲染生命周期的执行顺序</h3><p>在复合组件中，父组件套着子组件，两个组件都有自己的生命周期，那么执行顺序会是怎么样的，看下面案例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-componentWillMount</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillMount</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-componentDidMount</span></span><br><span class="line"><span class="comment">// parent-componentDidMount</span></span><br></pre></td></tr></table></figure><p>从上面的执行顺序可以看出，在执行父组件生命周期的时候，执行 <code>render</code> 会渲染子组件，渲染子组件会将子组件的生命周期优先执行，等子组件完成渲染继续父组件的渲染，即继续执行父组件渲染后的生命周期。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num - <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-child&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击子组件更新按钮</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// clild-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击父组件更新按钮</span></span><br><span class="line"><span class="comment">// parent-componentWillUpdate</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// clild-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// parent-componentDidUpdate</span></span><br></pre></td></tr></table></figure><p>当子组件更新时，父组件不会重新渲染，只会执行子组件的生命周期，当父组件更新时，子组件也会重新渲染，此时当父组件执行 <code>render</code> 时会执行子组件更新相关的生命周期，在继续执行父组件更新相关的生命周期。</p><p>点击父组件更新按钮生命周期的执行顺序：<code>parent-componentWillUpdate</code> → <code>parent-render</code> → <code>child-componentWillUpdate</code> → <code>clild-render</code> → <code>child-componentDidUpdate</code> → <code>parent-componentDidUpdate</code>。</p><p>点击子组件更新按钮生命周期的执行顺序：<code>child-componentWillUpdate</code> → <code>clild-render</code> → <code>child-componentDidUpdate</code>。</p><blockquote class="pullquote warning"><p><em><strong>注意：如果更新父组件时，不希望子组件重新渲染，可以通过子组件的 <code>shouldComponentUpdate</code> “钩子” 将返回值设置为 <code>false</code> 的方式来控制。</strong></em></p></blockquote><h3 id="componentWillReceiveProps-钩子"><a href="#componentWillReceiveProps-钩子" class="headerlink" title="componentWillReceiveProps 钩子"></a>componentWillReceiveProps 钩子</h3><p>当传入组件的参数，即 <code>props</code> 发生变化时，<code>componentWillReceiveProps</code> “钩子” 执行，该钩子有一个参数，代表下一次更新的 <code>props</code> 对象，执行该 “钩子” 时，<code>props</code> 并没有更新，也就是说是在 <code>props</code> 变化之前执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-shouldComponentUpdate'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentWillReceiveProps'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowProps, '</span><span class="keyword">this</span>.props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentWillUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter n=&#123;<span class="keyword">this</span>.state.num&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-componentWillUpdate</span></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-componentWillReceiveProps</span></span><br><span class="line"><span class="comment">// nowProps &#123; n: 0 &#125;</span></span><br><span class="line"><span class="comment">// nextProps &#123; n: 1 &#125;</span></span><br><span class="line"><span class="comment">// child-shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// child-componentWillUpdate</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// parent-componentDidUpdate</span></span><br></pre></td></tr></table></figure><p>点击父组件更新按钮后，父子组件生命周期的执行顺序如下：</p><p><code>parent-componentWillUpdate</code> → <code>parent-render</code> → <code>child-componentWillReceiveProps</code> → <code>child-shouldComponentUpdate</code> → <code>child-componentWillUpdate</code> → <code>child-render</code> → <code>child-componentDidUpdate</code> → <code>parent-componentDidUpdate</code>。</p><p>由此可以说明 <code>componentWillReceiveProps</code> 钩子在 <code>shouldComponentUpdate</code> 之前执行。</p><blockquote class="pullquote default"><p><em><strong>注意：<code>componentWillReceiveProps</code> “钩子” 在第一次渲染父子组件时不执行，在 <code>React 16.x</code> 版本中被标记为 “已废弃”。</strong></em></p></blockquote><h2 id="关于-setState-在生命周期中的使用"><a href="#关于-setState-在生命周期中的使用" class="headerlink" title="关于 setState 在生命周期中的使用"></a>关于 setState 在生命周期中的使用</h2><p>在 <code>React</code> 生命周期 “钩子” 中，只有 <code>componentWillMount</code>、<code>componentDidMount</code> 和 <code>componentWillReceiveProps</code> 中可以调用 <code>setState</code>。</p><p>原因是 <code>setState</code> 方法会触发 <code>render</code> “钩子” 执行，而 <code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>componentDidUpdate</code> 是在 <code>render</code> 后触发，包括在 <code>render</code> 中调用 <code>setState</code>，都会出现更新 “死循环” 的现象，最后造成堆栈溢出，而 <code>componentWillUnmount</code> “钩子” 执行时，组件将被卸载，在此时更新状态毫无意义。</p><blockquote class="pullquote warning"><p><em><strong>注意：在 <code>componentWillReceiveProps</code> 中使用 <code>setState</code>，其目的是为了将新更改的属性更新为该组件的状态，但 <code>React</code> 官方不建议这样使用。</strong></em></p></blockquote><h2 id="React-生命周期流程图"><a href="#React-生命周期流程图" class="headerlink" title="React 生命周期流程图"></a>React 生命周期流程图</h2><p>下面是一张关于目前版本比较常用的 <code>React</code> 生命周期 “钩子” 执行顺序的流程图，帮助大家快速理解 <code>React</code> 生命周期中各个钩子函数的执行过程。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/15/20180915194439/react-lifecycle-raw.png" alt="React 生命周期流程图" title>                </div>                <div class="image-caption">React 生命周期流程图</div>            </figure><p><br></p><h2 id="React-16-3-新增生命周期"><a href="#React-16-3-新增生命周期" class="headerlink" title="React 16.3 新增生命周期"></a>React 16.3 新增生命周期</h2><h3 id="getDerivedStateFromProps-静态方法"><a href="#getDerivedStateFromProps-静态方法" class="headerlink" title="getDerivedStateFromProps 静态方法"></a>getDerivedStateFromProps 静态方法</h3><p><code>getDerivedStateFromProps</code> 是一个类组件的静态方法，用来替代 <code>componentWillReceiveProps</code> “钩子”，在传入的属性变化之前执行，方法的参数与 <code>componentWillReceiveProps</code> 相同，是更新的属性对象，该方法要求必须返回一个状态对象的返回值，且使用该方法的组件必须含有 <code>state</code>，不能和 <code>componentWillMount</code> “钩子” 同时使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prevContext) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nowState'</span>, <span class="keyword">this</span>.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-getDerivedStateFromProps'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextProps'</span>, nextProps);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: nextProps.n &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parent-render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCounter n=&#123;<span class="keyword">this</span>.state.num&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ChildCounter</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;update-parent&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent-render</span></span><br><span class="line"><span class="comment">// child-render</span></span><br><span class="line"><span class="comment">// child-getDerivedStateFromProps</span></span><br><span class="line"><span class="comment">// nextProps &#123; n: 1 &#125;</span></span><br><span class="line"><span class="comment">// child-componentDidUpdate</span></span><br><span class="line"><span class="comment">// nowState &#123; num: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>点击父组件的更新按钮钩子的执行顺序如下：<code>parent-render</code> → <code>child-render</code> → <code>child-getDerivedStateFromProps</code> → <code>child-componentDidUpdate</code>。</p><blockquote class="pullquote primary"><p><em><strong>注意：<code>getDerivedStateFromProps</code> 除了上面叙述的用法的注意事项，与 <code>componentWillReceiveProps</code> 相比还有两个优势，第一点是默认第一次渲染时也会执行该方法，第二点是不需要在通过调用 <code>setState</code> 将新的 <code>props</code> 转换成组件的状态，可以直接通过方法的返回值设置状态。</strong></em></p></blockquote><h3 id="getSnapshotBeforeUpdate-钩子"><a href="#getSnapshotBeforeUpdate-钩子" class="headerlink" title="getSnapshotBeforeUpdate 钩子"></a>getSnapshotBeforeUpdate 钩子</h3><p><code>getSnapshotBeforeUpdate</code> “钩子” 用于替代 <code>componentWillUpdate</code> “钩子”，不能与 <code>componentWillMount</code> “钩子” 同时使用，必须与 <code>componentDidUpdate</code> “钩子” 同时使用，需返回一个值或者 <code>null</code>，该值会传给 <code>componentWillUpdate</code> “钩子” 的第三个参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getSnapshotBeforeUpdate'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, prop) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prop'</span>, prop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// getSnapshotBeforeUpdate</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// prop 123</span></span><br></pre></td></tr></table></figure><p>点击更新按钮执行顺序为：<code>render</code> → <code>getSnapshotBeforeUpdate</code> → <code>componentDidUpdate</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>以上就是关于 <code>React</code> 生命周期的内容，涵盖了在 <code>React</code> 开发中对生命周期大部分的应用，也是 <code>React</code> 知识体系中非常重要的部分，<code>React</code> 生命周期和 <code>Vue</code> 相比的特点是名字长，不容易记，希望大家在学习理解之后多巩固，孰能生巧。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/15/20180915194439/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— 带你走进 React 世界</title>
      <link>https://www.overtaking.top/2018/09/10/20180910025959/</link>
      <guid>https://www.overtaking.top/2018/09/10/20180910025959/</guid>
      <pubDate>Sun, 09 Sep 2018 18:59:59 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/10/20180910025959/react.png&quot; title=&quot;React 16&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-介绍&quot;&gt;&lt;a href=&quot;#React-介绍&quot; class=&quot;headerlink&quot; title=&quot;React 介绍&quot;&gt;&lt;/a&gt;React 介绍&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;code&gt;React&lt;/code&gt; 是前端最流行的框架之一，由 Facebook 产出，由于其独特的 &lt;code&gt;JSX&lt;/code&gt; 语法与组件化开发模式，将原本前端基于 &lt;code&gt;DOM&lt;/code&gt; 的编程方式变成了基于组件和数据编程，给前端带来的益处是颠覆性的，因为我们知道 &lt;code&gt;DOM&lt;/code&gt; 操作是 “昂贵” 的，&lt;code&gt;React&lt;/code&gt; 在提高应用性能的同时又大大提高了开发效率，所以受到很多前端开发者的支持，也就有了庞大的生态，如今 &lt;code&gt;React&lt;/code&gt; 已经成为前端工程师之必备技术栈。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/10/20180910025959/react.png" title="React 16"><p><br></p><h2 id="React-介绍"><a href="#React-介绍" class="headerlink" title="React 介绍"></a>React 介绍</h2><blockquote class="pullquote default"><p><code>React</code> 是前端最流行的框架之一，由 Facebook 产出，由于其独特的 <code>JSX</code> 语法与组件化开发模式，将原本前端基于 <code>DOM</code> 的编程方式变成了基于组件和数据编程，给前端带来的益处是颠覆性的，因为我们知道 <code>DOM</code> 操作是 “昂贵” 的，<code>React</code> 在提高应用性能的同时又大大提高了开发效率，所以受到很多前端开发者的支持，也就有了庞大的生态，如今 <code>React</code> 已经成为前端工程师之必备技术栈。</p></blockquote><a id="more"></a><h2 id="创建-React-项目"><a href="#创建-React-项目" class="headerlink" title="创建 React 项目"></a>创建 React 项目</h2><p>在创建 <code>React</code> 项目时，可以使用当下最流行的脚手架 <code>create-react-app</code> 和 <code>generator-react-webpack</code>，前者是由 Facebook 官方出品，后者是第三方构建工具。</p><h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><p><code>create-react-app</code> 适用于大部分项目，集成了对 <code>React</code>、<code>JSX</code>、<code>ES6</code> 和 <code>Flow</code> 的支持，支持热更新，默认情况下无需对 <code>Webpack</code> 进行配置，如果要单独配置 <code>Webpack</code>，需要执行命令弹出配置项，下面命令分别对应安装脚手架工具、构建项目和弹出配置项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">create-react-app project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹射 Webpack 配置文件</span></span><br><span class="line">npm run eject</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：创建 <code>React</code> 项目时，项目名称不能含大写字母，使用 <code>eject</code> 命令弹出配置项的过程不可逆。</strong></em></p></blockquote><h3 id="generator-react-webpack"><a href="#generator-react-webpack" class="headerlink" title="generator-react-webpack"></a>generator-react-webpack</h3><p><code>generator-react-webpack</code> 适用于构建大型项目，它是需要 <code>yeoman</code> 的支持，几乎具备了 <code>create-react-app</code> 的全部功能，不同的是默认可以对 <code>Webpack</code> 进行配置，生成项目需要手动创建项目根目录，安装脚手架工具和构建项目的命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架及依赖</span></span><br><span class="line">npm install -g yo generator-react-webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目根目录</span></span><br><span class="line">mkdir project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目目录</span></span><br><span class="line"><span class="built_in">cd</span> project-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">yo react-webpack</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>我们本次使用 <code>create-react-app</code> 来构建一个项目，并弹出配置项，<code>src</code> 目录为我们主要的开发文件，必须含有一个入口文件 <code>index.js</code>，所以我们在构建项目后删除 <code>src</code> 中的无用文件，目录结构如下（可以通过 <code>npm run start</code> 启动项目）。</p><p><pre>react-demo<br>  |- config<br>  | |- jest<br>  | | |- cssTransform.js<br>  | | |- fileTransform.js<br>  | |- env.js.js<br>  | |- paths.js<br>  | |- webpack.config.dev.js<br>  | |- webpack.config.prod.js<br>  | |- webpackDevServer.config.js<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- scripts<br>  | |- build.js<br>  | |- start.js<br>  | |- test.js<br>  |- src<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><h2 id="探索-React"><a href="#探索-React" class="headerlink" title="探索 React"></a>探索 React</h2><h3 id="引入-React-变量必须大写"><a href="#引入-React-变量必须大写" class="headerlink" title="引入 React 变量必须大写"></a>引入 React 变量必须大写</h3><p><code>React</code> 的核心模块分为两个，分别为 <code>react</code> 和 <code>react-dom</code>，前者为 <code>React</code> 的核心逻辑，后者为 <code>React</code> 的渲染逻辑，在 <code>React</code> 中规定引入 <code>react</code> 模块的变量名必须大写。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染到页面</span></span><br><span class="line">ReactDOM.render(h1, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>如果向上面代码中将引入 <code>react</code> 的变量小写，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error1.png" alt="React 变量错写报错" title>                </div>                <div class="image-caption">React 变量错写报错</div>            </figure><p><br></p><p>该报错信息的意思是当前使用了 <code>JSX</code>，必须要有一个大写的 <code>React</code>，从而可以看出这是 <code>React</code> 所规定的，当将接收 <code>react</code> 的变量改成大写后，页面正常渲染。</p><h3 id="React-必须有-createElement-方法"><a href="#React-必须有-createElement-方法" class="headerlink" title="React 必须有 createElement 方法"></a>React 必须有 createElement 方法</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个大写的 React 对象</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>为了进一步验证，上面代码中创建一个名为 <code>React</code> 的对象，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error2.png" alt="React 没有 createElement 方法报错" title>                </div>                <div class="image-caption">React 没有 createElement 方法报错</div>            </figure><p><br></p><p>这个报错非常明显的在告诉我们，<code>React</code> 对象中缺少了 <code>createElement</code> 方法，我们将代码修改如下后发现报错信息消失。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个大写的 React 对象</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  createElement() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>页面 “白屏” 是因为并没有使用 <code>react-dom</code> 进行渲染，我们定义的 <code>h1</code> 是一个组件，同时也是 <code>JSX</code>，所以会调用 <code>createElement</code> 对 <code>JSX</code> 进行解析。</p><h3 id="解析后的-JSX-长什么样"><a href="#解析后的-JSX-长什么样" class="headerlink" title="解析后的 JSX 长什么样"></a>解析后的 JSX 长什么样</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 JSX</span></span><br><span class="line"><span class="keyword">let</span> h1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 JSX 解析后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(h1);</span><br></pre></td></tr></table></figure><p>打开 Chorme 浏览器控制台查看打印结果如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/virtualDOM.png" alt="JSX 解析后的虚拟 DOM 结构" title>                </div>                <div class="image-caption">JSX 解析后的虚拟 DOM 结构</div>            </figure><p><br></p><p>从结果可以看出 <code>createElement</code> 方法最终将 <code>JSX</code> 解析成了一个对象结构，其中 <code>props</code> 带表属性对象，其中的 <code>children</code> 代表子元素，也就是文本节点 <code>hello world</code>，<code>type</code> 代表标签类型为 <code>h1</code>，这样用来表述 <code>DOM</code> 结构的对象被称为虚拟 <code>DOM</code>。</p><h3 id="模拟解析和渲染过程"><a href="#模拟解析和渲染过程" class="headerlink" title="模拟解析和渲染过程"></a>模拟解析和渲染过程</h3><p>在上面我们知道了 <code>React</code> 可以自动将 <code>JSX</code> 转换成虚拟 <code>DOM</code>，而 <code>ReactDOM</code> 的 <code>render</code> 方法将虚拟 <code>DOM</code> 渲染成了真实的 <code>DOM</code>，用法如下。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  hello</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染到页面</span></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>查看页面可以看到正常渲染了，现在就用前面对 <code>React</code> 的了解来简单模拟解析与渲染的过程，代码如下。</p><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 React 对象和 createElement 方法</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  createElement(type, props, ...children) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; type, props, children &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  hello</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染的 render 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是字符串说明是文本节点，创建文本节点并插入到父元素中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> container.appendChild(<span class="built_in">document</span>.createTextNode(vnode));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是字符串说明是元素节点，解构元素类型、属性和子元素的数组</span></span><br><span class="line">  <span class="keyword">let</span> &#123; type, props, children &#125; = vnode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建元素</span></span><br><span class="line">  <span class="keyword">let</span> tag = <span class="built_in">document</span>.createElement(type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环添加属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    tag.getAttribute(key, props[key]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环子元素，并递归创建子元素</span></span><br><span class="line">  children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    render(child, tag);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将元素插入到容器中，root</span></span><br><span class="line">  container.appendChild(tag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染虚拟 DOM</span></span><br><span class="line">render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>通过上面实现的代码同样可以完成渲染，当然仅限于简单结构，<code>React</code> 内部的实现更为复杂，兼容了多种组件类型和复杂的 <code>DOM</code> 结构。</p><h3 id="JSX-最外层只能有一个元素"><a href="#JSX-最外层只能有一个元素" class="headerlink" title="JSX 最外层只能有一个元素"></a>JSX 最外层只能有一个元素</h3><figure class="highlight jsx"><figcaption><span>文件位置：&#126;react-demo/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JSX</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"hi"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在对上面代码中的 <code>JSX</code> 进行渲染时会有如下报错信息。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error3.png" alt="JSX 没有唯一父元素包裹报错" title>                </div>                <div class="image-caption">JSX 没有唯一父元素包裹报错</div>            </figure><p><br></p><p>上面的报错信息告诉我们 <code>JSX</code> 元素必须包裹在一个闭合的标签内，所以说在写 <code>JSX</code> 语法的时候我们必须保证最外层只有一个元素节点。</p><h2 id="React-的基本使用"><a href="#React-的基本使用" class="headerlink" title="React 的基本使用"></a>React 的基本使用</h2><p>在 <code>JSX</code> 全称为 <code>JavaScript XML</code>，但是和普通的 <code>HTML</code> 相比，有一些不同的用法，如元素属性 <code>class</code>、<code>for</code>、<code>style</code>、<code>dangerouslyInnerHTML</code> 以及注释写法等等。</p><h3 id="className-属性"><a href="#className-属性" class="headerlink" title="className 属性"></a>className 属性</h3><p>在 <code>JSX</code> 语法中，在标签中应使用 <code>className</code> 替代 <code>HTML</code> 中的 <code>class</code> 属性，因为在 JavaScript 中 <code>class</code> 为关键字。</p><figure class="highlight jsx"><figcaption><span>class 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"active"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><h3 id="htmlFor-属性"><a href="#htmlFor-属性" class="headerlink" title="htmlFor 属性"></a>htmlFor 属性</h3><p>在 <code>HTML</code> 中，通过点击 <code>label</code> 标签让 <code>input</code> 输入框获取焦点是很常见的，只需要让 <code>label</code> 标签 <code>for</code> 属性的值与 <code>input</code> 标签的 <code>id</code> 值相等即可，但是在 <code>JSX</code> 中这这样的写法会报错，必须将 <code>label</code> 标签的 <code>for</code> 属性使用 <code>htmlFor</code> 替代，代码如下。</p><figure class="highlight jsx"><figcaption><span>for 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;label htmlFor="username"&gt;用户名&lt;/</span>label&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h3><figure class="highlight jsx"><figcaption><span>style 属性错误的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: red;"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在 <code>JSX</code> 中关于 <code>style</code> 属性的写法发生了变化，如果用 <code>HTML</code> 中的写法会报错，错误信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error4.png" alt="JSX 中 style 属性错误写法报错" title>                </div>                <div class="image-caption">JSX 中 style 属性错误写法报错</div>            </figure><p><br></p><p>报错信息中明确的告诉我们 <code>style</code> 属性必须是一个含有代表样式键值的对象，而不是一个字符串，并给出正确的结构，正确的写法如下。</p><figure class="highlight jsx"><figcaption><span>style 属性在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> '<span class="attr">red</span>'&#125;&#125;&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：在解析 <code>JSX</code> 的过程中，<code>&lt;</code> 和 <code>&gt;</code> 包裹 <code>JSX</code> 元素，元素属性中最外层的 <code>{</code> 和 <code>}</code> 包裹 <code>JS</code> 代码，而内层的 <code>{</code> 和 <code>}</code> 则代表一个 <code>JS</code> 对象，所以 <code>style</code> 是被两层 “花括号” 所包裹，并不是 <code>mustache</code> 语法。</strong></em></p></blockquote><h3 id="取值表达式"><a href="#取值表达式" class="headerlink" title="取值表达式"></a>取值表达式</h3><p>在 <code>JSX</code> 中，所有的 <code>JS</code> 代码都可以写在 <code>JSX</code> 元素起始和闭合标签中间的 <code>{</code> 和 <code>}</code> 内，会将执行结果渲染到该元素上。</p><figure class="highlight jsx"><figcaption><span>取值表达式的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &lt;p&gt;hello&lt;<span class="regexp">/p&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let el = (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1&gt;&#123;fn()&#125;&lt;/</span>h1&gt;</span><br><span class="line">    &lt;div&gt;&#123;str&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&#123;JSON.stringify(obj)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;div&gt;&#123;<span class="literal">true</span> ? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>nihao<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>启动项目可以看到页面上已经成功的渲染了 <code>hello</code>、<code>world</code>、<code>{ hello: &#39;world&#39; }</code> 和 <code>nihao</code>，上面三元运算符结果如果为 <code>null</code> 则不会渲染这个节点，<code>viod 0</code> 与 <code>null</code> 作用相同。</p><h3 id="dangerouslySetInnerHTML-属性"><a href="#dangerouslySetInnerHTML-属性" class="headerlink" title="dangerouslySetInnerHTML 属性"></a>dangerouslySetInnerHTML 属性</h3><p>在 <code>JSX</code> 中，如果想要把一个含有标签元素的字符串插入到某一个节点中，应该使用 <code>dangerouslySetInnerHTML</code> 替代原生 <code>JS</code> 中的 <code>innerHTML</code>。</p><figure class="highlight jsx"><figcaption><span>dangerouslySetInnerHTML 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'&lt;h1&gt;hello&lt;/h1&gt;'</span>;</span><br><span class="line"><span class="keyword">let</span> el = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> <span class="attr">str</span>&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(el, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>dangerouslySetInnerHTML</code> 属性的值为对象，将要插入的 <code>HTML</code> 字符串作为对象中 <code>__html</code> 属性的值即可，设置 <code>dangerouslySetInnerHTML</code> 属性的 <code>JSX</code> 元素中不能有任何的子元素。</p><blockquote class="pullquote danger"><p><em><strong>注意：<code>dangerouslySetInnerHTML</code> 属性非常危险，容易引发 <code>XSS</code> 攻击，轻易不要使用。</strong></em></p></blockquote><h3 id="JSX-中注释的写法"><a href="#JSX-中注释的写法" class="headerlink" title="JSX 中注释的写法"></a>JSX 中注释的写法</h3><p>在 <code>JSX</code> 的 <code>DOM</code> 结构中，如果需要对代码进行注释不能使用 <code>JS</code> 中的 <code>// 注释</code>，也不能使用 <code>HTML</code> 中的 <code>&lt;!-- 注释 --&gt;</code>，注释必须使用 <code>{ }</code> 包裹，写法如下。</p><figure class="highlight jsx"><figcaption><span>注释在 JSX 中的写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 name=<span class="string">"hi"</span>&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* 这是注释，支持多行 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;world&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="Fragment-组件"><a href="#Fragment-组件" class="headerlink" title="Fragment 组件"></a>Fragment 组件</h3><p>在 <code>React 16.3</code> 中提供了一个组件，类似于原生 <code>JS</code> 中的文档碎片，可以将多个元素包裹起来，却不会被渲染，用法如下。</p><figure class="highlight jsx"><figcaption><span>Fragment 组件的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;world&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><h3 id="循环动态创建-JSX-结构"><a href="#循环动态创建-JSX-结构" class="headerlink" title="循环动态创建 JSX 结构"></a>循环动态创建 JSX 结构</h3><p>在 <code>React</code> 中不存在过多的 API，最大的特点就是 <code>JSX</code> 语法可以将 <code>JS</code> 与 <code>HTML</code> 混写，借助原生 <code>JS</code> 的方法实现功能，比如可以使用循环创建 <code>JSX</code> 结构。</p><figure class="highlight jsx"><figcaption><span>循环在 JSX 中的应用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> el = (</span><br><span class="line">  arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(el, window.root);</span></span><br></pre></td></tr></table></figure><p><strong>上面成功的渲染除了一个列表，但是有两点需要注意：</strong></p><ul><li>第一点是循环一定要使用具有返回值的方法，如 <code>map</code>、<code>filter</code> 等；</li><li>第二点是每一个循环出来的 <code>JSX</code> 元素必须绑定一个 <code>key</code> 属性，可以使用数据的 <code>id</code>（优先），也可以使用数组的索引。</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote class="pullquote info"><p>在上面所有代码中的 <code>JSX</code> 都很不优雅，如果一个项目非常大，这样的混乱的结构是难以维护的，组件就是为了更好的维护和复用相同的 <code>JSX</code> 结构以及提高工作效率而存在的。</p></blockquote><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>在 <code>React</code> 中可以通过函数创建组件，函数名称就是组件名，必须大写，必须有返回值，可以为 <code>JSX</code>，也可以为 <code>null</code>，通过单闭合和双闭合两种方式调用组件，可以通过属性传参，并通过函数组件的第一个参数接收，实现代码如下。</p><figure class="highlight jsx"><figcaption><span>函数组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Build</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;props.content&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render((</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Build title="1" content="1xx"&gt;&lt;/</span>Build&gt; &#123;<span class="comment">/* 双闭合 */</span>&#125;</span><br><span class="line">    &lt;Build title=<span class="string">"2"</span> content=<span class="string">"2xx"</span>/&gt; &#123;<span class="comment">/* 单闭合 */</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">), window.root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><em><strong>缺点 1：在函数组件内部 <code>this</code> 为 <code>undefined</code>；</strong></em><br><em><strong>缺点 2：在函数组件内部没有状态，即只能使用通过属性传递的参数，却没有更改的能力；</strong></em><br><em><strong>缺点 3：函数组件没有生命周期，无法使用生命周期 “钩子” 完成一些操作。</strong></em></p></blockquote><p>由于函数组件的缺陷，所以更适合渲染一些静态的不需要数据变化的结构，如果想要让传入的属性变化可以通过不断执行 <code>React.render</code> 的方式不断更新传入组件参数的值，下面是一个时钟案例，通过函数组件实现时间的变化。</p><figure class="highlight jsx"><figcaption><span>函数组件多次渲染</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;当前时间&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;props.time&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 每秒渲染一次组件</span></span><br><span class="line"><span class="regexp">setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Clock time=&#123;new Date().toLocaleString()&#125;/</span>&gt;,</span><br><span class="line">    <span class="built_in">window</span>.root</span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>类组件解决了函数组件所有的缺陷，是通过类声明的。</p><figure class="highlight jsx"><figcaption><span>类组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constructor(props) &#123;</span></span><br><span class="line">  <span class="comment">//   super(props);</span></span><br><span class="line">  <span class="comment">//   this.state = &#123;</span></span><br><span class="line">  <span class="comment">//     time: new Date().toLocaleString();</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等价于 constructor 的写法，更简洁</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染组件</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的类组件中，我们同样使用了一个简单的时钟功能，可以看出类组件即有 <code>this</code>，又能创建和更新状态，也可以通过生命周期进行一些操作。</p><p>所有的类组件都需要继承 <code>React.Component</code>，这样就可以使用 <code>React.Component</code> 的原型方法 <code>setState</code> 对状态进行更新，每次更新，都会使组件重新渲染，但是只会重新渲染变化的 <code>DOM</code>，这是 <code>ReactDOM</code> 通过 <code>diff</code> 算法所做的优化。</p><h3 id="类组件中添加事件"><a href="#类组件中添加事件" class="headerlink" title="类组件中添加事件"></a>类组件中添加事件</h3><p>在平时开发中每个组件都会有一些对应的功能，这就需要事件的配合，在类组建中绑定事件大概有四种方式，我们还是用上面的时钟案例，给该组件添加一个按钮，在点击时卸载这个组件。</p><figure class="highlight jsx"><figcaption><span>方式 1：使用箭头函数直接绑定事件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ 卸载组件的方法</span></span><br><span class="line"><span class="regexp">          ReactDOM.unmountComponentAtNode(window.root);</span></span><br><span class="line"><span class="regexp">        &#125;&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>方式 2：使用 bind 绑定函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面两种方式都有一个共同的问题，箭头函数的方式在每次执行 <code>render</code> 时都会创建新的箭头函数，而将函数作为原型方法，通过 <code>bind</code> 是为了修正方法内部的 <code>this</code> 指向，但是每次执行 <code>render</code> 时，<code>bind</code> 也会返回一个新的函数。</p><figure class="highlight jsx"><figcaption><span>方式 3：在方式 2 的基础上提前生成函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.fn = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.fn&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>这样就解决了上面每次执行 <code>render</code> 就创建新函数的问题，但是这样的写法并不优雅，又产生了新的问题，所有的事件执行函数全都添加到了组件的实例上，而且代码会随着事件的增加而越来越乱。</p><figure class="highlight jsx"><figcaption><span>方式 4：使用 ES7 语法将原型方法使用箭头函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>ES7</code> 的新语法，既解决了事件处理函数方法内部 <code>this</code> 指向问题，又解决了每次执行 <code>render</code> 创建新函数的问题。</p><h3 id="卸载组件后不能再更新状态"><a href="#卸载组件后不能再更新状态" class="headerlink" title="卸载组件后不能再更新状态"></a>卸载组件后不能再更新状态</h3><p>还是上面的时钟案例，我们知道卸载一个组件应该使用 <code>ReactDOM.unmountComponentAtNode</code> 方法，参数一个组件，执行后会卸载这个组件内部所有的组件。</p><p>当真正点击时钟组件的按钮去卸载组件，组件虽然成功卸载了，但是控制台报错了，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error5.png" alt="卸载组件后更新状态报错" title>                </div>                <div class="image-caption">卸载组件后更新状态报错</div>            </figure><p><br></p><p>这个报错信息的意思是告诉我们在组件卸载后不能再通过 <code>setState</code> 更新状态，所以我们要在组件卸载之前先清空调用 <code>setState</code> 的定时器，代码修改如下。</p><figure class="highlight jsx"><figcaption><span>完整的时钟组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染</span></span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件将要卸载时清空定时器</span></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染这个组件会调用 render 方法</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        时间：&lt;span&gt;&#123;<span class="keyword">this</span>.state.time&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;kill&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在这个组件中用到了两个生命周期 “钩子”，<code>componentDidMount</code> 钩子在组件挂载后执行，类似于原生 <code>JS</code> 的 <code>window.onload</code>，<code>componentWillUnmount</code> 钩子在组件将要卸载之前执行，后面会涉及更多生命周期钩子，我们会在这个 <code>React</code> 基础篇系列文章中一一说明。</p><h3 id="类组件的参数传递"><a href="#类组件的参数传递" class="headerlink" title="类组件的参数传递"></a>类组件的参数传递</h3><figure class="highlight jsx"><figcaption><span>类组件传参第一种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;this.props.age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 分别传入想要的属性</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>类组件传参第二种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 传入整个对象</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person &#123;...p&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面两种传参方式第一种是将对象中希望传入的属性传递给组件，第二种方式是将整个对象通过解构的方式直接传递给组件，而组件中可以在 <code>constructor</code> 中的第一个参数接收 <code>props</code>，也可以直接使用 <code>this.props</code>，因为 <code>React</code> 在组件创建实例调用 <code>super</code> 之前就已经将 <code>props</code> 作为了实例属性。</p><h3 id="组件参数的类型校验"><a href="#组件参数的类型校验" class="headerlink" title="组件参数的类型校验"></a>组件参数的类型校验</h3><p>在 <code>React</code> 组件传递参数时，是通过 <code>props</code> 取出传入的参数直接使用，传入的值类型并没有做任何的校验，这就可能造成传参时出现错误，在 <code>React</code> 生态中有一个第三方模块 <code>prop-types</code> 可以规定参数的类型，并对传入的参数进行校验，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prop-types</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用 prop-types 校验传给组件的参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123;</span><br><span class="line">  name: <span class="string">'panda'</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  gender: <span class="string">'男'</span>,</span><br><span class="line">  hobby: [<span class="string">'basketball'</span>, <span class="string">'swim'</span>],</span><br><span class="line">  pos: &#123; <span class="attr">x</span>: <span class="number">433</span>, <span class="attr">y</span>: <span class="number">822</span> &#125;,</span><br><span class="line">  salary: <span class="number">5000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义默认属性，React 自带</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name: <span class="string">'shen'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义属性类型</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired, <span class="comment">// 类型必须为字符串，必填项</span></span><br><span class="line">    age: PropTypes.number, <span class="comment">// 类型必须为数字</span></span><br><span class="line">    gender: PropTypes.oneOf([<span class="string">'男'</span>, <span class="string">'女'</span>]), <span class="comment">// 性别只能为男或女</span></span><br><span class="line">    hobby: PropTypes.arrayOf(PropTypes.string), <span class="comment">// 数组成员类型必须是字符串</span></span><br><span class="line">    pos: PropTypes.shape(&#123; <span class="comment">// 限制模型内部类型</span></span><br><span class="line">      x: PropTypes.number.isRequired,</span><br><span class="line">      y: PropTypes.number.isRequired</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数为原对象，第二个参数为当前属性，第三个参数为类</span></span><br><span class="line">    salary(obj, key, P) &#123;</span><br><span class="line">      <span class="comment">// 自行校验</span></span><br><span class="line">      <span class="keyword">if</span> (obj[key] &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'工资太低'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Person &#123;...p&#125;/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>prop-types</code> 必须在类组件上添加一个静态属性 <code>propTypes</code>，在内部定义属性的类型，其中 <code>isRequired</code> 为必填项，如果没有传参会报错，在检测是会优先检测 <code>React</code> 的静态属性 <code>defaultProps</code>，即默认属性，如果 <code>defaultProps</code> 存在则视为已经有该参数。</p><p><code>oneOf</code> 方法参数为一个数组，传给组件对应的参数值必须是传给 <code>oneOf</code> 数组中的其中一项，否则会报错，<code>arrayOf</code> 方法用于限制数组成员的类型，<code>shape</code> 方法用于限属性值为对象的内部属性类型，参数为对象。</p><p>在 <code>propTypes</code> 静态属性中以传入的属性名作为方法名，则该方法为自定义校验该属性的函数，参数的前三项为原对象，属性名和所属类，可以在函数内部自行实现校验逻辑。</p><h3 id="setState-更新状态"><a href="#setState-更新状态" class="headerlink" title="setState 更新状态"></a>setState 更新状态</h3><p>在前面的时钟组件中已经简单的使用过 <code>setState</code>，在这里我们会对 <code>setState</code> 的用法通过一个计数器案例来做详细说明。</p><figure class="highlight jsx"><figcaption><span>计数器案例 1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>在上面的计数器中，当我们点击按钮时会执行 <code>handleClick</code>，而在 <code>handleClick</code> 内部调用了两次 <code>setState</code> 更新状态，但是我们启动项目后发现只有一次是有效的，这也说明了一个问题，<code>setState</code> 是异步执行的，最后一次执行的会覆盖前一次，其实在 <code>setState</code> 方法调用时支持传入一个回调函数，代码如下。</p><figure class="highlight jsx"><figcaption><span>计数器案例 2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>setState</code> 传入的回调会在更新状态成功后执行，所以将代码修改后两次 <code>setState</code> 都生效了，<code>render</code> 执行了两次，这样的写法如果调用 <code>setState</code> 次数多了就形成了 “回调地狱”，<code>setState</code> 还有另一种用法如下。</p><figure class="highlight jsx"><figcaption><span>计数器案例 3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123; <span class="attr">num</span>: prevState.num + <span class="number">1</span> &#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123; <span class="attr">num</span>: prevState.num + <span class="number">1</span> &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.num&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter&gt;&lt;/</span>Counter&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p><code>setState</code> 方法可直接传入一个函数，函数的参数为上一次更新的 <code>state</code>，也就是 <code>this.state</code>，此时执行 <code>setState</code> 只更新状态，不重新渲染，当最后一次更新状态后统一渲染一次。</p><blockquote class="pullquote info"><p><em><strong>更新组件有两种方式，一种是重新调用 <code>render</code> 并传入新的属性值，一种是通过组件调用 <code>setState</code> 重新设置状态。</strong></em></p></blockquote><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>对于组件的分类除了可以按照组件的创建方式分为函数组件和类组件，还有另外一种分类方式，就是受控组件和非受控组件，简单来说 “受控” 和 “非受控” 就是指是否受到状态的控制，这种分类方式多用于表单元素，同时也指对于表单元素数据的不同处理方式。</p><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>下面是一个受控组件的写法，输入框的初始值是通过 <code>value</code> 和 <code>defaultValue</code> 属性绑定的状态的值。</p><figure class="highlight jsx"><figcaption><span>受控组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg1: <span class="string">'hello'</span>,</span><br><span class="line">    msg2: <span class="string">'world'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.msg1&#125;/&gt; &#123;<span class="comment">/* 报错 */</span>&#125;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> defaultValue=&#123;<span class="keyword">this</span>.state.msg2&#125;/&gt; &#123;<span class="comment">/* 不报错 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面的代码中是两种绑定初始值的方式，使用 <code>defaultValue</code> 属性可以正常的将状态中的属性作为初始值绑定到页面的输入框内，但是随着输入的变化并没更新状态的作用，而使用 <code>value</code> 做了同样的绑定后，虽然页面正常显示初始值，但是控制台报错了，报错信息如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/10/20180910025959/error6.png" alt="受控组件赋初始值报错" title>                </div>                <div class="image-caption">受控组件赋初始值报错</div>            </figure><p><br></p><p>输入框的值可以通过输入改变，但受控组件要求状态的值要随着输入框内的值改变而更新，而报错信息告诉我们想要达到这样的目的必须要给表单元素绑定一个 <code>onChange</code> 事件，这个功能其实就是输入框与数据的双向绑定，修改后的实现如下。</p><figure class="highlight jsx"><figcaption><span>受控组件 —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeHandler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">msg</span>: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面的代码中在 <code>onChange</code> 事件中调用了 <code>setState</code> 并更新了状态，但是如果有多个输入框，要保证 <code>onChange</code> 事件的复用，实现不同的输入框输入时 <code>onChange</code> 事件时更新不同的状态，实现如下。</p><figure class="highlight jsx"><figcaption><span>受控组件 —— 多个输入框复用 onChange</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg1: <span class="string">'hello'</span>,</span><br><span class="line">    msg2: <span class="string">'world'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeHandler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = e.target.name;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; [val]: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"msg1"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg1&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg1&#125;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"msg2"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.msg2&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.msg2&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Control&gt;&lt;/</span>Control&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面通过给 <code>input</code> 标签添加和状态的变量名相同的 <code>name</code> 属性，在触发 <code>onChange</code> 事件时用 <code>name</code> 属性作为更新状态数据的键值。</p><blockquote class="pullquote default"><p><em><strong>受控组件的好处是，可以实时对输入框输入的值进行校验，并可以随着输入框的内容更新而更新状态，进而更新视图。</strong></em></p></blockquote><h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p>非受控组件与受控组件相比就是直接操作 <code>DOM</code> 来操作表单元素，直接操作 <code>DOM</code> 可以在 <code>componentDidMount</code> 生命周期内（DOM 完全挂载），写法如下。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— 直接操作 DOM（不建议）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>);</span><br><span class="line">    username.value = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(username.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;UnControl&gt;&lt;/</span>UnControl&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>当然在 <code>React</code> 中并不会这么写，<code>React</code> 专门给我们提供了操作 <code>DOM</code> 属性 <code>ref</code>，用法如下。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— ref 常用写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 打印输入框的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.userDom.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span> ref=&#123;dom =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.userDom = dom;</span><br><span class="line">        &#125;&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">UnControl</span>&gt;</span><span class="tag">&lt;/<span class="name">UnControl</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>使用 <code>ref</code> 属性的方式通常会在其中传入一个函数，这个函数的参数就是当前表单元素对应的 <code>DOM</code>，通常情况下会使用类组件的一个属性来存储这个 <code>DOM</code>，方便在其他的事件或生命周期 “钩子” 中使用。</p><p>在 <code>React 16.3</code> 中推出了操作非受控组件的新的 API <code>React.createRef</code> 方法，返回值是一个对象，将这个对象绑定在表单元素的 <code>ref</code> 上，则可以通过这个对象的 <code>current</code> 属性获取这个表单元素的 <code>DOM</code> 元素。</p><figure class="highlight jsx"><figcaption><span>非受控组件 —— React 16.3 新 API</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControl</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  userDom = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 打印输入框的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.userDom.current.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span> ref=&#123;<span class="keyword">this</span>.userDom&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">UnControl</span>&gt;</span><span class="tag">&lt;/<span class="name">UnControl</span>&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>我们其实把 <code>React.createRef</code> 的返回值存储为了类组件的一个属性，并将这个属性传入 <code>ref</code>，这样可以在其他的事件或生命周期 “钩子” 中操作 <code>DOM</code>，如果存在多个这样的表单元素，许多次调用 <code>React.createRef</code>，并分别将存储返回值的类组件属性传入各个表单的 <code>ref</code> 中。</p><blockquote class="pullquote warning"><p><em><strong>非受控组件的好处是，操作 <code>DOM</code> 方便，可以与更多基于 <code>DOM</code> 操作的第三方库结合。</strong></em></p></blockquote><h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><p>复合组件指的就是存在父子关系的组件嵌套，在 <code>React</code> 中有两种形式的父子组件嵌套，第一种是直接将子组件在父组件中引入，并放在父组件 <code>render</code> 方法返回的 <code>JSX</code> 中。</p><figure class="highlight jsx"><figcaption><span>复合组件 —— 第一种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是父组件</span><br><span class="line">        &lt;Child/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件</span></span><br><span class="line"><span class="regexp">class Child extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;这是子组件&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>我们前面提到过组件可以通过单闭合或者双闭合的方式调用，第二种方式就是利用双闭合的调用方式，在父组件中引入子组件，把父组件中某些 <code>JSX</code> 放在双闭合的子组件标签中，作为参数传递给子组件，在子组件中通过 <code>props</code> 的 <code>children</code> 属性进行接收，并放入对应的位置。</p><figure class="highlight jsx"><figcaption><span>复合组件 —— 第二种方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是父组件</span><br><span class="line">        &lt;Child&gt;</span><br><span class="line">          &lt;div&gt;父组件传递给子组件的 JSX&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Child&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件</span></span><br><span class="line"><span class="regexp">class Child extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        这是子组件</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>这是系列关于 <code>React</code> 基础的文章，本篇是关于 <code>React</code> 的一些基础知识，也包含了一些 <code>React 16</code> 版本的一些新增内容，比较适合不了解 <code>React</code> 框架的同学们从零开始入门，在后面会陆续更新关于复合组件参数传递、生命周期等内容。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/10/20180910025959/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Koa2 洋葱模型 —— compose 串联中间件的四种实现</title>
      <link>https://www.overtaking.top/2018/09/06/20180906170854/</link>
      <guid>https://www.overtaking.top/2018/09/06/20180906170854/</guid>
      <pubDate>Thu, 06 Sep 2018 09:08:54 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/06/20180906170854/compose-logo.png&quot; title=&quot;Koa 洋葱模型&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;Koa&lt;/code&gt; 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 &lt;code&gt;Express&lt;/code&gt; 支持了异步，所以编码时经常使用 &lt;code&gt;async/await&lt;/code&gt;，提高了可读性，使代码变得更优雅，上一篇文章 &lt;a href=&quot;https://www.overtaking.top/2018/09/02/20180902141819/&quot; target=&quot;_blank&quot;&gt;NodeJS 进阶 —— Koa 源码分析&lt;/a&gt;，也对 “洋葱模型” 和实现它的 &lt;code&gt;compose&lt;/code&gt; 进行分析，由于个人觉得 &lt;code&gt;compose&lt;/code&gt; 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 &lt;code&gt;compose&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/06/20180906170854/compose-logo.png" title="Koa 洋葱模型"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Koa</code> 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 <code>Express</code> 支持了异步，所以编码时经常使用 <code>async/await</code>，提高了可读性，使代码变得更优雅，上一篇文章 <a href="https://www.overtaking.top/2018/09/02/20180902141819/" target="_blank">NodeJS 进阶 —— Koa 源码分析</a>，也对 “洋葱模型” 和实现它的 <code>compose</code> 进行分析，由于个人觉得 <code>compose</code> 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 <code>compose</code>。</p></blockquote><a id="more"></a><h2 id="洋葱模型案例"><a href="#洋葱模型案例" class="headerlink" title="洋葱模型案例"></a>洋葱模型案例</h2><p>如果你已经使用 <code>Koa</code> 对 “洋葱模型” 这个词一定不陌生，它就是 <code>Koa</code> 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面的写法我们按照官方推荐，使用了 <code>async/await</code>，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 <code>next</code>，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 <code>Koa</code> 源码中，这一功能是靠一个 <code>compose</code> 方法实现的，我们本文四种实现 <code>compose</code> 的方式中实现同步和异步，并附带对应的案例来验证。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在真正创建 <code>compose</code> 方法之前应该先做些准备工作，比如创建一个 <code>app</code> 对象来顶替 <code>Koa</code> 创建出的实例对象，并添加 <code>use</code> 方法和管理中间件的数组 <code>middlewares</code>。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Koa 创建的实例</span></span><br><span class="line"><span class="keyword">const</span> app = &#123;</span><br><span class="line">  middlewares: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 use 方法</span></span><br><span class="line">app.use = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  app.middlewares.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.compose.....</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><p>上面的模块中导出了 <code>app</code> 对象，并创建了存储中间件函数的 <code>middlewares</code> 和添加中间件的 <code>use</code> 方法，因为无论用哪种方式实现 <code>compose</code> 这些都是需要的，只是 <code>compose</code> 逻辑的不同，所以后面的代码块中会只写 <code>compose</code> 方法。</p><h2 id="Koa-中-compose-的实现方式"><a href="#Koa-中-compose-的实现方式" class="headerlink" title="Koa 中 compose 的实现方式"></a>Koa 中 compose 的实现方式</h2><p>首先介绍的是 <code>Koa</code> 源码中的实现方式，在 <code>Koa</code> 源码中其实是通过 <code>koa-compose</code> 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 <code>compose</code> 的原理，所以 <code>ctx</code> 参数就被去掉了，因为我们不会使用它，重点是 <code>next</code> 参数。</p><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所有中间件都执行完跳出</span></span><br><span class="line">    <span class="keyword">if</span> (index === app.middlewares.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第 index 个中间件并执行</span></span><br><span class="line">    <span class="keyword">const</span> route = app.middlewares[index];</span><br><span class="line">    <span class="keyword">return</span> route(<span class="function"><span class="params">()</span> =&gt;</span> dispatch(++index));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出第一个中间件函数执行</span></span><br><span class="line">  dispatch(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是同步的实现，通过递归函数 <code>dispatch</code> 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 <code>dispatch</code>，传入的参数 <code>+1</code>，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 <code>1 3 5 6 4 2</code> 的情况执行，测试例子如下（同步上、异步下）。</p><figure class="highlight js"><figcaption><span>文件：sync-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">"./app"</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">next</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>文件：async-test.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">"./app"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> fn(); <span class="comment">// 调用异步函数</span></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> next =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose();</span><br></pre></td></tr></table></figure><p>我们发现如果案例中按照 <code>Koa</code> 的推荐写法，即使用 <code>async</code> 函数，都会通过，但是在给 <code>use</code> 传参时可能会传入普通函数或 <code>async</code> 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 <code>Koa</code> 中 <code>compose</code> 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。</p><blockquote class="pullquote warning"><p><em><strong>注意：后面 <code>compose</code> 的其他实现方式中，都是使用 <code>sync-test.js</code> 和 <code>async-test.js</code> 验证，所以后面就不再重复了。</strong></em></p></blockquote><h3 id="升级为支持异步"><a href="#升级为支持异步" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所有中间件都执行完跳出，并返回一个 Promise</span></span><br><span class="line">    <span class="keyword">if</span> (index === app.middlewares.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出第 index 个中间件并执行</span></span><br><span class="line">    <span class="keyword">const</span> route = app.middlewares[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行后返回成功态的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(<span class="function"><span class="params">()</span> =&gt;</span> dispatch(++index)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出第一个中间件函数执行</span></span><br><span class="line">  dispatch(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>async</code> 函数中 <code>await</code> 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 <code>async-test.js</code> 进行测试，发现结果为 <code>1 3 hello(3s后) 5 6 4 2</code>。</p><h2 id="Redux-旧版本-compose-的实现方式"><a href="#Redux-旧版本-compose-的实现方式" class="headerlink" title="Redux 旧版本 compose 的实现方式"></a>Redux 旧版本 compose 的实现方式</h2><h3 id="同步的实现-1"><a href="#同步的实现-1" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> app.middlewares.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> () =&gt; b(a), () =&gt; &#123;&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 <code>middlewares</code> 中存储的三个中间件函数分别为 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于使用的是 <code>reduceRight</code> 方法，所以是逆序归并，第一次 <code>a</code> 代表初始值（空函数），<code>b</code> 代表 <code>fn3</code>，而执行 <code>fn3</code> 返回了一个函数，这个函数再作为下一次归并的 <code>a</code>，而 <code>fn2</code> 作为 <code>b</code>，依次类推，过程如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 次 reduceRight 的返回值，下一次将作为 a</span></span><br><span class="line">() =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)));</span><br></pre></td></tr></table></figure><p>由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 <code>fn1</code>，如果调用 <code>next</code> 则会执行 <code>fn2</code>，如果同样调用 <code>next</code> 则会执行 <code>fn3</code>，<code>fn3</code> 已经是最后一个中间件函数了，再次调 <code>next</code> 会执行我们最初传入的空函数，这也是为什么要将 <code>reduceRight</code> 的初始值设置成一个空函数，就是防止最后一个中间件调用 <code>next</code> 而报错。</p><p>经过测试上面的代码不会出现顺序错乱的情况，但是在 <code>compose</code> 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 <code>use</code> 的中间件函数既可以是普通函数，又可以是 <code>async</code> 函数，这就要我们的 <code>compose</code> 完全支持异步。</p><h3 id="升级为支持异步-1"><a href="#升级为支持异步-1" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">    app.middlewares.reduceRight(</span><br><span class="line">      (a, b) =&gt; <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(b(a)),</span><br><span class="line">      () =&gt; <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    )()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 <code>next</code> 后又调用了 <code>then</code>），都处理成了 Promise，保证了 <code>reduceRight</code> 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 <code>async</code> 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 <code>compose</code> 就可以调用 <code>then</code> 方法执行后续逻辑。</p><h2 id="Redux-新版本-compose-的实现方式"><a href="#Redux-新版本-compose-的实现方式" class="headerlink" title="Redux 新版本 compose 的实现方式"></a>Redux 新版本 compose 的实现方式</h2><h3 id="同步的实现-2"><a href="#同步的实现-2" class="headerlink" title="同步的实现"></a>同步的实现</h3><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> app.middlewares.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> arg =&gt; a(<span class="function"><span class="params">()</span> =&gt;</span> b(arg)))(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Redux</code> 新版本中将 <code>compose</code> 的逻辑做了些改动，将原本的 <code>reduceRight</code> 换成 <code>reduce</code>，也就是说将逆序归并改为了正序，我们不一定和 <code>Redux</code> 源码完全相同，是根据相同的思路来实现串行中间件的需求。</p><p>个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于 <code>reduce</code> 并没有传入初始值，所以此时 <code>a</code> 为 <code>fn1</code>，<code>b</code> 为 <code>fn2</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 reduce 的返回值，下一次将作为 a</span></span><br><span class="line">arg =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(arg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 reduce 的返回值，下一次将作为 a</span></span><br><span class="line">arg =&gt; <span class="function">(<span class="params">arg =&gt; fn1((</span>) =&gt;</span> fn2(arg)))(<span class="function"><span class="params">()</span> =&gt;</span> fn3(arg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于...</span></span><br><span class="line">arg =&gt; fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(arg)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行最后返回的函数连接中间件，返回值等价于...</span></span><br><span class="line">fn1(<span class="function"><span class="params">()</span> =&gt;</span> fn2(<span class="function"><span class="params">()</span> =&gt;</span> fn3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)));</span><br></pre></td></tr></table></figure><p>所以在调用 <code>reduce</code> 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 <code>fn3</code>，也就是第三个中间件，这样保证了在最后一个中间件调用 <code>next</code> 时不会报错。</p><h3 id="升级为支持异步-2"><a href="#升级为支持异步-2" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><p>下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">    app.middlewares.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> a(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(b(arg)));</span><br><span class="line">    &#125;)(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve())</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 <code>compose</code> 也返回 Promise。</p><h2 id="使用-async-函数实现"><a href="#使用-async-函数实现" class="headerlink" title="使用 async 函数实现"></a>使用 async 函数实现</h2><p>这个版本是我在之前在学习 <code>Koa</code> 源码时偶然在一位大佬的一篇分析 <code>Koa</code> 原理的文章中看到的（翻了半天实在没找到链接），在这里也拿出来和大家分享一下，由于是利用 <code>async</code> 函数实现的，所以默认就是支持异步的，因为 <code>async</code> 函数会返回一个 Promise。</p><figure class="highlight js"><figcaption><span>文件：app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.compose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自执行 async 函数返回 Promise</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义默认的 next，最后一个中间件内执行的 next</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="keyword">async</span> () =&gt; <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next</span></span><br><span class="line">    <span class="comment">// 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createNext</span>(<span class="params">middleware, oldNext</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> middleware(oldNext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向遍历中间件数组，先把 next 传给最后一个中间件函数</span></span><br><span class="line">    <span class="comment">// 将新的中间件函数存入 next 变量</span></span><br><span class="line">    <span class="comment">// 调用下一个中间件函数，将新生成的 next 传入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = app.middlewares.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      next = createNext(app.middlewares[i], next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>next</code> 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 <code>next</code>，而数组 <code>middlewares</code> 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 <code>createNext</code> 作用是返回一个新的可以执行数组中最后一个中间件的 <code>async</code> 函数，并传入了初始的 <code>next</code>，这个返回的 <code>async</code> 函数作为新的 <code>next</code>，再取到倒数第二个中间件，调用 <code>createNext</code>，又返回了一个 <code>async</code> 函数，函数内依然是倒数第二个中间件的执行，传入的 <code>next</code> 就是上次新生成的 <code>next</code>，这样依次类推到第一个中间件。</p><p>因此执行第一个中间件返回的 <code>next</code> 则会执行传入的上一个生成的 <code>next</code> 函数，就会执行第二个中间件，就会执行第二个中间件中的 <code>next</code>，就这样直到执行完最初定义的 <code>next</code>，通过案例的验证，执行结果与洋葱模型完全相同。</p><p>至于异步的问题，每次执行的 <code>next</code> 都是 <code>async</code> 函数，执行后返回的都是 Promise，而最外层的自执行 <code>async</code> 函数返回的也是 Promise，也就是说 <code>compose</code> 最后返回的是 Promise，因此完全支持异步。</p><blockquote class="pullquote info"><p><em><strong>这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>或许你看完这几种方式会觉得，还是 <code>Koa</code> 对于 <code>compose</code> 的实现方式最容易理解，你也可能和我一样在感慨 <code>Redux</code> 的两种实现方式和 <code>async</code> 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想，写出 <code>compose</code> 这种优雅又高逼格的代码，路漫漫其修远兮，愿你在技术的路上 “一去不复返”。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/06/20180906170854/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NodeJS 进阶 —— Koa 源码分析</title>
      <link>https://www.overtaking.top/2018/09/02/20180902141819/</link>
      <guid>https://www.overtaking.top/2018/09/02/20180902141819/</guid>
      <pubDate>Sun, 02 Sep 2018 06:18:19 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/02/20180902141819/koa-cover.png&quot; title=&quot;Koa 源码解析&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote success&quot;&gt;&lt;p&gt;&lt;code&gt;Koa 2.x&lt;/code&gt; 版本是当下最流行的 NodeJS 框架，同时社区涌现出一大批围绕 &lt;code&gt;Koa 2.x&lt;/code&gt; 的中间件以及基于 &lt;code&gt;Koa 2.x&lt;/code&gt; 封装的企业级框架，如 &lt;code&gt;egg.js&lt;/code&gt;，然而 &lt;code&gt;Koa&lt;/code&gt; 本身的代码却非常精简，精简到所有文件的代码去掉注释后还不足 &lt;code&gt;2000&lt;/code&gt; 行，本篇就围绕着这 &lt;code&gt;2000&lt;/code&gt; 行不到的代码抽出核心逻辑进行分析，并压缩成一版只有 &lt;code&gt;200&lt;/code&gt; 行不到的简易版 &lt;code&gt;Koa&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/02/20180902141819/koa-cover.png" title="Koa 源码解析"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><code>Koa 2.x</code> 版本是当下最流行的 NodeJS 框架，同时社区涌现出一大批围绕 <code>Koa 2.x</code> 的中间件以及基于 <code>Koa 2.x</code> 封装的企业级框架，如 <code>egg.js</code>，然而 <code>Koa</code> 本身的代码却非常精简，精简到所有文件的代码去掉注释后还不足 <code>2000</code> 行，本篇就围绕着这 <code>2000</code> 行不到的代码抽出核心逻辑进行分析，并压缩成一版只有 <code>200</code> 行不到的简易版 <code>Koa</code>。</p></blockquote><a id="more"></a><h2 id="Koa-分析过程"><a href="#Koa-分析过程" class="headerlink" title="Koa 分析过程"></a>Koa 分析过程</h2><p>在下面的内容中，我们将对 <code>Koa</code> 所使用的功能由简入深的分析，首先会给出使用案例，然后根据使用方式，分析实现原理，最后对分析的功能进行封装，封装过程会从零开始并一步一步完善，代码也是从少到多，会完整的看到一个简版 <code>Koa</code> 诞生的过程，再此之前我们打开 <code>Koa</code> <a href="https://github.com/koajs/koa/tree/master/lib" target="_blank">源码地址</a>。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/koa-dir.png" alt="Koa 文件目录" title>                </div>                <div class="image-caption">Koa 文件目录</div>            </figure><p><br></p><p>通过上面对 <code>Koa</code> 源码目录的截图，发现只有 <code>4</code> 个核心文件，为了方便理解，封装简版 <code>Koa</code> 的文件目录结构也将严格与源码同步。</p><h2 id="搭建基本服务"><a href="#搭建基本服务" class="headerlink" title="搭建基本服务"></a>搭建基本服务</h2><p>在引入 <code>Koa</code> 时我们需要创建一个 <code>Koa</code> 的实例，而启动服务是通过 <code>listen</code> 监听一个端口号实现的，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过使用我们可以分析出 <code>Koa</code> 导出的应该是一个类，或者构造函数，鉴于 <code>Koa</code> 诞生的时间以及基于 <code>node v7.6.0</code> 以上版本的情况来分析，正是 <code>ES6</code> 开始 “横行霸道” 的时候，所以推测 <code>Koa</code> 导出的应该是一个类，打开源码一看，果然如此，所以我们也通过 <code>class</code> 的方式来实现。</p><p>而从启动服务的方式上看，<code>app.listen</code> 的调用方式与原生 <code>http</code> 模块提供的 <code>server.listen</code> 几乎相同，我们分析，<code>listen</code> 方法应该是对原生 <code>http</code> 模块的一个封装，启动服务的本质还是靠 <code>http</code> 模块来实现的。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 请求回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>上面的代码初步实现了我们上面分析出的需求，为了防止代码冗余，我们将创建服务的回调抽取成一个 <code>handleRequest</code> 的实例方法，内部的逻辑在后面完善，现在可以创建这个 <code>Koa</code> 类的实例，通过调用实例的 <code>listen</code> 方法启动一个服务器。</p><h2 id="上下文对象-ctx-的封装"><a href="#上下文对象-ctx-的封装" class="headerlink" title="上下文对象 ctx 的封装"></a>上下文对象 ctx 的封装</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>Koa</code> 还有一个很重要的特性，就是它的 <code>ctx</code> 上下文对象，我们可以调用 <code>ctx</code> 的 <code>request</code> 和 <code>response</code> 属性获取原 <code>req</code> 和 <code>res</code> 的属性和方法，也在 <code>ctx</code> 上增加了一些原生没有的属性和方法，总之 <code>ctx</code> 给我们要操作的属性和方法提供了多种调用方式，使用案例如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 原生的 req 对象的 url 属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(ctx.req.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.req.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.response.req.url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Koa 扩展的 url</span></span><br><span class="line">  <span class="built_in">console</span>.log(ctx.url);</span><br><span class="line">  <span class="built_in">console</span>.log(ctx.request.req.url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置状态码和响应内容</span></span><br><span class="line">  ctx.response.status = <span class="number">200</span>;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建-ctx-的引用关系"><a href="#创建-ctx-的引用关系" class="headerlink" title="创建 ctx 的引用关系"></a>创建 ctx 的引用关系</h3><p>从上面我们可以看出，<code>ctx</code> 为 <code>use</code> 方法的第一个参数，<code>request</code> 和 <code>response</code> 是 <code>ctx</code> 新增的，而通过这两个属性又都可以获取原生的 <code>req</code> 和 <code>res</code> 属性，<code>ctx</code> 本身也可以获取到原生的 <code>req</code> 和 <code>res</code>，我们可以分析出，<code>ctx</code> 是对这些属性做了一个集成，或者说特殊处理。</p><p>源码的文件目录中正好有与 <code>request</code>、<code>response</code> 名字相对应的文件，并且还有 <code>context</code> 名字的文件，我们其实可以分析出这三个文件就是用于封装 <code>ctx</code> 上下文对象使用的，而封装 <code>ctx</code> 中也会用到 <code>req</code> 和 <code>res</code>，所以核心逻辑应该在 <code>handleRequest</code> 中实现。</p><p>在使用案例中 <code>ctx</code> 是作为 <code>use</code> 方法中回调函数的参数，所以我们分析应该有一个数组统一管理调用 <code>use</code> 后传入的函数，<code>Koa</code> 应该有一个属性，值为数组，用来存储这些函数，下面是实现代码。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>首先，给实例创建了三个属性 <code>context</code>、<code>request</code> 和 <code>response</code> 分别继承了 <code>context.js</code>、<code>request.js</code> 和 <code>response.js</code> 导出的对象，之所以这么做而不是直接赋值是防止操作实例属性时 “污染” 原对象，而获取原模块导出对象的属性可以通过原型链进行查找，并不影响取值。</p><p>其次，给实例挂载了 <code>middlewares</code> 属性，值为数组，为了存储 <code>use</code> 方法调用时传入的函数，在 <code>handleRequest</code> 把创建 <code>ctx</code> 属性及引用的过程单独抽取成了 <code>createContext</code> 方法，并在 <code>handleRequest</code> 中调用，返回值为创建好的 <code>ctx</code> 对象，而在 <code>createContext</code> 中我们根据案例中的规则构建了 <code>ctx</code> 的属性相关的各种引用关系。</p><h3 id="实现-request-取值"><a href="#实现-request-取值" class="headerlink" title="实现 request 取值"></a>实现 request 取值</h3><p>上面构建的属性中，所有通过访问原生 <code>req</code> 或 <code>res</code> 的属性都能获取到，反之则是 <code>undefined</code>，这就需要我们去构建 <code>request.js</code>。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/request.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 url 和 path 添加 getter</span></span><br><span class="line"><span class="keyword">const</span> request = &#123;</span><br><span class="line">  <span class="keyword">get</span> url() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.req.url;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> path() &#123;</span><br><span class="line">    <span class="keyword">return</span> url.parse(<span class="keyword">this</span>.req.url).pathname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = request;</span><br></pre></td></tr></table></figure><p>上面我们只构造了两个属性 <code>url</code> 和 <code>path</code>，我们知道 <code>url</code> 是原生所自带的属性，我们在使用 <code>ctx.request.url</code> 获取是通过 <code>request</code> 对象设置的 <code>getter</code>，将 <code>ctx.request.req.url</code> 的值返回了。</p><p><code>path</code> 是原生 <code>req</code> 所没有的属性，但却是通过原生 <code>req</code> 的 <code>url</code> 属性和 <code>url</code> 模块共同构建出来的，所以我们同样用了给 <code>request</code> 对象设置 <code>getter</code> 的方式获取 <code>req</code> 的 <code>url</code> 属性，并使用 <code>url</code> 模块将转换对象中的 <code>pathname</code> 返回，此时就可以通过 <code>ctx.request.path</code> 来获取访问路径，至于源码中我们没有处理的 <code>req</code> 属性都是通过这样的方式建立的引用关系。</p><h3 id="实现-response-的取值和赋值"><a href="#实现-response-的取值和赋值" class="headerlink" title="实现 response 的取值和赋值"></a>实现 response 的取值和赋值</h3><p><code>Koa</code> 中 <code>response</code> 对象的真正作用是给客户端进行响应，使用时是通过访问属性获取，并通过重新赋值实现响应，但是现在 <code>response</code> 获取的属性都是 <code>undefined</code>，我们这里先不管响应给浏览器的问题，首先要让 <code>response</code> 下的某个属性有值才行，下面我们来实现 <code>response.js</code>。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/response.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 body 和 status 添加 getter 和 setter</span></span><br><span class="line"><span class="keyword">const</span> response = &#123;</span><br><span class="line">  <span class="keyword">get</span> body() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._body;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> body(val) &#123;</span><br><span class="line">    <span class="comment">// 只要给 body 赋值就代表响应成功</span></span><br><span class="line">    <span class="keyword">this</span>.status = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">this</span>._body = val;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> status() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.res.statusCode;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> status(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.res.statusCode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = response;</span><br></pre></td></tr></table></figure><p>这里选择了 <code>Koa</code> 在使用时，<code>response</code> 对象上比较重要的两个属性进行处理，因为这两个属性是服务器响应客户端所必须的，并模仿了 <code>request.js</code> 的方式给 <code>body</code> 和 <code>status</code> 设置了 <code>getter</code>，不同的是响应浏览器所做的其实是赋值操作，所以又给这两个属性添加了 <code>setter</code>，对于 <code>status</code> 来说，直接操作原生 <code>res</code> 对象的 <code>statusCode</code> 属性即可，因为同为赋值操作。</p><p>还有一点，响应是通过给 <code>body</code> 赋值实现，我们认为只要触发了 <code>body</code> 的 <code>setter</code> 就成功响应，所以在 <code>body</code> 的 <code>getter</code> 中将响应状态码设置为 <code>200</code>，至于 <code>body</code> 赋值是如何实现响应的，放在后面再说。</p><h3 id="ctx-代理-request、response-的属性"><a href="#ctx-代理-request、response-的属性" class="headerlink" title="ctx 代理 request、response 的属性"></a>ctx 代理 request、response 的属性</h3><p>上面实现了通过 <code>request</code> 和 <code>response</code> 对属性的操作，<code>Koa</code> 虽然给我们提供了多样的属性操作方式，但由于我们程序猿（媛）们都很 “懒”，几乎没有人会在开发的时候愿意多写代码，大部分情况都是通过 <code>ctx</code> 直接操作 <code>request</code> 和 <code>response</code> 上的属性，这就是我们现在的问题所在，这些属性通过 <code>ctx</code> 访问不到。</p><p>我们需要给 <code>ctx</code> 对象做一个代理，让 <code>ctx</code> 可以访问到 <code>request</code> 和 <code>response</code> 上的属性，这个场景何曾相识，不正是 <code>Vue</code> 创建实例时，将传入参数对象 <code>options</code> 的 <code>data</code> 属性代理给实例本身的场景吗，既然如此，我们也通过相似的方式实现，还记得上面引入的 <code>context</code> 模块作为实例的 <code>context</code> 属性所继承的对象，而剩下的最后一个核心文件 <code>context.js</code> 正是用来做这件事的，代码如下。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/context.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将传入对象属性代理给 ctx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineGetter</span>(<span class="params">property, key</span>) </span>&#123;</span><br><span class="line">  proto.__defineGetter__(key, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[property][key];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ctx 值时直接操作传入对象的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineSetter</span>(<span class="params">property, key</span>) </span>&#123;</span><br><span class="line">  proto.__defineSetter__(key, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[property][key] = val;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 request 的 url 和 path 代理给 ctx</span></span><br><span class="line">defineGetter(<span class="string">'request'</span>, <span class="string">'url'</span>);</span><br><span class="line">defineGetter(<span class="string">'request'</span>, <span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 response 的 body 和 status 代理给 ctx</span></span><br><span class="line">defineGetter(<span class="string">'response'</span>, <span class="string">'body'</span>);</span><br><span class="line">defineSetter(<span class="string">'response'</span>, <span class="string">'body'</span>);</span><br><span class="line">defineGetter(<span class="string">'response'</span>, <span class="string">'status'</span>);</span><br><span class="line">defineSetter(<span class="string">'response'</span>, <span class="string">'status'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = proto;</span><br></pre></td></tr></table></figure><p>在 <code>Vue</code> 中是使用 <code>Object.defineProperty</code> 来时实现的代理，而在 <code>Koa</code> 源码中借助了 <code>delegate</code> 第三方模块来实现的，并在添加代理时链式调用了 <code>delegate</code> 封装的方法，我们并没有直接使用 <code>delegate</code> 模块，而是将 <code>delegate</code> 内部的核心逻辑抽取出来在 <code>context.js</code> 中直接编写，这样方便大家理解原理，也可以清楚的知道是如何实现代理的。</p><p>我们封装了两个方法 <code>defineGetter</code> 和 <code>defineSetter</code> 分别来实现取值和设置值时，将传入的属性（第二个参数）代理给传入的对象（第一个参数），函数内是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__" target="_blank">Object.prototype.__defineGetter__</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__" target="_blank">Object.prototype.__defineSetter__</a> 实现的，点击方法名可查看官方 API。</p><h2 id="洋葱模型-——-实现中间件的串行"><a href="#洋葱模型-——-实现中间件的串行" class="headerlink" title="洋葱模型 —— 实现中间件的串行"></a>洋葱模型 —— 实现中间件的串行</h2><blockquote class="pullquote info"><p>现在已经实现了 <code>ctx</code> 上下文对象的创建，但是会发现我们封装 <code>ctx</code> 之前所写的案例 <code>use</code> 回调中的代码并不能执行，也不会报错，根本原因是 <code>use</code> 方法内传入的函数没有调用，在使用 <code>Koa</code> 的过程中会发现，我们往往使用多个 <code>use</code>，并且传入 <code>use</code> 的回调函数除了 <code>ctx</code> 还有第二个参数 <code>next</code>，而这个 <code>next</code> 也是一个函数，调用 <code>next</code> 则执行下一个 <code>use</code> 中的回调函数，否则就会 “卡住”，这种执行机制被取名为 “洋葱模型”，而这些被执行的函数被称为 “中间件”，下面我们就来分析这个 “洋葱模型” 并实现中间件的串行。</p></blockquote><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/onion-model.png" alt="洋葱模型执行过程" title>                </div>                <div class="image-caption">洋葱模型执行过程</div>            </figure><p><br></p><h3 id="洋葱模型分析"><a href="#洋葱模型分析" class="headerlink" title="洋葱模型分析"></a>洋葱模型分析</h3><p>下面来看看表述洋葱模型的一个经典案例，结果似乎让人匪夷所思，一时很难想到原因，不着急先看了再说。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>根据上面的执行特性我们不妨来分析以下，我们知道 <code>use</code> 方法执行时其实是把传入的回调函数放入了实例的 <code>middlewares</code> 数组中，而执行结果打印了 <code>1</code> 说明第一个回调函数被执行了，接着又打印了 <code>2</code> 说明第二个回调函数被执行了，根据上面的代码我们可以大胆的猜想，第一个回调函数调用的 <code>next</code> 肯定是一个函数，可能就是下一个回调函数，或者是 <code>next</code> 函数中执行了下一个回调函数，这样根据函数调用栈先进后出的原则，会在 <code>next</code> 执行完毕，即出栈后，继续执行上一个回调函数的代码。</p><h3 id="支持异步的中间件串行"><a href="#支持异步的中间件串行" class="headerlink" title="支持异步的中间件串行"></a>支持异步的中间件串行</h3><p>在实现中间件串行之前需要补充一点，中间件函数内调用 <code>next</code> 时，前面的代码出现异步，则会继续向下执行，等到异步执行结束后要执行的代码插入到同步代码中，这会导致执行顺序错乱，所以在官方推荐中告诉我们任何遇到异步的操作前都需要使用 <code>await</code> 进行等待（包括 <code>next</code>，因为下一个中间件中可能包含异步操作），这也间接的说明了传入 <code>use</code> 的回调函数只要有异步代码需要 <code>await</code>，所以应该是 <code>async</code> 函数，而了解 <code>ES7</code> 特性 <code>async/await</code> 的我们来说，一定能分析出 <code>next</code> 返回的应该是一个 Promise 实例，下面是我们在之前 <code>application.js</code> 基础上的实现。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>仔细想想我们其实在利用循环执行每一个 <code>middlewares</code> 中的函数，而且需要把下一个中间件函数的执行作为函数体的代码包装一层成为新的函数，并作为参数 <code>next</code> 传入，那么在上一个中间件函数内部调用 <code>next</code> 就相当于先执行了下一个中间件函数，而下一个中间件函数内部调用 <code>next</code>，又先执行了下一个的下一个中间件函数，依次类推。</p><p>直到执行到最后一个中间件函数，调用了 <code>next</code>，但是 <code>middlewares</code> 中已经没有下一个中间件函数了，这也是为什么我们要给下一个中间件函数外包了一层函数而不是直接将中间件函数传入的原因之一（另一个原因是解决传参问题，因为在执行时还要传入下一个中间件函数），但是防止递归 “死循环”，要配合一个终止条件，即指向 <code>middlewares</code> 索引的变量等于了 <code>middlewares</code> 的长度，最后只是相当于执行了一个只有一条判断语句的函数就 <code>return</code> 的函数，而并没有报错。</p><p>在这整个过程中如果有任意一个 <code>next</code> 没有被调用，就不会向下执行其他的中间件函数，这样就 “卡住了”，完全符合 <code>Koa</code> 中间件的执行规则，而 <code>await</code> 过后也就是下一个中间件优先执行完成，则会继续执行当前中间件 <code>next</code> 调用下面的代码，这也就是 <code>1、3、5、6、4、2</code> 的由来。</p><p>为了实现所描述的执行过程，将所有中间件串行的逻辑抽出了一个 <code>compose</code> 方法，但是我们没有使用普通的循环，而是使用递归实现的，首先在 <code>compose</code> 创建 <code>dispatch</code> 递归函数，参数为当前数组函数的索引，初始值为 <code>0</code>，函数逻辑是先取出第一个函数执行，并传入一个回调函数参数，回调函数参数中递归 <code>dispatch</code>，参数 <code>+1</code>，这样就会将整个中间件串行起来了。</p><p>但是上面的串行也只是同步串行，如果某个中间件内部需要等待异步，则调用得 <code>next</code> 函数必须返回一个 Promise，有些中间件没有执行异步，则不需要 <code>async</code> 函数，也不会返回 Promise，而 <code>Koa</code> 规定只要遇到 <code>next</code> 就需要等待，则将取出每一个中间件函数执行后的结果使用 <code>Promise.resolve</code> 强行包装成一个成功态的 Promise，就对异步进行了兼容。</p><p>我们最后也希望 <code>compose</code> 返回一个 Promise 方便执行一些只有在中间件都执行后才会执行的逻辑，每次串行最后执行的都是一个只有一条判断逻辑就 <code>return</code> 了的函数（包含一个中间件也没有的情况），此时 <code>compose</code> 返回了 <code>undefined</code>，无法调用 <code>then</code> 方法，为了兼容这种情况也强行的使用相同的 “招数”，在判断条件的 <code>return</code> 关键字后面加上了 <code>Promise.resolve()</code>，直接返回了一个成功态的 Promise。</p><blockquote class="pullquote warning"><p><em><strong>注意：官方只是推荐我们在调用 <code>next</code> 的时候使用 <code>await</code> 等待，即使执行的 <code>next</code> 真的存在异步，也不是非 <code>await</code> 不可，我们完全可以使用 <code>return</code> 来代替 <code>await</code>，唯一的区别就是 <code>next</code> 调用后，下面的代码不会再执行了，类比 “洋葱模型”，形象地说就是 “下去了就上不来了”，这个完全可以根据我们的使用需要而定，如果 <code>next</code> 后面不再有任何逻辑，完全可以使用 <code>return</code> 替代。</strong></em></p></blockquote><h2 id="实现真正的响应"><a href="#实现真正的响应" class="headerlink" title="实现真正的响应"></a>实现真正的响应</h2><p>在对 <code>ctx</code> 实现属性代理后，我们通过 <code>ctx.body</code> 重新赋值其实只是改变了 <code>response.js</code> 导出对象的 <code>_body</code> 属性，而并没有实现真正的响应，看下面这个 <code>Koa</code> 的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = fs.createReadStream(<span class="string">'1.txt'</span>);</span><br><span class="line"></span><br><span class="line">  ctx.body = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'panda'</span>), <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实最后响应给客户端的值是 <code>panda</code>，正常在最后一个中间件执行后，由于异步定时器的代码没有执行完，<code>ctx.body</code> 最后的值应该是 <code>1.txt</code> 的可读流，这与客户端接收到的值相违背，通过这个猜想上的差异我们应该知道，<code>compose</code> 在串行执行中间件后为什么要返回一个 Promise 了，因为最后执行的只有判断语句的函数会等待我们例子中最后一个 <code>use</code> 传入的中间件函数执行完毕调用，也就是说在执行 <code>compose</code> 返回值的 <code>then</code> 时，<code>ctx.body</code> 的值已经是 <code>panda</code> 了。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">    <span class="comment">// 设置默认状态码（Koa 规定），必须在调用中间件之前</span></span><br><span class="line">    ctx.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取最后 body 的值</span></span><br><span class="line">      <span class="keyword">let</span> body = ctx.body;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器</span></span><br><span class="line">      <span class="keyword">if</span> (Buffer.isBuffer(body) || <span class="keyword">typeof</span> body === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 Buffer 类型的数据</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line">        res.end(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> body === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理对象类型</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) &#123;</span><br><span class="line">        <span class="comment">// 处理流类型的数据</span></span><br><span class="line">        body.pipe(res);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>处理 <code>response</code> 时，在 <code>body</code> 的 <code>setter</code> 中将状态码设置为了 <code>200</code>，就是说需要设置 <code>ctx.body</code> 去触发 <code>setter</code> 让响应成功，如果没有给 <code>ctx.body</code> 设置任何值，默认应该是无响应的，在官方文档也有默认状态码为 <code>404</code> 的明确说明，所以在 <code>handleRequest</code> 把状态码设置为了 <code>404</code>，但必须在 <code>compose</code> 执行之前才叫默认状态码，因为中间件中可能会操作 <code>ctx.body</code>，重新设置状态码。</p><p>在 <code>comose</code> 的 <code>then</code> 中，也就是在所有中间件执行后，我们取出 <code>ctx.body</code> 的值，即为最后生效的响应值，对该值进行了数据类型验证，如 Buffer、字符串、对象和流，并分别用不同的方式处理了响应，但本质都是调用的原生 <code>res</code> 对象的 <code>end</code> 方法。</p><h2 id="中间件错误处理"><a href="#中间件错误处理" class="headerlink" title="中间件错误处理"></a>中间件错误处理</h2><p>在上面的逻辑当中我们实现了很多 <code>Koa</code> 的核心逻辑，但是只考虑了顺利执行的情况，并没有考虑如果中间件中代码执行出现错误的问题，如下面案例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 error 监听</span></span><br><span class="line">app.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们之所以让 <code>compose</code> 方法在执行所有中间件后返回一个 Promise 还有一个更重要的意义，因为在 Promise 链式调用中，只要其中任何一个环节出现代码执行错误或抛出异常，都会直接执行出现错误的 <code>then</code> 方法中错误的回调或者最后的 <code>catch</code> 方法，对于 <code>Koa</code> 中间件的串行而言，最后一个 <code>then</code> 调用 <code>catch</code> 方法就是 <code>compose</code> 的返回值调用 <code>then</code> 后继续调用的 <code>catch</code>，<code>catch</code> 内可以捕获到任意一个中间件执行时出现的错误。</p><figure class="highlight js"><figcaption><span>文件路径：&#126koa/application.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line"><span class="comment">// 继承 EventEmitter 后可以用创建的实例 app 添加 error 监听，可以通过 emit 触发监听</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Koa</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    supper();</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储中间件</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="comment">// 将传给 use 的函数存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="comment">// 或取定义的上下文</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 request 和 response</span></span><br><span class="line">    ctx.request = <span class="keyword">this</span>.request;</span><br><span class="line">    ctx.response = <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 ctx、request、response 都具有原生的 req 和 res</span></span><br><span class="line">    ctx.req = ctx.request.req = ctx.response.req = req;</span><br><span class="line">    ctx.res = ctx.response.res = ctx.request.res = res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;</span><br><span class="line">  compose(ctx, middles) &#123;</span><br><span class="line">    <span class="comment">// 创建一个递归函数，参数为存储中间件的索引，从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）</span></span><br><span class="line">      <span class="keyword">if</span> (index === middles.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出第 index 个中间件函数</span></span><br><span class="line">      <span class="keyword">const</span> route = middles[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(route(ctx, () =&gt; dispatch(++index)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 默认执行一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 创建 ctx 上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认状态码（Koa 规定），必须在调用中间件之前</span></span><br><span class="line">    ctx.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 compose 将中间件组合在一起</span></span><br><span class="line">    <span class="keyword">this</span>.compose(ctx, <span class="keyword">this</span>.middlewares).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取最后 body 的值</span></span><br><span class="line">      <span class="keyword">let</span> body = ctx.body;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器</span></span><br><span class="line">      <span class="keyword">if</span> (Buffer.isBuffer(body) || <span class="keyword">typeof</span> body === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 Buffer 类型的数据</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line">        res.end(body);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> body === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理对象类型</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) &#123;</span><br><span class="line">        <span class="comment">// 处理流类型的数据</span></span><br><span class="line">        body.pipe(res);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行 error 事件</span></span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 500 状态码</span></span><br><span class="line">      ctx.status = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回状态码对应的信息响应浏览器</span></span><br><span class="line">      res.end(httpServer.STATUS_CODES[ctx.status]);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Koa;</span><br></pre></td></tr></table></figure><p>在使用的案例当中，使用 <code>app</code>（即 <code>Koa</code> 创建的实例）监听了一个 <code>error</code> 事件，当中间件执行错误时会触发该监听的回调，这让我们想起了 NodeJS 中一个重要的核心模块 <code>events</code>，这个模块帮我们提供了一个事件机制，通过 <code>on</code> 方法添加监听，通过 <code>emit</code> 触发监听，所以我们引入了 <code>events</code>，并让 <code>Koa</code> 类继承了 <code>events</code> 导入的 <code>EventEmitter</code> 类，此时 <code>Koa</code> 的实例就可以使用 <code>EventEmitter</code> 原型对象上的 <code>on</code> 和 <code>emit</code> 方法。</p><p>在 <code>compose</code> 执行后调用的 <code>catch</code> 中，通过实例调用了 <code>emit</code>，并传入了事件类型 <code>error</code> 和错误对象，这样就是实现了中间件的错误监听，只要中间件执行出错，就会执行案例中错误监听的回调。</p><h2 id="让引入的-Koa-直接指向-application-js"><a href="#让引入的-Koa-直接指向-application-js" class="headerlink" title="让引入的 Koa 直接指向 application.js"></a>让引入的 Koa 直接指向 application.js</h2><p>在上面我们实现了 <code>Koa</code> 大部分常用功能的核心逻辑，但还有一点美中不足，就是我们引入自己的简易版 <code>Koa</code> 时，默认会查找 <code>koa</code> 路径下的 <code>index.js</code>，想要执行我们的 <code>Koa</code> 必须要使用路径找到 <code>application.js</code>，代码如下。</p><figure class="highlight js"><figcaption><span>现在的引入方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa/application'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>希望的引入方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa'</span>);</span><br></pre></td></tr></table></figure><p>我们更希望像直接引入指定 <code>koa</code> 文件夹，就可以找到 <code>application.js</code> 文件并执行，这就需要我们在 <code>koa</code> 文件夹创建 <code>package.json</code> 文件，并在动一点小小的 “手脚” 如下。</p><figure class="highlight"><figcaption><span>文件路径：&#126koa/package.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  "main": "./application.js",</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Koa-原理图"><a href="#Koa-原理图" class="headerlink" title="Koa 原理图"></a>Koa 原理图</h2><p>在文章最后一节送给大家一张 <code>Koa</code> 执行的原理图，这张图片是准备写这篇文章时在 Google 上发现的，觉得把 <code>Koa</code> 的整个流程表达的非常清楚，所以这里拿来帮助大家理解 <code>Koa</code> 框架的原理和执行过程。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/02/20180902141819/koa-flow-chart.png" alt="Koa 原理图" title>                </div>                <div class="image-caption">Koa 原理图</div>            </figure><p><br></p><p>之所以没有在文章开篇放上这张图是因为觉得在完全没有了解过 <code>Koa</code> 的原理之前，可能有一部分小伙伴看这张图会懵，会打消学习的积极性，因为本篇的目的就是带着大家从零到有的，一步一步实现简易版 <code>Koa</code>，梳理 <code>Koa</code> 的核心逻辑，如果你已经看到了这里，是不是觉得这张图出现的不早不晚，刚刚好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>最后还是在这里做一个总结，在 <code>Koa</code> 中主要的部分有 <code>listen</code> 创建服务器、封装上下文对象 <code>ctx</code> 并代理属性、<code>use</code> 方法添加中间件、<code>compose</code> 串行执行中间、让 <code>Koa</code> 继承 <code>EventEmitter</code> 实现错误监听，而我个人觉得最重要的就是 <code>compose</code>，它是一个事件串行机制，也是实现 “洋葱模型” 的核心，如今 <code>compose</code> 已经不再只是一个方法名，而是一种编程思想，用于将多个程序串行在一起，或同步，或异步，在 <code>Koa</code> 中自不必多说，因为大家已经见识过了，<code>compose</code> 在 <code>React</code> 中也起着串联中间件的作用，如串联 <code>promise</code>、<code>redux-thunk</code>、<code>logger</code> 等，在 <code>Webpack</code> 源码依赖的核心模块 <code>tapable</code> 中也有所应用，在我们的学习过程中，这样优秀的编程思想是应该重点吸收的。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/02/20180902141819/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Express 中间件 body-parser 原理分析</title>
      <link>https://www.overtaking.top/2018/08/28/20180828022147/</link>
      <guid>https://www.overtaking.top/2018/08/28/20180828022147/</guid>
      <pubDate>Mon, 27 Aug 2018 18:21:47 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/08/28/20180828022147/express-middleware.png&quot; title=&quot;Express 中间件&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;Express&lt;/code&gt; 是基于 NodeJS 平台的 Web 框架，应用广泛，在 &lt;code&gt;Express&lt;/code&gt; 社区中有着大量的开发者通过 &lt;code&gt;Express&lt;/code&gt; 中间件的特性，开发了各种功能的中间件，用来处理某些响应以及给请求对象 &lt;code&gt;req&lt;/code&gt;、响应对象 &lt;code&gt;res&lt;/code&gt; 添加属性或方法，我们接下来就通过分析常用的 &lt;code&gt;body-parser&lt;/code&gt; 中间件的原理来了解如何开发 &lt;code&gt;Express&lt;/code&gt; 中间件，如果想了解更多 &lt;code&gt;Express&lt;/code&gt; 内部封装原理可以看 &lt;a href=&quot;https://www.overtaking.top/2018/08/25/20180825162129/&quot; target=&quot;_blank&quot;&gt;《Express 源码分析及简易封装》&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/08/28/20180828022147/express-middleware.png" title="Express 中间件"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Express</code> 是基于 NodeJS 平台的 Web 框架，应用广泛，在 <code>Express</code> 社区中有着大量的开发者通过 <code>Express</code> 中间件的特性，开发了各种功能的中间件，用来处理某些响应以及给请求对象 <code>req</code>、响应对象 <code>res</code> 添加属性或方法，我们接下来就通过分析常用的 <code>body-parser</code> 中间件的原理来了解如何开发 <code>Express</code> 中间件，如果想了解更多 <code>Express</code> 内部封装原理可以看 <a href="https://www.overtaking.top/2018/08/25/20180825162129/" target="_blank">《Express 源码分析及简易封装》</a>。</p></blockquote><a id="more"></a><h2 id="body-parser-的基本使用"><a href="#body-parser-的基本使用" class="headerlink" title="body-parser 的基本使用"></a>body-parser 的基本使用</h2><p>想刨析一个中间件的原理，首先应该从使用入手，在足够了解用法的基础上去分析，现在搭建一个简易的 <code>Express</code> 服务，并使用 <code>body-parser</code> 中间件，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express body-parser</span><br></pre></td></tr></table></figure><p><strong>使用 body-parser 代码如下：</strong></p><figure class="highlight js"><figcaption><span>使用 body-parser 中间件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 body-parser 中间</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body);</span><br><span class="line">  res.send(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动上面的服务器，通过 <code>postman</code> 工具分别通过表单提交和 <code>json</code> 的格式访问 <a href="javascript:;" target="_blank" rel="noopener">http://localhost:3000/login</a>，查看服务器控制后台的打印结果和 <code>postman</code> 的返回结果。</p><h2 id="body-parser-的实现"><a href="#body-parser-的实现" class="headerlink" title="body-parser 的实现"></a>body-parser 的实现</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>从上面的使用案例我们可以分析出一下几点：</p><ul><li>首先，<code>body-parser</code> 中间件的作用是给 <code>req</code> 添加属性 <code>body</code>，值为对象，以键值对的形式存储请求体中的参数；</li><li>其次，<code>body-parser</code> 只处理 <code>POST</code> 请求；</li><li>最后，<code>body-parser</code> 模块导出一个对象，上面有两个方法 <code>urlencoded</code> 和 <code>json</code>，分别处理表单提交和 <code>json</code> 格式的请求体参数。</li></ul><h3 id="分析-urlencoded、json-公共逻辑"><a href="#分析-urlencoded、json-公共逻辑" class="headerlink" title="分析 urlencoded、json 公共逻辑"></a>分析 urlencoded、json 公共逻辑</h3><p>在实现之前我们先分析一下两个方法，首先都需要先读取请求体中的内容，数据传输的类型为 Buffer，转换成字符串后会根据提交方式不同而导致请求体中的内容是查询字符串或者是 <code>json</code> 字符串的区别。</p><p>当解析失败时都需要做错误处理，当不是 <code>POST</code> 请求时都需要向下执行其他中间件，而最核心的事就是把请求体中的数据转换成对象挂在 <code>req.body</code> 上。</p><p>使用的转换数据的方法不同是唯一的区别，能区分两者的就是请求头 <code>Content-Type</code> 的值，因此我们可以把所有的公共逻辑抽取出来用一个 <code>acceptPost</code> 函数来执行。</p><h3 id="模块的创建"><a href="#模块的创建" class="headerlink" title="模块的创建"></a>模块的创建</h3><p>我们下面创建自己的 <code>body-parser</code> 模块，防止命名冲突，我们的模块命名为 <code>my-body-parser</code>，处理参数需要使用 <code>querystring</code> 和 <code>qs</code> 两个模块，其中 <code>qs</code> 是第三方模块，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qs</span><br></pre></td></tr></table></figure><p><code>qs</code> 和 <code>querystring</code> 作用基本相同，就是处理查询字符串格式的参数，但是也有一点小小的区别，<code>querystring</code> 只能处理一级，而 <code>qs</code> 可以处理多级。</p><figure class="highlight js"><figcaption><span>文件：my-body-parser.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// urlencoded 和 json 公共逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理表单提交的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlencoded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求体 json 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">json</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; urlencoded, json &#125;;</span><br></pre></td></tr></table></figure><p>在把基本模块搭建好后，我们下面就实现 <code>body-parser</code> 模块内的公共逻辑函数 <code>acceptPost</code>。</p><h3 id="acceptPost-的实现"><a href="#acceptPost-的实现" class="headerlink" title="acceptPost 的实现"></a>acceptPost 的实现</h3><p>为了兼容 <code>urlencoded</code> 方法和 <code>json</code> 方法设计了两个参数，一个是区分当前调用方法的 <code>type</code>，一个是针对 <code>urlencoded</code> 方法的 <code>options</code>。</p><figure class="highlight js"><figcaption><span>acceptPost 的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// urlencoded 方法和 json 方法的公共逻辑函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptPost</span>(<span class="params">type, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个中间件函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求头</span></span><br><span class="line">    <span class="keyword">const</span> contentType = req.headers[<span class="string">'content-type'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断如果不符合两种提交的请求头直接交给其他中间件处理</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      contentType === <span class="string">'application/x-www-form-urlencoded'</span> ||</span><br><span class="line">      contentType === <span class="string">'application/json'</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 存储数据的数组</span></span><br><span class="line">      <span class="keyword">const</span> buffers = [];</span><br><span class="line"></span><br><span class="line">      req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 接收数据并存入数组中</span></span><br><span class="line">        buffers.push(data);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 组合数据并转换成字符串</span></span><br><span class="line">        <span class="keyword">let</span> result = Buffer.concat(buffers).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数据并挂载 req.body 属性上</span></span><br><span class="line">        <span class="comment">// 如果是表单提交则使用 querystring 或 qs，否则使用 JSON.parse</span></span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">'form'</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果配置 extended 值为 true 使用 qs，否则使用 querystring</span></span><br><span class="line">          req.body = options.extended ?</span><br><span class="line">            qs.parse(result) :</span><br><span class="line">            querystring.parse(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'json'</span>) &#123;</span><br><span class="line">          req.body = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next(); <span class="comment">// 向下执行</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">      req.on(<span class="string">'err'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        next(err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="urlencoded-和-json-方法的实现"><a href="#urlencoded-和-json-方法的实现" class="headerlink" title="urlencoded 和 json 方法的实现"></a>urlencoded 和 json 方法的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理表单提交的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlencoded</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义 type 值</span></span><br><span class="line">  <span class="keyword">let</span> type = <span class="string">'form'</span>;</span><br><span class="line">  <span class="keyword">return</span> acceptPost(type, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求体 json 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">json</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义 type 值</span></span><br><span class="line">  <span class="keyword">let</span> type = <span class="string">'json'</span>;</span><br><span class="line">  <span class="keyword">return</span> acceptPost(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把所有的公共逻辑都抽取出去后发现，<code>urlencoded</code> 和 <code>json</code> 方法内部只需要定义不同的类型就可以执行自己的中间件逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>上面分析 <code>body-parse</code> 中间件的原理的目的在于理解 <code>Express</code> 中间件开发的模式，在此总结一下，<code>Express</code> 中间件返回的是一个函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，当功能无法处理某些情况时需要调用 <code>next</code>，当出现错误时调用 <code>next</code> 并传递错误，则交给 <code>Express</code> 内置的错误处理中间件，在中间件内部代码涉及异步操作时，须在异步完成的回调当中调用 <code>next</code>，这是不如 <code>Koa</code> 方便的一点，同时也是两者的区别，因为 <code>Koa</code> 中已经大量使用 <code>async/await</code>，在执行异步代码时可以等待。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/08/28/20180828022147/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Express 源码分析及简易封装</title>
      <link>https://www.overtaking.top/2018/08/25/20180825162129/</link>
      <guid>https://www.overtaking.top/2018/08/25/20180825162129/</guid>
      <pubDate>Sat, 25 Aug 2018 08:21:29 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/08/25/20180825162129/express.png&quot; title=&quot;Express 源码解析&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote success&quot;&gt;&lt;p&gt;&lt;code&gt;Express&lt;/code&gt; 是 NodeJS 的 Web 框架，与 &lt;code&gt;Koa&lt;/code&gt; 的轻量相比，功能要更多一些，依然是当前使用最广泛的 NodeJS 框架，本篇参考 &lt;code&gt;Express&lt;/code&gt; 的核心逻辑来实现一个简易版，&lt;code&gt;Express&lt;/code&gt; 源码较多，逻辑复杂，看一周可能也看不完，如果你已经使用过 &lt;code&gt;Express&lt;/code&gt;，又想快速的了解 &lt;code&gt;Express&lt;/code&gt; 常用功能的原理，那读这篇文章是一个好的选择，也可以为读真正的源码做铺垫，本篇内容每部分代码较多，因为按照 &lt;code&gt;Express&lt;/code&gt; 的封装思想很难拆分，所以建议以星号标注区域为主其他代码为辅。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/08/25/20180825162129/express.png" title="Express 源码解析"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><code>Express</code> 是 NodeJS 的 Web 框架，与 <code>Koa</code> 的轻量相比，功能要更多一些，依然是当前使用最广泛的 NodeJS 框架，本篇参考 <code>Express</code> 的核心逻辑来实现一个简易版，<code>Express</code> 源码较多，逻辑复杂，看一周可能也看不完，如果你已经使用过 <code>Express</code>，又想快速的了解 <code>Express</code> 常用功能的原理，那读这篇文章是一个好的选择，也可以为读真正的源码做铺垫，本篇内容每部分代码较多，因为按照 <code>Express</code> 的封装思想很难拆分，所以建议以星号标注区域为主其他代码为辅。</p></blockquote><a id="more"></a><h2 id="搭建基本服务"><a href="#搭建基本服务" class="headerlink" title="搭建基本服务"></a>搭建基本服务</h2><p>下面我们使用 <code>Express</code> 来搭建一个最基本的服务，只有三行代码，只能访问不能响应。</p><figure class="highlight js"><figcaption><span>三行代码搭建的最基本服务</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>从上面我们可以分析出，<code>express</code> 模块给我们提供了一个函数，调用后返回了一个函数或对象给上面有 <code>listen</code> 方法给我们创建了一个 <code>http</code> 服务，我们就按照官方的设计返回一个函数 <code>app</code>。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>我们创建一个模块 <code>express.js</code>，导出了 <code>createApplication</code> 函数并返回在内部创建 <code>app</code> 函数，<code>createApplication</code> 等于我们引入 <code>Express</code> 模块时所调用的那个函数，返回值就是我们接收的 <code>app</code>，在 <code>createApplication</code> 返回的 <code>app</code> 函数上挂载了静态方法 <code>listen</code>，用于帮助我们启动 <code>http</code> 服务。</p><p><code>createApplication</code> 函数内我们使用引入的 <code>http</code> 模块创建了服务，并调用了创建服务 <code>server</code> 的 <code>listen</code> 方法，将 <code>app.listen</code> 的所有参数传递进去，这就等于做了一层封装，将真正创建服务器的过程都包在了 <code>app.listen</code> 内部，我们自己封装的 <code>Express</code> 模块只有在调用导出函数并调用 <code>app.listen</code> 时才会真正的创建服务器和启动服务器，相当于将原生的两步合二为一。</p><h2 id="路由的实现"><a href="#路由的实现" class="headerlink" title="路由的实现"></a>路由的实现</h2><p>在 <code>Express</code> 框架中有多个路由方法，方法名分别对应不同的请求方式，可以帮助我们匹配路径和请求方式，在完全匹配时执行路由内部的回调函数，以、目的是在不同路由不同请求方法的情况下让服务器做出不同的响应，路由的使用方式如下。</p><figure class="highlight js"><figcaption><span>路由的使用方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'home'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'about'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>如果启动上面的服务，通过浏览器访问定义的路由时可以匹配到 <code>app.get</code>、<code>app.post</code> 或 <code>app.all</code> 并执行回调，但其实我们可以发现这些方法的名字是与请求类型严格对应的，不仅仅这几个，下面来看看实现路由的核心逻辑（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">    <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">    <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">    <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.lenth; i++) &#123;</span><br><span class="line">      <span class="comment">// 循环取得每一层</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (reqPath === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">        (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">    res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;reqPath&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>我们的逻辑大体可以分为两个部分，路由方法的创建以及路由的匹配，首先是路由方法的创建阶段，每一个方法的内部所做的事情就是将路由的路径、请求方式和回调函数作为对象的属性，并将对象存入一个数组中统一管理，所以我们创建了 <code>app.routes</code> 数组用来存储这些路由对象。</p><p>方法名对应请求类型，请类型有很多，我们不会一一的创建每一个方法，所以选择引入专门存储请求类型名称的 <code>methods</code> 模块，其实路由方法逻辑相同，我们封装了 <code>createRouteMethod</code> 方法用来生成不同路由方法的函数体，之所以这样做是因为有个特殊的路由方法 <code>app.all</code>，导致请求类型有差别，其他的可以从 <code>methods</code> 中取，<code>app.all</code> 我们定义类型为 <code>all</code> 通过 <code>createRouteMethod</code> 函数的参数传入。</p><p>接着就是循环 <code>methods</code> 调用 <code>createRouteMethod</code> 函数创建路由方法，并单独创建 <code>app.all</code> 方法。</p><p>路由匹配阶段实在函数 <code>app</code> 内完成的，因为启动服务接收到请求时会执行 <code>createServer</code> 中的回调，即执行 <code>app</code>，先通过原生自带的 <code>req.method</code> 取出请求方式并处理成小写，通过 <code>req.path</code> 取出完整路径并分成路由名和查询字符串两个部分。</p><p>循环 <code>app.routes</code> 用取到请求的类型和路由名称匹配，两者都相等则执行对应路由对象上的回调函数，在判断条件中，请求方式兼容了我们之前定义的 <code>all</code>，为了所有的请求类型只要路由匹配都可以执行 <code>app.all</code> 的回调，请求路径兼容了 <code>*</code>，因为如果某个路由方法定义的路径为 <code>*</code>，则任意路由都可以执行这个路由对象上的回调。</p><h2 id="扩展请求对象属性"><a href="#扩展请求对象属性" class="headerlink" title="扩展请求对象属性"></a>扩展请求对象属性</h2><p>且在路由内部可以通过 <code>req</code> 访问一些原生没有的属性如 <code>req.path</code>、<code>req.query</code>、<code>req.host</code> 和 <code>req.params</code>，这说明 <code>Express</code> 在实现的过程中对 <code>req</code> 进行了处理。</p><figure class="highlight js"><figcaption><span>req 属性的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.path);</span><br><span class="line">  <span class="built_in">console</span>.log(req.query);</span><br><span class="line">  <span class="built_in">console</span>.log(req.host);</span><br><span class="line">  res.end(<span class="string">'home'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/about/:id/:name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.params);</span><br><span class="line">  res.end(<span class="string">'about'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>在上面的使用中我们写了两个路由，分别打印了原生所不具备而 <code>Express</code> 帮我们处理并新增的属性，下面我们就来在之前自己实现的 <code>express.js</code> 的基础上增加这些属性（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">    <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">    <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************** 以下为修改代码 *****************************</span></span><br><span class="line">    <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">    req.path = reqPath;</span><br><span class="line">    <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">    req.query = querystring.parse(query);</span><br><span class="line">    <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">    req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.lenth; i++) &#123;</span><br><span class="line">      <span class="comment">// 循环取得每一层</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">      <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">        <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">        <span class="keyword">const</span> result = pathname.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">        <span class="keyword">if</span> (result &amp;&amp; (method === layer.method || layer.method === <span class="string">'all'</span>)) &#123;</span><br><span class="line">          <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">          req.params = layer.paramNames.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">            memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> memo;</span><br><span class="line">          &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行对应的回调</span></span><br><span class="line">          <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          (reqPath === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">          (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">    res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;reqPath&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>上面代码有些长，我们一点一点分析，首先是 <code>req.path</code>，就是我们浏览器地址栏里查询字符串前的路径，值其实就是我们之前从 <code>req.url</code> 中解构出来的 <code>pathname</code>，我们只需要将 <code>pathname</code> 赋值给 <code>req.path</code> 即可。</p><p><code>req.query</code> 是浏览器地址栏的查询字符串传递的参数，就是我们从 <code>req.url</code> 解构出来的查询字符串，借助 <code>querystring</code> 模块将查询字符串处理成对象赋值给 <code>req.query</code> 即可。</p><p><code>req.host</code> 是访问的主机名，请求头中的 <code>host</code> 包含了主机名和端口号，我们只要截取出前半部分赋值给 <code>req.host</code> 即可。</p><p>最复杂的是 <code>req.params</code> 的实现，大概分为两个步骤，首先是在路由方法创建时需要检查定义的路由是否含有路由参数，如果有则取出参数的键存入数组 <code>paramNames</code> 中，然后创建一个匹配路由参数的正则，通过 <code>replace</code> 实现正则字符串的创建，再通过 <code>RegExp</code> 构造函数来创建正则，并挂在路由对象上，之所以使用 <code>replace</code> 是因为创建的规则内的分组要和路由参数的个数是相同的，我们将这些逻辑完善进了 <code>createRouteMethod</code> 函数中。</p><h2 id="实现响应方法-send-和-sendFile"><a href="#实现响应方法-send-和-sendFile" class="headerlink" title="实现响应方法 send 和 sendFile"></a>实现响应方法 send 和 sendFile</h2><p>之前的例子中我们都是用原生的 <code>end</code> 方法响应浏览器，我们知道 <code>end</code> 方法只能接收字符串和 Buffer 作为响应的值，非常不方便，其实在 <code>Express</code> 中封装了一个 <code>send</code> 方法挂在 <code>res</code> 对象下，可以接收数组、对象、字符串、Buffer、数字处理后响应给浏览器，在 <code>Express</code> 内部同样封装了一个 <code>sendFile</code> 方法用于读取请求的文件。</p><figure class="highlight js"><figcaption><span>send 响应</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(&#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/test.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 必须传入绝对路径</span></span><br><span class="line">  res.sendFile(path.join(__dirname, req.path));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过我们的分析，封装的 <code>send</code> 方法应该是将 <code>end</code> 不支持的类型数据转换成了字符串，在内部再次调用 <code>end</code>，而 <code>sendFile</code> 方法规定参数必须为绝对路径，内部实现应该是利用可读流读取文件内容相应给浏览器，下面是两个方法的实现（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">    <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">    <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">    req.path = reqPath;</span><br><span class="line">    <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">    req.query = querystring.parse(query);</span><br><span class="line">    <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">    req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">    <span class="comment">// 响应方法</span></span><br><span class="line">    res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 设置响应头</span></span><br><span class="line">      res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">          res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">          params = util.inspect(params);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">          <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">          params = httpServer.STATUS_CODES[params];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应</span></span><br><span class="line">      res.end(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应文件方法</span></span><br><span class="line">    res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">      fs.createReadStream(pathname).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.lenth; i++) &#123;</span><br><span class="line">      <span class="comment">// 循环取得每一层</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">      <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">        <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">        <span class="keyword">const</span> result = reqPath.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">        <span class="keyword">if</span> (result &amp;&amp; (method === layer.method || layer.method === <span class="string">'all'</span>)) &#123;</span><br><span class="line">          <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">          req.params = layer.paramNames.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">            memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> memo;</span><br><span class="line">          &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行对应的回调</span></span><br><span class="line">          <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          (reqPath === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">          (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">    res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;reqPath&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>有一点需要注意，在 Node 环境中想把任何对象类型转换成字符串应该使用 <code>util.inspect</code> 方法，而当 <code>send</code> 方法输入数字类型时，要返回对应状态码的名称，可通过 <code>_http_server</code> 模块的 <code>STATUS_CODES</code> 对象获取。</p><h2 id="内置中间件的实现"><a href="#内置中间件的实现" class="headerlink" title="内置中间件的实现"></a>内置中间件的实现</h2><p><code>Express</code> 最大的特点就是中间件机制，中间件就是用来处理请求的函数，用来完成不同场景的请求处理，一个中间件处理完请求后可以再传递给下一个中间件，具有回调函数 <code>next</code>，不执行 <code>next</code> 则会卡在一个位置，调用 <code>next</code> 则继续向下传递。</p><figure class="highlight js"><figcaption><span>use 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(&#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>在上面代码中使用 <code>use</code> 方法执行了传入的回调函数，实现公共逻辑，起到了中间件的作用，调用回调参数的 <code>next</code> 方法向下继续执行，下面来实现 <code>use</code> 方法（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取第一个回调函数</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[index++];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">// 将当前中间件函数的属性解构出来</span></span><br><span class="line">        <span class="keyword">let</span> &#123; method, pathname, handler &#125; = layer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; <span class="comment">// 如果存在错误将错误交给错误处理中间件，否则</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>, handle.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hanlder(err, req, res, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在错误则继续向下执行</span></span><br><span class="line">          <span class="comment">// 判断是中间件还是路由</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配路径判断</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              pathname === <span class="string">'/'</span> ||</span><br><span class="line">              pathname === req.path ||</span><br><span class="line">              req.path.startWidth(pathname)</span><br><span class="line">            ) &#123;</span><br><span class="line">              handler(req, res, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              next();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">              <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">              <span class="keyword">const</span> result = req.path.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                result &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                  method === layer.method ||</span><br><span class="line">                  layer.method === <span class="string">'all'</span></span><br><span class="line">                )</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">                req.params = layer.paramNames.reduce(</span><br><span class="line">                  <span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index </span>) </span>&#123;</span><br><span class="line">                    memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">return</span> memo;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行对应的回调</span></span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (req.path === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">                (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">        res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">      <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">      <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">      req.path = reqPath;</span><br><span class="line">      <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">      req.query = querystring.parse(query);</span><br><span class="line">      <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">      req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应方法</span></span><br><span class="line">      res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">            params = util.inspect(params);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">            params = httpServer.STATUS_CODES[params];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        res.end(params);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应文件方法</span></span><br><span class="line">      res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">        fs.createReadStream(pathname).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下执行</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        pathname.method !== <span class="string">'middle'</span></span><br><span class="line">      ) &#123;</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  <span class="comment">// 添加中间件方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理没有传入路径的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = pathname;</span><br><span class="line">      pathname = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成函数并执行</span></span><br><span class="line">    createRouteMethod(<span class="string">'middle'</span>)(pathname, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将初始逻辑作为中间件执行</span></span><br><span class="line">  app.use(init());</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p><code>use</code> 方法第一个参数为路径，与路由相同，不传默认为 <code>/</code>，如果不传所有的路径都会经过该中间件，如果传入指定的值，则匹配后的请求才会通过该中间件。</p><p>中间件的执行可能存在异步的情况，但之前匹配路径使用的是 <code>for</code> 循环同步匹配，我们将其修改为异步并把路由匹配的逻辑与中间件路径匹配的逻辑进行了整合，并创建了 <code>use</code> 方法，对是否传了第一个参数做了一个兼容，其他将带有请求方式、路径和回调的逻辑统一使用 <code>createRouteMethod</code> 方法创建，并传入 <code>middle</code> 类型，<code>createRouteMethod</code> 中路由参数匹配的逻辑对 <code>middle</code> 类型做了一个排除。</p><p>使用 <code>Express</code> 中间件调用 <code>next</code> 方法时，不传递参数和参数为 <code>null</code> 代表执行成功，如果传入了其他的参数，表示执行出错，会跳过所有正常的中间件和路由，直接交给错误处理中间件处理，并将 <code>next</code> 传入的参数作为错误处理中间件回调函数的第一个参数 <code>err</code>，后面三个参数分别为 <code>req</code>、<code>res</code> 和 <code>next</code>。</p><p>代码种创建了 <code>index</code> 变量，默认调用了一次 <code>next</code> 方法，每次然后取出数组 <code>app.routes</code> 中的路由对象的回调函数执行，并在内部执行 <code>handler</code>，而 <code>handler</code> 回调中又调用了 <code>next</code> 方法，就这样将整个中间件和路由的回调串联起来。</p><p>我们发现在第一次调用 <code>next</code> 之前的所有逻辑，如给 <code>req</code> 添加属性，给 <code>res</code> 添加方法，都是公共逻辑，是任何中间件和路由在匹配之前都会执行的逻辑，我们既然有了中间件方法 <code>app.user</code>，可以将这些逻辑抽取出来作为一个单独的中间件回调函数执行，所以创建了 <code>init</code> 函数，内部返回了一个函数作为回调函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，并在<code>init</code> 调用返回的函数内部调用 <code>next</code> 向下执行。</p><h2 id="内置模板引擎的实现"><a href="#内置模板引擎的实现" class="headerlink" title="内置模板引擎的实现"></a>内置模板引擎的实现</h2><p>在 <code>Express</code> 框架中内置支持了 <code>ejs</code>、<code>jade</code> 等模板，使用方法 “三部曲” 如下。</p><figure class="highlight js"><figcaption><span>模板的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、指定模板引擎，其实就是模板文件的后缀名</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、指定模板的存放根目录</span></span><br><span class="line">app.set(<span class="string">'views'</span>, path.resolve(__dirname, <span class="string">'views'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、如果要自定义模板后缀和函数的关系</span></span><br><span class="line">app.engine(<span class="string">'.html'</span>, <span class="built_in">require</span>(<span class="string">'./ejs'</span>).__express);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//使用指定的模板引擎渲染 user 模板</span></span><br><span class="line">  res.render(<span class="string">'user'</span>, &#123; <span class="attr">title</span>: <span class="string">'用户管理'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面将模板根目录设置为 <code>views</code> 文件夹，并规定了模板类型为 <code>ejs</code>，可以同时给多种模板设置，并不冲突，如果需要将其他后缀名的模板按照另一种模板的渲染引擎渲染则使用 <code>app.engine</code> 进行设置，下面看一下实现代码（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取第一个回调函数</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[index++];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">// 将当前中间件函数的属性解构出来</span></span><br><span class="line">        <span class="keyword">let</span> &#123; method, pathname, handler &#125; = layer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; <span class="comment">// 如果存在错误将错误交给错误处理中间件，否则</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>, handle.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hanlder(err, req, res, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在错误则继续向下执行</span></span><br><span class="line">          <span class="comment">// 判断是中间件还是路由</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">              <span class="comment">// 匹配路径判断</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                pathname === <span class="string">'/'</span> ||</span><br><span class="line">                pathname === req.path ||</span><br><span class="line">                req.path.startWidth(pathname)</span><br><span class="line">              ) &#123;</span><br><span class="line">                handler(req, res, next);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">              <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">              <span class="keyword">const</span> result = req.path.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                result &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                  method === layer.method ||</span><br><span class="line">                  layer.method === <span class="string">'all'</span></span><br><span class="line">                )</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">                req.params = layer.paramNames.reduce(</span><br><span class="line">                  <span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">                    memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">return</span> memo;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行对应的回调</span></span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (req.path === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">                (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">        res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">      <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">      <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">      req.path = reqPath;</span><br><span class="line">      <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">      req.query = querystring.parse(query);</span><br><span class="line">      <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">      req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应方法</span></span><br><span class="line">      res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">            params = util.inspect(params);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">            params = httpServer.STATUS_CODES[params];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        res.end(params);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应文件方法</span></span><br><span class="line">      res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">        fs.createReadStream(pathname).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">      <span class="comment">// 模板渲染方法</span></span><br><span class="line">      res.render = <span class="function"><span class="keyword">function</span>(<span class="params">filename, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将文件名和模板路径拼接</span></span><br><span class="line">        <span class="keyword">let</span> filepath = path.join(app.get(<span class="string">'views'</span>), filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展名</span></span><br><span class="line">        <span class="keyword">let</span> extname = path.extname(filename.split(path.sep).pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有扩展名，则使用默认的扩展名</span></span><br><span class="line">        <span class="keyword">if</span> (!extname) &#123;</span><br><span class="line">          extname = <span class="string">`.<span class="subst">$&#123;app.get(<span class="string">'view engine'</span>)&#125;</span>`</span></span><br><span class="line">          filepath += extname;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取模板文件并使用渲染引擎相应给浏览器</span></span><br><span class="line">        app.engines[extname](filepath, data, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>&#123;</span><br><span class="line">          res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">          res.end(html);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下执行</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ***************************** 以下为修改代码 *****************************</span></span><br><span class="line">      <span class="comment">// 满足条件说明是取值方法</span></span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> app.settings[pathname];</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为修改代码 *****************************</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span> &amp;&amp; pathname.method !== <span class="string">'middle'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加中间件方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理没有传入路径的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = pathname;</span><br><span class="line">      pathname = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成函数并执行</span></span><br><span class="line">    createRouteMethod(<span class="string">'middle'</span>)(pathname, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将初始逻辑作为中间件执行</span></span><br><span class="line">  app.use(init());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">  <span class="comment">// 存储设置的对象</span></span><br><span class="line">  app.setting =&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储模板渲染方法</span></span><br><span class="line">  app.engines = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加设置的方法</span></span><br><span class="line">  app.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    app.use[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加渲染引擎的方法</span></span><br><span class="line">  app.engine = <span class="function"><span class="keyword">function</span>(<span class="params">ext, renderFile</span>) </span>&#123;</span><br><span class="line">    app.engines[ext] = renderFile;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>在上面新增代码中设置了两个缓存 <code>settings</code> 和 <code>engines</code>，前者用来存储模板相关的设置，如渲染成什么类型的文件、读取模板文件的根目录，后者用来存储渲染引擎，即渲染模板的方法，这所以设置这两个缓存对象是为了实现 <code>Express</code> 多种不同模板共存的功能，可以根据需要进行设置和使用，而设置的方法分别为 <code>app.set</code> 和 <code>app.engine</code>，有设置值的方法就应该有取值的方法，但是 <code>app.get</code> 方法已经被设置为路由方法了，为了语义我们在 <code>app.get</code> 方法逻辑中进行了兼容，当参数为 <code>1</code> 个时，从 <code>settings</code> 中取值并返回，否则执行添加路由方法的逻辑。</p><p>之前都是准备工作，在使用时无论是中间件还是路由中都是靠调用 <code>res.render</code> 方法并传入模板路径和渲染数据来真正实现渲染和响应的，<code>render</code> 方法是在 <code>init</code> 函数初始化时就挂在了 <code>res</code> 上，核心逻辑是取出传入的模板文件后缀名，如果存在则使用后缀名，将文件名与默认读取模板的文件夹路径拼接传递给设置的渲染引擎的渲染方法，如果不存在后缀名则默认拼接 <code>.html</code> 当作后缀名，再与默认读取模板路径进行拼接，在渲染函数的回调中将渲染引擎渲染的模板字符串响应给浏览器。</p><h2 id="内置静态资源中间件的实现"><a href="#内置静态资源中间件的实现" class="headerlink" title="内置静态资源中间件的实现"></a>内置静态资源中间件的实现</h2><p>在 <code>Express</code> 内部可以通过路由处理静态文件，但是如果可能请求多个文件不可能一个文件对应一个路由，因此 <code>Express</code> 内部实现了静态文件中间件，使用如下。</p><figure class="highlight js"><figcaption><span>静态文件中间件的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用处理静态文件中间件</span></span><br><span class="line">app.use(express.static(path.resolve(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>从上面使用可以看出，<code>express.static</code> 是一个函数，执行的时候传入了一个参数，为默认查找文件的根路径，而添加中间件的 <code>app.use</code> 方法传入的参数正好是回调函数，这说明 <code>express.static</code> 方法需要返回一个函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，通过调用方式我们能看出 <code>static</code> 是静态方法，挂在了模块返回的函数上，实现代码如下（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取第一个回调函数</span></span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[index++];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">// 将当前中间件函数的属性解构出来</span></span><br><span class="line">        <span class="keyword">let</span> &#123; method, pathname, handler &#125; = layer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; <span class="comment">// 如果存在错误将错误交给错误处理中间件，否则</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>, handle.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hanlder(err, req, res, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在错误则继续向下执行</span></span><br><span class="line">          <span class="comment">// 判断是中间件还是路由</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配路径判断</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              pathname === <span class="string">'/'</span> ||</span><br><span class="line">              pathname === req.path ||</span><br><span class="line">              req.path.startWidth(pathname)</span><br><span class="line">            ) &#123;</span><br><span class="line">              handler(req, res, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              next();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">              <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">              <span class="keyword">const</span> result = req.path.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                result &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                  method === layer.method ||</span><br><span class="line">                  layer.method === <span class="string">'all'</span></span><br><span class="line">                )</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">                req.params = layer.paramNames.reduce(</span><br><span class="line">                  <span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">                    memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">return</span> memo;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行对应的回调</span></span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (req.path === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">                (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">        res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">      <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">      <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">      req.path = reqPath;</span><br><span class="line">      <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">      req.query = querystring.parse(query);</span><br><span class="line">      <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">      req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应方法</span></span><br><span class="line">      res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line">            <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">            params = util.inspect(params);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">            params = httpServer.STATUS_CODES[params];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        res.end(params);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应文件方法</span></span><br><span class="line">      res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">        fs.createReadStream(pathname).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模板渲染方法</span></span><br><span class="line">      res.render = <span class="function"><span class="keyword">function</span>(<span class="params">filename, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将文件名和模板路径拼接</span></span><br><span class="line">        <span class="keyword">let</span> filepath = path.join(app.get(<span class="string">'views'</span>), filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展名</span></span><br><span class="line">        <span class="keyword">let</span> extname = path.extname(filename.split(path.sep).pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有扩展名，则使用默认的扩展名</span></span><br><span class="line">        <span class="keyword">if</span> (!extname) &#123;</span><br><span class="line">          extname = <span class="string">`.<span class="subst">$&#123;app.get(<span class="string">'view engine'</span>)&#125;</span>`</span></span><br><span class="line">          filepath += extname;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取模板文件并使用渲染引擎相应给浏览器</span></span><br><span class="line">        app.engines[extname](filepath, data, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>&#123;</span><br><span class="line">          res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">          res.end(html);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下执行</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 满足条件说明是取值方法</span></span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> app.settings[pathname];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span> &amp;&amp; pathname.method !== <span class="string">'middle'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加中间件方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理没有传入路径的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = pathname;</span><br><span class="line">      pathname = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成函数并执行</span></span><br><span class="line">    createRouteMethod(<span class="string">'middle'</span>)(pathname, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将初始逻辑作为中间件执行</span></span><br><span class="line">  app.use(init());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储设置的对象</span></span><br><span class="line">  app.setting =&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储模板渲染方法</span></span><br><span class="line">  app.engines = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加设置的方法</span></span><br><span class="line">  app.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    app.use[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加渲染引擎的方法</span></span><br><span class="line">  app.engine = <span class="function"><span class="keyword">function</span>(<span class="params">ext, renderFile</span>) </span>&#123;</span><br><span class="line">    app.engines[ext] = renderFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">createApplication.static = <span class="function"><span class="keyword">function</span>(<span class="params">staticRoot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件的完整路径</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(staticRoot, req.path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应</span></span><br><span class="line">    fs.access(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置响应头类型和响应文件内容</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">`<span class="subst">$&#123;mime.getType()&#125;</span>;charset=utf8`</span>);</span><br><span class="line">        fs.createReadStream(filename).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>这个方法的核心逻辑是获取文件的路径，检查文件的权限，如果没有权限，则调用 <code>next</code> 交给其他中间件，这里注意的是 <code>err</code> 错误对象不要传递给 <code>next</code>，因为后面的中间件还要执行，如果传递后会直接执行错误处理中间件，有权限的情况下就正常读取文件内容，给 <code>Content-Type</code> 响应头设置文件类型，并将文件的可读流通过 <code>pipe</code> 方法传递给可写流 <code>res</code>，即响应给浏览器。</p><h2 id="实现重定向"><a href="#实现重定向" class="headerlink" title="实现重定向"></a>实现重定向</h2><p>在 <code>Express</code> 中有一个功能在我们匹配到的某一个路由中调用可以直接跳转到另一个路由，即 <code>302</code> 重定向。</p><figure class="highlight js"><figcaption><span>使用重定向</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'user'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/detail'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 访问 /detail 重定向到 /user</span></span><br><span class="line">  res.redirect(<span class="string">'/user'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>看到上面的使用方式，我们根据前面的套路知道是 <code>Express</code> 在 <code>res</code> 对象上给挂载了一个 <code>redirect</code> 方法，参数为状态码（可选）和要跳转路由的路径，并且这个方法应该在 <code>init</code> 函数调用时挂在 <code>res</code> 上的，下面是实现的代码（直接找到星号提示新增或修改位置即可）。</p><figure class="highlight js"><figcaption><span>文件：express.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 模块返回存储所有请求方法名称的数组</span></span><br><span class="line"><span class="keyword">const</span> methods = <span class="built_in">require</span>(<span class="string">'methods'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'_http_server'</span>); <span class="comment">// 存储 node 服务相关信息</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 app 函数，身份为总管家，用于将请求分派给别人处理</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环匹配路径</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取第一个回调函数</span></span><br><span class="line">      <span class="keyword">let</span> layer = app.routes[index++];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">// 将当前中间件函数的属性解构出来</span></span><br><span class="line">        <span class="keyword">let</span> &#123; method, pathname, handler &#125; = layer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err) &#123; <span class="comment">// 如果存在错误将错误交给错误处理中间件，否则</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>, handle.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hanlder(err, req, res, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在错误则继续向下执行</span></span><br><span class="line">          <span class="comment">// 判断是中间件还是路由</span></span><br><span class="line">          <span class="keyword">if</span> (method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配路径判断</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              pathname === <span class="string">'/'</span> ||</span><br><span class="line">              pathname === req.path ||</span><br><span class="line">              req.path.startWidth(pathname)</span><br><span class="line">            ) &#123;</span><br><span class="line">              handler(req, res, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              next();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型</span></span><br><span class="line">            <span class="keyword">if</span> (layer.regexp) &#123;</span><br><span class="line">              <span class="comment">// 使用路径配置的正则匹配请求路径</span></span><br><span class="line">              <span class="keyword">const</span> result = req.path.match(layer.regexp);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果匹配到结果且请求方式匹配</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                result &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                  method === layer.method ||</span><br><span class="line">                  layer.method === <span class="string">'all'</span></span><br><span class="line">                )</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象</span></span><br><span class="line">                req.params = layer.paramNames.reduce(</span><br><span class="line">                  <span class="function"><span class="keyword">function</span>(<span class="params">memo, key, index</span>) </span>&#123;</span><br><span class="line">                    memo[key] = result[index + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">return</span> memo;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行对应的回调</span></span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果说路径和请求类型都能匹配，则执行该路由层的回调</span></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (req.path === layer.pathname || layer.pathname === <span class="string">'*'</span>) &amp;&amp;</span><br><span class="line">                (method === layer.method || layer.method === <span class="string">'all'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="keyword">return</span> layer.hanlder(req, res);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都没有匹配上，则响应错误信息</span></span><br><span class="line">        res.end(<span class="string">`CANNOT <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.path&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获取方法名统一转换成小写</span></span><br><span class="line">      <span class="keyword">const</span> method = req.method.toLowerCase();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2</span></span><br><span class="line">      <span class="keyword">let</span> [reqPath, query = <span class="string">''</span>] = req.url.split(<span class="string">'?'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将路径名赋值给 req.path</span></span><br><span class="line">      req.path = reqPath;</span><br><span class="line">      <span class="comment">// 将查询字符串转换成对象赋值给 req.query</span></span><br><span class="line">      req.query = querystring.parse(query);</span><br><span class="line">      <span class="comment">// 将主机名赋值给 req.host</span></span><br><span class="line">      req.host = req.headers.host.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应方法</span></span><br><span class="line">      res.send = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测传入值得数据类型</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">typeof</span> params) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf8'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任意类型的对象转换成字符串</span></span><br><span class="line">            params = util.inspect(params);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            <span class="comment">// 数字则直接取出状态吗对应的名字返回</span></span><br><span class="line">            params = httpServer.STATUS_CODES[params];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        res.end(params);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 响应文件方法</span></span><br><span class="line">      res.sendFile = <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">        fs.createReadStream(pathname).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模板渲染方法</span></span><br><span class="line">      res.render = <span class="function"><span class="keyword">function</span>(<span class="params">filename, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将文件名和模板路径拼接</span></span><br><span class="line">        <span class="keyword">let</span> filepath = path.join(app.get(<span class="string">'views'</span>), filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展名</span></span><br><span class="line">        <span class="keyword">let</span> extname = path.extname(filename.split(path.sep).pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有扩展名，则使用默认的扩展名</span></span><br><span class="line">        <span class="keyword">if</span> (!extname) &#123;</span><br><span class="line">          extname = <span class="string">`.<span class="subst">$&#123;app.get(<span class="string">'view engine'</span>)&#125;</span>`</span></span><br><span class="line">          filepath += extname;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取模板文件并使用渲染引擎相应给浏览器</span></span><br><span class="line">        app.engines[extname](filepath, data, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>&#123;</span><br><span class="line">          res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">          res.end(html);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***************************** 以下为新增代码 *****************************</span></span><br><span class="line">      <span class="comment">// 重定向方法</span></span><br><span class="line">      res.redirect = <span class="function"><span class="keyword">function</span>(<span class="params">status, target</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果第一个参数是字符串类型说明没有传状态码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> status === <span class="string">'string'</span>) &#123;</span><br><span class="line">          <span class="comment">// 将第二个参数（重定向的目标路径）设置给 target</span></span><br><span class="line">          target = status;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 再把状态码设置成 302</span></span><br><span class="line">          status = <span class="number">302</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应状态码，设置重定向响应头</span></span><br><span class="line">        res.statusCode = status;</span><br><span class="line">        res.setHeader(<span class="string">'Location'</span>, target);</span><br><span class="line">        res.end();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ***************************** 以上为新增代码 *****************************</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下执行</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储路由层的请求类型、路径和回调</span></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个函数体用于将路由层存入 app.routes 中</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRouteMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 满足条件说明是取值方法</span></span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> app.settings[pathname];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        pathname, <span class="comment">// 不包含查询字符串</span></span><br><span class="line">        handler</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果含有路由参数，如 /xxx/:aa/:bb</span></span><br><span class="line">      <span class="comment">// 取出路由参数的键 aa bb 存入数组并挂在路由对象上</span></span><br><span class="line">      <span class="comment">// 并生匹配 /xxx/aa/bb 的正则挂在路由对象上</span></span><br><span class="line">      <span class="keyword">if</span> (pathname.indexOf(<span class="string">':'</span>) !== <span class="number">-1</span> &amp;&amp; pathname.method !== <span class="string">'middle'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramNames = []; <span class="comment">// 存储路由参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将路由参数取出存入数组，并返回正则字符串</span></span><br><span class="line">        <span class="keyword">const</span> regStr = pathname.replace(<span class="regexp">/:(\w+)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">matched, attr</span>) </span>&#123;</span><br><span class="line">          paramNames.push(attr);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'(\\w+)'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr); <span class="comment">// 生成正则类型</span></span><br><span class="line">        layer.regexp = regexp; <span class="comment">// 将正则挂在路由对象上</span></span><br><span class="line">        layer.paramNames = paramNames; <span class="comment">// 将存储路由参数的数组挂载对象上</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这一层放入存储所有路由层信息的数组中</span></span><br><span class="line">      app.routes.push(layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构建所有路由方法，如 app.get app.post 等</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配路由的 get 方法</span></span><br><span class="line">    app[method] = createRouteMethod(method);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all 方法，通吃所有请求类型</span></span><br><span class="line">  app.all = createRouteMethod(<span class="string">'all'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加中间件方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span>(<span class="params">pathname, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理没有传入路径的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      handler = pathname;</span><br><span class="line">      pathname = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成函数并执行</span></span><br><span class="line">    createRouteMethod(<span class="string">'middle'</span>)(pathname, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将初始逻辑作为中间件执行</span></span><br><span class="line">  app.use(init());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储设置的对象</span></span><br><span class="line">  app.setting =&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储模板渲染方法</span></span><br><span class="line">  app.engines = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加设置的方法</span></span><br><span class="line">  app.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    app.use[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加渲染引擎的方法</span></span><br><span class="line">  app.engine = <span class="function"><span class="keyword">function</span>(<span class="params">ext, renderFile</span>) </span>&#123;</span><br><span class="line">    app.engines[ext] = renderFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动服务的 listen 方法</span></span><br><span class="line">  app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调</span></span><br><span class="line">    server.listen(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 app</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createApplication.static = <span class="function"><span class="keyword">function</span>(<span class="params">staticRoot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件的完整路径</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(staticRoot, req.path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应</span></span><br><span class="line">    fs.access(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置响应头类型和响应文件内容</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">`<span class="subst">$&#123;mime.getType()&#125;</span>;charset=utf8`</span>);</span><br><span class="line">        fs.createReadStream(filename).pipe(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br></pre></td></tr></table></figure><p>其实 <code>res.redirect</code> 方法的核心逻辑就是处理参数，如果没有传状态码的时候将参数设置给 <code>target</code>，将状态码设置为 <code>302</code>，并设置重定向响应头 <code>Location</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>到此为止 <code>Express</code> 的大部分内置功能就都简易的实现了，由于 <code>Express</code> 内部的封装思想，以及代码复杂、紧密的特点，各个功能代码很难单独拆分，总结一下就是很难表述清楚，只能通过大量代码来堆砌，好在每一部分实现我都标记了 “重点”，但看的时候还是要经历 “痛苦”，这已经将 <code>Express</code> 中的逻辑 “阉割” 到了一定的程度，读 <code>Express</code> 的源码一定比读这篇文章更需要耐心，当然如果你已经读到了这里证明困难都被克服了，继续加油。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/08/25/20180825162129/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Koa2 中间件原理解析 —— 看了就会写</title>
      <link>https://www.overtaking.top/2018/08/20/20180820200342/</link>
      <guid>https://www.overtaking.top/2018/08/20/20180820200342/</guid>
      <pubDate>Mon, 20 Aug 2018 12:03:42 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/08/20/20180820200342/koa-middleware.png&quot; title=&quot;Koa 中间件&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;code&gt;Koa 2.x&lt;/code&gt; 版本是当下最流行的 NodeJS 框架，&lt;code&gt;Koa 2.0&lt;/code&gt; 的源码特别精简，不像 &lt;code&gt;Express&lt;/code&gt; 封装的功能那么多，所以大部分的功能都是由 &lt;code&gt;Koa&lt;/code&gt; 开发团队（同 &lt;code&gt;Express&lt;/code&gt; 是一家出品）和社区贡献者针对 &lt;code&gt;Koa&lt;/code&gt; 对 NodeJS 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 &lt;code&gt;Koa&lt;/code&gt; 的 &lt;code&gt;use&lt;/code&gt; 方法使用在对应的位置，这样就可以通过在内部操作 &lt;code&gt;ctx&lt;/code&gt; 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 &lt;code&gt;Koa&lt;/code&gt; 中间件供自己和别人使用。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/08/20/20180820200342/koa-middleware.png" title="Koa 中间件"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><code>Koa 2.x</code> 版本是当下最流行的 NodeJS 框架，<code>Koa 2.0</code> 的源码特别精简，不像 <code>Express</code> 封装的功能那么多，所以大部分的功能都是由 <code>Koa</code> 开发团队（同 <code>Express</code> 是一家出品）和社区贡献者针对 <code>Koa</code> 对 NodeJS 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 <code>Koa</code> 的 <code>use</code> 方法使用在对应的位置，这样就可以通过在内部操作 <code>ctx</code> 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 <code>Koa</code> 中间件供自己和别人使用。</p></blockquote><a id="more"></a><h2 id="Koa-的洋葱模型介绍"><a href="#Koa-的洋葱模型介绍" class="headerlink" title="Koa 的洋葱模型介绍"></a>Koa 的洋葱模型介绍</h2><p>我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 API 的使用方式及洋葱模型分析中间件是如何工作的。</p><figure class="highlight js"><figcaption><span>洋葱模型特点</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Koa</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们知道 <code>Koa</code> 的 <code>use</code> 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 <code>next</code> 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 <code>Koa</code> 中都是建议使用 <code>async/await</code> 的，引入的中间件都是在 <code>use</code> 方法中调用，由此我们可以分析出每一个 <code>Koa</code> 的中间件都是返回一个 <code>async</code> 函数的。</p><h2 id="koa-bodyparser-中间件模拟"><a href="#koa-bodyparser-中间件模拟" class="headerlink" title="koa-bodyparser 中间件模拟"></a>koa-bodyparser 中间件模拟</h2><p>想要分析 <code>koa-bodyparser</code> 的原理首先需要知道用法和作用，<code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值，使用前需提前安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-bodyparser</span><br></pre></td></tr></table></figure><p><strong>koa-bodyparser 具体用法如下：</strong></p><figure class="highlight js"><figcaption><span>koa-bodyparser 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用中间件</span></span><br><span class="line">app.use(bodyParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">'/'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>根据用法我们可以看出 <code>koa-bodyparser</code> 中间件引入的其实是一个函数，我们把它放在了 <code>use</code> 中执行，根据 <code>Koa</code> 的特点，我们推断出 <code>koa-bodyparser</code> 的函数执行后应该给我们返回了一个 <code>async</code> 函数，下面是我们模拟实现的代码。</p><figure class="highlight js"><figcaption><span>文件：my-koa-bodyparser.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">bodyParser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 存储数据的数组</span></span><br><span class="line">      <span class="keyword">const</span> dataArr = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 接收数据</span></span><br><span class="line">      ctx.req.on(<span class="string">'data'</span>, data =&gt; dataArr.push(data));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 整合数据并使用 Promise 成功</span></span><br><span class="line">      ctx.req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取请求数据的类型 json 或表单</span></span><br><span class="line">        <span class="keyword">const</span> contentType = ctx.get(<span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据 Buffer 格式</span></span><br><span class="line">        <span class="keyword">const</span> data = Buffer.concat(dataArr).toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (contentType === <span class="string">'application/x-www-form-urlencoded'</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body</span></span><br><span class="line">          ctx.request.body = querystring.parse(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType === <span class="string">'applaction/json'</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body</span></span><br><span class="line">          ctx.request.body = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行成功的回调</span></span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续向下执行</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中由几点是需要我们注意的，即 <code>next</code> 的调用以及为什么通过流接收数据、处理数据和将数据挂在 <code>ctx.request.body</code> 要在 Promise 中进行。</p><blockquote class="pullquote info"><p><em><strong>首先是 <code>next</code> 的调用，我们知道 <code>Koa</code> 的 <code>next</code> 执行，其实就是在执行下一个中间件的函数，即下一个 <code>use</code> 中的 <code>async</code> 函数，为了保证后面的异步代码执行完毕后再继续执行当前的代码，所以我们需要使用 <code>await</code> 进行等待，其次就是数据从接收到挂在 <code>ctx.request.body</code> 都在 Promise 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 <code>ctx.request.body</code> 上，可以保证我们在下一个 <code>use</code> 的 <code>async</code> 函数中可以在 <code>ctx.request.body</code> 上拿到数据，所以我们使用 <code>await</code> 等待一个 Promise 成功后再执行 <code>next</code>。</strong></em></p></blockquote><h2 id="koa-better-body-中间件模拟"><a href="#koa-better-body-中间件模拟" class="headerlink" title="koa-better-body 中间件模拟"></a>koa-better-body 中间件模拟</h2><p><code>koa-bodyparser</code> 在处理表单提交时还是显得有一点弱，因为不支持文件上传，而 <code>koa-better-body</code> 则弥补了这个不足，但是 <code>koa-better-body</code> 为 <code>Koa 1.x</code> 版本的中间件，<code>Koa 1.x</code> 的中间件都是使用 <code>Generator</code> 函数实现的，我们需要使用 <code>koa-convert</code> 将 <code>koa-better-body</code> 转化成 <code>Koa 2.x</code> 的中间件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-better-body koa-convert path uuid</span><br></pre></td></tr></table></figure><p><strong>koa-better-body 具体用法如下：</strong></p><figure class="highlight js"><figcaption><span>koa-better-body 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> betterBody = <span class="built_in">require</span>(<span class="string">'koa-better-body'</span>);</span><br><span class="line"><span class="keyword">const</span> convert = <span class="built_in">require</span>(<span class="string">'koa-convert'</span>); <span class="comment">// 将  koa 1.0 中间转化成 koa 2.0 中间件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>); <span class="comment">// 生成随机串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 koa-better-body 中间件从 koa 1.0 转化成 koa 2.0，并使用中间件</span></span><br><span class="line">app.use(convert(betterBody(&#123;</span><br><span class="line">  uploadDir: path.resolve(__dirname, <span class="string">'upload'</span>)</span><br><span class="line">&#125;)));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">'/'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用中间件后 ctx.request.fields 属性自动加上了 post 请求的文件数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.fields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件重命名</span></span><br><span class="line">    <span class="keyword">let</span> imgPath = ctx.request.fields.avatar[<span class="number">0</span>].path;</span><br><span class="line">    <span class="keyword">let</span> newPath = path.resolve(__dirname, uuid());</span><br><span class="line">    fs.rename(imgPath, newPath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中 <code>koa-better-body</code> 的主要功能就是将表单上传的文件存入本地指定的文件夹下，并将文件流对象挂在了 <code>ctx.request.fields</code> 属性上，我们接下来就模拟 <code>koa-better-body</code> 的功能实现一版基于 <code>Koa 2.x</code> 处理文件上传的中间件。</p><figure class="highlight js"><figcaption><span>文件：my-koa-better-body.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 Buffer 扩展 split 方法预备后面使用</span></span><br><span class="line">Buffer.prototype.split = <span class="function"><span class="keyword">function</span> (<span class="params">sep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = Buffer.from(sep).length; <span class="comment">// 分隔符所占的字节数</span></span><br><span class="line">  <span class="keyword">let</span> result = []; <span class="comment">// 返回的数组</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>; <span class="comment">// 查找 Buffer 的起始位置</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>; <span class="comment">// 偏移量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找分隔符</span></span><br><span class="line">  <span class="keyword">while</span> ((offset = <span class="keyword">this</span>.indexOf(sep, start)) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 将分隔符之前的部分截取出来存入</span></span><br><span class="line">    result.push(<span class="keyword">this</span>.slice(start, offset));</span><br><span class="line">    start = offset + len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理剩下的部分</span></span><br><span class="line">  result.push(<span class="keyword">this</span>.slice(start));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> dataArr = []; <span class="comment">// 存储读取的数据</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取数据</span></span><br><span class="line">      ctx.req.on(<span class="string">'data'</span>, data =&gt; dataArr.push(data));</span><br><span class="line"></span><br><span class="line">      ctx.req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 取到请求体每段的分割线字符串</span></span><br><span class="line">        <span class="keyword">let</span> bondery = <span class="string">`--<span class="subst">$&#123;ctx.get(<span class="string">'content-Type'</span>).split(<span class="string">'='</span>)[<span class="number">1</span>]&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取不同系统的换行符</span></span><br><span class="line">        <span class="keyword">let</span> lineBreak = process.platform === <span class="string">'win32'</span> ? <span class="string">'\r\n'</span> : <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非文件类型数据的最终返回结果</span></span><br><span class="line">        <span class="keyword">let</span> fields = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分隔的 buffer 去掉没用的头和尾即开头的 '' 和末尾的 '--'</span></span><br><span class="line">        dataArr = dataArr.split(bondery).slice(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环处理 dataArr 中每一段 Buffer 的内容</span></span><br><span class="line">        dataArr.forEach(<span class="function"><span class="params">lines</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 对于普通值，信息由包含键名的行 + 两个换行 + 数据值 + 换行组成</span></span><br><span class="line">          <span class="comment">// 对于文件，信息由包含 filename 的行 + 两个换行 + 文件内容 + 换行组成</span></span><br><span class="line">          <span class="keyword">let</span> [head, tail] = lines.split(<span class="string">`<span class="subst">$&#123;lineBreak&#125;</span><span class="subst">$&#123;lineBreak&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 判断是否是文件，如果是文件则创建文件并写入，如果是普通值则存入 fields 对象中</span></span><br><span class="line">          <span class="keyword">if</span> (head.includes(<span class="string">'filename'</span>)) &#123;</span><br><span class="line">            <span class="comment">// 防止文件内容含有换行而被分割，应重新截取内容并去掉最后的换行</span></span><br><span class="line">            <span class="keyword">let</span> tail = lines.slice(</span><br><span class="line">              head.length + <span class="number">2</span> * lineBreak.length,</span><br><span class="line">              -lineBreak.length</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建可写流并指定写入的路径：</span></span><br><span class="line">            <span class="comment">// 绝对路径 + 指定文件夹 + 随机文件名，最后写入文件</span></span><br><span class="line">            fs.createWriteStream(</span><br><span class="line">              path.join(__dirname, options.uploadDir, uuid())</span><br><span class="line">            ).end(tail);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是普通值取出键名</span></span><br><span class="line">            <span class="keyword">let</span> key = head.match(<span class="regexp">/name='(\w+)'/</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 key 设置给 fields tail 去掉末尾换行后的内容</span></span><br><span class="line">            fields[key] = tail.toString(<span class="string">'utf8'</span>).slice(<span class="number">0</span>, -lineBreak.length);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将处理好的 fields 对象挂在 ctx.request.fields 上，并完成 Promise</span></span><br><span class="line">        ctx.request.fields = fields;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下执行</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的内容逻辑可以通过代码注释来理解，就是模拟 <code>koa-better-body</code> 的功能逻辑，我们主要的关心点在于中间件实现的方式，上面功能实现的异步操作依然是读取数据，为了等待数据处理结束仍然在 Promise 中执行，并使用 <code>await</code> 等待，Promise 执行成功调用 <code>next</code>。</p><h2 id="koa-views-中间件模拟"><a href="#koa-views-中间件模拟" class="headerlink" title="koa-views 中间件模拟"></a>koa-views 中间件模拟</h2><p>Node 模板是我们经常使用的工具用来在服务端帮我们渲染页面，模板的种类繁多，因此出现了 <code>koa-view</code> 中间件，帮我们来兼容这些模板，先安装依赖的模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-views ejs</span><br></pre></td></tr></table></figure><p><strong>下面是一个 ejs 的模板文件：</strong></p><figure class="highlight html"><figcaption><span>文件：index.ejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">'en'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'UTF-8'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ejs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%=</span> <span class="attr">name</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%=</span> <span class="attr">age</span> %&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">name</span>==<span class="string">'panda'</span>) &#123; %&gt;</span></span><br><span class="line">    panda</span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> &#123; %&gt;</span></span><br><span class="line">    shen</span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">arr.forEach</span>(<span class="attr">item</span> =&gt;</span> &#123; %&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=item%</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>koa-views 具体用法如下：</strong></p><figure class="highlight js"><figcaption><span>koa-views 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用中间件</span></span><br><span class="line">app.use(views(path.resolve(__dirname, <span class="string">'views'</span>), &#123;</span><br><span class="line">  extension: <span class="string">'ejs'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>, &#123; <span class="attr">name</span>: <span class="string">'panda'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>可以看出我们使用了 <code>koa-views</code> 中间件后，让 <code>ctx</code> 上多了 <code>render</code> 方法帮助我们实现对模板的渲染和响应页面，就和直接使用 <code>ejs</code> 自带的 <code>render</code> 方法一样，并且从用法可以看出 <code>render</code> 方法是异步执行的，所以需要使用 <code>await</code> 进行等待，接下来我们就来模拟实现一版简单的 <code>koa-views</code> 中间件。</p><figure class="highlight js"><figcaption><span>文件：my-koa-views.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将读取文件方法转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到处中间件</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">dir, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 动态引入模板依赖模块</span></span><br><span class="line">    <span class="keyword">const</span> view = <span class="built_in">require</span>(options.extension);</span><br><span class="line"></span><br><span class="line">    ctx.render = <span class="keyword">async</span> (filename, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 异步读取文件内容</span></span><br><span class="line">      <span class="keyword">let</span> tmpl = <span class="keyword">await</span> readFile(</span><br><span class="line">        path.join(dir, <span class="string">`<span class="subst">$&#123;filename&#125;</span>.<span class="subst">$&#123;options.extension&#125;</span>`</span>),</span><br><span class="line">        <span class="string">'utf8'</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将模板渲染并返回页面字符串</span></span><br><span class="line">      <span class="keyword">let</span> pageStr = view.render(tmpl, data);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置响应类型并响应页面</span></span><br><span class="line">      ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">      ctx.body = pageStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续向下执行</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂在 <code>ctx</code> 上的 <code>render</code> 方法之所以是异步执行的是因为内部读取模板文件是异步执行的，需要等待，所以 <code>render</code> 方法为 <code>async</code> 函数，在中间件内部动态引入了我们使的用模板，如 <code>ejs</code>，并在 <code>ctx.render</code> 内部使用对应的 <code>render</code> 方法获取替换数据后的页面字符串，并以 <code>html</code> 的类型响应。</p><h2 id="koa-static-中间件模拟"><a href="#koa-static-中间件模拟" class="headerlink" title="koa-static 中间件模拟"></a>koa-static 中间件模拟</h2><p>下面是 <code>koa-static</code> 中间件的用法，代码使用的依赖如下，使用前需安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-static mime</span><br></pre></td></tr></table></figure><p><strong>koa-static 具体用法如下：</strong></p><figure class="highlight js"><figcaption><span>koa-static 的用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">static</span>(path.resolve(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'hello world'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过使用和分析，我们知道了 <code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件，如果我们直接访问文件名的时候，会查找这个文件并直接响应，如果没有这个文件路径会当作文件夹，并查找文件夹下的 <code>index.html</code>，如果存在则直接响应，如果不存在则交给其他中间件处理。</p><figure class="highlight js"><figcaption><span>文件：my-koa-static.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 stat 和 access 转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> stat = promisify(fs.stat);</span><br><span class="line"><span class="keyword">const</span> access = promisify(fs.access)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /</span></span><br><span class="line">    <span class="keyword">let</span> realPath = path.join(dir, ctx.path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 stat 对象</span></span><br><span class="line">      <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(realPath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html</span></span><br><span class="line">      <span class="keyword">if</span> (statObj.isFile()) &#123;</span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">`<span class="subst">$&#123;mime.getType()&#125;</span>;charset=utf8`</span>);</span><br><span class="line">        ctx.body = fs.createReadStream(realPath);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filename = path.join(realPath, <span class="string">'index.html'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理</span></span><br><span class="line">        <span class="keyword">await</span> access(filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存在设置文件类型并响应内容</span></span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf8'</span>);</span><br><span class="line">        ctx.body = fs.createReadStream(filename);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑中需要检测路径是否存在，由于我们导出的函数都是 <code>async</code> 函数，所以我们将 <code>stat</code> 和 <code>access</code> 转化成了 Promise，并用 <code>try...catch</code> 进行捕获，在路径不合法时调用 <code>next</code> 交给其他中间件处理。</p><h2 id="koa-router-中间件模拟"><a href="#koa-router-中间件模拟" class="headerlink" title="koa-router 中间件模拟"></a>koa-router 中间件模拟</h2><p>在 <code>Express</code> 框架中，路由是被内置在了框架内部，而 <code>Koa</code> 中没有内置，是使用 <code>koa-router</code> 中间件来实现的，使用前需要安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa koa-router</span><br></pre></td></tr></table></figure><p><code>koa-router</code> 功能非常强大，下面我们只是简单的使用，并且根据使用的功能进行模拟。</p><figure class="highlight js"><figcaption><span>koa-router 的简单用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'Koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/panda'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'panda'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/pandashen'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'pandashen'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/shen'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'shen'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用路由中间件</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>从上面看出 <code>koa-router</code> 导出的是一个类，使用时需要创建一个实例，并且调用实例的 <code>routes</code> 方法将该方法返回的 <code>async</code> 函数进行连接，但是在匹配路由的时候，会根据路由 <code>get</code> 方法中的路径进行匹配，并串行执行内部的回调函数，当所有回调函数执行完毕之后会执行整个 <code>Koa</code> 串行的 <code>next</code>，原理同其他中间件，我下面来针对上面使用的功能简易实现。</p><figure class="highlight js"><figcaption><span>文件：my-koa-router.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制每一个路由层的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.path = path;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">  &#125;</span><br><span class="line">  match(path) &#123;</span><br><span class="line">    <span class="comment">// 地址的路由和当前配置路由相等返回 true，否则返回 false</span></span><br><span class="line">    <span class="keyword">return</span> path === <span class="keyword">this</span>.path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 存放每个路由对象的数组，&#123; path: /xxx, fn: cb &#125;</span></span><br><span class="line">    <span class="keyword">this</span>.layers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>(path, cb) &#123;</span><br><span class="line">    <span class="comment">// 将路由对象存入数组中</span></span><br><span class="line">    <span class="keyword">this</span>.layers.push(<span class="keyword">new</span> Layer(path, cb));</span><br><span class="line">  &#125;</span><br><span class="line">  compose(ctx, next, handlers) &#123;</span><br><span class="line">    <span class="comment">// 将匹配的路由函数串联执行</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前 index 个数大于了存储路由对象的长度，则执行 Koa 的 next 方法</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= handlers.length) <span class="keyword">return</span> next();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 否则调用取出的路由对象的回调执行</span></span><br><span class="line">      <span class="comment">// 并传入一个函数，在传入的函数中递归 dispatch(index + 1)</span></span><br><span class="line">      <span class="comment">// 目的是为了执行下一个路由对象上的回调函数</span></span><br><span class="line">      handlers[index].cb(ctx, () =&gt; dispatch(index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次执行路由对象的回调函数</span></span><br><span class="line">    dispatch(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  routes() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) &#123;</span><br><span class="line">      <span class="comment">// 当前 next 是 Koa 自己的 next，即 Koa 其他的中间件</span></span><br><span class="line">      <span class="comment">// 筛选出路径相同的路由</span></span><br><span class="line">      <span class="keyword">let</span> handlers = <span class="keyword">this</span>.layers.filter(<span class="function"><span class="params">layer</span> =&gt;</span> layer.match(ctx.path));</span><br><span class="line">      <span class="keyword">this</span>.compose(ctx, next, handlers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们创建了一个 <code>Router</code> 类，定义了 <code>get</code> 方法，当然还有 <code>post</code> 等，我们只实现 <code>get</code> 意思一下，<code>get</code> 内为逻辑为将调用 <code>get</code> 方法的参数函数和路由字符串共同构建成对象存入了数组 <code>layers</code>，所以我们创建了专门构造路由对象的类 <code>Layer</code>，方便扩展，在路由匹配时我们可以根据 <code>ctx.path</code> 拿到路由字符串，并通过该路由过滤调数组中与路由不匹配的路由对象，调用 <code>compose</code> 方法将过滤后的数组作为参数 <code>handlers</code> 传入，串行执行路由对象上的回调函数。</p><blockquote class="pullquote warning"><p><em><strong><code>compose</code> 这个方法的实现思想非常的重要，在 <code>Koa</code> 源码中用于串联中间件，在 <code>React</code> 源码中用于串联 <code>redux</code> 的 <code>promise</code>、<code>thunk</code> 和 <code>logger</code> 等模块，我们的实现是一个简版，并没有兼容异步，主要思想是递归 <code>dispatch</code> 函数，每次取出数组中下一个路由对象的回调函数执行，直到所有匹配的路由的回调函数都执行完，执行 <code>Koa</code> 的下一个中间件 <code>next</code>，注意此处的 <code>next</code> 不同于数组中回调函数的参数 <code>next</code>，数组中路由对象回调函数的 <code>next</code> 代表下一个匹配路由的回调。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>上面我们分析和模拟了一些中间件，其实我们会理解 <code>Koa</code> 和 <code>Express</code> 相比较的优势是没有那么繁重，开发使用方便，需要的功能都可以用对应的中间件来实现，使用中间件可以给我们带来一些好处，比如能将我们处理好的数据和新方法挂载在 <code>ctx</code> 上，方便后面 <code>use</code> 传入的回调函数中使用，也可以帮我们处理一些公共逻辑，不至于在每一个 <code>use</code> 的回调中都去处理，大大减少了冗余代码，由此看来其实给 <code>Koa</code> 使用中间件的过程就是一个典型的 “装饰器” 模式，在通过上面的分析之后相信大家也了解了 <code>Koa</code> 的 “洋葱模型” 和异步特点，知道该如何开发自己的中间件了。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/08/20/20180820200342/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NodeJS 使用 cookie 和 session</title>
      <link>https://www.overtaking.top/2018/08/17/20180817153635/</link>
      <guid>https://www.overtaking.top/2018/08/17/20180817153635/</guid>
      <pubDate>Fri, 17 Aug 2018 07:36:35 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/08/17/20180817153635/cookie-session.png&quot; title=&quot;cookie-session&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;由于浏览器无状态的特性，&lt;code&gt;cookie&lt;/code&gt; 技术应运而生，&lt;code&gt;cookie&lt;/code&gt; 是一个会话级的存储，大小 &lt;code&gt;4KB&lt;/code&gt; 左右，用于浏览器将服务器设置的信息重新带给服务器进行验证，不支持跨域，在浏览器清空缓存或超过有效期后失效，不能存放敏感信息，&lt;code&gt;session&lt;/code&gt; 是专门用于存储最初设置给浏览器 &lt;code&gt;cookie&lt;/code&gt; 数据的地方，我们本篇就来讨论一下 &lt;code&gt;cookie&lt;/code&gt; 和 &lt;code&gt;session&lt;/code&gt; 在 NodeJS 中的使用方式。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/08/17/20180817153635/cookie-session.png" title="cookie-session"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>由于浏览器无状态的特性，<code>cookie</code> 技术应运而生，<code>cookie</code> 是一个会话级的存储，大小 <code>4KB</code> 左右，用于浏览器将服务器设置的信息重新带给服务器进行验证，不支持跨域，在浏览器清空缓存或超过有效期后失效，不能存放敏感信息，<code>session</code> 是专门用于存储最初设置给浏览器 <code>cookie</code> 数据的地方，我们本篇就来讨论一下 <code>cookie</code> 和 <code>session</code> 在 NodeJS 中的使用方式。</p></blockquote><a id="more"></a><h2 id="cookie-的基本使用"><a href="#cookie-的基本使用" class="headerlink" title="cookie 的基本使用"></a>cookie 的基本使用</h2><h3 id="NodeJS-原生操作-cookie"><a href="#NodeJS-原生操作-cookie" class="headerlink" title="NodeJS 原生操作 cookie"></a>NodeJS 原生操作 cookie</h3><p>下面是 <code>cookie</code> 在 Node 原生中的读取和写入方法。</p><figure class="highlight js"><figcaption><span>原生中操作 cookie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/read'</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取 cookie</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.headers.cookie);</span><br><span class="line">    res.end(req.headers.cookie);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">'/write'</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置 cookie</span></span><br><span class="line">    res.setHeader(<span class="string">'Set-Cookie'</span>, [</span><br><span class="line">      <span class="string">'name=panda; domain=panda.com; path=/write; httpOnly=true'</span>,</span><br><span class="line">      <span class="string">`age=28; Expires=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">1000</span> * <span class="number">10</span>).toGMTString()&#125;</span>`</span>,</span><br><span class="line">      <span class="string">`address=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(<span class="string">'回龙观'</span>)&#125;</span>; max-age=10`</span></span><br><span class="line">    ]);</span><br><span class="line">    res.end(<span class="string">'Write ok'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面代码创建了一个 <code>http</code> 服务器，可以通过读取 <code>cookie</code> 请求头的值来获取浏览器发来的 <code>cookie</code>，服务器可以通过给浏览器设置响应头 <code>Set-Cookie</code> 实现对浏览器 <code>cookie</code> 的设置，多个 <code>cookie</code> 参数为数组，在数组内可以规定每一条 <code>cookie</code> 的规则，中间使用一个分号和一个空格隔开。</p><ul><li><code>domain</code> 用来设置允许访问 <code>cookie</code> 的域；</li><li><code>path</code> 用来设置允许访问 <code>cookie</code> 的路径；</li><li><code>httpOnly</code> 用来设置是否允许浏览器中修改 <code>cookie</code>，如果通过浏览器修改设置过 <code>httpOnly=true</code> 的 <code>cookie</code>，则会增加一条同名 <code>cookie</code>，原来的 <code>cookie</code> 不会被修改；</li><li><code>Expires</code> 用来设置过期时间，绝对时间，值为一个 <code>GMT</code> 或 <code>UTC</code> 格式的时间；</li><li><code>max-age</code> 同样用来设置过期时间，相对时间，值为一个正整数，单位 <code>s</code>。</li></ul><blockquote class="pullquote info"><p><em><strong><code>cookie</code> 默认不支持存储中文，如果存储中文需先使用 <code>encodeURIComponent</code> 方法进行转译，将转译后的结果存入 <code>cookie</code>，在浏览器获取 <code>cookie</code> 需使用 <code>decodeURIComponent</code> 方法转回中文。</strong></em></p></blockquote><h3 id="Koa-中操作-cookie"><a href="#Koa-中操作-cookie" class="headerlink" title="Koa 中操作 cookie"></a>Koa 中操作 cookie</h3><p><code>Koa</code> 是当下流行的 NodeJS 框架，是对原生 Node 的一个轻量的封装，但是内部实现了快捷操作 <code>cookie</code> 的方法，下面是原生中对 <code>cookie</code> 的操作在 <code>Koa</code> 中的写法。</p><figure class="highlight js"><figcaption><span>Koa 中操作 cookie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务和路由</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名需要设置 key</span></span><br><span class="line">app.keys = [<span class="string">'shen'</span>];</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/read'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取 cookie</span></span><br><span class="line">  <span class="keyword">let</span> name = ctx.cookies.get(name) || <span class="string">'No name'</span>;</span><br><span class="line">  <span class="keyword">let</span> name = ctx.cookies.get(age) || <span class="string">'No age'</span>;</span><br><span class="line">  ctx.body = <span class="string">`<span class="subst">$&#123;name&#125;</span>-<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/write'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设置 cookie</span></span><br><span class="line">  ctx.cookies.set(<span class="string">'name'</span>, <span class="string">'panda'</span>, &#123; <span class="attr">domain</span>: <span class="string">'panda.com'</span> &#125;);</span><br><span class="line">  ctx.cookies.set(<span class="string">'age'</span>, <span class="number">28</span>, &#123; <span class="attr">maxAge</span>: <span class="number">10</span> * <span class="number">1000</span>, <span class="attr">signed</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>在 <code>Koa</code> 中将获取和设置 <code>cookie</code> 的方法都挂在了 <code>ctx</code> 上下文对象的 <code>cookies</code> 属性上，分别为 <code>get</code> 和 <code>set</code>。</p><p><code>cookies.get</code> 的参数为获取 <code>cookie</code> 的键名，返回值为键对应的值，<code>cookies.set</code> 的第一个参数同样为 <code>cookie</code> 的键名，第二个参数为键对应的值，第三个参数为一个对象，用来配置该条 <code>cookie</code> 的规则，如 <code>domain</code>、<code>path</code> 和过期时间等，这里 <code>maxAge</code> 值为毫秒数。</p><blockquote class="pullquote warning"><p><em><strong>注意：<code>Koa</code> 中设置的 <code>cookie</code> 默认不允许浏览器端通过 <code>document.cookie</code> 获取，但是服务器也可以被欺骗，比如使用 <code>postman</code> 发送一个带 <code>Cookie</code> 请求头的请求，服务器可以通过设置签名来预防，即添加 <code>signed</code> 选项并将值设置为 <code>true</code>。</strong></em></p></blockquote><h3 id="Koa-操作-cookie-方法的原理"><a href="#Koa-操作-cookie-方法的原理" class="headerlink" title="Koa 操作 cookie 方法的原理"></a>Koa 操作 cookie 方法的原理</h3><p><code>cookies</code> 对象都是挂在 <code>ctx</code> 上来实现的，使用过 <code>Koa</code> 都知道如果要操作 <code>ctx</code> 就会用到中间件的思想，我们这就看看这两个方法使用原生封装的过程。</p><figure class="highlight js"><figcaption><span>Koa 中 ctx.cookies 对象 get 和 set 方法的原理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取 cookie</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">get</span> = key =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> cookies = ctx.get(<span class="string">'cookie'</span>) || <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">return</span> querystring.parse(result, <span class="string">'; '</span>)[key];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 cookie，存储所有的 cookie，等于 setHeader 中的第二个参数</span></span><br><span class="line">  <span class="keyword">const</span> cookies = [];</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">set</span> = (key, val, options = &#123;&#125;) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 用于构造单条 cookie 和权限等设置的数组，默认存放这条 cookie 的键和值</span></span><br><span class="line">    <span class="keyword">let</span> single = [<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(val)&#125;</span>`</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是配置</span></span><br><span class="line">    <span class="keyword">if</span> (options.domain) &#123;</span><br><span class="line">      arr.push(<span class="string">`domain=<span class="subst">$&#123;options.domain&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.maxAge) &#123;</span><br><span class="line">      arr.push(<span class="string">`Max-Age=<span class="subst">$&#123;options.maxAge&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.path) &#123;</span><br><span class="line">      arr.push(<span class="string">`path=<span class="subst">$&#123;options.path&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.httpOnly) &#123;</span><br><span class="line">      arr.push(<span class="string">`HttpOnly=true`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将配置组合到 single 中后转为字符串存入 cookies</span></span><br><span class="line">    cookies.push(single.join(<span class="string">'; '</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置给浏览器</span></span><br><span class="line">    ctx.set(<span class="string">'Set-Cookie'</span>, cookies);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将获取和设置 cookie 的方法挂在 cookies 对象上</span></span><br><span class="line">  ctx.cookies = &#123; <span class="keyword">get</span>, <span class="keyword">set</span> &#125;;</span><br><span class="line"></span><br><span class="line">  await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>get</code> 方法内部获取 <code>cookie</code> 请求头的值并根据传入的 <code>key</code> 获取值，<code>set</code> 方法内，将传入的键值和选项拼接成符合 <code>cookie</code> 的字符串，通过 <code>Set-Cookie</code> 响应头设置给浏览器。</p><h2 id="session-的基本使用"><a href="#session-的基本使用" class="headerlink" title="session 的基本使用"></a>session 的基本使用</h2><h3 id="NodeJS-原生使用-session"><a href="#NodeJS-原生使用-session" class="headerlink" title="NodeJS 原生使用 session"></a>NodeJS 原生使用 session</h3><p>正常 <code>session</code> 是存放在数据库中的，我们这里为了方便就用一个名为 <code>session</code> 的对象来代替。</p><figure class="highlight js"><figcaption><span>原生中使用 session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>); <span class="comment">// 生成随字符串</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放 session</span></span><br><span class="line"><span class="keyword">const</span> session = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/user'</span>) &#123;</span><br><span class="line">    <span class="comment">// 取出 cookie 存储的用户 ID</span></span><br><span class="line">    <span class="keyword">let</span> userId = querystring.parse(req.headers[<span class="string">'cookie'</span>], <span class="string">'; '</span>)[<span class="string">'study'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userId) &#123;</span><br><span class="line">      <span class="keyword">if</span> (session[userId].studyCount === <span class="number">0</span>) res.end(<span class="string">'您的学习次数已用完'</span>);</span><br><span class="line">      session[userId].studyCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 生成 userId</span></span><br><span class="line">      userId = uuid();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将用户信息存入 session</span></span><br><span class="line">      session[userId] = &#123; <span class="attr">studyCount</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 cookie</span></span><br><span class="line">      req.setHeader(<span class="string">'Set-Cookie'</span>, [<span class="string">`study=<span class="subst">$&#123;userId&#125;</span>`</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应信息</span></span><br><span class="line">    res.end(<span class="string">`</span></span><br><span class="line"><span class="string">      您的用户 ID 为 <span class="subst">$&#123;userId&#125;</span>，</span></span><br><span class="line"><span class="string">      剩余学习次数为：<span class="subst">$&#123;session[userId].studyCount&#125;</span></span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面写的案例是一个网校的场景，一个新用户默认有 <code>30</code> 次学习机会，以后每次访问服务器学习次数减 <code>1</code>，如果 <code>studyCount</code> 值为 <code>0</code>，则提示学习次数用完，否则提示当前用户的 <code>ID</code> 和剩余学习次数，<code>session</code> 中存储的是每一个用户 <code>ID</code> 对应的剩余学习次数，这样就不会轻易的被修改学习剩余次数，因为服务器只认用户 <code>ID</code>，再通过 <code>ID</code> 去更改对应的剩余次数（当然忽略了别人冒充这个 <code>ID</code> 的情况，只能减，不能加），这样就不会因为篡改 <code>cookie</code> 而篡改用户存在 <code>session</code> 中的数据，除非连整个数据库都拖走。</p><h3 id="Koa-中使用-session"><a href="#Koa-中使用-session" class="headerlink" title="Koa 中使用 session"></a>Koa 中使用 session</h3><p>我们接下来使用 <code>Koa</code> 实现和上面一摸一样的场景，在 <code>Koa</code> 的社区中提供了专门操作 <code>session</code> 的中间件 <code>koa-session</code>，使用前需安装。</p><figure class="highlight js"><figcaption><span>Koa 中使用 session</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> session = requier(<span class="string">'koa-session'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务和路由</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cookie 的签名</span></span><br><span class="line">app.keys = [<span class="string">'panda'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 koa-session 中间件</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  key: <span class="string">'shen'</span>,</span><br><span class="line">  maxAge: <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">&#125;, app));</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 取出 cookie 存储的用户 ID</span></span><br><span class="line">  <span class="keyword">let</span> userId = ctx.cookie(<span class="string">'study'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.session.userId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.session[userId].studyCount === <span class="number">0</span>) res.end(<span class="string">'您的学习次数已用完'</span>);</span><br><span class="line">    ctx.session[userId].studyCount--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 生成 userId</span></span><br><span class="line">    userId = uuid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将用户信息存入 session</span></span><br><span class="line">    ctx.session[userId] = &#123; <span class="attr">studyCount</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 cookie</span></span><br><span class="line">    ctx.cookies.set(<span class="string">'study'</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应信息</span></span><br><span class="line">  ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">    您的用户 ID 为 <span class="subst">$&#123;userId&#125;</span>，</span></span><br><span class="line"><span class="string">    剩余学习次数为：<span class="subst">$&#123;session[userId].studyCount&#125;</span></span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>Koa</code> 的 <code>koa-session</code> 以后，不再需要我们创建 <code>session</code> 对象进行存储，并且 <code>cookie-session</code> 中间件帮我们封装了 API 可以直接操作 <code>mongo</code> 和 <code>MySQL</code> 数据库，上面代码中与用原生相比还增加了 <code>cookie</code> 和 <code>session</code> 的签名和过期时间，比原生写起来要方便很多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>本篇内容更偏向于 <code>cookie</code> 和 <code>session</code> 在 NodeJS 中的使用，没有过多的叙述理论性的内容，<code>cookie</code> 和 <code>session</code> 是相互依存的，也就是说共同使用的，现在已经有 JWT 的方案来替代，因为相比较下有很多优点，但某些项目和特殊场景还在使用 <code>cookie</code> 和 <code>session</code>，所以还是写了这一篇，如果对 JWT 感兴趣可以看 <a href="https://www.overtaking.top/2018/08/16/20180816141146/" target="_blank">通过一个案例理解 JWT</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/08/17/20180817153635/#disqus_thread</comments>
    </item>
    
    <item>
      <title>通过一个案例理解 JWT</title>
      <link>https://www.overtaking.top/2018/08/16/20180816141146/</link>
      <guid>https://www.overtaking.top/2018/08/16/20180816141146/</guid>
      <pubDate>Thu, 16 Aug 2018 06:11:46 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/08/16/20180816141146/jwt.png&quot; title=&quot;JWT&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;JWT-简述&quot;&gt;&lt;a href=&quot;#JWT-简述&quot; class=&quot;headerlink&quot; title=&quot;JWT 简述&quot;&gt;&lt;/a&gt;JWT 简述&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;JWT（json web token）是为了在网络应用环境之间传递声明而基于 &lt;code&gt;json&lt;/code&gt; 的开放标准，JWT 的声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便于从资源服务器获取资源。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/08/16/20180816141146/jwt.png" title="JWT"><p><br></p><h2 id="JWT-简述"><a href="#JWT-简述" class="headerlink" title="JWT 简述"></a>JWT 简述</h2><blockquote class="pullquote default"><p>JWT（json web token）是为了在网络应用环境之间传递声明而基于 <code>json</code> 的开放标准，JWT 的声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便于从资源服务器获取资源。</p></blockquote><a id="more"></a><h2 id="JWT-的应用场景"><a href="#JWT-的应用场景" class="headerlink" title="JWT 的应用场景"></a>JWT 的应用场景</h2><p>JWT 一般用于用户登录上，身份认证在这种场景下，一旦用户登录完成，在接下来的每个涉及用户权限的请求中都包含 JWT，可以对用户身份、路由、服务和资源的访问权限进行验证。</p><p>举一个例子，假如一个电商网站，在用户登录以后，需要验证用户的地方其实有很多，比如购物车，订单页，个人中心等等，访问这些页面正常的逻辑是先验证用户权限和登录状态，如果验证通过，则进入访问的页面，否则重定向到登录页。</p><p>而在 JWT 之前，这样的验证我们大多都是通过 <code>cookie</code> 和 <code>session</code> 去实现的，我们接下来就来对比以下这两种方式的不同。</p><h2 id="JWT-对比-cookie-session"><a href="#JWT-对比-cookie-session" class="headerlink" title="JWT 对比 cookie/session"></a>JWT 对比 cookie/session</h2><p><strong>cookie/session 的过程：</strong></p><p>由于浏览器的请求是无状态的，<code>cookie</code> 的存在就是为了带给服务器一些状态信息，服务器在接收到请求时会对其进行验证（其实是在登录时，服务器发给浏览器的），如果验证通过则正常返回结果，如果验证不通过则重定向到登录页，而服务器是根据 <code>session</code> 中存储的结果和收到的信息进行对比决定是否验证通过，当然这里只是简述过程。</p><p><strong>cookie/session 的问题：</strong></p><p>从上面可以看出服务器种植 <code>cookie</code> 后每次请求都会带上 <code>cookie</code>，浪费带宽，而且 <code>cookie</code> 不支持跨域，不方便与其他的系统之间进行跨域访问，而服务器会用 <code>session</code> 来存储这些用户验证的信息，这样浪费了服务器的内存，当多个服务器想要共享 <code>session</code> 需要都拷贝过去。</p><p><strong>JWT 的过程：</strong></p><p>当用户发送请求，将用户信息带给服务器的时候，服务器不再像过去一样存储在 <code>session</code> 中，而是将浏览器发来的内容通过内部的密钥加上这些信息，使用 <code>sha256</code> 和 <code>RSA</code> 等加密算法生成一个 <code>token</code> 令牌和用户信息一起返回给浏览器，当涉及验证用户的所有请求只需要将这个 <code>token</code> 和用户信息发送给服务器，而服务器将用户信息和自己的密钥通过既定好的算法进行签名，然后将发来的签名和生成的签名比较，严格相等则说明用户信息没被篡改和伪造，验证通过。</p><blockquote class="pullquote info"><p>JWT 的过程中，服务器不再需要额外的内存存储用户信息，和多个服务器之间只需要共享密钥就可以让多个服务器都有验证能力，同时也解决了 <code>cookie</code> 不能跨域的问题。</p></blockquote><h2 id="JWT-的结构"><a href="#JWT-的结构" class="headerlink" title="JWT 的结构"></a>JWT 的结构</h2><p>JWT 之所以能被作为一种声明传递的标准是因为它有自己的结构，并不是随便的发个 <code>token</code> 就可以的，JWT 用于生成 <code>token</code> 的结构有三个部分，使用 <code>.</code> 隔开。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p><code>Header</code> 头部中主要包含两部分，<code>token</code> 类型和加密算法，如 <code>{typ: &#39;jwt&#39;, alg: &#39;HS256&#39;}</code>，<code>HS256</code> 就是指 <code>sha256</code> 算法，会将这个对象转成 <code>base64</code>。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p><code>Payload</code> 负载就是存放有效信息的地方，有效信息被分为标准中注册的声明、公共的声明和私有的声明。</p><h4 id="标准中注册的声明"><a href="#标准中注册的声明" class="headerlink" title="标准中注册的声明"></a>标准中注册的声明</h4><p>下面是标准中注册的声明，建议但不强制使用。</p><ul><li>iss：<code>jwt</code> 签发者；</li><li>sub：<code>jwt</code> 所面向的用户；</li><li>aud：接收 <code>jwt</code> 的一方；</li><li>exp：<code>jwt</code> 的过期时间，这个过期时间必须要大于签发时间，这是一个秒数；</li><li>nbf：定义在什么时间之前，该 <code>jwt</code> 都是不可用的；</li><li>iat：<code>jwt</code> 的签发时间。</li></ul><p>上面的标准中注册的声明中常用的有 <code>exp</code> 和 <code>nbf</code>。</p><h4 id="公共声明"><a href="#公共声明" class="headerlink" title="公共声明"></a>公共声明</h4><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密，如 <code>{&#39;id&#39;, username: &#39;panda&#39;, adress: &#39;Beijing&#39;}</code>，会将这个对象转成 <code>base64</code>。</p><h4 id="私有声明"><a href="#私有声明" class="headerlink" title="私有声明"></a>私有声明</h4><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 <code>base64</code> 是对称解密的，意味着该部分信息可以归类为明文信息。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p><code>Signature</code> 这一部分指将 <code>Header</code> 和 <code>Payload</code> 通过密钥 <code>secret</code> 和加盐算法进行加密后生成的签名，<code>secret</code>，密钥保存在服务端，不会发送给任何人，所以 JWT 的传输方式是很安全的。</p><p>最后将三部分使用 <code>.</code> 连接成字符串，就是要返回给浏览器的 <code>token</code> 浏览器一般会将这个 <code>token</code> 存储在 <code>localStorge</code> 以备其他需要验证用户的请求使用。</p><blockquote class="pullquote warning"><p>经过上面对 JWT 的叙述可能还是没有完全的理解什么是 JWT，具体怎么操作的，我们接下来实现一个小的案例，为了方便，服务端使用 <code>express</code> 框架，数据库使用 <code>mongo</code> 来存储用户信息，前端使用 <code>Vue</code> 来实现，做一个登录页登录后进入订单页验证 <code>token</code> 的功能。</p></blockquote><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><pre>jwt-apply<br>  |- jwt-client<br>  | |- src<br>  | | |- views<br>  | | | |- Login.vue<br>  | | | |- Order.vue<br>  | | |- App.vue<br>  | | |- axios.js<br>  | | |- main.js<br>  | | |- router.js<br>  | |- .gitignore<br>  | |- babel.config<br>  | |- package.json<br>  |- jwt-server<br>  | |- model<br>  | | |- user.js<br>  | |- app.js<br>  | |- config.js<br>  | |- jwt-simple.js<br>  | |- package.json</pre></p><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>在搭建服务端之前需要安装我们使用的依赖，这里我们使用 <code>yarn</code> 来安装，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add express body-parse mongoose jwt-simple</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">'db_url'</span>: <span class="string">'mongodb://localhost:27017/jwt'</span>, <span class="comment">// 操作 mongo 自动生成这个数据库</span></span><br><span class="line">  <span class="string">'secret'</span>: <span class="string">'pandashen'</span> <span class="comment">// 密钥</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面配置文件中，<code>db_url</code> 存储的是 <code>mango</code> 数据库的地址，操作数据库自动创建，<code>secret</code> 是用来生成 <code>token</code> 的密钥。</p><h3 id="创建数据库模型"><a href="#创建数据库模型" class="headerlink" title="创建数据库模型"></a>创建数据库模型</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/model/user.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作数据库的逻辑</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">let</span> &#123; db_url &#125; = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库，端口默认 27017</span></span><br><span class="line">mongoose.connect(db_url, &#123;</span><br><span class="line">  useNewUrlParser: <span class="literal">true</span> <span class="comment">// 去掉警告</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个骨架 Schema，数据会按照这个骨架格式存储</span></span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  username: <span class="built_in">String</span>,</span><br><span class="line">  password: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个模型</span></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">'User'</span>, UserSchema);</span><br></pre></td></tr></table></figure><p>我们将连接数据库、定义数据库字段和值类型以及创建数据模型的代码统一放在了 <code>model</code> 文件夹下的 <code>user.js</code> 当中，将数据模型导出方便在服务器的代码中进行查找操作。</p><h3 id="实现基本服务"><a href="#实现基本服务" class="headerlink" title="实现基本服务"></a>实现基本服务</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jwt-simple'</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'./model/user'</span>);</span><br><span class="line"><span class="keyword">let</span> &#123; secret &#125; = <span class="built_in">require</span>(<span class="string">'./config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置中间件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注册接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 登录接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 验证 token 接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口号</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面是一个基本的服务器，引入了相关的依赖，能保证启动，接下来添加处理 <code>post</code> 请求的中间件和实现 <code>cors</code> 跨域的中间件。</p><h3 id="添加中间件"><a href="#添加中间件" class="headerlink" title="添加中间件"></a>添加中间件</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置跨域中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 允许跨域的头</span></span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 允许浏览器发送的头</span></span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type,Authorization'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 允许哪些请求方法</span></span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET,POST,PUT,DELETE,OPTIONS'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前请求是 OPTIONS 直接结束，否则继续执行</span></span><br><span class="line">  req.method === <span class="string">'OPTIONS'</span> ? res.end() : next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置处理 post 请求参数的中间件</span></span><br><span class="line">app.use(bodyParser.json());</span><br></pre></td></tr></table></figure><p>之所以设置处理 <code>post</code> 请求参数中间件是因为注册和登录都需要使用 <code>post</code> 请求，之所以设置跨域中间件是因为我们项目虽小也是前后端分离的，需要用前端的 <code>8080</code> 端口访问服务器的 <code>3000</code> 端口，所以需要服务端使用 <code>cors</code> 处理跨域问题。</p><h3 id="注册接口的实现"><a href="#注册接口的实现" class="headerlink" title="注册接口的实现"></a>注册接口的实现</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册接口的实现</span></span><br><span class="line">app.post(<span class="string">'/reg'</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取 post 请求的数据</span></span><br><span class="line">  <span class="keyword">let</span> user = req.body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误验证</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据库，添加成功后返回的就是添加后的结果</span></span><br><span class="line">    user = <span class="keyword">await</span> User.create(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回注册成功的信息</span></span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code: <span class="number">0</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">          id: user._id,</span><br><span class="line">          username: user.username</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 返回注册失败的信息</span></span><br><span class="line">    res.json(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">data</span>: <span class="string">'注册失败'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面将用户注册的信息存入了 <code>mongo</code> 数据库，返回值为存入的数据，如果存入成功，则返回注册成功的信息，否则返回注册失败的信息。</p><h3 id="登录接口的实现"><a href="#登录接口的实现" class="headerlink" title="登录接口的实现"></a>登录接口的实现</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户能登录</span></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = req.body;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 查找用户是否存在</span></span><br><span class="line">    user = <span class="keyword">await</span> User.findOne(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">      <span class="comment">// 生成 token</span></span><br><span class="line">      <span class="keyword">let</span> token = jwt.encode(&#123;</span><br><span class="line">        id: user._id,</span><br><span class="line">        username: user.username,</span><br><span class="line">        exp: <span class="built_in">Date</span>.now() + <span class="number">1000</span> * <span class="number">10</span></span><br><span class="line">      &#125;, secret);</span><br><span class="line"></span><br><span class="line">      res.json(&#123;</span><br><span class="line">        code: <span class="number">0</span>,</span><br><span class="line">        data: &#123; token &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.json(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">data</span>: <span class="string">'用户不存在'</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    res.json(&#123; <span class="attr">code</span>: <span class="number">1</span>, <span class="attr">data</span>: <span class="string">'登录失败'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>登录的过程中会先拿用户的账号和密码进数据库中进行严重和查找，如果存在，则登录成功并返回 <code>token</code>，如果不存在则登录失败。</p><h3 id="token-校验接口"><a href="#token-校验接口" class="headerlink" title="token 校验接口"></a>token 校验接口</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只针对 token 校验接口的中间件</span></span><br><span class="line"><span class="keyword">const</span> auth = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取请求头 authorization</span></span><br><span class="line">  <span class="keyword">const</span> authorization = req.headers[<span class="string">'authorization'</span>];</span><br><span class="line">  <span class="comment">// 如果存在，则获取 token</span></span><br><span class="line">  <span class="keyword">if</span> (authorization) &#123;</span><br><span class="line">    <span class="keyword">const</span> token = authorization.split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 对 token 进行校验</span></span><br><span class="line">      req.user = jwt.decode(token, secret);</span><br><span class="line">      next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).send(<span class="string">'Not Allowed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.status(<span class="number">401</span>).send(<span class="string">'Not Allowed'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户可以校验是否登录过，通过请求头 authorization: Bearer token</span></span><br><span class="line">app.get(<span class="string">'/order'</span>, auth, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      user: req.user</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在校验过程中，每次浏览器都会将 <code>token</code> 通过请求头 <code>authorization</code> 带给服务器，请求头的值为 <code>Bearer token</code>，这是 JWT 规定的，服务器取出 <code>token</code> 使用 <code>decode</code> 方法进行解码，并使用 <code>try...catch</code> 进行捕获，如果解码失败则会触发 <code>try...catch</code>，说明 <code>token</code> 过期、被篡改、或被伪造，返回 <code>401</code> 响应。</p><h2 id="前端的实现"><a href="#前端的实现" class="headerlink" title="前端的实现"></a>前端的实现</h2><p>我们使用 <code>3.0</code> 版本的 <code>vue-cli</code> 脚手架生成 <code>Vue</code> 项目，并安装 <code>axios</code> 发送请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add global @vue/cli</span><br><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/main.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为生产模式</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><p>上面这个文件是 <code>vue-cli</code> 自动生成的，我们并没有做改动，但是为了方便查看我们会将主要文件的代码一一贴出来。</p><h3 id="主组件-App"><a href="#主组件-App" class="headerlink" title="主组件 App"></a>主组件 App</h3><figure class="highlight html"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'nav'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/order"</span>&gt;</span>订单<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在主组件中我们将 <code>router-link</code> 分别对应了 <code>/login</code> 和 <code>/order</code> 两个路由。</p><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/router.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./views/Login.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Order <span class="keyword">from</span> <span class="string">'./views/Order.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/order'</span>,</span><br><span class="line">      name: <span class="string">'order'</span>,</span><br><span class="line">      component: Order</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们定义了两个路由，一个对应登录页，一个对应订单页，并引入了组件 <code>Login</code> 和 <code>Order</code>，前端并没有写注册模块，可以使用 <code>postman</code> 发送注册请求生成一个账户以备后面验证使用。</p><h3 id="登录组件-Login"><a href="#登录组件-Login" class="headerlink" title="登录组件 Login"></a>登录组件 Login</h3><figure class="highlight html"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/views/Login.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">    用户名</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"user.username"</span>&gt;</span></span><br><span class="line">    密码</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"user.password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"login"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'../axios'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">      user: &#123;</span></span><br><span class="line"><span class="javascript">        username: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">        password: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    login() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 发送请求访问服务器的登录接口</span></span></span><br><span class="line"><span class="javascript">      axios.post(<span class="string">'/login'</span>, <span class="keyword">this</span>.user).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 将返回的 token 存入 localStorage，并跳转订单页</span></span></span><br><span class="line"><span class="javascript">        localStorage.setItem(<span class="string">'token'</span>, res.data.token);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$router.push(<span class="string">'/order'</span>);</span></span><br><span class="line"><span class="javascript">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 弹出错误</span></span></span><br><span class="line"><span class="undefined">        alert(err.data);</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Login</code> 组件中将两个输入框的值同步到 <code>data</code> 中，用来存放账号和密码，当点击提交按钮时，触发点击事件 <code>login</code> 发送请求，请求成功后将返回的 <code>token</code> 存入 <code>localStorage</code>，并跳转路由到订单页，请求错误时弹出错误信息。</p><h3 id="订单组件-Order"><a href="#订单组件-Order" class="headerlink" title="订单组件 Order"></a>订单组件 Order</h3><figure class="highlight html"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/views/Order.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"order"</span>&gt;</span></span><br><span class="line">    &#123;&#123;username&#125;&#125; 的订单</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'../axios'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      username: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  mounted() &#123;</span></span><br><span class="line"><span class="javascript">    axios.get(<span class="string">'/order'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.username = res.data.user.username;</span></span><br><span class="line"><span class="javascript">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">      alert(err);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Order</code> 页面显示的内容是 “XXX 的订单”，在加载 <code>Order</code> 组件被挂载时发送请求获取用户名，即访问服务器的验证 <code>token</code> 接口，因为订单页就是一个涉及到验证用户的页面，当请求成功时，将用户名同步到 <code>data</code>，否则弹出错误信息。</p><p>在 <code>Login</code> 和 <code>Order</code> 两个组件中对请求的回调内似乎写的太简单了，其实是因为 <code>axios</code> 的返回值会在服务器返回的返回值外面包了一层，存放一些 <code>http</code> 响应的相关信息，两个接口访问时请求地址也是同一个服务器，而且在服务器响应时的错误处理都是对状态吗 <code>401</code> 的处理，在涉及验证用户信息的请求中需要设置请求头 <code>Authorization</code> 发送 <code>token</code>。</p><p>这些逻辑我们似乎在组件请求相关的代码中都没有看到，是因为我们使用 <code>axios</code> 的 API 设置了 <code>baseURL</code> 请求拦截和响应拦截，细心可以发现其实引入的 <code>axios</code> 并不是直接从 <code>node_modules</code> 引入，而是引入了我们自己的导出的 <code>axios</code>。</p><h3 id="axios-配置"><a href="#axios-配置" class="headerlink" title="axios 配置"></a>axios 配置</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-client/src/axios.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认访问地址</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">'http://localhost:3000'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 报错执行 axios then 方法错误的回调，成功返回正确的数据</span></span><br><span class="line">  <span class="keyword">return</span> res.data.code !== <span class="number">0</span> ? <span class="built_in">Promise</span>.reject(res.data) : res.data;</span><br><span class="line">&#125;, res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 token 验证失败则跳回登陆页，并执行 axios then 方法错误的回调</span></span><br><span class="line">  <span class="keyword">if</span> (res.response.status === <span class="number">401</span>) &#123;</span><br><span class="line">    router.history.push(<span class="string">'/login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'Not Allowed'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截，用于将请求统一带上 token</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 localStorage 获取 token</span></span><br><span class="line">  <span class="keyword">const</span> token = localStorage.getItem(<span class="string">'token'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在则设置请求头</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios;</span><br></pre></td></tr></table></figure><p>访问服务器时会将 <code>axios</code> 中的第一个参数拼接在 <code>axios.defaults.baseURL</code> 的后面作为请求地址。</p><p><code>axios.interceptors.response.use</code> 为响应拦截，<code>axios</code> 发送请求后所有的响应都会先执行这个方法内部的逻辑，返回值为数据，作为参数传递给 <code>axios</code> 返回值的 <code>then</code> 方法。</p><p><code>axios.interceptors.request.use</code> 为请求拦截，<code>axios</code> 发送的所有请求都会先执行这个方法的逻辑，然后发送给服务器，一般用来设置请求头。</p><h2 id="jwt-simple-模块的实现原理"><a href="#jwt-simple-模块的实现原理" class="headerlink" title="jwt-simple 模块的实现原理"></a>jwt-simple 模块的实现原理</h2><p>相信通过上面的过程已经非常清楚 JWT 如何生成的，<code>token</code> 的格式是怎样的，如何跟前端交互去验证 <code>token</code>，我们在这些基础上再深入的研究一下 <code>token</code> 的整个生成过程和验证过程，我们使用的 <code>jwt-simple</code> 模块的 <code>encode</code> 方法如何生成 <code>token</code>，使用 <code>decode</code> 方法如何验证 <code>token</code>，下面就看看一看 <code>jwt-simple</code> 的实现原理。</p><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 其他方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  encode,</span><br><span class="line">  decode</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道 <code>jwt-simple</code> 我们使用的有两个方法 <code>encode</code> 和 <code>decode</code>，所以最后导出的对象上有这两个方法，使用加盐算法进行签名需要使用 <code>crypto</code>，所以我们提前引入。</p><h3 id="字符串和-Base64-互相转换"><a href="#字符串和-Base64-互相转换" class="headerlink" title="字符串和 Base64 互相转换"></a>字符串和 Base64 互相转换</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将子子符串转换成 Base64</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToBase64</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Buffer.from(str).toString(<span class="string">'base64'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Base64 转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64ToString</span>(<span class="params">base64</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Buffer.from(base64, <span class="string">'base64'</span>).toString(<span class="string">'utf8'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法的名字相信很容易看出用途和参数，所以就一起放在这了，其实本质是在两种编码之间进行转换，所以转换之前都应该先转换成 Buffer。</p><h3 id="生成签名的方法"><a href="#生成签名的方法" class="headerlink" title="生成签名的方法"></a>生成签名的方法</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSign</span>(<span class="params">str, secret</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用加盐算法进行加密</span></span><br><span class="line">  <span class="keyword">return</span> crypto.createHmac(<span class="string">'sha256'</span>, secret).update(str).digest(<span class="string">'base64'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步就是通过加盐算法使用 <code>sha256</code> 和密钥 <code>secret</code> 进行生成签名，但是为了方便我们把使用的加密算法给写死了，正常情况下是应该根据 <code>Header</code> 中 <code>alg</code> 字段的值去检索 <code>alg</code> 的值与加密算法名称对应的 <code>map</code>，去使用设置的算法生成签名。</p><h3 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params">payload, secret</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 头部</span></span><br><span class="line">  <span class="keyword">const</span> = stringToBase64(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    typ: <span class="string">'JWT'</span>,</span><br><span class="line">    alg: <span class="string">'HS256'</span></span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 负载</span></span><br><span class="line">  <span class="keyword">const</span> content = stringToBase64(<span class="built_in">JSON</span>.stringify(payload));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 签名</span></span><br><span class="line">  <span class="keyword">const</span> sign = createSign([header, content].join(<span class="string">'.'</span>), secret);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成签名</span></span><br><span class="line">  <span class="keyword">return</span> [header, content, sign].join(<span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>encode</code> 中将 <code>Header</code>、<code>Payload</code> 转换成 <code>base64</code>，通过 <code>.</code> 连接在一起，然后使用 <code>secret</code> 密钥生成签名，最后将 <code>Header</code> 和 <code>Payload</code> 的 <code>base64</code> 通过 <code>.</code> 和生成的签名连接在一起，这就形成了 “明文” + “明文” + “暗文” 三段格式的 <code>token</code>。</p><h3 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h3><figure class="highlight js"><figcaption><span>文件位置：&#126;jwt-apply/jwt-server/jwt-simple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params">token, secret</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [header, content, sign] = token.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将接收到的 token 的前两部分（base64）重新签名并验证，验证不通过抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (sign !== createSign([header, content].join(<span class="string">'.'</span>), secret)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Allow'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 content 转成对象</span></span><br><span class="line">  content = <span class="built_in">JSON</span>.parse(base64ToString(content));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测过期时间，如果过去抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (content.exp &amp;&amp; content.exp &lt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Allow'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在验证方法 <code>decode</code> 中，首先将 <code>token</code> 的三段分别取出，并用前两段重新生成签名，并与第三段 <code>sign</code> 对比，相同通过验证，不同说明篡改过并抛出错误，将 <code>Payload</code> 的内容重新转换成对象，也就是将 <code>content</code> 转换成对象，取出 <code>exp</code> 字段与当前时间对比来验证是否过期，如果过期抛出错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 JWT 生成的 <code>token</code> 中，前两段明文可解，这样别人拦截后知道了我们的加密算法和规则，也知道我们传输的信息，也可以使用 <code>jwt-simple</code> 加密一段暗文拼接成 <code>token</code> 的格式给服务器去验证，为什么 JWT 还这么安全呢，这就说到了最最重点的地方，无论别人知道多少我们在传输的信息，篡改和伪造后都不能通过服务器的验证，是因为无法获取服务器的密钥 <code>secret</code>，真正能保证安全的就是 <code>secret</code>，同时证明了 <code>Header</code> 和 <code>Payload</code> 并不安全，可以被破解，所以不能存放敏感信息。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/08/16/20180816141146/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL —— 简单聊一聊数据库设计</title>
      <link>https://www.overtaking.top/2018/08/14/20180814131241/</link>
      <guid>https://www.overtaking.top/2018/08/14/20180814131241/</guid>
      <pubDate>Tue, 14 Aug 2018 05:12:41 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/08/14/20180814131241/mysql-table-design.png&quot; title=&quot;MySQL 数据库设计&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;这是关于 MySQL 系列文章的第三篇，在前两篇文章 &lt;a href=&quot;https://www.overtaking.top/2018/08/08/20180808012303/&quot; target=&quot;_blank&quot;&gt;《MySQL —— 数据库基础》&lt;/a&gt; 和 &lt;a href=&quot;https://www.overtaking.top/2018/08/09/20180809115245/&quot; target=&quot;_blank&quot;&gt;《MySQL —— SQL 语句总结》&lt;/a&gt; 中，主要介绍了一些数据库的基础概念、创建表的方式以及 SQL 语句的使用，本篇在使用的基础上做一个小小的升华，来简单聊一聊数据库的设计，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/08/14/20180814131241/mysql-table-design.png" title="MySQL 数据库设计"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>这是关于 MySQL 系列文章的第三篇，在前两篇文章 <a href="https://www.overtaking.top/2018/08/08/20180808012303/" target="_blank">《MySQL —— 数据库基础》</a> 和 <a href="https://www.overtaking.top/2018/08/09/20180809115245/" target="_blank">《MySQL —— SQL 语句总结》</a> 中，主要介绍了一些数据库的基础概念、创建表的方式以及 SQL 语句的使用，本篇在使用的基础上做一个小小的升华，来简单聊一聊数据库的设计，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。</p></blockquote><a id="more"></a><h2 id="为什么设计数据库"><a href="#为什么设计数据库" class="headerlink" title="为什么设计数据库"></a>为什么设计数据库</h2><p>说到为什么要设计数据库，就要说到数据的完整性，我们要在设计数据库时保证域的完整性和实体的完整性，同时从性能出发，我们要保证最大限度的节省存储空间，比如一张成绩表，上面没必要存储学生的姓名、年龄等信息，只需要存储成绩，如果一个数据库设计的合理，最后的结果就是方便我们对数据库的开发和扩展。</p><p>如果是一个 “糟糕” 的数据库设计会造成一系列的不良反应，比如数据冗余，存储空间浪费，内存浪费，有时甚至会造成数据插入和更新的异常，比如学生表存了学生信息，而成绩表也存了，这样在修改时没有全部修改就会出现错误。</p><h2 id="软件项目开发中数据库设计的生命周期"><a href="#软件项目开发中数据库设计的生命周期" class="headerlink" title="软件项目开发中数据库设计的生命周期"></a>软件项目开发中数据库设计的生命周期</h2><p><strong>软件项目开发中数据库设计的生命周期可大概分为以下几个阶段：</strong></p><ul><li>需求分析阶段，分析客户的业务和数据处理需求；</li><li>概要设计阶段，设计数据库 <code>E-R</code> 模型图，确认需求的正确和完整性；</li><li>详细设计阶段，应用三大范式审核数据库；</li><li>代码编写阶段，物理实现数据库，编码实现应用；</li><li>软件测试阶段；</li><li>安装部署阶段。</li></ul><p>上面数据库的设计经历了从 “现实世界” 到 “信息世界” 到 “数据库模型” 再到 “数据库” 产生的一个完整过程。</p><h2 id="设计数据库的步骤"><a href="#设计数据库的步骤" class="headerlink" title="设计数据库的步骤"></a>设计数据库的步骤</h2><p>收集信息：收集信息其实就是与相关人员进行交流、访谈、调研，充分了解用户需求，理解整个项目的完整流程，并理解数据库需要完成的任务，这部分工作大部分由需求人员完成，并根技术人员进行对接。</p><p>标识实体和实体属性：开发人员在明确需求和流程之后，标识数据库的实体，比如学生信息表，每一条实体中应该由哪些字段组成，成绩表中实体由哪些字段组成等等。</p><p>标识实体之间的关系：其实就是通过表之间的某字段对表进行关联，对表的实体之间建立对应关系，如学生表的 <code>id</code> 字段会关联成绩表的 <code>student_id</code> 字段，用来查找某个学生的成绩。</p><h2 id="数据库-E-R-图"><a href="#数据库-E-R-图" class="headerlink" title="数据库 E-R 图"></a>数据库 E-R 图</h2><h3 id="E-R-图基本概念"><a href="#E-R-图基本概念" class="headerlink" title="E-R 图基本概念"></a>E-R 图基本概念</h3><p><code>E-R</code> 图也叫做实体关系图，是指用实体、关系、属性三个基本概念概括数据的基本结构，从而描述静态数据的概念模型。</p><p><code>E-R</code> 图的实体：即数据模型中的数据对象，每一张表就是一个 <code>E-R</code> 图的实体。</p><p><code>E-R</code> 图的属性：即数据对象中所具有的属性，例如学生表的学生、姓名、年龄等，属性又分为唯一属性和非唯一属性，唯一属性如经过唯一约束和主键约束的属性，不可重复，其他的都是非唯一属性。</p><p><code>E-R</code> 图的关系：用来表示每一个数据对象与数据对象之间的联系，即每一个实体之间的联系，例如学生表和成绩表之间的联系，因为每个学生都有自己的成绩。</p><h3 id="E-R-图的关联关系"><a href="#E-R-图的关联关系" class="headerlink" title="E-R 图的关联关系"></a>E-R 图的关联关系</h3><h4 id="1-对-1-（1-1）"><a href="#1-对-1-（1-1）" class="headerlink" title="1 对 1 （1 : 1）"></a>1 对 1 （1 : 1）</h4><p><code>1</code> 对 <code>1</code> 关系是指对于实体集 <code>A</code> 和 实体集 <code>B</code>，<code>A</code> 中的每一个实体最多与 <code>B</code> 中的一个实体有关系，反之在实体集 <code>B</code> 中的每一个实体之多与实体集 <code>A</code> 中的一个实体有关系。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/onetoone.png" alt="1 对 1 关系图" title>                </div>                <div class="image-caption">1 对 1 关系图</div>            </figure><p><br></p><h4 id="1-对多（1-N）"><a href="#1-对多（1-N）" class="headerlink" title="1 对多（1 : N）"></a>1 对多（1 : N）</h4><p><code>1</code> 对多关系是指实体集 <code>A</code> 与实体集 <code>B</code> 中至少有 <em>N (N &gt; 0)</em> 个实体有关系，并且实体集 <code>B</code> 中最多与实体集 <code>A</code> 中的一个实体有关系。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/onetomany.png" alt="1 对多关系图" title>                </div>                <div class="image-caption">1 对多关系图</div>            </figure><p><br></p><h4 id="多对多（M-N）"><a href="#多对多（M-N）" class="headerlink" title="多对多（M : N）"></a>多对多（M : N）</h4><p>多对多关系是指实体集 <code>A</code> 中的每一个实体与实体集 <code>B</code> 中至少有 <em>M (M &gt; 0)</em> 个实体有关系，并且实体集 <code>B</code> 中的每一个实体与实体集 <code>A</code> 中至少有 <em>N (N &gt; 0)</em> 个实体有关系。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/manytomany.png" alt="多对多关系图" title>                </div>                <div class="image-caption">多对多关系图</div>            </figure><p><br></p><h2 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h2><h3 id="确保每列的原子性"><a href="#确保每列的原子性" class="headerlink" title="确保每列的原子性"></a>确保每列的原子性</h3><p>如果每列都是不可再分的最小单元信息，则满足第一范式，比如下图中，地址是由国家和城市组成的，显然可以继续在拆分成两个列，国家和城市，是不满足第一范式的，需要将地址列差分成国家和城市两个列。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/firstpattern.png" alt="原子性事例" title>                </div>                <div class="image-caption">原子性事例</div>            </figure><p><br></p><p>举一个简单的例子，我们平时在淘宝购物的时候需要添加地址，在填写新地址时，都是让我们选择国家、省、城市、区、街道、小区这样的方式，而不是让我们自己将这些地址写在一起，其原因就是因为淘宝的数据库设计严格遵循每列的原子性，这样的提交可以方便后端获取每一个列的信息在数据库中进行存储。</p><h3 id="每个表只能描述一件事情"><a href="#每个表只能描述一件事情" class="headerlink" title="每个表只能描述一件事情"></a>每个表只能描述一件事情</h3><p>如下图中所示，在左侧的表中，描述了学生信息和课程信息，这明显是两件事情，假设再有一张成绩表，也要描述学生信息，课程信息和成绩等多件事情，就会造成数据的重复、冗余，也可能会导致更新、插入、删除数据异常的现象。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/secondpattern.png" alt="每个表描述一件" title>                </div>                <div class="image-caption">每个表描述一件</div>            </figure><p><br></p><p>所以正确的做法是应该将左侧表差分成两张表分别为学生表和课程表，并使用学生编号与课程编号进行关联。</p><h3 id="其他列都不传递依赖于主键列"><a href="#其他列都不传递依赖于主键列" class="headerlink" title="其他列都不传递依赖于主键列"></a>其他列都不传递依赖于主键列</h3><p>其他列都不传递依赖于主键列的意思是表中各列必须都与主键直接相关，不能间接相关，从下图左表可以看出，学生编号为主键，年级 <code>ID</code> 也应该为主键，正常应该通过学生编号找到年级 <code>ID</code>，再找到年级名称，这样年级名称与学生编号之间就形成了一个传递并且依赖于主键年级 <code>ID</code>，即年级 <code>ID</code> 做为主键在中间隔了一层，这样就使年级名称与主键学生编号间接相关，如果在同一张表中，所有的字段都是应该直接依赖于主键，而不是再通过其他的主键传递。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/thirdpattern.png" alt="其他列都不传递依赖于主键列" title>                </div>                <div class="image-caption">其他列都不传递依赖于主键列</div>            </figure><p><br></p><p>如果一个表中表述了多件事情并有多个作为主键的列，与上一条的处理方式相同，应该拆成多张表，并且每张表只有一个主键列。</p><h2 id="RBAC-基于角色的访问控制"><a href="#RBAC-基于角色的访问控制" class="headerlink" title="RBAC 基于角色的访问控制"></a>RBAC 基于角色的访问控制</h2><h3 id="RBAC-的含义"><a href="#RBAC-的含义" class="headerlink" title="RBAC 的含义"></a>RBAC 的含义</h3><blockquote class="pullquote info"><p>RBAC（Role-Based Access Control）基于角色的访问控制，就是用户通过角色与权限进行关联，简单的说，一个用户拥若干个角色，每个角色拥有若干个权限，这样就构造成了 “用户 → 角色 → 权限 → 资源” 的授权模型，在这个模型中，用户与角色之间，角色与权限之间，权限与资源之间，一般都是多对多的关系，在 <code>RBAC</code> 中最重要的概念主要有四部分，就是用户（User）、角色（Role）、权限（Permission）和资源（Resource）。</p></blockquote><h3 id="RBAC-的安全原则"><a href="#RBAC-的安全原则" class="headerlink" title="RBAC 的安全原则"></a>RBAC 的安全原则</h3><ul><li>最小权限原则：最小权限原则之所以被 <code>RBAC</code> 所支持，是因为 <code>RBAC</code> 可以将其角色配置成完成任务所需要的最小的权限集；</li><li>责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一个帐目；</li><li>数据抽象原则：数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限。</li></ul><h3 id="RBAC-的-E-R-图"><a href="#RBAC-的-E-R-图" class="headerlink" title="RBAC 的 E-R 图"></a>RBAC 的 E-R 图</h3><p>之前说 <code>RBAC</code> 最重要的概念由四部分，其实体现在数据库的表中有主要三部分，因为角色和用户是重叠的，那么主要有三张表分别为用户表、权限表和资源表，其中用户表与权限表之间有一张关联表，权限表与资源表之间有一张关联表，<code>E-R</code> 图如下。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/14/20180814131241/RBAC.png" alt="RBAC 的 E-R 图" title>                </div>                <div class="image-caption">RBAC 的 E-R 图</div>            </figure><p><br></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="为什么需要事务？"><a href="#为什么需要事务？" class="headerlink" title="为什么需要事务？"></a>为什么需要事务？</h3><p>在生活中我们经常使用银行转账或者支付宝和微信支付，这种操作每一次至少影响两个用户的数据信息，比如一方给另一方转钱，如果成功则转钱方余额减去转出金额，而收钱方余额增加收到的金额，这应该是一个请求操作了数据表中的俩个实体，如果在两个操作数据的环节任意一个失败了，都会影响两个人数据的正确性，这种时候需要两个操作同时失败或同时成功，就是说有一个操作出现失败的情况，即使另一个成功了也需要进行回滚操作，这就是事务的由来。</p><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是作为单个逻辑工作单元执行的一系列操作，多个操作作为一个整体向系统提交，要么都执行，要么都不执行，是一个不可分割的工作逻辑单元。</p><p>转账过程就是一个整体，它需要两条 <code>UPDATE</code> 语句，如果任何一个出错，则整个转账业务取消，两个账户的余额都恢复到原来的数据（回滚），确保总余额不变。</p><p>这里再举一个例子，有一个上传文件的功能，后端接收到文件流时是需要先写入的，当写入成功后，会将上传成功的结果返回给客户端，如果文件很大，写入的时间就会长，如果在此期间突然写入失败，则会删除之前写入的内容，将整个操作回滚到写入之前，这里面主要两步操作，创建一个新文件并写入，写入成功删除旧文件，如果写入失败，两个操作将会同时失败，即不会删除旧文件，这也是一个事务的例子，只是没有转账那么明显。</p><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性 ACID"></a>事务的特性 ACID</h3><p><strong>事务具有以下特性，被简称为 ACID：</strong></p><ul><li>原子性（Atomicity）：事务是一个完整的操作，事务各个部分是不可分的，要么都执行，要么都不执行；</li><li>一致性（Consistency）：当事务完成后，数据必须处理完整的状态；</li><li>隔离性（Isolation）：并发事务彼此隔离、独立，它不应该以任何方式依赖于其它事务；</li><li>持久性（Durability）：事务完成后，它对数据库的修改被永久保持。</li></ul><h3 id="如何创建事务"><a href="#如何创建事务" class="headerlink" title="如何创建事务"></a>如何创建事务</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>创建表 <code>account</code>，<code>id</code> 列为主键列，<code>name</code> 列为姓名，<code>balance</code> 为余额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`account`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`balance`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>将表 <code>account</code> 添加两条数据，分别为 “张三” 和 “李四”，余额都为 <code>100</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`name`</span>, <span class="string">`balance`</span>) <span class="keyword">VALUES</span> (<span class="string">"张三"</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`name`</span>, <span class="string">`balance`</span>) <span class="keyword">VALUES</span> (<span class="string">"李四"</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h4 id="使用-NodeJS-实现事务"><a href="#使用-NodeJS-实现事务" class="headerlink" title="使用 NodeJS 实现事务"></a>使用 NodeJS 实现事务</h4><figure class="highlight js"><figcaption><span>一个非常简单的事务</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据库连接</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>, <span class="comment">// 主机名</span></span><br><span class="line">  port: <span class="string">'3306'</span>, <span class="comment">// 数据库服务端口号</span></span><br><span class="line">  username: <span class="string">'root'</span>, <span class="comment">// 数据库名称</span></span><br><span class="line">  pwd: <span class="string">'123456'</span>, <span class="comment">// 数据库密码</span></span><br><span class="line">  database: <span class="string">'school'</span>  <span class="comment">// 连接的数据库名称</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">connection.beginTransaction(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 回调参数为错误对象，返回结果，返回字段描述</span></span><br><span class="line">  connection.query(</span><br><span class="line">    <span class="string">'UPDATE account SET balance - 50 WHERE id = 1'</span>,</span><br><span class="line">    (err, result, fields) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        connection.rollback(); <span class="comment">// 如果失败直接回归</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connection.query(</span><br><span class="line">          <span class="string">'UPDATE account SET balance - 50 WHERE id = 1'</span>,</span><br><span class="line">          (err, result, fields) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果失败直接回归，如果两个都成功了则提交事务</span></span><br><span class="line">            err ? connection.rollback() : connection.commit();</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>到此关于 MySQL 的系列文章就告一段落了，希望前端的同学们在看了这几篇文章后对你们入门 MySQL 有一些帮助，那这几篇的文章就达到目的了，也欢迎后端的小伙伴来指出文章中的错误和不足。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/08/14/20180814131241/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL —— SQL 语句总结</title>
      <link>https://www.overtaking.top/2018/08/09/20180809115245/</link>
      <guid>https://www.overtaking.top/2018/08/09/20180809115245/</guid>
      <pubDate>Thu, 09 Aug 2018 03:52:45 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/08/09/20180809115245/sql.png&quot; title=&quot;SQL 语句&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;这是关于 MySQL 系列文章的第二篇，在上一篇 &lt;a href=&quot;https://www.overtaking.top/2018/08/08/20180808012303/&quot; target=&quot;_blank&quot;&gt;《MySQL —— 数据库基础》&lt;/a&gt; 中，主要介绍了一些数据库的基础概念、创建表的方式以及使用 DDL 数据定义语言对表的操作，本篇的主要内容是在开发中使用 SQL 语句对数据库的增、删、改、查，函数、聚合函数的应用以及表连接，本篇大部分内容都贴近开发中的实际操作，不会像上一篇那么枯燥，也可当作一个小小的查询文档，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/08/09/20180809115245/sql.png" title="SQL 语句"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于 MySQL 系列文章的第二篇，在上一篇 <a href="https://www.overtaking.top/2018/08/08/20180808012303/" target="_blank">《MySQL —— 数据库基础》</a> 中，主要介绍了一些数据库的基础概念、创建表的方式以及使用 DDL 数据定义语言对表的操作，本篇的主要内容是在开发中使用 SQL 语句对数据库的增、删、改、查，函数、聚合函数的应用以及表连接，本篇大部分内容都贴近开发中的实际操作，不会像上一篇那么枯燥，也可当作一个小小的查询文档，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。</p></blockquote><a id="more"></a><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>还记得在上一篇的最后我们使用 DDL 创建了完整的表关系，<code>student</code>、<code>score</code> 和 <code>course</code> 三张表如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/student-score-course.png" alt="完整表关系图" title>                </div>                <div class="image-caption">完整表关系图</div>            </figure><p><br></p><p>其中 <code>score</code> 是外键表，创建外键约束关联了两张主键表 <code>scudent</code> 和 <code>cource</code>，接下来的 SQL 语句都是基于这几张表来进行的。</p><h2 id="SQL-的组成"><a href="#SQL-的组成" class="headerlink" title="SQL 的组成"></a>SQL 的组成</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>DDL（data definition language）是数据定义语言，主要命令有 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code> 等，DDL 主要用在定义或改变数据表（TABLE）的结构、数据类型、表之间的链接和约束等初始化工作上，大多数在建立表时使用，在上一篇中 DDL 操作表的部分着重做了介绍并创建数据表，也可以将存储 DDL 语句的文件存储在 <code>.sql</code> 后缀名结尾的文件当中，在 DBMS 数据管理系统中导入，直接创建数据库。</p><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>DML（data manipulation language）是数据操做语言，通过 DML 语句对数据库数据表中的实体进行增、删、改、查，数据量非常大时，我们不可能使用 DBMS 一条一条的操作数据，所以都是通过代码完成操作，DML 是在学习 MySQL 数据库中最最重要的内容，也是本篇的重点，后面会非常详细的说明。</p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL（data control language）是数据库控制语言，用来设置或更改数据库用户或角色权限的语句，包括 <code>grant</code>、<code>revoke</code> 等，<code>grant</code> 是授权命令，<code>revoke</code> 是收回权限命令。</p><h2 id="SQL-运算符"><a href="#SQL-运算符" class="headerlink" title="SQL 运算符"></a>SQL 运算符</h2><blockquote class="pullquote info"><p>SQL 元算符分为算术运算符、逻辑运算符和比较运算符，是用来完成列之间或者变量之间的比较和运算的。</p></blockquote><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th style="width:20%;text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="width:20%;text-align:center">+</td><td style="text-align:center">加运算，求两个数或表达式相加的和，如 1 + 1</td></tr><tr><td style="width:20%;text-align:center">-</td><td style="text-align:center">减运算，求两个数或表达式相减的差，如 4 - 1</td></tr><tr><td style="width:20%;text-align:center">*</td><td style="text-align:center">乘运算，求两个数或表达式相乘的积，如 2 * 2</td></tr><tr><td style="width:20%;text-align:center">\</td><td style="text-align:center">除运算，求两个数或表达式相除的商，如 6 / 4</td></tr><tr><td style="width:20%;text-align:center">%</td><td style="text-align:center">取模运算，求两个数或表达式相除的余数，如 6 % 4</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th style="width:20%;text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="width:20%;text-align:center">AND</td><td style="text-align:center">当且仅当两个布尔表达式都为 true 时，返回 true</td></tr><tr><td style="width:20%;text-align:center">OR</td><td style="text-align:center">当且仅当两个布尔表达式都为 false 时，返回 false</td></tr><tr><td style="width:20%;text-align:center">NOT</td><td style="text-align:center">布尔表达式的值取反</td></tr></tbody></table><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table><thead><tr><th style="width:20%;text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="width:20%;text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="width:20%;text-align:center">></td><td style="text-align:center">大于</td></tr><tr><td style="width:20%;text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="width:20%;text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="width:20%;text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="width:20%;text-align:center">&lt;&gt;</td><td style="text-align:center">不等于</td></tr><tr><td style="width:20%;text-align:center">!=</td><td style="text-align:center">不等于</td></tr><tr><td style="width:20%;text-align:center">&lt;=&gt;</td><td style="text-align:center">安全不等于</td></tr></tbody></table><h2 id="SQL-语句之数据增、删、改"><a href="#SQL-语句之数据增、删、改" class="headerlink" title="SQL 语句之数据增、删、改"></a>SQL 语句之数据增、删、改</h2><h3 id="插入数据行"><a href="#插入数据行" class="headerlink" title="插入数据行"></a>插入数据行</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 [(列名)] <span class="keyword">VALUES</span> (值列表)</span><br></pre></td></tr></table></figure><p>给上面的 <code>student</code> 表插入一条数据，姓名为张三，卡号为 <code>100</code>，年龄为 <code>20</code>，城市默认为北京。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`name`</span>, <span class="string">`idcard`</span>, <span class="string">`age`</span>, <span class="string">`city`</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">"张三"</span>, <span class="string">"100"</span>, <span class="number">20</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>每次插入一行数据，不能只插入一部分数据，即不能只插入了一个实体的某几列，插入的数据是否有效将严格按照实体的完整性要求来检验；</li><li>每个数据值的数据类型、精度、位数必须要与对应的列名精确匹配，严格按照域的完整性要求来检验；</li><li>不能为标识符指定值（规定），例如作为主键自增的标识列；</li><li>如果某字段设置非空约束，则该列必须插入不为 <code>null</code> 的数据；</li><li>插入数据时还要符合检查性约束的要求，如非空约束、唯一约束等；</li><li>设置了默认值的列，有缺省值时，可以使用 <code>DEFAULT</code> 关键字来代替插入的实际值。</li></ul><h3 id="更新数据行"><a href="#更新数据行" class="headerlink" title="更新数据行"></a>更新数据行</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名 = 更新值 [<span class="keyword">WHERE</span> &lt;更新条件&gt;]</span><br></pre></td></tr></table></figure><p>将 <code>student</code> 表中 <code>id</code> 为 <code>1</code> 的实体的 <code>idcard</code> 列值改为 <code>200</code>，<code>age</code> 列值改为 <code>24</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">`idcard`</span> = <span class="string">"200"</span>, <span class="string">`age`</span> = <span class="number">24</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`id`</span> = <span class="number">1</span> <span class="keyword">AND</span> <span class="string">`name`</span> = <span class="string">"张三"</span>;</span><br></pre></td></tr></table></figure><p>将 <code>student</code> 表中 <code>city</code> 列为空的实体 <code>city</code> 列的值设置为 “上海”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">`city`</span> = <span class="string">"上海"</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>更新多列时，列赋值语句之间使用逗号分隔，一定要加更新条件，否则会更新所有的行；</li><li>多个联合条件根据逻辑关系使用 <code>AND</code> 或 <code>OR</code> 连接。</li></ul><h3 id="删除数据行"><a href="#删除数据行" class="headerlink" title="删除数据行"></a>删除数据行</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> [<span class="keyword">FROM</span>] 表名 [<span class="keyword">WHERE</span> &lt;删除条件&gt;]</span><br></pre></td></tr></table></figure><p>删除 <code>student</code> 表中 <code>age</code> 列值为 <code>24</code> 或者 <code>idcard</code> 列值为 <code>200</code> 的实体。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`age`</span> = <span class="number">24</span> <span class="keyword">OR</span> <span class="string">`idcard`</span> = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>删除的是一整行的数据，所以不需要提供列名；</li><li>如果要删除主表数据，则要先删除外键连接对应的子表数据。</li></ul><h2 id="SQL-语句之数据查询"><a href="#SQL-语句之数据查询" class="headerlink" title="SQL 语句之数据查询"></a>SQL 语句之数据查询</h2><blockquote class="pullquote default"><p>在 SQL 语句的增、删、改、查中，最繁琐和复杂的就是查询语句，在实际开发中七分查询三分增、删、改的说法一点也不为过，查询语句是在业务中使用最多的语句，所以我们将查询语句与增、删、改分离出来，用这单独的一节来叙述。</p></blockquote><h3 id="查询简介"><a href="#查询简介" class="headerlink" title="查询简介"></a>查询简介</h3><p>查询就是从客户端发出查询，请求数据库服务器，并从数据库返回查询结果的过程，每次执行查询只是从数据表中提取数据，并按照表的方式呈现出来，查询产生的虚拟表并不会保存。</p><h3 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;查询条件表达式&gt;]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序的列名&gt; [<span class="keyword">ASC</span> 或 <span class="keyword">DESC</span>]]</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;起始索引&gt;, &lt;查询条数&gt;;</span><br></pre></td></tr></table></figure><p>我们继续操作之前的三张表，查询 “北京” 的学生并按 <code>id</code> 的正序排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> = <span class="string">"北京"</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>上面 SQL 语句中的 <code>*</code> 代表查询表中所有的列，如果查找某些列，列名之间用 <code>,</code> 分隔。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>在查询数据表的某个列的时候可以通过别名改变查询到虚拟表列的名称，在列的后面使用 <code>AS</code> 关键字加上别名，<code>AS</code> 可以省略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`city`</span> <span class="keyword">AS</span> <span class="string">`城市`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> = <span class="string">"北京"</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="查询空行"><a href="#查询空行" class="headerlink" title="查询空行"></a>查询空行</h3><p>假设表中的某一列值为 <code>null</code>，我们可以通过 <code>IS</code> 关键字查询这一列值为空的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`city`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="常量列"><a href="#常量列" class="headerlink" title="常量列"></a>常量列</h3><p>查询一个数据表中没有的列，我们可以在查询时将这一列增加为常量列，如 <code>city</code> 的值都是中国的，我们可以增加一个常量列值都为 “中国”，列名为 <code>country</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`city`</span>, <span class="string">"中国"</span> <span class="keyword">AS</span> <span class="string">`country`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><h3 id="查询列的不重复数据"><a href="#查询列的不重复数据" class="headerlink" title="查询列的不重复数据"></a>查询列的不重复数据</h3><p>假设查询 <code>student</code> 表中同学们来自那些城市，正常按照 <code>city</code> 列查询，有多个条数据的 <code>city</code> 列都来自同一个城市，我们可以使用 <code>DISTINCT</code> 关键字，只保留一个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="string">`city`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><h3 id="限制查询条数"><a href="#限制查询条数" class="headerlink" title="限制查询条数"></a>限制查询条数</h3><p><code>LIMIT</code> 关键字用来限制查询返回的条数，后面的值为数字，下面查询 <code>student</code> 表，只返回 <code>3</code> 条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>当 <code>LIMIT</code> 参数大于一个时，第一个参数代表起始的索引（跳过的条数），第二个参数代表返回的条数，中间用 <code>,</code> 隔开，还是查询 <code>student</code> 表，返回第 <code>4</code> 到 <code>6</code> 条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="运算符在查询中的使用"><a href="#运算符在查询中的使用" class="headerlink" title="运算符在查询中的使用"></a>运算符在查询中的使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> + <span class="number">1</span>; <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> + <span class="string">"1"</span>; <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> + <span class="string">"panda"</span>; <span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> + <span class="literal">NULL</span>; <span class="comment">-- NULL</span></span><br></pre></td></tr></table></figure><p>通过上面的例子可以看出在 SQL 语句中，使用算术运算符相加无法起到字符串拼接的作用，会将值转化为数字进行计算，字符串转为数字 <code>0</code>，数字与 <code>null</code> 相加结果为 <code>null</code>，没意义。</p><h3 id="查询语句练习案例"><a href="#查询语句练习案例" class="headerlink" title="查询语句练习案例"></a>查询语句练习案例</h3><p>首先我们将上面的三张表 <code>student</code>，<code>cource</code> 和 <code>score</code> 三张表插入数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给 student 表插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"郭靖"</span>,</span><br><span class="line">  <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"40"</span>,</span><br><span class="line">  <span class="string">"济南"</span>,</span><br><span class="line">  <span class="string">"山东省"</span>,</span><br><span class="line">  <span class="string">"1978-09-03"</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"1@qq.com"</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"2"</span>,</span><br><span class="line">  <span class="string">"黄蓉"</span>,</span><br><span class="line">  <span class="string">"2"</span>,</span><br><span class="line">  <span class="string">"36"</span>,</span><br><span class="line">  <span class="string">"济南"</span>,</span><br><span class="line">  <span class="string">"山东省"</span>,</span><br><span class="line">  <span class="string">"1982-09-03"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">"2@qq.com"</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"3"</span>,</span><br><span class="line">  <span class="string">"杨过"</span>,</span><br><span class="line">  <span class="string">"3"</span>,</span><br><span class="line">  <span class="string">"22"</span>,</span><br><span class="line">  <span class="string">"终南山"</span>,</span><br><span class="line">  <span class="string">"陕西省"</span>,</span><br><span class="line">  <span class="string">"1996-09-03"</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"3@qq.com"</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"4"</span>,</span><br><span class="line">  <span class="string">"小龙女"</span>,</span><br><span class="line">  <span class="string">"4"</span>,</span><br><span class="line">  <span class="string">"28"</span>,</span><br><span class="line">  <span class="string">"终南山"</span>,</span><br><span class="line">  <span class="string">"陕西省"</span>,</span><br><span class="line">  <span class="string">"1990-09-03"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">"4@qq.com"</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">VALUES</span> (</span><br><span class="line">  <span class="string">"5"</span>,</span><br><span class="line">  <span class="string">"欧阳锋"</span>,</span><br><span class="line">  <span class="string">"5"</span>, <span class="string">"70"</span>,</span><br><span class="line">  <span class="string">"白驼山"</span>,</span><br><span class="line">  <span class="string">"新疆"</span>,</span><br><span class="line">  <span class="string">"1948-09-03"</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"5@qq.com"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 cource 表插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">"1"</span>, <span class="string">"语文"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">"2"</span>, <span class="string">"数学"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">"3"</span>, <span class="string">"英语"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 score 表插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"100"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"90"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"70"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"100"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"2"</span>, <span class="string">"2"</span>, <span class="string">"40"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"80"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"3"</span>, <span class="string">"1"</span>, <span class="string">"100"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"3"</span>, <span class="string">"2"</span>, <span class="string">"60"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">"3"</span>, <span class="string">"3"</span>, <span class="string">"80"</span>);</span><br></pre></td></tr></table></figure><p><strong>添加数据后的三张表如下图：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/tables.png" alt="表的具体数据" title>                </div>                <div class="image-caption">表的具体数据</div>            </figure><p><br></p><p><strong>查询山东省学生的全部信息：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`province`</span> = <span class="string">"山东"</span>;</span><br></pre></td></tr></table></figure><p><strong>查询山东省男学生的全部信息：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`province`</span> = <span class="string">"山东"</span> <span class="keyword">AND</span> <span class="string">`gender`</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>查询没填写电子邮箱学生的姓名和身份证号：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>, <span class="string">`idcard`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`email`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>把学生的成绩按升序排列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`grade`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><strong>课程编号升序排列，成绩降序排列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`course_id`</span> <span class="keyword">ASC</span>, <span class="string">`grade`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL-语句之模糊查询"><a href="#SQL-语句之模糊查询" class="headerlink" title="SQL 语句之模糊查询"></a>SQL 语句之模糊查询</h2><blockquote class="pullquote primary"><p>在上一节中我们所使用的查询叫 “完整查询” 或 “精准查询”，而本节的 “模糊查询” 是指查询条件不明确，可以尽量多的匹配满足查询条件的数据。</p></blockquote><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>“通配符” 用于代替一个或多个真正的字符，与 <code>LIKE</code> 关键字一起使用，通配符的解释、示例如下表。</p><table><thead><tr><th style="width:15%;text-align:center">通配符</th><th style="text-align:center">解释</th><th style="width:20%;text-align:center">示例</th><th style="width:25%;text-align:center">符合条件的值</th></tr></thead><tbody><tr><td style="text-align:center">_</td><td style="text-align:center">一个任意字符</td><td style="text-align:center">LIKE “a_”</td><td style="text-align:center">as、ad 等</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">任意长度的字符串</td><td style="text-align:center">LIKE “c%”</td><td style="text-align:center">code、cat 等</td></tr><tr><td style="text-align:center">[ ]</td><td style="text-align:center">括号中所指定范围内的一个字符</td><td style="text-align:center">LIKE “1[35]5”</td><td style="text-align:center">135 或 155</td></tr><tr><td style="text-align:center">[^]</td><td style="text-align:center">不再括号中所指定范围内的一个字符</td><td style="text-align:center">LIKE “1[^1-2]5”</td><td style="text-align:center">135 或 155 等</td></tr></tbody></table><p>查询 <code>student</code> 表中 <code>email</code> 列是 <code>qq</code> 邮箱的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`emai`</span> <span class="keyword">LIKE</span> <span class="string">`%qq%`</span>;</span><br></pre></td></tr></table></figure><p>查询 <code>student</code> 表中姓杨的名字为两个字的所有学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`name`</span> <span class="keyword">LIKE</span> <span class="string">"杨_"</span>;</span><br></pre></td></tr></table></figure><h3 id="BETWEEN…AND…"><a href="#BETWEEN…AND…" class="headerlink" title="BETWEEN…AND…"></a>BETWEEN…AND…</h3><p><code>BETWEEN...AND...</code> 用于查询某一列在指定范围内的记录，包括两个边界。</p><p>查询 <code>score</code> 表中成绩在 <code>80</code> 到 <code>90</code> 范围内的所有学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 精准查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`grade`</span> &gt;= <span class="number">80</span> <span class="keyword">AND</span> <span class="string">`grade`</span> &lt;= <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`grade`</span> <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><p>查询某一列中的值在列出的内容列表中。</p><p>查询 <code>student</code> 表中 <code>city</code> 列为 “北京” 或 “上海” 或 “杭州” 所有学生的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 精准查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> = <span class="string">"北京"</span> <span class="keyword">OR</span> <span class="string">`city`</span> = <span class="string">"上海"</span> <span class="keyword">OR</span> <span class="string">`city`</span> = <span class="string">"杭州"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`city`</span> <span class="keyword">IN</span> (<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"杭州"</span>);</span><br></pre></td></tr></table></figure><h2 id="截断表"><a href="#截断表" class="headerlink" title="截断表"></a>截断表</h2><p>作为主键的标识列，值是会随着数据的增加，自动递增的，且具有 “断号保留” 的特性，随着表中数据的增删，标识列的值会非常混乱，我们可以通过截断表来解决该问题，截断表有两个作用如下。</p><ul><li>使表中数据的标识列的值重新从 <code>1</code> 开始计数；</li><li>清空表中数据；</li></ul><blockquote class="pullquote warning"><p><em><strong>使用截断表时，表的列和约束不会改动，使用的前提是表与表之间不能存在外键约束，表之间如果通过外键进行关联，无法清空主表中数据，即无法截断表。</strong></em></p></blockquote><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure><p><strong>截断 student 表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>截断表操作轻易不要使用，因为普通的 SQL 操作会记录日志，并且可以还原，而 <code>TRUNCATE</code> 操作不会记录日志，并且不可还原，万一删错，彻底完蛋。</strong></em></p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote class="pullquote default"><p>在 MySQL 中有很多内置的函数帮我们实现一些功能，函数大类可分为普通函数和聚合函数，我们本节主要介绍普通函数，常用的普通函数大概可分为字符函数、数字函数、日期函数和流程控制函数等，还有一些与数据库相关的辅助函数以及自定义函数，都会在本节一一介绍。</p></blockquote><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><h4 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH"></a>LENGTH</h4><p><code>LENGTH</code> 函数的作用是返回输入字符串的长度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(<span class="string">"panda"</span>); <span class="comment">-- 5</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(<span class="string">"你好啊"</span>); <span class="comment">-- 9</span></span><br></pre></td></tr></table></figure><h4 id="CONCAT-和-CONCAT-WS"><a href="#CONCAT-和-CONCAT-WS" class="headerlink" title="CONCAT 和 CONCAT_WS"></a>CONCAT 和 CONCAT_WS</h4><p><code>CONCAT</code> 函数用于将多个字符串拼接成一个字符串，<code>CONCAT_WS</code> 函数用于使用分隔符将多个字符串拼接成一个字符串，第一个参数为分隔符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">"Panda"</span>, <span class="string">"Shen"</span>); <span class="comment">-- PandaShen</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT_WS</span>(<span class="string">"-"</span>, <span class="string">"Hello"</span>, <span class="string">"Panda"</span>, <span class="string">"Shen"</span>); <span class="comment">-- Hello-Panda-Shen</span></span><br></pre></td></tr></table></figure><h4 id="UPPER-和-LOWER"><a href="#UPPER-和-LOWER" class="headerlink" title="UPPER 和 LOWER"></a>UPPER 和 LOWER</h4><p><code>UPPER</code> 函数用于将字符串转换为大写，<code>LOWER</code> 函数用于将字符串转换为小写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UPPER</span>(<span class="string">"panda"</span>); <span class="comment">-- PANDA</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LOWER</span>(<span class="string">"PANDA"</span>); <span class="comment">-- panda</span></span><br></pre></td></tr></table></figure><h4 id="SUBSTR"><a href="#SUBSTR" class="headerlink" title="SUBSTR"></a>SUBSTR</h4><p><code>SUBSTR</code> 函数用于截取字符串，第一个参数为源字符串，第二个参数为起始的索引（从 <code>1</code> 开始），第三个参数为截取的长度，不传默认截取后面全部字符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">"panda"</span>, <span class="number">3</span>); <span class="comment">-- nda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">"panda"</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">-- nd</span></span><br></pre></td></tr></table></figure><h4 id="LEFT-和-RIGHT"><a href="#LEFT-和-RIGHT" class="headerlink" title="LEFT 和 RIGHT"></a>LEFT 和 RIGHT</h4><p><code>LEFT</code> 函数和 <code>RIGHT</code> 函数分别代表在字符串取左边或右边的规定位数，第一个参数为源字符串，第二个参数为规定的位数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">"panda12345"</span>, <span class="number">5</span>); <span class="comment">-- panda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">"panda12345"</span>, <span class="number">5</span>); <span class="comment">-- 12345</span></span><br></pre></td></tr></table></figure><h4 id="INSTR"><a href="#INSTR" class="headerlink" title="INSTR"></a>INSTR</h4><p><code>INSTR</code> 函数用于查找某个字符串在一个源字符串中的起始（第一个匹配到的）索引，第一个参数为源字符串，第二个参数为查询字符串，查询不到返回 <code>0</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSTR</span>(<span class="string">"panda"</span>, <span class="string">"a"</span>); <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSTR</span>(<span class="string">"panda"</span>, <span class="string">"x"</span>); <span class="comment">-- 0</span></span><br></pre></td></tr></table></figure><h4 id="LTRIM、RTRIM-和-TRIM"><a href="#LTRIM、RTRIM-和-TRIM" class="headerlink" title="LTRIM、RTRIM 和 TRIM"></a>LTRIM、RTRIM 和 TRIM</h4><p><code>LTRIM</code> 函数用于去掉字符串左侧空格，<code>RTRIM</code> 用于去掉字符串右侧空格，<code>TRIM</code> 用于去掉字符串两侧的空格，如果 <code>TRIM</code> 的参数将两个字符串使用 <code>FROM</code> 连接，则代表去掉右侧字符串左右两侧的左侧字符串（说的有点绕，看例子）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LTRIM</span>(<span class="string">"  panda"</span>); <span class="comment">-- panda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RTRIM</span>(<span class="string">"panda  "</span>); <span class="comment">-- panda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">"  panda  "</span>); <span class="comment">-- panda</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">"@"</span> <span class="keyword">FROM</span> <span class="string">"@@panda@@"</span>); <span class="comment">-- panda</span></span><br></pre></td></tr></table></figure><h4 id="LPAD-和-RPAD"><a href="#LPAD-和-RPAD" class="headerlink" title="LPAD 和 RPAD"></a>LPAD 和 RPAD</h4><p><code>LPAD</code> 函数和 <code>RPAD</code> 函数分别用于向源字符串的左、右按照规定字符串的长度填充定义的字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">"panda"</span>, <span class="number">10</span>, <span class="string">"@"</span>); <span class="comment">-- @@@@@panda</span></span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">"panda"</span>, <span class="number">10</span>, <span class="string">"@"</span>); <span class="comment">-- panda@@@@@</span></span><br></pre></td></tr></table></figure><h4 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE"></a>REPLACE</h4><p><code>REPLACE</code> 函数用于替换某字符串的部分字符，第一个参数为源字符串，第二个参数为被替换字符，第三个参数为替换字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">REPLACE</span>(<span class="string">"panda"</span>, <span class="string">"a"</span>, <span class="string">"e"</span>); <span class="comment">-- pende</span></span><br></pre></td></tr></table></figure><h4 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h4><p>查询 <code>id</code> 为 <code>3</code> 学生的邮箱域名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">`email`</span>, <span class="keyword">INSTR</span>(<span class="string">`email`</span>, <span class="string">"@"</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`id`</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- qq.com</span></span><br></pre></td></tr></table></figure><p>将 <code>student</code> 表中的邮箱地址全部由小写改成大写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">`email`</span> = <span class="keyword">UPPER</span>(<span class="string">`email`</span>);</span><br></pre></td></tr></table></figure><p>给 <code>student</code> 表新增一列 <code>level</code>，类型为 <code>varchar</code>，值为 <code>1-1</code>、<code>1-2</code>、<code>1-3</code>、<code>2-1</code>、<code>2-2</code> 等，按照 <code>level</code> 列值中 <code>-</code> 的前半段正序排列，后半段逆序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`level`</span>,</span><br><span class="line"><span class="keyword">SUBSTR</span>(<span class="string">`level`</span>, <span class="number">1</span>, <span class="keyword">INSTR</span>(<span class="string">`level`</span>, <span class="string">"-"</span>) - <span class="number">1</span>),</span><br><span class="line"><span class="keyword">SUBSTR</span>(<span class="string">`level`</span>, <span class="keyword">INSTR</span>(<span class="string">`level`</span>, <span class="string">"-"</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">SUBSTR</span>(<span class="string">`level`</span>, <span class="number">1</span>, <span class="keyword">INSTR</span>(<span class="string">`level`</span>, <span class="string">"-"</span>) - <span class="number">1</span>) <span class="keyword">ASC</span>,</span><br><span class="line"><span class="keyword">SUBSTR</span>(<span class="string">`level`</span>, <span class="keyword">INSTR</span>(<span class="string">`level`</span>, <span class="string">"-"</span>) + <span class="number">1</span>) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>将 <code>pandashen</code> 转换成 <code>Panda_Shen</code>，将两个单词拆开，并实现首字母大写，其他字符小写，然后用 <code>_</code> 拼接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CONCAT</span>(</span><br><span class="line">  <span class="keyword">CONCAT</span>(</span><br><span class="line">    <span class="keyword">UPPER</span>(<span class="keyword">SUBSTR</span>(<span class="keyword">SUBSTR</span>(<span class="string">"pandashen"</span>, <span class="number">1</span>, <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    <span class="keyword">SUBSTR</span>(<span class="keyword">SUBSTR</span>(<span class="string">"pandashen"</span>, <span class="number">1</span>, <span class="number">5</span>), <span class="number">2</span>)</span><br><span class="line">  ),</span><br><span class="line">  <span class="string">"_"</span>,</span><br><span class="line">  <span class="keyword">CONCAT</span>(</span><br><span class="line">    <span class="keyword">UPPER</span>(<span class="keyword">SUBSTR</span>(<span class="keyword">SUBSTR</span>(<span class="string">"pandashen"</span>, <span class="number">6</span>), <span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    <span class="keyword">SUBSTR</span>(<span class="keyword">SUBSTR</span>(<span class="string">"pandashen"</span>, <span class="number">6</span>), <span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Panda_Shen</span></span><br></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><h4 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h4><p><code>FORMAT</code> 函数用于将数字格式化，第一个参数为要格式化的数字，第二个参数为保留的小数位数，返回值为字符串，整数部分每三位使用 <code>,</code> 分隔。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">100000</span>, <span class="number">2</span>); <span class="comment">-- 100,000.00</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">100.31111</span>, <span class="number">3</span>); <span class="comment">-- 100.311</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">100.31111</span>, <span class="number">0</span>); <span class="comment">-- 100</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">423423234.65534453</span>, <span class="number">2</span>); <span class="comment">-- 423,423,234.66</span></span><br></pre></td></tr></table></figure><h4 id="CEIL-和-FLOOR"><a href="#CEIL-和-FLOOR" class="headerlink" title="CEIL 和 FLOOR"></a>CEIL 和 FLOOR</h4><p><code>CEIL</code> 函数为向上取整，<code>FLOOR</code> 函数为向下取整。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">2.4</span>); <span class="comment">-- 3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">2.4</span>); <span class="comment">-- 2</span></span><br></pre></td></tr></table></figure><h4 id="ROUND-和-TRUNCATE"><a href="#ROUND-和-TRUNCATE" class="headerlink" title="ROUND 和 TRUNCATE"></a>ROUND 和 TRUNCATE</h4><p><code>ROUND</code> 函数为四舍五入，<code>TRUNCATE</code> 函数为小数截断，第一个参数为截断的数字，第二个参数为保留的小数位数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">2.1</span>); <span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">2.5</span>); <span class="comment">-- 3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>, <span class="number">0</span>); <span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>, <span class="number">1</span>); <span class="comment">-- 1.6</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>, <span class="number">2</span>); <span class="comment">-- 1.66</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.66</span>, <span class="number">3</span>); <span class="comment">-- 1.66</span></span><br></pre></td></tr></table></figure><h4 id="POWER"><a href="#POWER" class="headerlink" title="POWER"></a>POWER</h4><p><code>POWER</code> 函数用于幂运算，第一个参数为底数，第二个参数为指数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">POWER</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">-- 8</span></span><br></pre></td></tr></table></figure><h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p><code>MOD</code> 函数用于取余运算，第一个参数为被除数，第二个参数为除数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SElECT</span> <span class="keyword">MOD</span>(<span class="number">10</span>, <span class="number">3</span>); <span class="comment">-- 1</span></span><br></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h4 id="NOW、CURDATE-和-CURTIME"><a href="#NOW、CURDATE-和-CURTIME" class="headerlink" title="NOW、CURDATE 和 CURTIME"></a>NOW、CURDATE 和 CURTIME</h4><p><code>NOW</code> 函数用于获取当前的时间，格式为 <code>yyyy-mm-dd hh:mm:ss</code>，<code>CURDATE</code> 函数用于获取当前日期，格式为 <code>yyyy-mm-dd hh:mm:ss</code>，<code>CURTIME</code> 函数用于获取当前时间，格式为 <code>hh:mm:ss</code>，返回类型均为日期格式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>(); <span class="comment">-- 2018-08-09 19:23:18</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURDATE</span>(); <span class="comment">-- 2018-08-09</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURTIME</span>(); <span class="comment">-- 19:25:31</span></span><br></pre></td></tr></table></figure><h4 id="DATE-ADD"><a href="#DATE-ADD" class="headerlink" title="DATE_ADD"></a>DATE_ADD</h4><p><code>DATE_ADD</code> 函数用于增加时间，即将时间求和，第一个参数为 <code>yyyy-mm-dd hh:mm:ss</code> 格式的时间，第二个参数为时间间隔，<code>INTERVAL</code> 关键字代表时间间隔，后面跟上数字，单位为 <code>DAY</code>、<code>MONTH</code>、<code>YEAR</code> 等，返回类型为字符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>); <span class="comment">-- 2019-08-09 19:30:15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>); <span class="comment">-- 2018-09-09 19:30:15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>); <span class="comment">-- 2019-08-09 19:30:15</span></span><br></pre></td></tr></table></figure><h4 id="STR-TO-DATE"><a href="#STR-TO-DATE" class="headerlink" title="STR_TO_DATE"></a>STR_TO_DATE</h4><p><code>STR_TO_DATE</code> 函数可以将一个日期格式的字符串转换成日期，第一个参数为日期格式的字符串，第二个参数为日期的格式描述，如 <code>%Y-%m-%d</code>，传入的日期字符串的格式与日期格式描述必须保持一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">"2018-08-09"</span>, <span class="string">"%Y-%m-%d"</span>); <span class="comment">-- 2018-08-09</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">"2018/08/09"</span>, <span class="string">"%Y/%m/%d"</span>); <span class="comment">-- 2018-08-09</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">"2018.08.09"</span>, <span class="string">"%Y.%m.%d"</span>); <span class="comment">-- 2018-08-09</span></span><br></pre></td></tr></table></figure><p>从 <code>student</code> 表中查询一个生日（列名为 <code>birthday</code>）为 <code>1982</code> 年 <code>9</code> 月 <code>3</code> 的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`birthday`</span> = <span class="keyword">STR_TO_DATE</span>(<span class="string">'09-03 1982'</span>,<span class="string">'%m-%d %Y'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果查到了黄蓉的信息</span></span><br></pre></td></tr></table></figure><p><strong>格式描述参考下表：</strong></p><table><thead><tr><th style="width:20%;text-align:center">序号</th><th style="width:20%;text-align:center">格式符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><span style="font-weight:inherit;font-style:inherit">%Y</span></td><td style="text-align:center">4 位的年份</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">%y</td><td style="text-align:center">2 位的年份</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">%m</td><td style="text-align:center">月份（01，02）</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">%c</td><td style="text-align:center">月份（1，2）</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">%d</td><td style="text-align:center">日（01，02）</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">%H</td><td style="text-align:center">小时（24 小时制）</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">%h</td><td style="text-align:center">小时（12 小时制）</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">%i</td><td style="text-align:center">分钟（00，01）</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">%s</td><td style="text-align:center">秒（00，01）</td></tr></tbody></table><h4 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT"></a>DATE_FORMAT</h4><p><code>DATE_FORMAT</code> 函数与 <code>STR_TO_DATE</code> 作用正好相反，是将一个日期类型按照格式描述转换成日期字符串，第一个参数为日期对象，第二个参数为日期的格式描述。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">STR_TO_DATE</span>(<span class="string">"2018-08-09"</span>, <span class="string">"%Y-%m-%d"</span>), <span class="string">"%Y年%m月%d日"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2018年08月09日</span></span><br></pre></td></tr></table></figure><h4 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h4><p><code>DATEDIFF</code> 函数用于计算时间间隔，两个参数均为日期对象，得到的结果为第一个与第二个的差值，单位为 “天”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(<span class="keyword">NOW</span>(), <span class="keyword">STR_TO_DATE</span>(<span class="string">"2018-08-08"</span>, <span class="string">"%Y-%m-%d"</span>)); <span class="comment">-- 1</span></span><br></pre></td></tr></table></figure><p>通过查询 <code>student</code> 的 <code>birthday</code> 列计算每个人的年龄（周岁）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="keyword">DATEDIFF</span>(<span class="keyword">NOW</span>(), <span class="string">`birthday`</span>) / <span class="number">365</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><h4 id="返回日期中指定的部分"><a href="#返回日期中指定的部分" class="headerlink" title="返回日期中指定的部分"></a>返回日期中指定的部分</h4><p>下面方法传入参数均为日期对象，返回的时间中对应的部分均为字符串。</p><ul><li>YEAR：返回年；</li><li>MONTH：返回月；</li><li>DAY：返回日；</li><li>HOUR：返回小时；</li><li>MINUTE：返回分钟；</li><li>SECOND：返回秒；</li><li>MONTHNAME：返回月份名称（英文）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 2018</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 8</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 9</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">HOUR</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 19</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 48</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SECOND</span>(<span class="keyword">NOW</span>()); <span class="comment">-- 53</span></span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(<span class="keyword">NOW</span>()); <span class="comment">-- August</span></span><br></pre></td></tr></table></figure><h4 id="综合练习-1"><a href="#综合练习-1" class="headerlink" title="综合练习"></a>综合练习</h4><p>查询 <code>student</code> 表中出生月份是 <code>9</code> 月的学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(<span class="string">`birthday`</span>) = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>查询 <code>student</code> 表中生日是今天的学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>()) = <span class="keyword">MONTH</span>(<span class="string">`birthday`</span>) <span class="keyword">AND</span> <span class="keyword">DAY</span>(<span class="keyword">NOW</span>()) = <span class="keyword">DAY</span>(<span class="string">`birthday`</span>);</span><br></pre></td></tr></table></figure><p>在 <code>student</code> 表中查询年龄超过 <code>18</code> 岁的男同学。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法 1：求生日与现在时间的差值转换成年与年龄比较</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATEDIFF</span>(<span class="keyword">NOW</span>(), <span class="string">`birthday`</span>) / <span class="number">365</span> &gt; <span class="number">18</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法 2：给生日加上 18 年看看是否大于今天的时间</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATE_ADD</span>(<span class="string">`birthday`</span>, <span class="built_in">INTERVAL</span> <span class="number">18</span> <span class="keyword">YEAR</span>) &lt; <span class="keyword">NOW</span>();</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法 3：获取今天时间的年份和生日的年份做差，看是否大于 18</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) - <span class="keyword">YEAR</span>(<span class="string">`birthday`</span>) &gt; <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h3 id="数据库辅助函数"><a href="#数据库辅助函数" class="headerlink" title="数据库辅助函数"></a>数据库辅助函数</h3><h4 id="CONNECTION-ID"><a href="#CONNECTION-ID" class="headerlink" title="CONNECTION_ID"></a>CONNECTION_ID</h4><p>连接每个数据库都会分配对应的连接号，我们称为连接 ID，<code>CONNECTION_ID</code> 函数可以帮我们获取连接 ID。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONNECTION_ID(); <span class="comment">-- 10</span></span><br></pre></td></tr></table></figure><h4 id="DATABASE"><a href="#DATABASE" class="headerlink" title="DATABASE"></a>DATABASE</h4><p><code>DATABASE</code> 函数用于查看当前的连接的数据库，返回数据库名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(); <span class="comment">-- school</span></span><br></pre></td></tr></table></figure><h4 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION"></a>VERSION</h4><p><code>VERSION</code> 函数用来查看当前 MySQL 数据库的版本号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>(); <span class="comment">-- 5.5.61</span></span><br></pre></td></tr></table></figure><h4 id="LAST-INSERT-ID"><a href="#LAST-INSERT-ID" class="headerlink" title="LAST_INSERT_ID"></a>LAST_INSERT_ID</h4><p><code>LAST_INSERT_ID</code> 可以获取上次向表中（任意表）插入数据时，插入数据的 <code>id</code> 号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">LAST_INSERT_ID</span>(); <span class="comment">-- 0</span></span><br></pre></td></tr></table></figure><h4 id="USER-和-PASSWORD"><a href="#USER-和-PASSWORD" class="headerlink" title="USER 和 PASSWORD"></a>USER 和 PASSWORD</h4><p><code>USER</code> 用于查询当前数据库登录的用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(); <span class="comment">-- root@</span></span><br></pre></td></tr></table></figure><p>在 MySQL 数据库中存在一张表存放着 MySQL 当前所有的用户，可以通过下面命令查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure><p>通过查询结果可以看出密码的位置存储的是密文，如果要修改密码需要将设置的密码转换成密文进行存储，<code>PASSWORD</code> 函数就是来做这件事的，修改密码命令如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">FROM</span> mysql.user</span><br><span class="line"><span class="keyword">SET</span> <span class="string">`password`</span> = <span class="keyword">PASSWORD</span>(<span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p><code>MD5</code> 可以将传入的字符串进行一个 <code>MD5</code> 散列算法的转换并输出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MD5</span>(<span class="string">"panda"</span>); <span class="comment">-- ce61649168c4550c2f7acab92354dc6e</span></span><br></pre></td></tr></table></figure><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><h4 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h4><p><code>IF</code> 函数可以根据传入的判断条件在两个结果中进行选择输出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="number">1</span> &gt; <span class="number">2</span>, <span class="string">"yes"</span>, <span class="string">"no"</span>); <span class="comment">-- no</span></span><br></pre></td></tr></table></figure><h4 id="CASE、WHEN、THEN、ELSE-和-END"><a href="#CASE、WHEN、THEN、ELSE-和-END" class="headerlink" title="CASE、WHEN、THEN、ELSE 和 END"></a>CASE、WHEN、THEN、ELSE 和 END</h4><p><code>CASE</code>、<code>WHEN</code>、<code>THEN</code>、<code>ELSE</code> 和 <code>END</code> 共同组成了一个流程控制函数，可以代替多个 <code>IF</code>，<code>CASE</code> 为条件判断起始关键字，<code>WHEN</code> 为判断条件关键字（可以有多个），<code>THEN</code> 为输出结果关键字，<code>ELSE</code> 为默认输出关键字，<code>END</code> 为流程结束关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`grade`</span>,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">`grade`</span> &gt; <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">"优"</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">`grade`</span> &gt; <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">"良"</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">`grade`</span> &gt; <span class="number">70</span> <span class="keyword">THEN</span> <span class="string">"中"</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">`grade`</span> &gt; <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">"及格"</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">"不及格"</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>自定义函数是对 MySQL 的扩展，使用方式和内置函数相同；</li><li>函数必须要有参数和返回值，函数可以接收任意类型的值和参数，返回值只能有一个；</li><li>函数体由合法的 SQL 语句组成，可以包含声明、循环和流程控制，也可以是 <code>SELECT</code> 或 <code>INSERT</code> 语句，如果函数体是复合结构（多条语句）要用 <code>BEGIN...END</code>。</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> FUNC_NAME <span class="keyword">RETURNS</span> &#123;<span class="keyword">String</span>|<span class="built_in">Integer</span>&#125;</span><br><span class="line"><span class="keyword">BODY</span></span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">VALUE</span></span><br></pre></td></tr></table></figure><p><code>CREATE FUNCTION</code> 为创建函数关键字，<code>FUNC_NAME</code> 为函数的名字，<code>RETURNS</code> 为返回类型关键字，“&#123; &#125;” 中的内容为返回值类型，如 <code>varchar</code> 等，<code>BODY</code> 代表函数体，<code>RETURN VALUE</code> 代表返回值。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>写一个自定义函数用于获取中文格式的当前时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数 ZHNOW</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> ZHNOW() <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(), <span class="string">"%Y年%m月%d日"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 ZHNOW</span></span><br><span class="line"><span class="keyword">SELECT</span> ZHNOW(); <span class="comment">-- 2018年08月10日</span></span><br></pre></td></tr></table></figure><p>实现一个自定义函数对两个数字进行相乘运算并将结果返回。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数 MYPRODUCT，参数为两个数字</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> MYPRODUCT(n <span class="built_in">INT</span>, m <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">RETURN</span> n * m;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 MYPRODUCT</span></span><br><span class="line"><span class="keyword">SELECT</span> MYPRODUCT(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">-- 10</span></span><br></pre></td></tr></table></figure><p>针对上面的 <code>course</code> 学科表，写一个自定义函数用来增加学科并返回增加数据的 <code>id</code> 值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数 ADD_COURSE，参数为添加课程的名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> ADD_COURSE(<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>)) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> (<span class="string">`name`</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">name</span>);</span><br><span class="line">RETURN LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 ADD_COURSE</span></span><br><span class="line"><span class="keyword">SELECT</span> ADD_COURSE(<span class="string">"体育"</span>); <span class="comment">-- 4</span></span><br></pre></td></tr></table></figure><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><blockquote class="pullquote info"><p>上一节中的函数都是普通函数，多用于操作表达式后返回结果，而聚合函数更多是对一组值进行计算，并返回计算后的值，一般用来统计数据，使用难度要大于普通函数。</p></blockquote><h3 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h3><p><code>SUM</code> 函数用于累加所有行的值。</p><p>还是以上面的 <code>score</code> 表为例，我们取出 <code>student_id</code> 值为 <code>1</code> 的学生全部科目的总成绩。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`student_id`</span> = <span class="number">1</span>; <span class="comment">-- 260</span></span><br></pre></td></tr></table></figure><p>其实上面的操作是分为两部分进行，首先先查出 <code>student_id</code> 为 <code>1</code> 的所有学科的成绩，在对这些成绩进行求和计算后返回。</p><h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h3><p><code>AVG</code> 函数用于计算所有行的平均值。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>3</code> 的学生全部科目成绩的平均值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`student_id`</span> = <span class="number">3</span>; <span class="comment">-- 80</span></span><br></pre></td></tr></table></figure><h3 id="MAX-和-MIN"><a href="#MAX-和-MIN" class="headerlink" title="MAX 和 MIN"></a>MAX 和 MIN</h3><p><code>MAX</code> 和 <code>MIN</code> 分别用于计算所有行的最大值和最小值。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>2</code> 的学生全部科目成绩的最大值和最小值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="string">`grade`</span>), <span class="keyword">MIN</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`student_id`</span> = <span class="number">2</span>; <span class="comment">-- 100 40</span></span><br></pre></td></tr></table></figure><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><p><code>COUNT</code> 按照某一列统计所有行的总条数，如果参照的列值为 <code>null</code> 则不统计在内。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>1</code> 的学生成绩总数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`student_id`</span> = <span class="number">1</span>; <span class="comment">-- 3</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL-语句之分组聚合"><a href="#SQL-语句之分组聚合" class="headerlink" title="SQL 语句之分组聚合"></a>SQL 语句之分组聚合</h2><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组查询就是按某一列或某几列的值进行分组，相同的值分为一组，然后可以对组内使用聚合函数分别进行统计。</p><p><strong>以 <code>score</code> 表为例，分组表示图如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/group.jpg" alt="成绩表分组数据" title>                </div>                <div class="image-caption">成绩表分组数据</div>            </figure><p><br></p><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名, 查询表达式</span><br><span class="line"><span class="keyword">FROM</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组字段&gt;</span><br></pre></td></tr></table></figure><p><code>GROUP BY</code> 关键字用于对筛选后的结果进行分组。</p><p><strong>例子：</strong></p><p>统计 <code>score</code> 表中每位同学的平均成绩（单列分组，对 <code>student_id</code> 进行分组）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`student_id`</span>, <span class="keyword">AVG</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`student_id`</span>;</span><br></pre></td></tr></table></figure><p>统计 <code>score</code> 表中每门课程的最高分（单列分组，对 <code>course_id</code> 进行分组），并按照分数从低到高排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`course_id`</span>, <span class="keyword">MAX</span>(<span class="string">`grade`</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`course_id`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`grade`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>统计 <code>student</code> 表中各省男女同学人数（多列分组，按照 <code>province</code> 和 <code>gender</code> 进行分组）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`province`</span>, <span class="string">`gender`</span>, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`province`</span>, <span class="string">`gender`</span>;</span><br></pre></td></tr></table></figure><p><code>COUNT</code> 中的 <code>*</code> 代表任意一列。</p><h3 id="分组筛选"><a href="#分组筛选" class="headerlink" title="分组筛选"></a>分组筛选</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名, 查询表达式</span><br><span class="line"><span class="keyword">FROM</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;条件&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组字段&gt;</span><br><span class="line"><span class="keyword">HAVING</span> 分组后的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 [<span class="keyword">ASC</span>, <span class="keyword">DESC</span>]</span><br><span class="line"><span class="keyword">LIMIT</span> 偏移量, 条数</span><br></pre></td></tr></table></figure><p><code>WHERE</code> 用于过滤掉不符合条件的记录，<code>HAVING</code> 用于过滤分组后的记录。</p><blockquote class="pullquote warning"><p><em><strong>注意：上面查询的关键字不一定每条查询语句都要有，但是如果有其中的某些关键字，一定要按照上面的顺序进行。</strong></em></p></blockquote><p><strong>例子：</strong></p><p>统计 <code>student</code> 表中学生人数多于一个的省份。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`province`</span>, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`province`</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>统计 <code>score</code> 表中不及格次数大于 <code>1</code> 的学生按逆序排列并取前 <code>3</code> 条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`student_id`</span>, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`grade`</span> &lt; <span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`student_id`</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="string">`grade`</span>) &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(<span class="string">`grade`</span>) <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL-语句之子查询"><a href="#SQL-语句之子查询" class="headerlink" title="SQL 语句之子查询"></a>SQL 语句之子查询</h2><p><strong>子查询的注意点：</strong></p><ul><li>子查询是出现在其他 SQL 语句中的 <code>SELECT</code> 语句；</li><li>子查询嵌套在查询内部，且必须写在圆括号中，外层可以是 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>SET</code> 等；</li><li>子查询可以包含多个关键字或条件；</li><li>子查询可以返回常量、一行数据、一列数据或其它子查询（返回多行数据需使用其他关键字处理）。</li></ul><h3 id="比较运算符连接子查询"><a href="#比较运算符连接子查询" class="headerlink" title="比较运算符连接子查询"></a>比较运算符连接子查询</h3><p>在查询通过 <code>WHERE</code> 进行条件筛选时，可以使用比较运算符连接子查询。</p><p>查询年龄大于平均年龄的学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) - <span class="keyword">YEAR</span>(<span class="string">`birthday`</span>) &gt; (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) - <span class="keyword">YEAR</span>(<span class="string">`birthday`</span>))</span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="IN-和-NOT-IN"><a href="#IN-和-NOT-IN" class="headerlink" title="IN 和 NOT IN"></a>IN 和 NOT IN</h3><p>当查询一张表的数据需要另一张表中的数据作为筛选条件时，可以在查询时通过 <code>IN</code> 和 <code>NOT IN</code> 关键字连接子查询。</p><p>查询 <code>student</code> 有不及格成绩的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`id`</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="string">`student_id`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line">  <span class="keyword">WHERE</span> <span class="string">`grade`</span> &lt; <span class="number">60</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果查到了黄蓉</span></span><br></pre></td></tr></table></figure><p>上面例子查到了 “黄蓉” 同学的信息，如果将 <code>IN</code> 修改为 <code>NOT IN</code> 则会查询到除 “黄蓉” 以外其他同学的信息。</p><p>查询 <code>student</code> 表中在 <code>score</code> 表中有成绩的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> student.id <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="string">`student_id`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="EXISTS-和-NOT-EXISTS"><a href="#EXISTS-和-NOT-EXISTS" class="headerlink" title="EXISTS 和 NOT EXISTS"></a>EXISTS 和 NOT EXISTS</h3><p><code>EXISTS</code> 和 <code>NOT EXISTS</code> 关键字用于连接子查询，代表 “存在” 或 “不存在” 的意思，接收的子查询返回为数据为布尔值。</p><p>拿上面查询 <code>student</code> 表在 <code>score</code> 表中有成绩学生信息的例子，使用 <code>EXISTS</code> 实现查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`student_id`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line">  <span class="keyword">WHERE</span> score.student_id = student.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><em><strong><code>IN</code>、<code>NOT IN</code> 与 <code>EXISTS</code>、<code>NOT EXISTS</code> 比较，后者的性能更高，查询速度更快，因为判断是在子查询内部，<code>EXISTS</code>、<code>NOT EXISTS</code> 只需要判断布尔值就可以了，<code>IN</code>、<code>NOT IN</code> 在子查询返回数据的基础上还要再次过滤。</strong></em></p></blockquote><h3 id="ALL、SOME-和-ANY"><a href="#ALL、SOME-和-ANY" class="headerlink" title="ALL、SOME 和 ANY"></a>ALL、SOME 和 ANY</h3><p>当子查询返回了多条数据的时候，可以使用 <code>ALL</code>、<code>SOME</code> 和 <code>ANY</code> 关键字作为比较运算符和子查询之间的连接。</p><ul><li><code>ALL</code> 关键字代表全部，即查询的数据筛选条件要去和所有子查询返回的比较并都满足；</li><li><code>SOME</code> 关键字代表某些，查询数据筛选条件只要满足子查询返回数据的某些条即可；</li><li><code>ANY</code> 关键字代表任何一个，查询数据的筛选条件只要满足子查询返回数据的任意一条即可。</li></ul><p>查询 <code>student</code> 表中年龄大于等于所有人的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`age`</span> &gt;= <span class="keyword">ALL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`age`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果查到了欧阳锋</span></span><br></pre></td></tr></table></figure><p>查询 <code>student</code> 表中年龄大于某些人的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`age`</span> &gt; <span class="keyword">SOME</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`age`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果查到除杨过以外的所有人（因为杨过年龄最小）</span></span><br></pre></td></tr></table></figure><p>查询 <code>student</code> 表中年龄大于任意一个人的学生信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`age`</span> &gt; <span class="keyword">ANY</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`age`</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回结果同 SOME 没区别</span></span><br></pre></td></tr></table></figure><h2 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h2><h3 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h3><p><strong>在 MySQL 中的表连接类型：</strong></p><ul><li><code>INNER JOIN</code>：内连接，代表取两张关联表的交集，可以用 <code>JOIN</code> 关键字代替；</li><li><code>LEFT</code>：左外连接，代表取两张表的交集后再和左侧表求并集，即包含左侧表全部数据；</li><li><code>RIGHT</code>：右外连接，代表取两张表的交际后再和右侧表求并集，即包含右侧表全部数据。</li></ul><p><strong>三种连接类型表示如下图：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/table-join.jpg" alt="表连接类型韦恩图" title>                </div>                <div class="image-caption">表连接类型韦恩图</div>            </figure><p><br></p><h3 id="连接条件-ON"><a href="#连接条件-ON" class="headerlink" title="连接条件 ON"></a>连接条件 ON</h3><p><code>ON</code> 关键字用来设定表的连接条件，也可以使用 <code>WHERE</code> 对结果进行过滤的方式来代替。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用内连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`score`</span> <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/inner-join-result.png" alt="内连接查询结果" title>                </div>                <div class="image-caption">内连接查询结果</div>            </figure><p><br></p><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用左外连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`score`</span> <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/left-join-result.png" alt="左外连接查询结果" title>                </div>                <div class="image-caption">左外连接查询结果</div>            </figure><p><br></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用右外连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="string">`score`</span> <span class="keyword">ON</span> student.id = score.student_id;</span><br></pre></td></tr></table></figure><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/08/09/20180809115245/right-join-result.png" alt="右外连接查询结果" title>                </div>                <div class="image-caption">右外连接查询结果</div>            </figure><p><br></p><h4 id="多表连接案例"><a href="#多表连接案例" class="headerlink" title="多表连接案例"></a>多表连接案例</h4><p>连接 <code>student</code>、<code>score</code> 和 <code>course</code> 三张表，分别查询学生姓名、学科和分数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student.name, course.name, score.grade</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`score`</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`student`</span> <span class="keyword">ON</span> student.id = score.student_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`course`</span> <span class="keyword">ON</span> course.id = score.course_id;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>到此 MySQL 系列文章的第二篇就结束了，本篇的大部分都是和操作数据库的 SQl 语句相关的知识点，里面涵盖了基本的增、删、改、查以及函数、聚合函数的应用等，如果记不住的话（当然我也记不住，只是负责替大家和我自己整理）建议收藏，在使用时随时查阅，这一篇的内容对于前端而言，可以说基本够用了，如果你对数据库还有兴趣，想了解关于表的设计的相关思想，期待我的下一篇 <a href="https://www.overtaking.top/2018/08/14/20180814131241/" target="_blank">《MySQL —— 简单聊一聊数据库设计》</a> 更新吧。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/08/09/20180809115245/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
