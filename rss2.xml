<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Shen&#39;s Blog</title>
    <link>https://www.overtaking.top/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 24 Jun 2019 03:37:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>React 基础篇 —— React Hooks</title>
      <link>https://www.overtaking.top/2019/05/07/20190507155411/</link>
      <guid>https://www.overtaking.top/2019/05/07/20190507155411/</guid>
      <pubDate>Tue, 07 May 2019 07:54:11 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/05/07/20190507155411/react-hooks.jpeg&quot; title=&quot;React Hooks&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-Hooks-简介&quot;&gt;&lt;a href=&quot;#React-Hooks-简介&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 简介&quot;&gt;&lt;/a&gt;React Hooks 简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;code&gt;React Hooks&lt;/code&gt; 是 &lt;code&gt;16.8&lt;/code&gt; 版本中正式加入的特性，配合函数组件使用，在没有 &lt;code&gt;Hooks&lt;/code&gt; 之前，函数组件使用场景非常有限，只适合编写纯展示性的 &lt;code&gt;UI&lt;/code&gt; 组件，其余复杂的场景不得不使用类组件，而 &lt;code&gt;Hooks&lt;/code&gt; 的主要作用是在函数组件中使用原本所不具备的 &lt;code&gt;React&lt;/code&gt; 特性。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/05/07/20190507155411/react-hooks.jpeg" title="React Hooks"><p><br></p><h2 id="React-Hooks-简介"><a href="#React-Hooks-简介" class="headerlink" title="React Hooks 简介"></a>React Hooks 简介</h2><blockquote class="pullquote default"><p><code>React Hooks</code> 是 <code>16.8</code> 版本中正式加入的特性，配合函数组件使用，在没有 <code>Hooks</code> 之前，函数组件使用场景非常有限，只适合编写纯展示性的 <code>UI</code> 组件，其余复杂的场景不得不使用类组件，而 <code>Hooks</code> 的主要作用是在函数组件中使用原本所不具备的 <code>React</code> 特性。</p></blockquote><a id="more"></a><h2 id="React-Hooks-产生的动机"><a href="#React-Hooks-产生的动机" class="headerlink" title="React Hooks 产生的动机"></a>React Hooks 产生的动机</h2><p>在业务开发中，数据主要存在两种形式，业务数据和 <code>UI</code> 数据，我们需要将这两种数据区分开，而有时数据又在组件之间存在共用关系，情况稍微复杂，参数传递的方式就无法满足需求，于是就会有状态管理进入到项目中（<code>Redux</code>、<code>Mobx</code>）等，会增加开发者的学习成本和项目的维护成本。</p><p>使用 <code>React</code> 的开发者都知道，<code>React</code> 主张组件化，就是把业务页面拆分成多个组件进行组合、嵌套、渲染。为了保证项目质量，开发者会花费大量精力在项目的模块化、状态数据最小化以及功能解耦上，而一部分组件会因为数据状态的共享耦合在一起，这时需要使用高阶组件、属性渲染、渲染回调等更高级的 <code>React</code> 特性去解耦，但是会增加代码的复杂程度、降低代码的可读性，在渲染时也会增加 <code>DOM</code> 的层级。</p><p>上面这些实际问题促成了 <code>React Hooks</code> 的诞生，而在有 <code>Hooks</code> 后官方也越来越推荐使用函数组件，主要原因总结如下。</p><ul><li>为了状态相关逻辑的提取和复用；</li><li>解决复杂组件代码变得难以理解的问题；</li><li>解决类组件带给开发者一些容易混淆的点，比如 <code>this</code> 指向问题；</li><li>由于 <code>JS</code> 解释器在解释 <code>class</code> 关键字时的性能问题，使用函数组件代替。</li></ul><blockquote class="pullquote info"><p><code>React</code> 没有重大变化，完全兼容类组件，可以让开发者不必完全重写现有代码，而是在后续开发中逐步尝试使用 <code>Hooks</code>。</p></blockquote><h2 id="React-Hooks-分类"><a href="#React-Hooks-分类" class="headerlink" title="React Hooks 分类"></a>React Hooks 分类</h2><p><strong><code>React</code> 官方主要给 <code>Hooks</code> 分为两大类：</strong></p><ul><li>基础 <code>Hooks API</code>：<code>useState</code>、<code>useEffect</code>、<code>useContext</code>；</li><li>其他 <code>Hooks API</code>：<code>useReducer</code>、<code>useCallback</code>、<code>useImperativeHandle</code>、<code>useMemo</code>、<code>useRef</code>、<code>useLayoutEffect</code>、<code>useDebugValue</code>。</li></ul><h2 id="React-Hooks-使用规则"><a href="#React-Hooks-使用规则" class="headerlink" title="React Hooks 使用规则"></a>React Hooks 使用规则</h2><p>为了保证 <code>Hooks</code> 在使用时不会出现不可预测的问题，官方制定了一定要遵循的两条使用规则（非建议），在此提前声明。</p><blockquote class="pullquote warning"><p><em><strong>1、只在函数组件内部最顶层调用 <code>Hook</code>，不要在循环、条件判断或者嵌套函数中调用；</strong></em><br><em><strong>2、只能在函数组件中调用 <code>Hook</code>（自定义 <code>Hook</code> 中可以调用 <code>Hook</code>），不要在其他 <code>JavaScript</code> 函数中调用。</strong></em></p></blockquote><h2 id="React-Hooks-API"><a href="#React-Hooks-API" class="headerlink" title="React Hooks API"></a>React Hooks API</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 方法用于在函数组件内部实现组件的状态管理，可以起到类组件中 <code>state</code> 一样的作用。</p><figure class="highlight jsx"><figcaption><span>类组件实现的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Components &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Components</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click!</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面是一个类组件实现的计数器，当前计数器的值在类组件的 <code>state</code> 中进行管理。</p><figure class="highlight jsx"><figcaption><span>Hooks 实现的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>使用 <code>React Hooks</code> 的 <code>useState</code> 实现的计数器和类组件实现的功能完全相同，从 <code>useState</code> 实现的代码可以看出 <code>useState</code> 是一个函数，传入的参数是状态的初始值，返回值是一个数组，数组的第一项是当前状态的值，数组的第二项是改变状态值的方法。</p><figure class="highlight jsx"><figcaption><span>实现每次加 2 的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> countAction = <span class="function">(<span class="params">preCount, n</span>) =&gt;</span> preCount + n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(countAction(count, 2))&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面计数器功能的实现逻辑比较简单，下面来看一个类组件实现的稍微复杂的案例，然后再通过 <code>useState</code> 进行重构。</p><figure class="highlight jsx"><figcaption><span>类组件实现的模态切换功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Modal &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Toggle 组件专门提供切换状态和切换方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 on 的值</span></span><br><span class="line">    <span class="keyword">this</span>.state.on = <span class="keyword">this</span>.props.initial;</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123; <span class="attr">on</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  toggle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">on</span>: !<span class="keyword">this</span>.state.on &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.on, <span class="keyword">this</span>.toggle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Toggle initial=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        (on, toggle) =&gt; (</span><br><span class="line">          &lt;Fragment&gt;</span><br><span class="line">            &lt;Button type=<span class="string">"primary"</span> onClick=&#123;toggle&#125;&gt;</span><br><span class="line">              Open Model</span><br><span class="line">            &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Modal visible=&#123;on&#125; onCancel=&#123;toggle&#125;/</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面代码中的类组件 <code>Toggle</code> 主要的作用就是管理模态框显示的状态和对状态的控制，选择使用 <code>children</code> 并传入一个函数，目的是函数可以在类组件内部通过 <code>children</code> 属性调用，并将 <code>Toggle</code> 内部的状态和方法作为参数传入，进而将功能提供给函数组件，这种高级的用法叫做 “渲染回调”，可以成功的将组件进行解耦，但是这样的方式缺点也显而易见，就是代码的逻辑抽象，可读性差，下面来使用 <code>useState</code> 进行重构。</p><figure class="highlight jsx"><figcaption><span>useState 重构切换模态的功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Modal &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ on, setOn ] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Button type=<span class="string">"primary"</span> onClick=&#123;() =&gt; setOn(<span class="literal">true</span>)&#125;&gt;</span><br><span class="line">        Open Model</span><br><span class="line">      &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Modal visible=&#123;on&#125; onCancel=&#123;() =&gt; setOn(false)&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong>因为 <code>React Hooks</code> 的 <code>useState</code> 让函数组件具备了管理组件状态的能力，所以不需要单独实现 <code>Toggle</code> 组件，代码变得更精简、清晰，更函数式编程，更新粒度更细。</strong></p></blockquote><p><code>useState</code> 解构出的用来更改状态的函数传入的参数支持函数类型，传入函数的参数为上一次的状态值，也就是说当更新状态的新值依赖于上一次的值时，会通过这样的方式解决。</p><figure class="highlight jsx"><figcaption><span>当 useState 更新的状态依赖于上一次的值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prev =&gt; prev + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, root);</span><br></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>正如 <code>useEffect</code> 钩子的命名一样，是在函数组件中专门用来处理副作用的，这个副作用是指某些操作使用了函数组件作用域外的变量，而且这个操作的结果会影响函数组件外部的环境。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次渲染后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初次渲染后执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Execute once'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 count 更改时才执行</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count changed'</span>);</span><br><span class="line">  &#125;, [ count ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count)&#125;&gt;</span><br><span class="line">        Click no change!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面案例是通过 <code>useState</code> 一节中的计数器案例改编，我们增加了每次点击计数器将计数器状态同步到页面标题上的功能，并使用 <code>useEffect</code> 实现，<code>useEffect</code> 函数的参数为回调函数，并在每次页面渲染之后执行（包含首次渲染和更新渲染）。</p><blockquote class="pullquote primary"><p><strong>可以使用 <code>useEffect</code> 替代类组件的生命周期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</strong></p></blockquote><p><code>useEffect</code> 还支持传入第二个参数，类型为数组，数组的值为被监听的状态（被 <code>useState</code> 监听），此时 <code>useEffect</code> 内部会做一次比较，数组中变量的值没发生变化时，传入对应 <code>useEffect</code> 的回调不会执行，当传入 <code>useEffect</code> 的数组为空时，则传入的回调只在函数组件首次渲染时执行一次，作用相当于类组件的声明周期 <code>componentDidMount</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Hooks 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HooksCom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times (hooks)`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 类组件</span></span><br><span class="line"><span class="regexp">class ClassCom extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123; count: 1 &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    document.title = `You clicked $&#123;this.state.count&#125; times (class)`;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidUpdate() &#123;</span></span><br><span class="line"><span class="regexp">    document.title = `You clicked $&#123;this.state.count&#125; times (class)`;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;)&#125;&gt;Click!<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Fragment&gt;</span></span><br><span class="line"><span class="regexp">      &lt;HooksCom /</span>&gt;</span><br><span class="line">      &lt;ClassCom /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>通过上面案例，对于使用了 <code>componentDidMount</code> 生命周期的类组件和使用了 <code>useEffect</code> 的函数组件对于页面标题更改的对比，<code>useEffect</code> 的执行会晚于 <code>componentDidMount</code>。</strong></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChatAPI = &#123;</span><br><span class="line">  handle: <span class="literal">null</span>,</span><br><span class="line">  isOnline: <span class="literal">false</span>,</span><br><span class="line">  login() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOnline = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.handle &amp;&amp; <span class="keyword">this</span>.handle(&#123; <span class="attr">isOnline</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  logout() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isOnline = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.handle &amp;&amp; <span class="keyword">this</span>.handle(&#123; <span class="attr">isOnline</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  subscribeToFriendStatus(id, handle) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`订阅好友：<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.handle = handle;</span><br><span class="line">  &#125;,</span><br><span class="line">  unsubscribeToFriendStatus(id, handle) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`清理好友：<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.handle = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于渲染好友在线状态的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制好友在线的变量和方法</span></span><br><span class="line">  <span class="keyword">const</span> [ isOnline, setIsOnline ] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置好友状态的函数</span></span><br><span class="line">  <span class="keyword">const</span> handleStatusChange = <span class="function">(<span class="params">status</span>) =&gt;</span> setIsOnline(status.isOnline);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 订阅好友状态</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 清除好友状态</span></span><br><span class="line">      ChatAPI.unsubscribeToFriendStatus(props.friend.id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [ props.friend.id ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;计数器：&#123;props.friend.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;br/</span>&gt;</span><br><span class="line">      &lt;span&gt;</span><br><span class="line">        登录状态：</span><br><span class="line">        &#123;</span><br><span class="line">          isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ show, setShow ] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [ userId, setUserId ] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;用户ID：&#123;userId&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;br/</span>&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        show &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">FriendStatus</span> <span class="attr">friend</span>=<span class="string">&#123;&#123;</span> <span class="attr">id:</span> <span class="attr">userId</span>, <span class="attr">name:</span> '<span class="attr">Hello</span>' &#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(!show)&#125;&gt;显示/关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setUserId(userId + 1)&#125;&gt;增加用户ID<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;增加计数器<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;ChatAPI.login.bind(ChatAPI)&#125;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;ChatAPI.logout.bind(ChatAPI)&#125;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面是一个覆盖比较全的 <code>useEffect</code> 案例，用来实现组件 <code>FriendStatus</code> 内对用户的订阅和取消订阅，其中 <code>App</code> 组件中的 <code>show</code> 状态用来控制 <code>FriendStatus</code> 组件是否渲染，<code>显示/关闭</code> 按钮用来控制 <code>show</code> 的值，<code>FriendStatus</code> 默认登录状态显示 <code>Loading...</code>，<code>登录</code> 和 <code>退出</code> 按钮用来空登录状态的显示（<code>Online</code> 或 <code>Offline</code>），<code>增加用户ID</code> 和 <code>增加计数器</code> 按钮分别用来更改当前用户 <code>ID</code> 和计数器的值，计数器的 <code>count</code> 属性和 <code>setUserId</code> 通过 <code>Render Props</code> 的方式传递给 <code>FriendStatus</code>，我们将使用到的方法统一都放在 <code>ChatAPI</code> 对象上。</p><p>默认渲染 <code>FriendStatus</code> 在控制台发现 <code>useEffect</code> 执行了，并订阅了当前传入的用户，而点击 <code>显示/关闭</code> 按钮时发现取消订阅了用户，这说明组件卸载之前执行了 <code>useEffect</code> 回调内部返回的函数，点击增加计数器按钮，<code>FriendStatus</code> 组件发生了重新渲染，而 <code>useEffect</code> 内部并没有再次对用户进行订阅，原因是指定了 <code>useEffect</code> 的第二个参数，并将用户的 <code>ID</code> 作为元素存入数组内，也就是用户 <code>ID</code> 不发生变化的时候就不会重新执行这个 <code>useEffect</code> 去订阅用户，当点击 <code>增加用户ID</code> 按钮时，控制台首先取消订阅了上一个用户，又订阅了新的用户，这说明 <code>FriendStatus</code> 组件重新渲染时，如果需要执行 <code>useEffect</code>，则会优先执行回调内返回的取消订阅的函数。</p><blockquote class="pullquote default"><p><strong>如果在 <code>useEffect</code> 方法传入的回调中返回一个函数，这个函数会在组件卸载之前执行，或重新渲染需时要执行对应的 <code>useEffect</code> 时优先执行。</strong></p></blockquote><figure class="highlight jsx"><figcaption><span>频繁更新未被监听的变量不变</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的案例是一个状态频繁变化的组件，但是我们给 <code>useEffect</code> 传入的第二个参数为空数组，这就会产生一个 <code>Bug</code>，由于 <code>useEffect</code> 默认只执行一次，并没有执行清除定时器的返回函数，所以导致取到的依然是上一次的状态值，还记得上面一节 <code>useState</code> 中提到使用上一次的状态去更新状态，这里我们可以通过这种方式修复这个 <code>Bug</code>。</p><figure class="highlight jsx"><figcaption><span>解决频繁更新未被监听变量不变的问题</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">prev</span> =&gt;</span> prev + <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>所以说在有些时候，对于 <code>useEffect</code> 第二个参数传入 <code>[ ]</code> 的行为不是绝对安全的，并且不建议这样使用。</strong></p></blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p><code>useReducer</code> 是 <code>useState</code> 的替代方案，用来处理复杂的 <code>state</code> 更新，看到这个名字大家可能会想到 <code>Redux</code> 中的 <code>reducer</code>，其实 <code>useReducer</code> 就是 <code>React Hooks</code> 中用来替代 <code>Redux</code> 解决问题的，让我们从此不需要 <code>Redux</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始 state</span></span><br><span class="line"><span class="keyword">const</span> initalCountState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.payload &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始 state 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initalCountState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>: initalCountState.count + <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initalCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalCountState, init);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      count: &#123; state.count &#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: initalCount &#125;)&#125;</span><br><span class="line">      &gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Counter initalCount=&#123;0&#125; /</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p><code>useReducer</code> 有三个参数，第一个参数为 <code>reducer</code> 函数（根据 <code>action</code> 的类型匹配新的 <code>state</code> 值），第二个参数为监听状态对象 <code>state</code> 的初始值，第三个参数也是一个函数，参数为初始的 <code>state</code>，作用是输出一个新的 <code>state</code> 替换初始的 <code>state</code>，只在最初执行一次。</p><p><code>useReducer</code> 的返回值为数组，数组第一项是监听的 <code>state</code> 对象，第二项是用来触发 <code>state</code> 的函数，参数为 <code>action</code>。</p><figure class="highlight jsx"><figcaption><span>useReducer 不传第三个参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.payload &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initalCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalCount);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      count: &#123; state.count &#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;</span><br><span class="line">          type: <span class="string">'reset'</span>,</span><br><span class="line">          payload: initalCount.count</span><br><span class="line">        &#125;)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Counter initalCount=&#123;&#123; count: 0 &#125;&#125; /</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>这个案例跟之前的稍有差别，去掉了 <code>useReducer</code> 的第三个参数，并将 <code>Counter</code> 组件的入参 <code>initalCount</code> 作为了初始 <code>state</code>。</p><blockquote class="pullquote success"><p><strong>使用 <code>React</code> 进行过项目开发应该都是用过 <code>Redux</code> 和 <code>Mobx</code> 之类的状态管理工具，但其实他们并不是专门针对 <code>React</code> 所设计的，里面都蕴含了一些关于状态管理的编程思想和自己独立的逻辑，也可以在其他框架技术栈中使用，只是和 <code>React</code> 搭配使用时更舒适，而 <code>React hooks</code> 中提供了官方自身的状态管理解决方案，避免依赖第三方库，所以 <code>Facebook</code> 挖来了 <code>Redux</code> 的作者开发了 <code>React hooks</code> 中状态管理相关的 <code>API</code>。</strong></p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>想了解 <code>useContext</code> 首先要了解 <code>context API</code>，即 <code>React.createContext</code> 方法，执行后返回一个对象，其中包含两个属性分别为 <code>Provider</code> 和 <code>Consumer</code>，都为组件，<code>Provider</code> 用于包裹提供状态的容器组件，<code>Consumer</code> 用于包裹消费这个状态的组件，更详细的用法不在这里过多赘述，可以查看 <a href="https://react.docschina.org/docs/context.html" target="_blank">React 官方文档</a>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, setCount &#125; = useContext(myContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      子组件：&#123;count&#125;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;myContext.Provider value=&#123;&#123; count, setCount &#125;&#125;&gt;</span><br><span class="line">      父组件：&#123;count&#125;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;Com /&gt;</span><br><span class="line">    &lt;<span class="regexp">/myContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面是 <code>useContext</code> 的一个简单用法，我们创建了 <code>context</code>，在父组件 <code>App</code> 中创建了 <code>count</code> 和更改 <code>count</code> 的函数 <code>setCount</code>，并将它们通过 <code>context</code> 的 <code>Provider</code> 组件提供给子组件 <code>Com</code>，子组件中调用 <code>useContext</code> 并传入这个创建的 <code>context</code> 对象，返回了父组件所提供的状态数据，并在子组件中点击的方式来更改，此时父、子组件中渲染的 <code>count</code> 都发生了变化。</p><p>上面说 <code>React hooks</code> 中提供了自己的状态管理解决方案，也就是说可以替代 <code>Redux</code> 的工作，实现整个项目的状态管理以及相关状态逻辑的复用，下面就使用 <code>useContext</code> 和 <code>useReducer</code> 来实现一个简单的状态管理逻辑。</p><figure class="highlight jsx"><figcaption><span>reducer.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态（默认值）</span></span><br><span class="line"><span class="keyword">const</span> initalState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出共用的上下文</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 reducer 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> initalState;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出提供状态的函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextProvider = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ state, dispatch ] = useReducer(reducer, initalState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;myContext.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/myContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的 <code>reducer.js</code> 文件用来提供整个状态管理的核心逻辑，创建了初始的 <code>state</code>，创建了共用的上下文对象，创建了 <code>reducer</code> 函数（通过 <code>action</code> 来匹配并返回新的 <code>state</code>），创建了用来提供 <code>state</code> 和 <code>dispatch</code> 的公共组件 <code>ContextProvider</code>，该组件内部通过创建上下文的 <code>Provider</code> 组件给该组件中间包裹的所有子组件 <code>children</code> 通过 <code>value</code> 提供 <code>state</code> 和 <code>dispatch</code>（通过 <code>useReducer</code> 创建）。</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ContextProvider &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ContextProvider&gt;</span><br><span class="line">        &lt;Counter /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ContextProvider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p><code>App</code> 组件，是提供状态的容器（一般使用根组件），根据 <code>reducer.js</code> 的用法，只需要引入 <code>ContextProvider</code> 组件包裹需要使用状态的子组件，与 <code>react-redux</code> 的 <code>Provider</code> 组件提供 <code>store</code> 的模式相似，这样被 <code>ContextProvider</code> 组件包裹的子组件就可以使用 <code>reducer.js</code> 中所 <code>useReducer</code> 所提供的 <code>state</code> 和 <code>dispatch</code>，<code>Counter</code> 子组件代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myContext &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; state, dispatch &#125; = useContext(myContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Counter count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'reset'</span> &#125;)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure><p>在使用 <code>reducer.js</code> 中实现的状态管理逻辑的组件中，只需要引入 <code>reducer.js</code> 提供的 <code>context</code>，并使用 <code>useContext</code> 就可以解构出 <code>state</code> 和 <code>dispatch</code>，并通过 <code>action</code> 实现三种不同的对状态的 <code>state</code> 的操作。</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p><code>useCallback</code> 是 <code>React</code> 针对函数组件的优化考虑所设计的 <code>Hook API</code>，在函数被渲染时，<code>React</code> 底层是通过调用的方式去创建的，如果函数组件作用域中创建了实现某些功能的函数，则底层每次调用函数组件时，这些函数都会被重新创建，也就是指向新的引用，有了 <code>React Hooks</code> 以后，函数组件中需要的函数可以通过 <code>useCallback</code> 创建。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useCallback, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存储 useCallback 返回的函数</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 useCallback 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestUseCallback</span>(<span class="params">&#123; nums, name &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedCallback = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nums, <span class="string">'Hello world!'</span>);</span><br><span class="line">  &#125;, [ nums ]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'callback 是否相同：'</span>, <span class="built_in">Object</span>.is(fn, memoizedCallback));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nums &gt; '</span>, nums, <span class="string">'name &gt; '</span>, name);</span><br><span class="line">  fn = memoizedCallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;memoizedCallback&#125;&gt;TestUseCallback&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来触发重新 render 的类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    nums: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    name: <span class="string">'hello'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;));</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChangeNum = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">nums</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="attr">name</span>: <span class="string">'world'</span> &#125;);</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; nums, name &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;h2&gt;Start editing to see some magic happen!<span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleChangeNum&#125;&gt;修改传入的 nums 值&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TestUseCallback nums=&#123;nums&#125; name=&#123;name&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>在上面的案例中渲染的组件 <code>App</code> 是一个类组件，该组件在挂载后会创建一个定时器，每 <code>3s</code> 更新 <code>state</code> 的 <code>count</code> 值，来完成重渲染，内部的 <code>TestUseCallback</code> 组件也会跟着重渲染，在内部检测 <code>useCallback</code> 创建的函数是否每次都会创建新的，同时打印父组件传递的参数，在通过父组件的点击事件更改的依赖的时候，观察 <code>useCallback</code> 是否会新创建返回的值。</p><blockquote class="pullquote info"><p><strong>执行 <code>useCallback</code> 方法传入的的参数为回调函数和依赖列表（数组），返回值为传入的函数，<code>React</code> 已经将传入的函数注入，只要依赖列表中的依赖没有发生变化，就不会创建新的函数返回，这样就大大减小了每次都在内存中创建新的引用来存储新函数的开销，也同时减少了 <code>GC</code> 的压力。</strong></p></blockquote><figure class="highlight jsx"><figcaption><span>组件中不同方式事件处理函数的区别</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick()&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com2</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click happened'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Com1</code>：类组件，直接使用箭头函数，每次重新渲染都产生新的函数；</li><li><code>Com2</code>：类组件，在 <code>constructor</code> 中使用 <code>bind</code> 绑定 <code>this</code>，每次重新渲染都使用一个函数；</li><li><code>Com3</code>：函数组件，直接创建函数，每次重新渲染都产生新的函数；</li><li><code>Com4</code>：函数组件，使用 <code>useCallback</code> 创建函数，每次重新渲染都使用一个函数；</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = React.memo(<span class="function">(<span class="params">&#123; a, memo &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Child 渲染'</span>)&#125;</span><br><span class="line">      &lt;span&gt;a: &#123;a&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;memo&#125;&gt;Click in child&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const [ a, setA ] = useState(0);</span></span><br><span class="line"><span class="regexp">  const [ b, setB ] = useState(0);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 直接创建的函数</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ const handleClick = () =&gt; console.log('click');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 使用 useCallback 创建的函数</span></span><br><span class="line"><span class="regexp">  const handleClick = useCallback(() =&gt; console.log('click'), []);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;console.log('App 渲染')&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Child a=&#123;a&#125; memo=&#123;handleClick&#125; /</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setA(a + <span class="number">1</span>)&#125;&gt;改变 a&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setB(b + 1)&#125;&gt;改变 b&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面案例中使用了 <code>React.memo</code> 的函数组件优化方法来进一步验证了 <code>useCallback</code> 的作用，方法 <code>React.memo</code> 的参数为一个函数组件，会返回一个高阶组件，作用是当传入的函数组件内部的 <code>props</code> 不发生变化时，则不会重新渲染。</p><p>父组件 <code>App</code> 中使用 <code>useCallback</code> 创建的函数和使用 <code>useState</code> 创建的状态 <code>a</code> 作为参数传递给子组件 <code>Child</code>，并通过点击事件改变 <code>a</code> 和 <code>b</code> 的状态，初次渲染时控制台打印 <code>App 渲染</code> 和 <code>Child 渲染</code>，当点击 <code>改变 a</code> 时，父、子组件同时渲染，是因为子组件 <code>props</code> 中的 <code>a</code> 发生变化，当点击 <code>改变 b</code> 时，父组件重新渲染，但是子组件并没有，说明 <code>useCallback</code> 并没有产生新的函数传递给子组件，当使用 <code>App</code> 组件注释中直接创建的函数时，则点击 <code>改变 b</code>，子组件也会重新渲染，是因为父组件重渲染创建了新的函数，导致子组件的参数发生变化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储两个组件的函数</span></span><br><span class="line"><span class="keyword">let</span> fnn1 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> fnn2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 React.memo 改写的一个渲染耗时的组件（假设很耗时）</span></span><br><span class="line"><span class="keyword">const</span> ExpensiveCom = React.memo(<span class="function">(<span class="params">&#123; onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;console.log('昂贵组件渲染了！')&#125;</span></span><br><span class="line"><span class="xml">    &#123;date.getSeconds()&#125;</span></span><br><span class="line"><span class="xml">    我是一个昂贵的组件！渲染耗时！</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com1</span>(<span class="params">&#123; p1 &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fn'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Com1'</span>, <span class="built_in">Object</span>.is(fnn1, fn));</span><br><span class="line">  fnn1 = fn;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ExpensiveCom</span> <span class="attr">onClick</span>=<span class="string">&#123;fn&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Com2(&#123; p2 &#125;) &#123;</span></span><br><span class="line"><span class="xml">  const fn = useCallback(() =&gt; console.log('fn', p2), [ p2 ]);</span></span><br><span class="line"><span class="xml">  console.log('Com2', Object.is(fnn2, fn));</span></span><br><span class="line"><span class="xml">  fnn2 = fn;</span></span><br><span class="line">  return &lt;ExpensiveCom onClick=&#123;fn&#125; /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [ p1, setP1 ] = useState(0);</span><br><span class="line">  const [ p2, setP2 ] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;每次点击 fn 都是新的&lt;/h2&gt;</span><br><span class="line">      &lt;Com1 p1=&#123;p1&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; setP1(&#123; p1: p1 + 1 &#125;)&#125;</span><br><span class="line">      &gt;p1 + 1&lt;/button&gt;</span><br><span class="line">      &lt;br/&gt;</span><br><span class="line">      &lt;h2&gt;不用重复生成 fn&lt;/h2&gt;</span><br><span class="line">      &lt;Com2 p2=&#123;p2&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; setP2(&#123; p2: p2 + 1 &#125;)&#125;</span><br><span class="line">      &gt;p2 + 1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中假设 <code>ExpensiveCom</code> 是一个渲染非常耗时的 “昂贵” 组件，并在两个不同的容器组件 <code>Com1</code> 和 <code>Com2</code> 中对比，<code>ExpensiveCom</code> 参数是在父组件 <code>Com1</code> 和 <code>Com2</code> 中创建的函数，前者直接创建，后者使用 <code>useCallback</code> 创建，在 <code>App</code> 组件中渲染 <code>Com1</code> 和 <code>Com2</code>，分别传入状态 <code>p1</code> 和 <code>p2</code>，并在 <code>Com1</code> 和 <code>Com2</code> 内部的函数中进行打印，而创建的函数作为 “昂贵” 组件的参数，并作为内部点击的执行函数。</p><p>当在页面点击 <code>p1 + 1</code> 或 <code>p2 + 1</code> 时，都会导致 <code>App</code> 的状态变化，也就是 <code>App</code> 的重渲染，而作为 <code>App</code> 的子组件, <code>Com1</code> 和 <code>Com2</code>，也会跟着重新渲染，点击 <code>p1 + 1</code>，从控制台打印结果看，只有 <code>Com1</code> 内部的 “昂贵” 组件重新渲染，而 <code>Com2</code> 中并没有，是因为 <code>useCallback</code> 中依赖的 <code>p2</code> 没有改变，没有生成新的函数，当点击 <code>p2 + 1</code> 时，<code>Com2</code> 内部的 “昂贵” 组件重新渲染，同时 <code>Com1</code> 内部的 “昂贵” 组件也重新渲染，由此可以看出 <code>Com2</code> 的性能是要优于 <code>Com1</code> 的。</p><blockquote class="pullquote default"><p><strong>在大型的项目中，可能在内层组件中存在非常耗时耗性能的 “昂贵” 组件，如果因为在外层组件中一个函数的更新导致的所有组件重新渲染，显然性能代价是非常大的，所以合理的使用 <code>useCallback</code> 对函数组件进行优化是非常有必要的。</strong></p></blockquote><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 是一种优化手段，接收两个参数，第一个参数是一个函数，第二个参数是依赖列表，返回值是传入函数的返回结果，在函数组件渲染时，其中的 <code>useMemo</code> 只有在依赖列表中的依赖发生变化，才会重新计算函数的结果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 useMemo 的返回结果</span></span><br><span class="line"><span class="keyword">let</span> ch = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于观察是否重渲染的组件</span></span><br><span class="line"><span class="keyword">const</span> Com = <span class="function">(<span class="params">&#123; val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Com 重新渲染了'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;val&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> child1 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'child1 重新计算'</span>)&#125;</span><br><span class="line">      &lt;Com val=&#123;b&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ), [ a ]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  console.log('child1 是否和之前相等', child1 === ch);</span></span><br><span class="line"><span class="regexp">  ch = child1;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  const child2 = (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;console.log('child2 重新计算')&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Com val=&#123;b&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;child1&#125;</span></span><br><span class="line"><span class="regexp">      &#123;child2&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供状态的容器组件</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ a, setA ] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [ b, setB ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Parent a=&#123;a&#125; b=&#123;b&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setA(a + <span class="number">1</span>)&#125;&gt;改变 a&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setB(b + 1)&#125;&gt;改变 b&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中 <code>App</code> 组件提供状态 <code>a</code> 和 <code>b</code> 作为参数提供给 <code>Parent</code> 组件，<code>App</code> 中可以通过 <code>改变 a</code> 和 <code>改变 b</code> 按钮更新状态 <code>a</code> 和 <code>b</code>，当 <code>a</code> 和 <code>b</code> 发生变化时导致 <code>Parent</code> 组件重新渲染，内部的 <code>child1</code> 和 <code>child2</code> 分别是通过 <code>useMemo</code> 和直接创建的组件，其中分别渲染 <code>Com</code> 组件，默认情况下 <code>child1</code> 和 <code>child2</code> 都会渲染，点击 <code>改变 a</code>，<code>child1</code> 和 <code>child2</code> 重新渲染，因为 <code>child1</code> 的依赖 <code>a</code> 发生变化，点击 <code>改变 b</code>，发现只有 <code>child2</code> 重新渲染，而再此点击 <code>改变 a</code>，由于都重新渲染导致 <code>child1</code> 和 <code>child2</code> 渲染的值同步了。</p><blockquote class="pullquote primary"><p><strong><code>useMemo</code> 不仅仅可以优化耗时的复杂计算程序，同时可以优化渲染耗时且页面不要求更新的复杂组件，但有一点需要注意，就是不要在传入 <code>useMemo</code> 的函数中执行与渲染无关的操作，如副作用，这类的操作属于 <code>useEffect</code> 的范畴，而不是 <code>useMemo</code>。</strong></p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>在 <code>React</code> 组件中有一个区分方式，受控组件和非受控组件，大多场景应用于表单元素，受控组件就是通过 <code>onChange</code> 事件和 <code>state</code> 实现双向绑定，这里不过多赘述，非受控组件是通过元素的 <code>ref</code> 属性获取 <code>Dom</code> 的引用，进而对表单进行操作，在 <code>React 16.3</code> 以后推荐使用 <code>React.createRef</code> 方法创建。</p><p>类组件中使用 <code>ref</code> 通常是将引用关联到类组件的实例属性上，方便操作，而 <code>useRef</code> 就是为了在函数组件中实现这个功能而存在的，在函数组件中同样可以 <code>React.createRef</code> 来实现，但是函数组件的每一次重新渲染都会导致 <code>ref</code> 对象的重新创建，浪费内存和性能，下面是一个官方的例子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useRef, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef();</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;获取焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;TextInputWithFocusButton /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong><code>useRef</code> 的参数为创建 <code>ref</code> 对象 <code>current</code> 属性的初始值，<code>ref</code> 对象创建后会作为函数组件的实例属性，除非组件卸载，否则不会重新创建。</strong></p></blockquote><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>在介绍 <code>useImperativeHandle</code> 之前一定要清楚 <code>React</code> 关于 <code>ref</code> 转发（也叫透传）的知识点，是使用 <code>React.forwardRef</code> 方法实现的，该方法返回一个组件，参数为函数（<code>props callback</code>，并不是函数组件），函数的第一个参数为父组件传递的 <code>props</code>，第二给参数为父组件传递的 <code>ref</code>，其目的就是希望可以在封装组件时，外层组件可以通过 <code>ref</code> 直接控制内层组件或元素的行为。</p><figure class="highlight jsx"><figcaption><span>一个关于 ref 转发的例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useCallback, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 ref 的转发</span></span><br><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input ref=&#123;ref&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">    &lt;button&gt;&#123;props.children&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件中使用子组件的 ref</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef();</span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> ref.current.focus(), [ ref ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;FancyButton ref=&#123;ref&#125;&gt;Click Me&lt;<span class="regexp">/FancyButton&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClick&#125;&gt;获取焦点&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面例子中创建了一个 <code>FancyButton</code> 组件，内部渲染了一个 <code>button</code> 元素，我们希望在父元素 <code>App</code> 中渲染 <code>FancyButton</code>，并通过传递给 <code>FancyButton</code> 的 <code>ref</code> 直接操作内部的 <code>button</code>。</p><figure class="highlight jsx"><figcaption><span>一个官方的 useImperativeHandle 例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FancyInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="xml">  const fancyInputRef = useRef();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; fancyInputRef.current.focus()&#125;</span><br><span class="line">      &gt;父组件调用子组件的 focus&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br></pre></td></tr></table></figure><p>上面这个例子中与直接转发 <code>ref</code> 不同，直接转发 <code>ref</code> 是将 <code>React.forwardRef</code> 中函数上的 <code>ref</code> 参数直接应用在了返回元素的 <code>ref</code> 属性上，其实父、子组件引用的是同一个 <code>ref</code> 的 <code>current</code> 对象，官方不建议使用这样的 <code>ref</code> 透传，而使用 <code>useImperativeHandle</code> 后，可以让父、子组件分别有自己的 <code>ref</code>，通过 <code>React.forwardRef</code> 将父组件的 <code>ref</code> 透传过来，通过 <code>useImperativeHandle</code> 方法来自定义开放给父组件的 <code>current</code>。</p><p><code>useImperativeHandle</code> 的第一个参数是定义 <code>current</code> 对象的 <code>ref</code>，第二个参数是一个函数，返回值是一个对象，即这个 <code>ref</code> 的 <code>current</code> 对象，这样可以像上面的案例一样，通过自定义父组件的 <code>ref</code> 来使用子组件 <code>ref</code> 的某些方法。</p><blockquote class="pullquote warning"><p><strong><code>useImperativeHandle</code> 和 <code>React.forwardRef</code> 必须是配合使用的，这也是为什么在开头要介绍 <code>ref</code> 的转发。</strong></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;</span><br><span class="line">  useState,</span><br><span class="line">  useRef,</span><br><span class="line">  useImperativeHandle,</span><br><span class="line">  useCallback</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FancyInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ fresh, setFresh ] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> attRef = useRef(<span class="number">0</span>);</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    attRef,</span><br><span class="line">    fresh</span><br><span class="line">  &#125;), [ fresh ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    attRef.current++;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;attRef.current&#125;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Fancy&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setFresh(!fresh)&#125;&gt;刷新&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const fancyInputRef = useRef();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;FancyInput ref=&#123;fancyInputRef&#125; /</span>&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; <span class="built_in">console</span>.log(fancyInputRef.current)&#125;</span><br><span class="line">      &gt;父组件访问子组件的实例属性&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的案例相对于官方的例子意图更明显一些，通过 <code>useImperativeHandle</code> 将子组件的实例属性输出到父组件，而子组件内部通过 <code>ref</code> 更改 <code>current</code> 对象后，组件不会重新渲染，需要改变 <code>useState</code> 设置的状态才能更改。</p><blockquote class="pullquote info"><p><strong><code>useImperativeHandle</code> 方法还支持传入第三个参数，即依赖列表，当监听的依赖发生变化时，<code>useImperativeHandle</code> 才会重新将子组件的实例属性输出到父组件 <code>ref</code> 的 <code>current</code> 属性上，如果为空数组，则不会重新输出。</strong></p></blockquote><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p><code>useLayoutEffect</code> 的使用方法和 <code>useEffect</code> 相同，唯一的区别就是执行时机不一样。</p><figure class="highlight jsx"><figcaption><span>对比 useLayoutEffect 与 useEffect 的执行时机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useLayoutEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Com 渲染'</span>)&#125;</span><br><span class="line">      &lt;h2&gt;Com1&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Com /&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的例子中在 <code>Com</code> 组件中同时使用了 <code>useLayoutEffect</code> 和 <code>useEffect</code>，在页面初次渲染时可以看到控制台打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 执行...</code>。</p><p>当点击 <code>App</code> 组件按钮更新状态导致 <code>Com</code> 重新渲染，打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><p>在刚接触 <code>React Hooks</code> 时，说到执行时机我们一般会和类组件的生命周期去类比，下面是一个 <code>useLayoutEffect</code>、<code>useEffect</code> 与类组件生命周期配合使用的例子。</p><figure class="highlight jsx"><figcaption><span>对比 useLayoutEffect、useEffect 与类组件生命周期的执行时机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useLayoutEffect, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 useLayoutEffect 和 useEffect 的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 执行...'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect 销毁...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">console</span>.log(<span class="string">'Com 渲染'</span>)&#125;</span><br><span class="line">      &lt;h2&gt;Com1&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生命周期的类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  setCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'App componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'App componentDidUpdate'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;Com /&gt;</span><br><span class="line">        &#123;<span class="built_in">console</span>.log(<span class="string">'App 渲染'</span>)&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.setCount&#125;&gt;count + <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面例子中 <code>useLayoutEffect</code> 和 <code>useEffect</code> 依然在 <code>Com</code> 组件中使用，<code>App</code> 组件为类组件，<code>Com</code> 作为 <code>App</code> 的子组件，在首次渲染时控制台的打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidMount</code> → <code>useEffect 执行...</code>。</p><p>而点击按钮更改状态触发重渲染时，打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidUpdate</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><blockquote class="pullquote default"><p><strong><code>useLayoutEffect</code> 的执行时机要早于 <code>useEffect</code>，<code>useLayoutEffect</code> 的执行在类组件生命周期前，<code>useEffect</code> 的执行在类组件生命周期后，官方的建议是要求我们尽量使用 <code>useEffect</code>，以避免阻塞视觉更新，如果是将代码从类组件重构为 <code>React Hooks</code>，并且使用 <code>useEffect</code> 出现问题，再考虑使用 <code>useLayoutEffect</code>，服务端渲染时使用 <code>useLayoutEffect</code> 会触发警告。</strong></p></blockquote><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p><code>useDebugValue</code> 用于在 <code>React</code> 开发者工具（如果已安装，在浏览器控制台 <code>React</code> 选项查看）中显示 <a href="https://www.overtaking.top/2019/05/07/20190507155411/#%E8%87%AA%E5%AE%9A%E4%B9%89-Hook" target="_blank">自定义 Hook</a> 的标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useDebugValue &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调试自定义 Hook，显示在 devtools 上</span></span><br><span class="line">  useDebugValue(count &gt; num ? <span class="string">'溢出'</span> : <span class="string">'不足'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ count, myCount ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, seCount ] = useMyCount(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; seCount()&#125;&gt;setCount&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面例子中创建了 <code>useMyCount</code> 自定义 <code>Hook</code>，在内部使用 <code>useDebugValue</code> 对 <code>count</code> 的状态进行了调试，在开发工具中显示如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/05/07/20190507155411/usedebugvalue.png" alt="useDebugValue 调试效果图" title="">                </div>                <div class="image-caption">useDebugValue 调试效果图</div>            </figure><p><br></p><p><code>useDebugValue</code> 还支持第二个参数，类型为函数，函数的默认参数为 <code>debug</code> 的状态，作用是对 <code>debug</code> 的值进行格式化，官方叫做 “延迟格式化”。</p><figure class="highlight jsx"><figcaption><span>延迟格式化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useDebugValue &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟格式化</span></span><br><span class="line">  useDebugValue(count &gt; num ? <span class="string">'溢出'</span> : <span class="string">'不足'</span>, status =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> status === <span class="string">'溢出'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ count, myCount ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, seCount ] = useMyCount(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; seCount()&#125;&gt;setCount&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, root);</span></span><br></pre></td></tr></table></figure><p>上面的例子只是做了小小的改动，增加了一个格式化函数作为 <code>useDebugValue</code> 的第二个参数，当状态为 <code>不足</code> 时显示 <code>0</code>，为 <code>溢出</code> 时显示 <code>1</code>。</p><blockquote class="pullquote info"><p><strong>提示：我们不推荐你向每个自定义 <code>Hook</code> 使用 <code>useDebugValue</code>，只有自定义 <code>Hook</code> 被复用时才最有意义。</strong></p></blockquote><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>在开篇介绍 <code>React Hooks</code> 产生的动机时，提到了在类组件中使用 “高阶组件” 和 “渲染回调” 的方式对状态逻辑进行复用和解耦会导致渲染嵌套的层级增多以及代码可读性差的问题，在 <code>React 16.8</code> 以后可以通过自定义 <code>Hook</code> 来解决这些问题。</p><figure class="highlight jsx"><figcaption><span>一个没有解决问题的例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Counter1 /&gt;</span><br><span class="line">      &lt;Counter2 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>上面实现了两个计数器，都有自动增加状态的更新数组的功能，并且都是使用 <code>React Hooks</code> 实现的，很明显我们可以将更新状态的逻辑抽离出来，下面是通过自定义 <code>Hook</code> 改写的例子。</p><figure class="highlight jsx"><figcaption><span>使用自定义 Hook 对状态逻辑进行抽离</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'销毁老的定时器'</span>)</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = useNumber();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = useNumber();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Counter1 /&gt;</span><br><span class="line">      &lt;Counter2 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, root);</span><br></pre></td></tr></table></figure><p>使用自定义 <code>Hook</code> 就很容易的实现了状态逻辑的复用和解耦，代码简单易读，也避免了 “高阶组件” 和 “渲染回调” 造成渲染层级增加的问题。</p><blockquote class="pullquote primary"><p><strong>注意：官方建议在创建自定义 <code>Hook</code> 时，也采用 <code>use</code> 开头的命名方式，以保持命名的默认约定，便于识别。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><code>React Hooks</code> 出现后让我们对使用 <code>React</code> 编程如释重负，好的技术就是应该越用越简单，编写大家都读得懂的代码才是好代码，上面就是在学习完 <code>React Hooks</code> 后的一些总结，最后附上相关案例的 <a href="https://github.com/shenqiuhui/react-hooks-examples" target="_blank">Guthub 地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/05/07/20190507155411/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 获取对象属性名的方法和区别</title>
      <link>https://www.overtaking.top/2019/04/17/20190417112536/</link>
      <guid>https://www.overtaking.top/2019/04/17/20190417112536/</guid>
      <pubDate>Wed, 17 Apr 2019 03:25:36 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/04/17/20190417112536/get-object-key.png&quot; title=&quot;JavaScript 获取对象属性名的方法和区别&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;JavaScript&lt;/code&gt; 中想获取某一个对象的属性名，有多种方法可供选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for in&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Reflect.ownKeys&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/17/20190417112536/get-object-key.png" title="JavaScript 获取对象属性名的方法和区别"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>JavaScript</code> 中想获取某一个对象的属性名，有多种方法可供选择。</p><ul><li><code>for in</code></li><li><code>Object.keys</code></li><li><code>Object.getOwnPropertyNames</code></li><li><code>Object.getOwnPropertySymbols</code></li><li><code>Reflect.ownKeys</code></li></ul><p>在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。</p><a id="more"></a><h2 id="创建对象案例"><a href="#创建对象案例" class="headerlink" title="创建对象案例"></a>创建对象案例</h2><p>下面来创建一个对象的案例让这些方法来获取属性，再通过结果来看区别。</p><figure class="highlight js"><figcaption><span>父类，继承自 Object.prototype</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'symbolParent'</span>)]: &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>子类，继承自 parent</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">  c: &#123;</span><br><span class="line">    value: <span class="number">4</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    value: <span class="number">5</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'symbolChild'</span>)]: &#123;</span><br><span class="line">    value: <span class="number">6</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面我们创建了一个对象 <code>parent</code>，上面创建了两个普通属性 <code>a</code>（可枚举）、<code>b</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolParent</code>，创建了一个对象 <code>child</code> 继承自 <code>parent</code>，上面创建了两个普通属性 <code>c</code>（可枚举）、<code>d</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolChild</code>。</p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>从结果来看，<code>for...in</code> 先遍历并获取到了自身的部分属性名，又获取到了继承的部分属性名。</p><blockquote class="pullquote info"><p><strong>总结：<code>for...in</code> 可以遍历自身和继承的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c"]</span></span><br></pre></td></tr></table></figure><p>从结果来看，<code>Object.keys</code> 返回了一个数组，里面存储获取的属性的键名，不能获取继承的属性名，只能获取自身的部分属性名，这种效果相当于 <code>for...in</code> 与 <code>hasOwnProperty</code> 方法的组合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.hasOwnProperty(k)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>总结：<code>Object.keys</code> 只能遍历自身的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c", "d"]</span></span><br></pre></td></tr></table></figure><p>从结果看，<code>Object.getOwnPropertyNames</code> 方法返回了一个数组，存储获取对象属性的键名。</p><blockquote class="pullquote danger"><p><strong>总结：<code>Object.getOwnPropertyNames</code> 只能遍历自身的（包含不可枚举）、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Symbol(symbolChild)]</span></span><br></pre></td></tr></table></figure><p>从结果看，<code>Object.getOwnPropertySymbols</code> 方法返回了一个数组，存储的都是 <code>Symbol</code> 类型的键，说明是专门用来处理 <code>Symbol</code> 类型的。</p><blockquote class="pullquote default"><p><strong>总结：<code>Object.getOwnPropertySymbols</code> 只能遍历自身 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["c", "d", Symbol(symbolChild)]</span></span><br></pre></td></tr></table></figure><p><code>Reflect.ownKeys</code> 的返回值为数组，存储遍历到的属性名。</p><blockquote class="pullquote success"><p><strong>总结：<code>Reflect.ownKeys</code> 可以遍历自身的所有属性（包含不可枚举和 <code>Symbol</code> 类型）。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/17/20190417112536/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript 基础知识总结</title>
      <link>https://www.overtaking.top/2019/04/16/20190416160637/</link>
      <guid>https://www.overtaking.top/2019/04/16/20190416160637/</guid>
      <pubDate>Tue, 16 Apr 2019 08:06:37 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/04/16/20190416160637/typescript.jpeg&quot; title=&quot;Typescript&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;TypeScript-简介&quot;&gt;&lt;a href=&quot;#TypeScript-简介&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 简介&quot;&gt;&lt;/a&gt;TypeScript 简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 是由微软开发的开源编程语言（后面简称 &lt;code&gt;TS&lt;/code&gt;），是 &lt;code&gt;JavaScript&lt;/code&gt; 的超集（后面简称 &lt;code&gt;JS&lt;/code&gt;），由于 &lt;code&gt;JS&lt;/code&gt; 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 &lt;code&gt;Bug&lt;/code&gt; 和风险，而 &lt;code&gt;TS&lt;/code&gt; 更适合大型企业应用，是因为 &lt;code&gt;TS&lt;/code&gt; 需要编译成 &lt;code&gt;JS&lt;/code&gt; 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/16/20190416160637/typescript.jpeg" title="Typescript"><p><br></p><h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><blockquote class="pullquote info"><p><code>TypeScript</code> 是由微软开发的开源编程语言（后面简称 <code>TS</code>），是 <code>JavaScript</code> 的超集（后面简称 <code>JS</code>），由于 <code>JS</code> 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 <code>Bug</code> 和风险，而 <code>TS</code> 更适合大型企业应用，是因为 <code>TS</code> 需要编译成 <code>JS</code> 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。</p></blockquote><a id="more"></a><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/04/16/20190416160637/ts-js.png" alt="TypeScript 与 JavaScript 关系图" title="">                </div>                <div class="image-caption">TypeScript 与 JavaScript 关系图</div>            </figure><p><br></p><p><code>TS</code> 是前端开发工程化新的趋势，目前很多的开源项目内部都是用 <code>TS</code> 编写，也有很多大牛在推广 <code>TS</code>，目前使用 <code>TS</code> 开发的典型项目有 <code>VSCode</code>、<code>Angular6</code>、<code>Vue3</code> 和 <code>React16</code> 等。</p><h2 id="如何使用-TS"><a href="#如何使用-TS" class="headerlink" title="如何使用 TS"></a>如何使用 TS</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用 <code>TS</code> 之前应该先进行全局安装。</p><figure class="highlight bash"><figcaption><span>安装 TS 的命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure><p>全局安装后会提供 <code>tsc</code> 命令，<code>tsc -v</code> 可以查看当前安装 <code>TS</code> 版本。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>我们可以通过命令单独对文件进行编译，也可以编译整个项目的 <code>TS</code> 文件。</p><figure class="highlight bash"><figcaption><span>编译单个文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>块级作用域变量名检测，两个文件（无论 <code>JS</code> 还是 <code>TS</code>）不允许有相同的变量名。</strong></p></blockquote><p>编译整个项目的 <code>TS</code> 文件需要在项目中设置 <code>tsconfig.json</code> 的配置文件，快速生成配置文件命令如下。</p><figure class="highlight bash"><figcaption><span>生成 tsconfig.json 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>生成 <code>TS</code> 配置文件以后，编译命令 <code>tsc</code> 不需要再指定文件名，会默认读取 <code>tsconfig.json</code> 文件的配置进行编译，关于 <code>tsconfig.json</code> 属性详解请看 <code>TO DO</code>。</p><p>当 <code>TS</code> 文件发生变化时，可以通过 <code>--watch</code> 参数进行实时监听，并当 <code>TS</code> 文件变化时实时编译，也可以把命令配置在 <code>package.json</code> 中通过 <code>npm</code> 执行。</p><figure class="highlight"><figcaption><span>package.json 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "tsc",</span><br><span class="line">    "start": "tsc --watch"</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS-的数据类型"><a href="#TS-的数据类型" class="headerlink" title="TS 的数据类型"></a>TS 的数据类型</h2><p>在 <code>TS</code> 中提供了强大的类型系统，编译时帮助我们对代码中定义的数据类型和值进行检查，如果使用支持 <code>TS</code> 比较好的编辑器，如 <code>VSCode</code>，可以在代码编写时及时发现错误。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="基本数据类型定义"><a href="#基本数据类型定义" class="headerlink" title="基本数据类型定义"></a>基本数据类型定义</h4><p><code>TS</code> 中包含了 <code>JS</code>，所以 <code>TS</code> 也有 <code>6</code> 种基本数据类型，<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'panda'</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> merried: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> sym: symbol = Symbol();</span><br></pre></td></tr></table></figure><p>上面声明变量的值与所定义的数据类型必须严格符合，否则编译时报错（编辑器默认就会报错，后面统一说成报错）。</p><p><code>undefined</code> 和 <code>null</code> 是其他基本类型的子类型，类型定义为 <code>undefined</code> 的变量只能赋值 <code>undefined</code>，类型定义为 <code>null</code> 的变量只能赋值 <code>null</code>，类型定义为其他的可以赋值为 <code>undefined</code> 和 <code>null</code>。</p><figure class="highlight ts"><figcaption><span>默认不会报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果想让其他类型的赋值也必须严格与其定义相对应，可以通过配置 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性实现，也被叫做严格类型检查模式。</p><figure class="highlight"><figcaption><span>tsconfig.json 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    "strictNullChecks": true</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类型-any"><a href="#数据类型-any" class="headerlink" title="数据类型 any"></a>数据类型 any</h4><p>希望定义的数据类型可以赋值任何值，可以将数据类型定义为 <code>any</code>，这样相当于没有使用类型校验，等同于直接使用 <code>JS</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span> = <span class="number">18</span>;</span><br><span class="line">value = <span class="string">'hello world'</span>;</span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line">value = <span class="literal">null</span>;</span><br><span class="line">value = <span class="literal">undefined</span>;</span><br><span class="line">value = Symbol();</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p>上面代码中的赋值操作不会报任何错误，因为变量的值类型定义为了 <code>any</code>。</p></blockquote><h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><p>在 <code>TS</code> 中，如果定义的变量没有定义类型，则会对变量的类型进行推测，同样可以在代码编译阶段按照推测的类型校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num = <span class="string">'hello'</span>; <span class="comment">// 报错，不能将类型“"hello"”分配给类型“number”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'world'</span>;</span><br><span class="line">str = <span class="number">1</span>; <span class="comment">// 报错，不能将类型“1”分配给类型“string”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value; <span class="comment">// let value: any</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>类型推论规则：</strong></p><ul><li><strong>从报错的结果可以看出，<code>TS</code> 中声明变量如果没有指定值的类型，则会默认将声明变量时赋值数据的类型定义为该变量的值类型；</strong></li><li><strong>当声明变量没有直接赋值时，<code>TS</code> 会将变量的值类型定义为 <code>any</code>。</strong></li></ul></blockquote><h4 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h4><p><code>TS</code> 也包含基本包装类，基本数据类型是没有方法的（只有对象可以调用对应原型上的方法），在基本数据类型调用方法时是先进行包装过程，把基本类型包装成对象类型。</p><figure class="highlight ts"><figcaption><span>基本数据类型调用方法的包装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num.toFixed(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Number(num).toFixed(2);</span></span><br></pre></td></tr></table></figure><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>有些时候定义的变量在不同场景会赋不同类型的值，我们想要指定这个变量只接受某几个固定类型的值，可以使用联合类型的方式。</p><figure class="highlight ts"><figcaption><span>联合类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">'hello'</span>;</span><br><span class="line">value = <span class="number">10</span>;</span><br><span class="line">value = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>被定义联合类型的变量可以指定符合联合类型中任意一种类型的值，定义时不同的数据类型用 <code>|</code> 隔开，当被赋值不符合联合类型时会报错。</p><blockquote class="pullquote warning"><p><strong>上面联合类型的写法如果多处相同会让代码冗余，在 <code>TS</code> 中提供了 <code>type</code> 关键字来声明类型，用法如下。</strong></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冗余的写法</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> z: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后...</span></span><br><span class="line"><span class="keyword">type</span> MyType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">let</span> x: MyType = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> y: MyType = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> z: MyType = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>被定义联合类型的变量可以通过类型断言指定为更具体的类型，不可以指定联合类型中不包含的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">value = <span class="string">'hello'</span>;</span><br><span class="line">value = <span class="number">10</span>;</span><br><span class="line">value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((value <span class="keyword">as</span> <span class="built_in">string</span>).length); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>断言的语法是将变量使用 <code>as</code> 关键字指定要断言的类型，上面代码中因为变量 <code>value</code> 值最后已经是布尔，而强行将 <code>value</code> 指定为 <code>string</code> 类型去获取 <code>length</code> 属性报错，因为布尔值无法调用 <code>length</code> 属性。</p><h4 id="值的联合"><a href="#值的联合" class="headerlink" title="值的联合"></a>值的联合</h4><p>值的联合（又叫字面量联合）与联合类型不同的是，联合类型只是指定了变量的值类型必须为哪几种，而值的联合则限定了变量的值，变量赋值必须是值的联合中的其中某一个，否则报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: <span class="number">1</span> | <span class="number">6</span> | <span class="number">10</span>;</span><br><span class="line">point = <span class="number">10</span>;</span><br><span class="line">point = <span class="string">'hello'</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> level: <span class="string">'A'</span> | <span class="string">'B'</span> | <span class="string">'C'</span>;</span><br><span class="line">level = <span class="string">'B'</span>;</span><br><span class="line">level = <span class="string">'b'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 <code>TS</code> 中，数组是引用类型，定义一个数组类型时需要定义数组内部元素的类型。</p><figure class="highlight ts"><figcaption><span>普通数组类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: <span class="built_in">string</span>[] = [<span class="string">'Jim'</span>, <span class="string">'Peter'</span>];</span><br><span class="line"><span class="keyword">let</span> ages: <span class="built_in">number</span>[] = [<span class="number">18</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>泛型定义（泛型会在后面详细说明）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'Jim'</span>, <span class="string">'Peter'</span>];</span><br><span class="line"><span class="keyword">let</span> ages: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">18</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>上面两种方式定义的数组内元素类型必须统一，如果让数组内部元素类型不同该怎么办，在 <code>TS</code> 中有一种特殊的数组类型定义叫做 “元组类型”（<code>tuple</code>）。</p><figure class="highlight ts"><figcaption><span>元组类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Jim'</span>, <span class="number">18</span>];</span><br></pre></td></tr></table></figure><p><strong>元组类型和数组类型的特点如下表：</strong></p><table><thead><tr><th style="text-align:left">元组</th><th style="text-align:left">数组</th></tr></thead><tbody><tr><td style="text-align:left">元素可以是不同类型</td><td style="text-align:left">元素必须为相同类型</td></tr><tr><td style="text-align:left">有预定的长度</td><td style="text-align:left">没有预定的长度</td></tr><tr><td style="text-align:left">用于表示一个结构</td><td style="text-align:left">用于表示一个列表</td></tr></tbody></table><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型是 <code>JS</code> 中所不包含的数据类型，通过 <code>enum</code> 关键字定义，在业务需求中经常会出现某个业务类型对应固定的值，前后端交互的参数都是通过这个值进行约束和传递的。</p><h4 id="普通枚举"><a href="#普通枚举" class="headerlink" title="普通枚举"></a>普通枚举</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Gender &#123;</span><br><span class="line">  BOY,</span><br><span class="line">  GIRL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">  MONDAY = <span class="string">'1'</span>,</span><br><span class="line">  TUESDAY = <span class="string">'2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>编译后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Gender;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Gender</span>) </span>&#123;</span><br><span class="line">  Gender[Gender[<span class="string">"BOY"</span>] = <span class="number">0</span>] = <span class="string">"BOY"</span>;</span><br><span class="line">  Gender[Gender[<span class="string">"GIRL"</span>] = <span class="number">1</span>] = <span class="string">"GIRL"</span>;</span><br><span class="line">&#125;)(Gender || (Gender = &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Week;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Week</span>) </span>&#123;</span><br><span class="line">  Week[<span class="string">"MONDAY"</span>] = <span class="string">"1"</span>;</span><br><span class="line">  Week[<span class="string">"TUESDAY"</span>] = <span class="string">"2"</span>;</span><br><span class="line">&#125;)(Week || (Week = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>从编译结果来看，枚举类型编译成 <code>JS</code> 后帮助我们创建了一个类似于映射表的同名对象，所以可以在 <code>TS</code> 中通过对象属性的方式获取枚举的值。</p><figure class="highlight ts"><figcaption><span>获取枚举值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Gender.BOY); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Week.MONDAY); <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure><h4 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h4><p>常数枚举的的语法是在创建枚举的 <code>enum</code> 关键字前使用 <code>const</code> 声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  RED,</span><br><span class="line">  YELLOW,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [Colors.RED, Colors.YELLOW, Colors.BLUE];</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>编译后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">0</span> <span class="comment">/* RED */</span>, <span class="number">1</span> <span class="comment">/* YELLOW */</span>, <span class="number">2</span> <span class="comment">/* BLUE */</span>];</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>常数枚举与普通枚举的不同是，在编译阶段不会为枚举的类型创建对象，使用枚举类型值的位置直接编译成对应的枚举值。</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数类型定义"><a href="#参数类型定义" class="headerlink" title="参数类型定义"></a>参数类型定义</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在函数中经常会定义可选参数，即非必传，但是 <code>TS</code> 中函数如果按照上面方式定义在调用时不传会报错，可选参数的类型定义如下。</p><figure class="highlight ts"><figcaption><span>可选参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">people</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people(<span class="string">'jim'</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>?:</code> 替代 <code>:</code>，即代表该参数为可选参数，在 <code>TS</code> 中也支持使用默认参数和剩余参数，使用方式如下。</p><figure class="highlight ts"><figcaption><span>默认参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">sum: <span class="built_in">number</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>剩余参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">prefix: <span class="built_in">string</span>, ...args: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix + args.reduce(<span class="function">(<span class="params">sum, val</span>) =&gt;</span> sum + val, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="string">'$'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>在使用默认参数和剩余参数时，设置的参数初始值和传入的剩余参数与定义类型不符合，则会报错。</p><h4 id="返回值类型定义"><a href="#返回值类型定义" class="headerlink" title="返回值类型定义"></a>返回值类型定义</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊的返回值类型：</strong></p><ul><li><code>never</code>：是其他类型的子类型，代表不会出现的值，作为没有返回值的返回类型，函数无法执行完；</li><li><code>void</code>：表示没有任何类型，指函数没有返回值，函数可以正常执行完，如果一个函数没有返回值，则 <code>TS</code> 认为返回值为 <code>void</code> 类型。</li></ul><figure class="highlight ts"><figcaption><span>never 为返回值类型的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">nerver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">nerver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个函数返回值设置为 <code>never</code>，因为抛错和死循环导致都没有执行完毕，此时函数编译不会报错。</p><figure class="highlight ts"><figcaption><span>void 为返回值类型的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>fn2</code> 函数只在非严格检查模式下不会报错，非严格检查模式下返回值类型被定义为 <code>void</code> 的函数可以返回 <code>null</code> 和 <code>undefined</code>。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>之前的函数参数和返回值类型定义是函数声明的方式，声明函数同样有另外一种方式，函数表达式，即给变量赋值为函数，那如何为接收函数的变量定义类型呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fullName: <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">fullName = <span class="function"><span class="keyword">function</span> (<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>括号中 <code>x</code> 和 <code>y</code> 代表定义参数的类型，箭头后代表定义返回值的类型，也可以使用 <code>type</code> 关键字进行声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fn = <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fullName: Fn = <span class="function"><span class="keyword">function</span> (<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>赋值函数的参数类型必须与变量声明的函数参数类型严格一致，返回值同理。</strong></p></blockquote><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是强类型语言中的特性，在 <code>Java</code> 中代表多个同名函数参数不相同，而在 <code>TS</code> 中有所不同，代表为同一个函数提供多个参数类型及返回值定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">type</span> MyType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载限定函数 double</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">boolean</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: MyType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) <span class="keyword">return</span> val + val;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) <span class="keyword">return</span> <span class="number">2</span> * val;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) <span class="keyword">return</span> !val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double(<span class="string">'hello'</span>); <span class="comment">// hellohello</span></span><br><span class="line">double(<span class="number">5</span>); <span class="comment">// 10</span></span><br><span class="line">double(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>重载限定某个函数的方式只有函数声明、函数名、参数及返回值的类型，而没有函数体。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p><code>TS</code> 类的定义与 <code>JS</code> 相同，使用 <code>class</code> 关键字声明，但可以直接对属性、方法定义参数类型和返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  getName(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">'neil'</span>;</span><br><span class="line">p.getName(); <span class="comment">// neil</span></span><br></pre></td></tr></table></figure><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>在 <code>TS</code> 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为，并可以定义存取器的参数及返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  myName: <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">myName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.myName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(newVal: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// neil</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'jim'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// jim</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>上面都在类中定义属性，也可以使用参数属性进行简化，代码如下。</p><figure class="highlight ts"><figcaption><span>简化前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>简化后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> myName: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.myName); <span class="comment">// neil</span></span><br></pre></td></tr></table></figure><p><code>public</code> 修饰符写在 <code>constructor</code> 的参数前，代表创建一个与参数同名的公有属性。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>在 <code>TS</code> 中可以在类中定义只读属性，只需要通过 <code>readonly</code> 修饰符修饰即可，只在编译阶段进行检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> readonly myName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.myName = myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'neil'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.myName); <span class="comment">// neil</span></span><br><span class="line">p.myName = <span class="string">'jim'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>不同类别的（非互斥）的修饰符可以同时修饰一个变量，使用空格隔开。</strong></p></blockquote><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>类与类之间通过 <code>extends</code> 关键字实现继承，子类继承父类后拥有父类的属性和方法，可以增强代码的复用性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  hobby: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, hobby: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">    <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">  &#125;</span><br><span class="line">  getHobby(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hobby;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Child(<span class="string">'neil'</span>, <span class="number">20</span>, <span class="string">'swim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.getHobby()); <span class="comment">// swim</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getName()); <span class="comment">// neil</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getAge()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>在 <code>TS</code> 的类中有三种访问控制修饰符，分别为 <code>public</code>、<code>protected</code> 和 <code>private</code>。</p><ul><li><code>public</code>：公有的属性，所有地方都能访问；</li><li><code>protected</code>：受保护的的属性，只能在自己和自己的子类中被访问；</li><li><code>private</code>：私有属性，只有自己内部可以访问。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> money: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, money: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.money = money;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类：'</span> + <span class="keyword">this</span>.money);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name, age, money</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age, money);</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类：'</span> + <span class="keyword">this</span>.money); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中 <code>name</code> 属性可以通过父类的实例访问、子类的实例访问，父类的 <code>getName</code> 方法访问，子类的 <code>getName</code> 方法访问，<code>age</code> 属性可以只能通过父类和子类的 <code>getAge</code> 方法访问，<code>money</code> 属性只能通过父类 <code>getMoney</code> 方法访问，其他不被允许的访问方式都会报错。</p><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>在 <code>TS</code> 中给类定义私有属性和方法的修饰符为 <code>static</code>，与 <code>JS</code> 的类相同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Father &#123;</span><br><span class="line">  <span class="keyword">static</span> myName: <span class="built_in">string</span> = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">static</span> getMyName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Father.myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Father.myName); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.getMyName()); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种抽象的概念，使用 <code>abstract</code> 关键字定义，无法被实例化（无法使用 <code>new</code>），只能被继承。</p><p>抽象类的内部包含抽象方法和抽象属性，同样使用 <code>abstract</code> 关键字定义，抽象方法不能在抽象类中实现，具体实现细节只能在抽象类的子类中实现，而且必须实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">abstract</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">abstract</span> speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'喵喵喵'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong>继承抽象类的子类中必须包含所有抽象类中所定义的内容，继承中这种子类覆盖抽象类所定义抽象方法的行为叫做 “重写”，多个子类创建不同的抽象方法的现象被叫做 “多态”。</strong></p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口是 <code>TS</code> 中的核心之一，主要有两个作用：</strong></p><ul><li>用于描述或约束一种对象结构，描述属性的名称和值的类型；</li><li>用来表示行为的抽象，让类去实现接口。</li></ul><h3 id="接口的定义和使用"><a href="#接口的定义和使用" class="headerlink" title="接口的定义和使用"></a>接口的定义和使用</h3><p><code>TS</code> 中使用 <code>interface</code> 关键字来定义接口，接口成员可以是属性或方法名，多个成员可以使用分号、逗号或换行隔开，主要定义属性的名称和值的类型。</p><figure class="highlight ts"><figcaption><span>定义接口，使用接口创建对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: UserInterface = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面 <code>UserInterface</code> 接口创建的对象 <code>user</code>，属性和值的类型必须与定义的接口严格对应。</p><figure class="highlight ts"><figcaption><span>让类去实现定义的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Flyable &#123;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bird <span class="keyword">implements</span> Flyable &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bird fly'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让类实现一个接口使用 <code>implements</code> 关键字，接口在定义方法时与抽象类非常类似，只需要定义方法和类型，不需要具体实现，在实现接口的类中对方法进行具体实现。</p><figure class="highlight ts"><figcaption><span>一个类实现多个接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> Speakable &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  speak(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Eatable &#123;</span><br><span class="line">  food: <span class="built_in">string</span>;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> Speakable, Eatable &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>;</span><br><span class="line">  food: <span class="string">'cake'</span>;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat cake'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong>继承与实现接口的区别是，一个类可以实现多个接口，一个接口可以被多个类实现，而一个父类（包含抽象类）可以被多个类所继承，一个子类只能继承一个父类（单继承）。</strong></p></blockquote><h3 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h3><p>接口中可以定义只读属性，这样通过接口创建的对象的值在修改时会报错，可以在定义接口属性是加上 <code>readonly</code> 修饰符实现。</p><figure class="highlight ts"><figcaption><span>接口的只读属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>;</span><br><span class="line">  name: <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// 1</span></span><br><span class="line">p.name = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h3><p>在上面接口定义时，创建的对象和实现接口类的属性方法都必须与接口定义的属性名、类型一致，其实在接口定义时也可以定义一些非必须的可选属性，在使用接口创建对象或使用类实现接口时，这样的属性不定义不会报错。</p><figure class="highlight ts"><figcaption><span>接口的可选属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Person = &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  name: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义接口的可选属性与函数定义可选参数类似，都是使用 <code>?:</code> 替代原本的 <code>:</code> 即代表可选。</p><h3 id="接口的未知属性"><a href="#接口的未知属性" class="headerlink" title="接口的未知属性"></a>接口的未知属性</h3><p>当接口中存在可选属性时，也只是满足某些属性可以在使用接口时（对象、类），可选属性可以不创建，但是如果对象和类上扩展了未知的其他任意属性，则编译会报错，此时定义接口未知属性，可以解决编译时报错的问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  [proName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong><code>proName</code> 名字是任意的，可以随意取，<code>string</code> 代表属性的类型，<code>any</code> 代表属性值的类型，上面的写法不固定，可以根据需求定义，只需满足 <code>[name: type]: type</code> 的结构即可。</strong></p></blockquote><p>根据上面的未知属性格式可以衍生出 “可索引接口” 专门用来限制长度未知的数组、属性名和属性个数未知的对象。</p><p><strong>可索引接口限制数组和对象：</strong></p><figure class="highlight ts"><figcaption><span>限制数组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userArr: UserInterface = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">userArr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">1</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面的数组 <code>userArr</code> 内的的索引为数字类型，满足可索引接口的要求，但是使用 <code>UserInterface</code> 约束后，所有项必须是字符串，如果改成其他类型则会报错。</p><figure class="highlight ts"><figcaption><span>限制对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInterface &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userObj: UserInterface = &#123;</span><br><span class="line">  jim: <span class="string">'1'</span>,</span><br><span class="line">  bob: <span class="string">'2'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的对象 <code>userObj</code> 使用 <code>UserInterface</code> 约束后，键和值必须都为字符串，否则报错。</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口的继承同类的继承相同，使用 <code>extends</code> 关键字实现，下面是一段接口继承的代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父接口</span></span><br><span class="line"><span class="keyword">interface</span> Speakable &#123;</span><br><span class="line">  speak(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子接口</span></span><br><span class="line"><span class="keyword">interface</span> SpeakChinese <span class="keyword">extends</span> Speakable &#123;</span><br><span class="line">  speakChinese(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现接口</span></span><br><span class="line"><span class="keyword">class</span> ChinesePerson <span class="keyword">implements</span> SpeakChinese &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'speak'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  speakChinese() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你好'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>当类实现的接口继承了其他的接口，那这个类的内部需要同时实现子接口和父接口的属性和方法。</strong></p></blockquote><h3 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h3><p>函数型接口专门对函数或方法传入的参数和返回值进行约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Discount &#123;</span><br><span class="line">  (price: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dFun: Discount = discount;</span><br></pre></td></tr></table></figure><p>上面代码中 <code>Discount</code> 接口内部括号内代表参数类型定义，后面代表返回值类型，函数 <code>discount</code> 定义的参数和返回值类型必须与 <code>Discount</code> 接口内部定义的类型保持一致。</p><h3 id="构造函数型接口"><a href="#构造函数型接口" class="headerlink" title="构造函数型接口"></a>构造函数型接口</h3><p>在 <code>TS</code> 中存在对构造函数或类的实例化的类型约束，即在执行 <code>new</code> 操作的时候进行约束检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被约束实例化动作的类</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束实例化的接口</span></span><br><span class="line"><span class="keyword">interface</span> WithNameClazz &#123;</span><br><span class="line">  <span class="keyword">new</span> (name: <span class="built_in">string</span>): Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnimal</span>(<span class="params">clazz: WithNameClazz, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> clazz(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = createAnimal(Animal, <span class="string">'hellop'</span>);</span><br></pre></td></tr></table></figure><p>上面代码的 <code>interface</code> 中，<code>new</code> 代表约束的动作为实例化操作，<code>name</code> 为参数，<code>string</code> 为参数的类型，而 <code>Animal</code> 代表返回值需要是一个 <code>Animal</code> 类的实例。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>“泛型” 是指在定义函数、接口和类的时候，不预先指定具体的类型，而在使用的时候再进行指定的一种特性。</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>在介绍泛型函数之前先创建一个普通的函数，参数为长度和值，返回一个长度为传入长度、内部元素都为传入值的数组。</p><figure class="highlight ts"><figcaption><span>为使用泛型定义的函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">len: <span class="built_in">number</span>, val: <span class="built_in">any</span></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: <span class="built_in">any</span>[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result[i] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray(<span class="number">3</span>, <span class="string">'x'</span>)); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><p>在上面函数中我们类型都是提前进行定义，包括参数、返回值和函数内部变量，这样如果函数内给数组每一项赋值操作没有使用 <code>val</code> 参数传入的值，而是使用其他值，这样无法进行限定，下面使用泛型重新编写上面的函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">len: <span class="built_in">number</span>, val: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result[i] = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="number">1</span>)); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面的 <code>T</code> 是泛型的占位符，代表 <code>Type</code> 的意思，也可以使用其他字母代替（类比函数的形参），真正定义类型的时候是在函数调用时传入的。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyArray&lt;T&gt; &#123;</span><br><span class="line">  list: T[] = [];</span><br><span class="line">  add(val: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">  getFirst(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = <span class="keyword">new</span> MyArray&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myArray.add(<span class="number">1</span>);</span><br><span class="line">myArray.add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray.getFirst());</span><br></pre></td></tr></table></figure><p>泛型类与泛型函数相似，都是通过占位符 <code>T</code> 占位，在真正实例化的时候传入类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>上面接口一节中接口内部属性及函数型接口等，成员类型也可以使用泛型进行约束，在某个具体的对象使用接口或类实现接口时传入具体类型，下面是一个函数型接口使用泛型的例子。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SUM&lt;T&gt; &#123;</span><br><span class="line">  (a: T, b: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum2: SUM&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="keyword">function</span> (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>泛型占位符（上面为 <code>T</code>）只在约束的函数、类和接口内部可以使用，可类比函数的形参。</strong></p></blockquote><h3 id="默认泛型类型"><a href="#默认泛型类型" class="headerlink" title="默认泛型类型"></a>默认泛型类型</h3><p>默认泛型类型指的是定义泛型的默认值，被约束的函数、类或者接口在使用时不传入具体类型，则会使用默认类型，编译时会检查是否符合这个默认类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyArray&lt;T = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  list: T[] = [];</span><br><span class="line">  add(val: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = <span class="keyword">new</span> MyArray();</span><br><span class="line">myArray.add(<span class="number">1</span>);</span><br><span class="line">myArray.add(<span class="string">'a'</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="定义多个泛型"><a href="#定义多个泛型" class="headerlink" title="定义多个泛型"></a>定义多个泛型</h3><p>上面的泛型中都只使用了一个占位符 <code>T</code>，其实泛型是允许有多个的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt;(<span class="params">tuple: [A, B]</span>): [<span class="title">B</span>, <span class="title">A</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(swap&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;([<span class="string">'a'</span>, <span class="number">1</span>])); <span class="comment">// [1, 'a']</span></span><br></pre></td></tr></table></figure><p>上面方法中定义了两个泛型，函数参数为一个元组类型的数组，函数返回值为两项交换后的数组。</p><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><p>在函数或类中使用泛型，由于预先不知道泛型的具体类型，所以不能随便使用泛型约束变量的属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span>&gt;(<span class="params">val: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h3><p>如果一定要在函数或类中使用泛型约束变量的属性和方法时，可以预先通过接口定义使用的属性和方法，再通过泛型去继承这个接口即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> LengthWise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">LengthWise</span>&gt;(<span class="params">val: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger&lt;<span class="built_in">number</span>&gt;(<span class="string">'hello'</span>); <span class="comment">// 报错</span></span><br><span class="line">logger&lt;<span class="built_in">string</span>&gt;(<span class="string">'hello'</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="泛型的流程控制"><a href="#泛型的流程控制" class="headerlink" title="泛型的流程控制"></a>泛型的流程控制</h3><p>在定义泛型的时候能够加入逻辑分支，可以使泛型更加灵活。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  nameFish: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Water &#123;</span><br><span class="line">  nameWater: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  nameBird: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sky &#123;</span><br><span class="line">  nameSky: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Condition&lt;T&gt; = T <span class="keyword">extends</span> Fish ? Water : Sky;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> con: Condition&lt;Fish&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了四个接口 <code>Fish</code>、<code>Bird</code>、<code>Water</code> 和 <code>Sky</code>，定义一个 <code>Condition</code> 类型和泛型，如果泛型为 <code>Fish</code> 则继承 <code>Water</code>，否则继承 <code>Sky</code>，在变量 <code>con</code> 使用类型 <code>Condition</code> 时，传入 <code>Fish</code> 接口。</p><h3 id="泛型的别名"><a href="#泛型的别名" class="headerlink" title="泛型的别名"></a>泛型的别名</h3><p>泛型可以使用 <code>type</code> 关键字定义别名，还记得在基本数据类型一节数组的定义中有泛型的定义方式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br></pre></td></tr></table></figure><p>其实上面的 <code>Array</code> 就是定义泛型的别名，<code>&lt;string&gt;</code> 则是在调用这个泛型时传入的具体类型，看了下面例子就明白了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型别名</span></span><br><span class="line"><span class="keyword">type</span> Cart&lt;T&gt; = &#123; list: T[] &#125; | T[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型别名</span></span><br><span class="line"><span class="keyword">let</span> cart1: Cart&lt;<span class="built_in">string</span>&gt; = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">let</span> cart2: Cart&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  list: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>JS</code> 中有很多类数组对象，如 <code>arguments</code>、获取的 <code>DOM</code> 元素集合等等，每一种类数组对象 <code>TS</code> 都定义了对应的泛型别名，下面看两个案例。</p><figure class="highlight ts"><figcaption><span>arguments 对象的泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> params: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">    result += params[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>DOM 节点类数组对象的泛型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">let</span> children: HTMLCollection = root.children;</span><br><span class="line"><span class="keyword">let</span> childNodes: NodeListOf&lt;ChildNode&gt; = root.childNodes;</span><br></pre></td></tr></table></figure><p>上面用来定义 <code>arguments</code> 类数组对象的泛型别名为 <code>IArguments</code>，获取 <code>DOM</code> 节点的元素节点集合的泛型别名为 <code>HTMLCollection</code>，而全部子节点的泛型别名为 <code>NodeListOf&lt;ChildNode&gt;</code>，如果使用 <code>VSCode</code> 编辑器，可以将鼠标放在变量前面会自动提示对应的泛型别名。</p><blockquote class="pullquote info"><p><strong>接口和泛型别名的区别：</strong></p><ul><li><strong>接口会创建一个新的名称，而别名不会（只是用 <code>type</code> 关键字创建了一个变量）；</strong></li><li><strong>别名不能被继承和实现；</strong></li><li><strong>定义一个类型的时候使用接口，要使用联合类型或者元组类型时，类型别名会更合适。</strong></li></ul></blockquote><h2 id="结构类型系统"><a href="#结构类型系统" class="headerlink" title="结构类型系统"></a>结构类型系统</h2><p>如果传入的变量和声明的类型不匹配，<code>TS</code> 会进行兼容性检查，不是基于定义的类型名称来决定的，而是基于类型的组成结构。</p><h3 id="基本数据类型的兼容性"><a href="#基本数据类型的兼容性" class="headerlink" title="基本数据类型的兼容性"></a>基本数据类型的兼容性</h3><p>基本数据类型也有兼容性判断，如果赋值过程中右侧值的类型符合左侧值的类型，则不会报错，如果左侧类型定义含有 <code>toString</code> 方法的约束，则右侧值凡是可以通过 <code>toString</code> 转换成字符串的都不会报错，赋值时如果右侧值传入的属性多余左侧定义的值时也会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> str1: <span class="built_in">string</span>;</span><br><span class="line">num1 = str1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num2: &#123;</span><br><span class="line">  toString(): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str2: <span class="built_in">number</span>;</span><br><span class="line">num2 = str2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="string">'male'</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="枚举的兼容性"><a href="#枚举的兼容性" class="headerlink" title="枚举的兼容性"></a>枚举的兼容性</h3><p>默认的枚举类型与数字类型兼容，数字类型与枚举类型兼容，不同的枚举类型之间是不兼容的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  RED,</span><br><span class="line">  YELLOW,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容数字类型</span></span><br><span class="line"><span class="keyword">let</span> colorRed: <span class="built_in">number</span> = Colors.RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容枚举类型</span></span><br><span class="line"><span class="keyword">let</span> colorYello: Colors;</span><br><span class="line">colorYello = Colors.Red;</span><br><span class="line">colorYello = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="函数的兼容性"><a href="#函数的兼容性" class="headerlink" title="函数的兼容性"></a>函数的兼容性</h3><p>比较函数的兼容性时要先比较函数的参数，再比较函数的返回值。</p><h4 id="参数的兼容性"><a href="#参数的兼容性" class="headerlink" title="参数的兼容性"></a>参数的兼容性</h4><figure class="highlight ts"><figcaption><span>参数的类型比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SumFunc = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> sum: SumFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错的赋值</span></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错的赋值</span></span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的类型检查可以兼容少传参数或不传参数，但是多传参数会报错。</p><h4 id="参数的双向协变"><a href="#参数的双向协变" class="headerlink" title="参数的双向协变"></a>参数的双向协变</h4><p>参数的双向协变是指变量定义的参数类型去兼容变量赋值定义的参数类型，或者变量赋值的参数类型去兼容定义的参数类型，只要有一个成立即可，所谓兼容必须是包含的关系。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogFunc = <span class="function">(<span class="params">val: <span class="built_in">number</span> | <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> log: LogFunc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量定义类型兼容赋值定义类型</span></span><br><span class="line">log = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量赋值类型兼容变量定义的类型</span></span><br><span class="line">log = <span class="function"><span class="keyword">function</span> (<span class="params">val: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回值的兼容性"><a href="#返回值的兼容性" class="headerlink" title="返回值的兼容性"></a>返回值的兼容性</h4><figure class="highlight ts"><figcaption><span>返回值的类型比较</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetPerson = <span class="function"><span class="params">()</span> =&gt;</span> &#123; name: <span class="built_in">string</span>, age: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> getPerson: GetPerson;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错的赋值</span></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span>, age: <span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span>, age: <span class="number">20</span>, gender: <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错的赋值</span></span><br><span class="line">getPerson = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">'hello'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能调用 age 属性的方法</span></span><br><span class="line">getPerson().age.toFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>返回值可以兼容多返回的属性，属性少了会报错，因为可能会调用返回值缺失属性的方法。</p><h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">let</span> c1: Child = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Parent = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">let</span> c2: Child = <span class="keyword">new</span> Parent(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>父类和子类能不能赋值给限制了父类或子类泛型的变量，能不能赋值和是父类或子类没任何关联，主要看属性是否满足，而上面 <code>p2</code> 没有报错的原因是子类的实例继承了父类的属性，所以提供了父类泛型所要求的属性，而 <code>c2</code> 报错是因为父类的实例并没有提供子类泛型要求的属性。</p><h3 id="接口的兼容性"><a href="#接口的兼容性" class="headerlink" title="接口的兼容性"></a>接口的兼容性</h3><p>在检查参数类型时，并不是真正的比较接口类型，而是比较具体的属性是否兼容。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Person = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">a: Animal</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName(p); <span class="comment">// hello;</span></span><br></pre></td></tr></table></figure><p>上面的代码中定义了两个接口 <code>Animal</code> 和 <code>Person</code>，<code>Person</code> 定义的属性更多，当一个符合 <code>Person</code> 的对象传给参数用 <code>Animal</code> 约束的函数时，检测的是接口的属性，只要提供的属性不比约束的属性少，则不会报错。</p><h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><p>泛型在判断兼容性的时候会先判断具体类型，再进行兼容性的判断，即用到了就会比较，没用到就不会比较。</p><figure class="highlight ts"><figcaption><span>空接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>属性使用了泛型的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">x = y; <span class="comment">// 报错，因为 number 类型的属性不能赋值给 string 类型的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">interface</span> NotEmptyString&#123;</span><br><span class="line">  data: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NotEmptyNumber&#123;</span><br><span class="line">  data: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xString: NotEmptyString;</span><br><span class="line"><span class="keyword">let</span> yNumber: NotEmptyNumber;</span><br><span class="line">xString = yNumber; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>类型保护就是一些表达式在编译时，能通过类型信息确保某个具体作用域内变量的类型。</p><h3 id="typeof-和-instanceof-类型保护"><a href="#typeof-和-instanceof-类型保护" class="headerlink" title="typeof 和 instanceof 类型保护"></a>typeof 和 instanceof 类型保护</h3><figure class="highlight ts"><figcaption><span>typeof 类型保护</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val.repeat(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法因为使用 <code>typeof</code> 做了类型判断，所以分别在 <code>if</code> 判断的作用域内 <code>val</code> 的值会变成判断后对应的类型，可以调用类型对应的方法，而在判断的外面无法确认值的类型，调用方法编译时报错。</p><figure class="highlight ts"><figcaption><span>instanceof 类型保护</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bird &#123;</span><br><span class="line">  nameBird: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">  nameDog: stirng;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.nameBird;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.nameDog;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>typeof</code> 类似，使用 <code>instanceof</code> 判断了函数 <code>getName</code> 是否是 <code>Bird</code> 和 <code>Dog</code> 类的实例，判断的作用域内可以获取判断结果对应类上定义的属性。</p><h3 id="null-类型保护"><a href="#null-类型保护" class="headerlink" title="null 类型保护"></a>null 类型保护</h3><p>之前我们提到过在 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性设置为 <code>true</code> 时，则会对 <code>null</code> 进行严格检查，此时下面代码将会报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的报错就是由于对 <code>null</code> 的类型保护引起的，有如下解决方法。</p><figure class="highlight ts"><figcaption><span>方法一</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>方法二</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式第一种是通过设置初始值的方式来保证在调用字符串方法时 <code>str</code> 的值已经是一个字符串类型，第二种则是通过判断直接返回，没有走到调用字符串方法的代码，类型检查自然不会报错，下面还有一个稍微复杂的案例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str.tirm()); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  log();</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>str</code> 调用 <code>tirm</code> 方法的代码封装在了函数 <code>log</code> 内部，当 <code>log</code> 调用时 <code>str</code> 的值已经变为了字符串，但是还是报错了，原因是代码编译阶段由上至下一行一行解析，所以解析函数 <code>log</code> 的时候就已经在函数内部报错了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstLetter</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str!.tirm());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  log();</span><br><span class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在 <code>log</code> 函数中，<code>str</code> 调用 <code>tirm</code> 方法时加了一个 <code>!</code>，意思为强行调用，不管类型是否符合都会调用，相当于忽略了函数 <code>getFirstLetter</code> 的参数类型检查。</p><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>上面的强制调用方式虽然通能过编译，但是在运行时有报错的风险，应该慎用，在 <code>JS</code> 中有一个提案叫链判断运算符，针对上面情况，会先判断是否为字符串再去调用字符串方法，这样写起来比较繁琐，而链判断运算符就是用来解决这个问题，通过 <code>?.</code> 来调用。</p><figure class="highlight js"><figcaption><span>链判断运算符的几种用法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a?.b;</span><br><span class="line"><span class="comment">// 如果 a 不含有 b 属性则返回 undefined，否则返回 a.b，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b;</span><br><span class="line"></span><br><span class="line">a?.[b];</span><br><span class="line"><span class="comment">// 如果 a 不含有键为 b 变量值的属性则返回 undefined，否则返回 a[b]，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[b];</span><br><span class="line"></span><br><span class="line">a?.b()</span><br><span class="line"><span class="comment">// 如果 a 不含 b 属性则返回 undefined，否则执行 a.b()</span></span><br><span class="line"><span class="comment">// 如果 a.b 不是一个函数抛出类型错误，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b();</span><br><span class="line"></span><br><span class="line">a?.()</span><br><span class="line"><span class="comment">// 如果 a 不是函数则返回 undefined，否则执行 a()，等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a();</span><br></pre></td></tr></table></figure><h3 id="可辨识的联合类型"><a href="#可辨识的联合类型" class="headerlink" title="可辨识的联合类型"></a>可辨识的联合类型</h3><p>可辨识的联合类型是指，通过联合类型中的共同属性进行类型保护的一种技巧，通过同属性值的判断可以确定联合类型中的具体类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> WarningButton &#123;</span><br><span class="line">  <span class="keyword">class</span>: <span class="string">'warning'</span>;</span><br><span class="line">  name1: <span class="string">'modified'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> DangerButton &#123;</span><br><span class="line">  <span class="keyword">class</span>: <span class="string">'danger'</span>;</span><br><span class="line">  name2: <span class="string">'delete'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义联合类型</span></span><br><span class="line"><span class="keyword">type</span> Button = WarningButton | DangerButton;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getButton</span>(<span class="params">button: Button</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (button.class === <span class="string">'warning'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> button.name1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (button.class === <span class="string">'danger'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> button.name2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h3><p>在可辨识的联合类型中如果没有共同的属性，共同属性判断不同值区分的方法行不通，这时可以用 <code>in</code> 操作符和不同属性判断进行类型保护。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  talon: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'talon'</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.talon);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'leg'</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.leg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p><code>TS</code> 中的上面用到的类型保护大部分为表达式，其实可以不使用这些表达式，通过自定义类型保护函数的方式实现同样的效果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  talon: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型保护函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBird</span>(<span class="params">animal: Bird | Dog</span>): <span class="title">animal</span> <span class="title">is</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// return (animal as Bird).talon &gt; 0;</span></span><br><span class="line">  <span class="keyword">return</span> (&lt;Bird&gt;animal).talon &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">animal: Bird | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isBird(animal)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.talon);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.leg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的自定义保护函数 <code>isBird</code> 中参数类型与 <code>getNumber</code> 参数一致，返回值的 <code>animal is Bird</code> 是一个类型谓词，语法为 <code>param is type</code>，代表返回是否满足 <code>Bird</code> 接口，由于 <code>animal</code> 并不知道自己符合哪一个接口，所以使用类型断言指定成了 <code>Bird</code>，<code>isBird</code> 代码中注释和非注释两种方式都可以实现类型断言，这样自定义类型检查函数 <code>isBird</code> 就可以在 <code>getNumber</code> 中使用并实现类型保护。</p><h2 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型表示为将多个类型合并为一个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取的是接口的并集</span></span><br><span class="line"><span class="keyword">type</span> BirdMan = Bird &amp; Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口必须包含两个接口所有的属性和方法</span></span><br><span class="line"><span class="keyword">let</span> birdMan: BirdMan = &#123;</span><br><span class="line">  name: <span class="string">'niao'</span>,</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fly'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="typeof-获取类型"><a href="#typeof-获取类型" class="headerlink" title="typeof 获取类型"></a>typeof 获取类型</h3><p>在 <code>TS</code> 使用时如果数据内容在变化，要不停的更改对应的接口，此时可以使用 <code>typeof</code> 关键字快速获取一个变量的类型。</p><figure class="highlight ts"><figcaption><span>先定义类型，后定义变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><figcaption><span>先定义变量，后定义接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People = <span class="keyword">typeof</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">p: People</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取的类型定义 <code>People</code> 是根据 <code>p</code> 对象的属性和值生成，然后可以使用获取的类型去限制其他对象。</p><h3 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h3><p><code>TS</code> 中的索引访问操作符指可以通过 <code>[]</code> 获取一个类型的子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义嵌套类型接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 对象，包含 name 属性</span></span><br><span class="line">  job: &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 成员为对象组成的数组，对象中含有 name 和 level 属性</span></span><br><span class="line">  hobbies: &#123; name: <span class="built_in">string</span>; level: <span class="built_in">number</span> &#125;[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Person 接口 job 对象中 name 属性的类型定义为 FEJob 的类型</span></span><br><span class="line"><span class="keyword">let</span> FEJob: Person[<span class="string">"job"</span>] = &#123;</span><br><span class="line">  name: <span class="string">"FE"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中任意一项中 level 属性的类型作为 hobbyLevel 的类型</span></span><br><span class="line"><span class="keyword">let</span> hobbyLevel: Person[<span class="string">'hobbies'</span>][<span class="number">0</span>][<span class="string">'level'</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p><code>TS</code> 中定义的关键字 <code>keyof</code> 是索引类型查询操作符，用来定义类型，当定义一个获取对象属性值的函数，传入的值为对象和属性名，这样属性名参数的类型定义为 <code>string</code> 不准确，因为很可能传入一个对象本身没有的属性字符串，<code>keyof</code> 就是用来解决类似这样问题的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">'male'</span> | <span class="string">'female'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 keyof 定义类型</span></span><br><span class="line"><span class="keyword">type</span> PersonKey = keyof Person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValueByKey</span>(<span class="params">p: Person, key: PersonKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>: person: Person = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getValueByKey(person, <span class="string">'name'</span>); <span class="comment">// hello</span></span><br><span class="line">getValueByKey(person, <span class="string">'say'</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>在某一个类型定义中使用 <code>in</code> 操作符和 <code>keyof</code> 操作符批量映射修改一个新的类型定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">'male'</span> | <span class="string">'female'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射 Person 接口定义的类型，把每一个属性都变成可选的</span></span><br><span class="line"><span class="keyword">type</span> PartPerson = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof Person]?: Person[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: PartPerson = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中 <code>keyof Person</code> 取到了 <code>Person</code> 接口的每一个属性的类型，<code>key</code> 通过运算符 <code>in</code>（批量映射）代表获取的每一个属性名，<code>?:</code> 代表可选，<code>Person[key]</code> 代表对应的值。</p><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p>在 <code>TS</code> 内部内置了一些工具类型来帮助我们更好、更方便的使用类型系统。</p><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p><code>Partial</code> 可以将传入类型定义的属性由非可选变为可选，功能跟映射类型一节实现的功能非常相似，只是具体被映射的类型是通过参数传入的，所以底层是使用泛型实现的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Partial</span></span><br><span class="line"><span class="keyword">let</span> p: Partial&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial 的原理</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]?: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p><code>Required</code> 可以将传入类型定义的属性变为必选，使用 <code>-?:</code> 替换原有的 <code>:</code> 也可以实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Required</span></span><br><span class="line"><span class="keyword">let</span> p: Required&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Required 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyRequired&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]-?: T[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p><code>Readonly</code> 可以将传入类型定义的属性每一项都加上 <code>readonly</code> 修饰符来实现属性的只读。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Readonly</span></span><br><span class="line"><span class="keyword">let</span> p: Readonly&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  age: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'world'</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Readonly 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [key <span class="keyword">in</span> keyof T]: T[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p><code>Pick</code> 可以摘取传入类型定义的属性中的某一项返回。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Pick</span></span><br><span class="line"><span class="keyword">let</span> p: Pick&lt;Person, <span class="string">'name'</span>&gt; = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick 的原理</span></span><br><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> K]: T[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置条件类型"><a href="#内置条件类型" class="headerlink" title="内置条件类型"></a>内置条件类型</h3><p>还记得在泛型一节中提到了泛型的流程控制，在 <code>TS</code> 中内置了一些常用的条件类型。</p><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">Exclude&lt;T, U&gt; <span class="comment">// 从 T 可分配给的类型中排除 U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">Extract&lt;T, U&gt; <span class="comment">// 从 T 可分配的类型中提取 U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = Extract&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="number">10</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">NonNullable&lt;T&gt; <span class="comment">// 从 T 中排除 null 和 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> E = NonNullable&lt;<span class="built_in">string</span> | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">let</span> x: E = <span class="literal">null</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> y: E = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">ReturnType&lt;T&gt; <span class="comment">// 获取函数类型的返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">"hello"</span>, age: <span class="number">10</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo = ReturnType&lt;<span class="keyword">typeof</span> getUserInfo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: UserInfo = &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">InstanceType&lt;T&gt; <span class="comment">// 获取构造函数类型的实例类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name</span>) &#123;&#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P = InstanceType&lt;<span class="keyword">typeof</span> Person&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: P = &#123;</span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'myName'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/16/20190416160637/#disqus_thread</comments>
    </item>
    
    <item>
      <title>NodeJS 实现一个提交自动检测的 Git Hook</title>
      <link>https://www.overtaking.top/2019/04/09/20190409024640/</link>
      <guid>https://www.overtaking.top/2019/04/09/20190409024640/</guid>
      <pubDate>Mon, 08 Apr 2019 18:46:40 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/04/09/20190409024640/git-hooks-location.png&quot; title=&quot;Git Hook&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-Git-Hook&quot;&gt;&lt;a href=&quot;#什么是-Git-Hook&quot; class=&quot;headerlink&quot; title=&quot;什么是 Git Hook&quot;&gt;&lt;/a&gt;什么是 Git Hook&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;Git Hook&lt;/code&gt; 是能在 &lt;code&gt;Git&lt;/code&gt; 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 &lt;code&gt;.git/hooks&lt;/code&gt; 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 &lt;code&gt;.sample&lt;/code&gt;，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/04/09/20190409024640/git-hooks-location.png" title="Git Hook"><p><br></p><h2 id="什么是-Git-Hook"><a href="#什么是-Git-Hook" class="headerlink" title="什么是 Git Hook"></a>什么是 Git Hook</h2><blockquote class="pullquote info"><p><code>Git Hook</code> 是能在 <code>Git</code> 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 <code>.git/hooks</code> 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 <code>.sample</code>，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。</p></blockquote><a id="more"></a><h2 id="实现-Hook-功能介绍"><a href="#实现-Hook-功能介绍" class="headerlink" title="实现 Hook 功能介绍"></a>实现 Hook 功能介绍</h2><p>本次将使用 <code>NodeJS</code> 实现一个 <code>Git Hook</code>，功能为在提交代码之前检测功能如下：</p><ul><li>检测是否为 <code>Git</code> 项目；</li><li>检测邮箱是否符合规格；</li><li>检测代码是否含有冲突；</li><li>自动执行 <code>Eslint</code>，并检测问题。</li></ul><h2 id="需求的由来"><a href="#需求的由来" class="headerlink" title="需求的由来"></a>需求的由来</h2><p>在开始代码的编写之前，一定要清楚，团队开发时为什么需要这样的 <code>hook</code>，下面列举的场景，可能都会对团队项目持续集成的历史树造成污染，或在协同开发时对团队成员造成麻烦。</p><p><strong>邮箱错误：</strong>当团队 <code>Gitlab</code> 仓库对邮箱格式进行了严格的限制，必须为公司邮箱才可以进行推送，这样很可能导致邮箱配错时进行了提交，而推送时发现邮箱错了，要对本地的 <code>commit</code> 记录修正，再重新进行推送。</p><blockquote class="pullquote warning"><p><strong>容易造成邮箱设置错误的常见原因：</strong></p><ul><li><strong>维护不同团队的开源项目太多，不同项目需要配置不同的邮箱，很可能导致邮箱配置错误；</strong></li><li><strong>当团队中有外包开发人员，且由于权限问题同一套代码是存放在两个仓库，正式员工需要在本地项目中通过 <code>remote</code> 来同时指定两个仓库地址，并在本地代码修改后拉取外包仓库的代码进行合并，同时同步到正式仓库和外包仓库，如果正式仓库对推送过来的提交邮箱格式进行了严格的限制，并且外包提交记录的邮箱错误，就导致正式员工合并后的提交被正式仓库拒绝，如果使用 <code>rebase</code> 强行修正错误的邮箱，变基后的 <code>commit</code> 哈希发生变化可能与远端仓库不一致，需要进行强推到两个仓库，并全员的本地回滚到变基之前。</strong></li></ul></blockquote><p><strong>代码冲突：</strong>开发时和其他人同时修改了相同部分造成冲突，如果冲突不能及时被发现，提交并推送到远端是对远端仓库的污染，也可能其他开发人员正好拉取了这样的代码，会对团队造成麻烦。</p><blockquote class="pullquote danger"><p><strong>容易造成冲突未及时处理的原因：</strong></p><ul><li><strong>项目过大，文件较多；</strong></li><li><strong>编辑器不智能；</strong></li><li><strong>前端项目使用了路由懒加载，不切换到冲突代码所在的路由，项目不会报错。</strong></li></ul></blockquote><p><strong>Eslint：</strong>有些团队的项目对代码规范要求高，并为了减小线上 <code>Bug</code> 率，会在项目中集成 <code>Eslint</code> 对代码风格进行检查，通常都是在命令行手动执行检测命令，有些时候可能忘记执行命令进行检测，就将代码进行了提交和推送。</p><blockquote class="pullquote default"><p>为了规避上面的情况，所以才有了这次关于 <code>Git Hook</code> 的需求，以及下面的代码实现，目的是防患于未然，将大家在开发时容易犯的错误或对项目代码持续集成和管理的潜在风险扼杀在摇篮中。</p></blockquote><h2 id="目录结构及文件简介"><a href="#目录结构及文件简介" class="headerlink" title="目录结构及文件简介"></a>目录结构及文件简介</h2><p><pre>git-hooks<br>  |- default-events.js<br>  |- default-rules.js<br>  |- git-checker.js<br>  |- pre-commit.js</pre></p><ul><li><code>default-events.js</code>：用来编写默认的检测事件；</li><li><code>default-rules.js</code>：用来管理默认检测事件用到的规则（正则）；</li><li><code>git-checker.js</code>：用来构建 <code>Hook</code> 的核心逻辑；</li><li><code>pre-commit.js</code>：用来编写执行检测的调用逻辑。</li></ul><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在编写这个 <code>hook</code> 之前需要用到一个第三方模块 <a href="https://www.npmjs.com/package/husky" target="_blank">husky</a>，这个模块的作用是根据项目中 <code>package.json</code> 的配置来向 <code>.git/hooks</code> 中的脚本写入我们的逻辑，项目中需要安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky</span><br></pre></td></tr></table></figure><h2 id="代码设计思路分析"><a href="#代码设计思路分析" class="headerlink" title="代码设计思路分析"></a>代码设计思路分析</h2><p>设计这个 <code>hook</code> 时提供了 <code>Git</code> 目录检测、邮箱验证、冲突检测、和执行 <code>Eslint</code> 的功能，当然我们希望检测函数不是强制的，是可以选择性使用，而使用者也可以编写自己需要的检测函数来覆盖其他的场景。</p><p>我们希望项目中的 <code>husky</code> 配置如下：</p><figure class="highlight"><figcaption><span>使用 hook 项目的 package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "node git-hooks/pre-commit"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>husky</code> 帮我们执行了 <code>git-hooks/pre-commit.js</code> 文件，我们希望使用者的用法如下：</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/pre-commit.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GitChecker = <span class="built_in">require</span>(<span class="string">'./git-checker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commitChecker = <span class="keyword">new</span> GitChecker(<span class="string">'pre-commit'</span>, &#123;</span><br><span class="line">  <span class="comment">// default event names</span></span><br><span class="line">  defaultEventNames: [<span class="string">'isGit'</span>, <span class="string">'email'</span>, <span class="string">'conflict'</span>, <span class="string">'eslint'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// your costom rules</span></span><br><span class="line">  &#125;,</span><br><span class="line">  checkEvents: &#123;</span><br><span class="line">    <span class="comment">// your custom check events</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">commitChecker.checkStart();</span><br></pre></td></tr></table></figure><p>上面的用法通过创建实例来创建 <code>checker</code>，即 “检测者”，调用 <code>checkStart</code> 方法帮助我们检测，创建实例的参数为 <code>options</code>，类型为对象。</p><p>上面的用法既可以让用户通过配置 <code>options</code> 的 <code>defaultEventNames</code> 属性来选择性的使用默认的检测函数，又可以通过 <code>checkEvents</code> 属性来让使用者编写检测函数。</p><p><code>rules</code> 属性是来存放使用者编写检测函数时使用的正则，会和默认检测函数中的正则合并，我们专门用 <code>default-rules.js</code> 文件来管理默认检测函数中使用的正则。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-rules.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  emailCheck: <span class="regexp">/\S+((@youemail\.com)|(@enterprise\.com))(\n|\r\n)*$/</span>,</span><br><span class="line">  conflictCheck: <span class="string">'^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\s'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="GitChecker-类的实现"><a href="#GitChecker-类的实现" class="headerlink" title="GitChecker 类的实现"></a>GitChecker 类的实现</h2><p>我们需要一个工厂创造 “检测者”，取名为 <code>GitChecker</code>，在 <code>GitChecker</code> 中需要使用发布订阅模式，对检测函数进行注册，并在执行实例的 <code>checkStart</code> 方法时依次执行，代码如下。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/git-checker.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultRules = <span class="built_in">require</span>(<span class="string">'./default-rules'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultEvents = <span class="built_in">require</span>(<span class="string">'./default-events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 GitChecker 类并继承 EventEmitter，目的是继承 on 和 emit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitChecker</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止使用者 options 内部属性传错，进行初始化</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      rules = &#123;&#125;,</span><br><span class="line">      defaultEventNames = [],</span><br><span class="line">      checkEvents = &#123;&#125;</span><br><span class="line">    &#125; = options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并默认检测函数使用的正则和用户自定义检测函数使用的正则统一管理</span></span><br><span class="line">    <span class="keyword">this</span>.rules = <span class="built_in">Object</span>.assign(defaultRules, rules);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并用户选择使用的默认检测函数和自定义检测函数</span></span><br><span class="line">    <span class="keyword">this</span>.checkEvents = <span class="built_in">Object</span>.assign(</span><br><span class="line">      <span class="keyword">this</span>.getDefaultEvents(defaultEventNames),</span><br><span class="line">      checkEvents</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.type = type; <span class="comment">// git 操作类型</span></span><br><span class="line">    <span class="keyword">this</span>.isCommit = <span class="literal">true</span>; <span class="comment">// 当前是否可以被提交</span></span><br><span class="line">    <span class="keyword">this</span>.gitConfigEnvs = [<span class="string">'local'</span>, <span class="string">'global'</span>, <span class="string">'system'</span>]; <span class="comment">// 取邮箱时的环境</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将提交状态更改为禁止，绑定 this 是为了防止在检测函数内解构更改指向</span></span><br><span class="line">    <span class="keyword">this</span>.forbiddenCommit = <span class="keyword">this</span>.forbiddenCommit.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.init(); <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="comment">// 将检测函数常用方法挂载到实例上</span></span><br><span class="line">    <span class="keyword">this</span>.log = log;</span><br><span class="line">    <span class="keyword">this</span>.exec = exec;</span><br><span class="line">    <span class="keyword">this</span>.chalk = chalk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册当前类型 git 操作对应的检测函数</span></span><br><span class="line">    <span class="keyword">this</span>.register(<span class="keyword">this</span>.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getDefaultEvents(eventsNames) &#123;</span><br><span class="line">    <span class="keyword">return</span> eventsNames.reduce(<span class="function">(<span class="params">memo, eventName</span>) =&gt;</span> &#123;</span><br><span class="line">      memo[<span class="string">`<span class="subst">$&#123;eventName&#125;</span>CheckTask`</span>] = defaultEvents[<span class="string">`<span class="subst">$&#123;eventName&#125;</span>CheckTask`</span>];</span><br><span class="line">      <span class="keyword">return</span> memo;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  register(type) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.checkEvents).forEach(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 订阅事件，每一个函数传入当前实例，方便取实例上的属性和方法</span></span><br><span class="line">      <span class="keyword">this</span>.on(type, () =&gt; <span class="keyword">this</span>.checkEvents[event](<span class="keyword">this</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forbiddenCommit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isCommit = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> checkStart() &#123;</span><br><span class="line">    log(chalk.green(<span class="string">'开始代码检测'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布执行检测函数</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.emit(<span class="keyword">this</span>.type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束后结束当前 git 操作进程</span></span><br><span class="line">    <span class="keyword">this</span>.checkEnd();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkEnd() &#123;</span><br><span class="line">    <span class="comment">// 如果当前状态为不可提交，则退出进程号不为 0，git 规定</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isCommit) process.exit(<span class="number">1</span>);</span><br><span class="line">    log(chalk.green(<span class="string">'检测通过'</span>));</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = GitChecker;</span><br></pre></td></tr></table></figure><p>在上面的设计中之所以将一些常用方法都挂载在了实例上，目的是为了让使用者编写自定义检测函数时不再需要引入依赖，和更方便的获取实例上的属性、方法，当然也方便了我自己编写默认检测函数。</p><h2 id="默认检测函数的实现"><a href="#默认检测函数的实现" class="headerlink" title="默认检测函数的实现"></a>默认检测函数的实现</h2><p>由于检测工厂 <code>GitChecker</code> 已经将自己创建的 “检测者” 塞入了检测函数的参数中去，那就可以把所有的默认检测函数放入一个 <code>default-events.js</code> 文件中统一管理。</p><h3 id="检测目录是否被-Git-管理"><a href="#检测目录是否被-Git-管理" class="headerlink" title="检测目录是否被 Git 管理"></a>检测目录是否被 Git 管理</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.isGitCheckTask = <span class="function">(<span class="params">&#123; exec, log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行 git 命令，如果跑出异常证明不是一个 git 管理的项目</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(<span class="string">'git status'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    log(chalk.red(<span class="string">'错误：当前不是一个git项目目录'</span>));</span><br><span class="line">    forbiddenCommit(); <span class="comment">// 更改提交状态太为不能提交</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>检测是否为一个 <code>Git</code> 所管理的项目只需执行 <code>git status</code> 来检测一下文件变化，如果抛出异常则说明不被 <code>Git</code> 所管理。</p><h3 id="检测邮箱是否合规"><a href="#检测邮箱是否合规" class="headerlink" title="检测邮箱是否合规"></a>检测邮箱是否合规</h3><blockquote class="pullquote primary"><p>上一个方法使用了从参数解构的方式获取实例属性和方法，为了更便于理解这个方法正常使用参数。</p></blockquote><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">exports.emailCheckTask = <span class="function">(<span class="params">checker</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> checkEmailEnvs = <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取出正则和获取 git 邮箱的环境参数集合</span></span><br><span class="line">    <span class="keyword">const</span> gitConfigEnvs = checker.gitConfigEnvs;</span><br><span class="line">    <span class="keyword">const</span> rules = checker.rules;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取邮箱的 git 命令</span></span><br><span class="line">    <span class="keyword">const</span> command = <span class="string">`git config --<span class="subst">$&#123;gitConfigEnvs[i]&#125;</span> user.email`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取邮箱成功，则校验邮箱是否合规</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> userEmail = checker.exec(command).toString();</span><br><span class="line">      <span class="keyword">const</span> isValidate = rules.emailCheck.test(userEmail);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isValidate) &#123;</span><br><span class="line">        checker.log(checker.chalk.red(<span class="string">'错误：请使用正确的邮箱提交代码'</span>));</span><br><span class="line">        checker.log(checker.chalk.yellow(<span class="string">`你当前的邮箱是：<span class="subst">$&#123;userEmail&#125;</span>`</span>));</span><br><span class="line">        checker.forbiddenCommit();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checker.log(checker.chalk.green(<span class="string">'邮箱校验通过'</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === gitConfigEnvs.length) &#123;</span><br><span class="line">        checker.log(checker.chalk.red(<span class="string">'错误：请设置git的提交邮箱'</span>));</span><br><span class="line">        checker.forbiddenCommit();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checkEmailEnvs(i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  checkEmailEnvs(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p>在 <code>Git</code> 中有三个参数设置邮箱，分别 <code>--local</code>、<code>--global</code>、<code>--system</code>，分别对应项目、用户和系统三个环境，顺序即为获取优先级，所以获取也是如此。</p></blockquote><p>该方法使用了递归的思想实现，从优先级最高的环境开始获取邮箱，如果取到邮箱则进行验证，没取到则选择优先级次之的环境获取，直到取到邮箱为止，若都取不到则提示用户设置邮箱，如果取到邮箱，校验不通过则提示用户当前邮箱，并提醒用户设置正确的邮箱。</p><h3 id="检测冲突"><a href="#检测冲突" class="headerlink" title="检测冲突"></a>检测冲突</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exports.conflictCheckTask = <span class="function">(<span class="params">checker</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对文件进行正则匹配的 git 命令</span></span><br><span class="line">  <span class="keyword">const</span> command = <span class="string">`git grep -n -P -E "<span class="subst">$&#123;rules.conflictCheck&#125;</span>"`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有成功匹配，则抛出异常，成功匹配打印冲突代码</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> conflicts = checker.exec(command, &#123; <span class="attr">encoding</span>: <span class="string">'utf-8'</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (conflicts) &#123;</span><br><span class="line">      checker.log(checker.chalk.red(<span class="string">'错误：发现冲突，请解决后再提交'</span>));</span><br><span class="line">      checker.log(checker.chalk.red(<span class="string">'错误代码：'</span>));</span><br><span class="line">      checker.log(checker.chalk.red(conflicts.trim()));</span><br><span class="line">      checker.forbiddenCommit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    checker.log(checker.chalk.green(<span class="string">'未发现冲突'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p>在上面的 <code>Git</code> 命令中，<code>-n</code> 为显示匹配文件的行号，因为 <code>shell</code> 的正则支持不全，<code>-P</code> 和 <code>-E</code> 是为了支持正则扩展，保证正则生效。</p></blockquote><h3 id="执行-Eslint"><a href="#执行-Eslint" class="headerlink" title="执行 Eslint"></a>执行 Eslint</h3><figure class="highlight js"><figcaption><span>&#126;git-hooks/default-events.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.eslintCheckTask = <span class="function">(<span class="params">&#123; exec, log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    exec(<span class="string">'lint-staged'</span>);</span><br><span class="line">    log(chalk.green(<span class="string">'Eslint 校验通过'</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    log(chalk.red(<span class="string">'错误：Eslint 校验不通过'</span>));</span><br><span class="line">    forbiddenCommit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><code>Eslint</code> 本身具备检测冲突的功能，检测冲突的函数更适用于没有集成 <code>Eslint</code> 的项目，如果项目已经集成了 <code>Eslint</code> 可以不适用检测冲突函数。</p></blockquote><h2 id="关于扩展"><a href="#关于扩展" class="headerlink" title="关于扩展"></a>关于扩展</h2><p>当需求变更，需要在 <code>push</code> 之间执行某些脚本应该怎么办，可以在 <code>git-hooks</code> 文件夹增加一个 <code>pre-push.js</code> 文件，文件内容如下。</p><figure class="highlight js"><figcaption><span>&#126;git-hooks/pre-push.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GitChecker = <span class="built_in">require</span>(<span class="string">'./git-checker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pushChecker = <span class="keyword">new</span> GitChecker(<span class="string">'pre-push'</span>, &#123;</span><br><span class="line">  defaultEventNames: [<span class="string">'isGit'</span>, <span class="string">'email'</span>], <span class="comment">// default event names</span></span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// your costom rules</span></span><br><span class="line">  &#125;,</span><br><span class="line">  checkEvents: &#123;</span><br><span class="line">    myHook: <span class="function">(<span class="params">&#123; log, chalk, forbiddenCommit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      log(chalk.red(<span class="string">'check prev push'</span>));</span><br><span class="line">      forbiddenCommit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">commitChecker.checkStart();</span><br></pre></td></tr></table></figure><p>由于我们的 <code>hook</code> 依赖于 <code>husky</code>，所以项目 <code>package.json</code> 中的 <code>husky</code> 也有所修改如下。</p><figure class="highlight"><figcaption><span>使用 hook 项目的 package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "node git-hooks/pre-commit",</span><br><span class="line">      "pre-push": "node git-hooks/pre-push"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote class="pullquote success"><p>以上就是本次 <code>Git Hook</code> 的使用场景和实现，也希望通过本文，能让大家对 <code>Git Hook</code> 的相关知识有一定了解，另附赠 <code>Github</code> 地址 <a href="https://github.com/shenqiuhui/git-hooks/tree/master" target="_blank">https://github.com/shenqiuhui/git-hooks/tree/master</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/04/09/20190409024640/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之 Github 团队协作</title>
      <link>https://www.overtaking.top/2019/03/27/20190327025116/</link>
      <guid>https://www.overtaking.top/2019/03/27/20190327025116/</guid>
      <pubDate>Tue, 26 Mar 2019 18:51:16 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/03/27/20190327025116/github.jpeg&quot; title=&quot;Github 团队协作&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;Github-的由来&quot;&gt;&lt;a href=&quot;#Github-的由来&quot; class=&quot;headerlink&quot; title=&quot;Github 的由来&quot;&gt;&lt;/a&gt;Github 的由来&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; 的诞生是由于 &lt;code&gt;Git&lt;/code&gt; 的局限性，尽管当时 &lt;code&gt;Git&lt;/code&gt; 对于代码的管理以及团队协作方面已经非常出色，但是 &lt;code&gt;Git&lt;/code&gt; 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 &lt;code&gt;Git&lt;/code&gt; 特性的代码平台的诉求成为必然，&lt;code&gt;Github&lt;/code&gt; 就这样诞生了。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/27/20190327025116/github.jpeg" title="Github 团队协作"><p><br></p><h2 id="Github-的由来"><a href="#Github-的由来" class="headerlink" title="Github 的由来"></a>Github 的由来</h2><blockquote class="pullquote default"><p><code>Github</code> 的诞生是由于 <code>Git</code> 的局限性，尽管当时 <code>Git</code> 对于代码的管理以及团队协作方面已经非常出色，但是 <code>Git</code> 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 <code>Git</code> 特性的代码平台的诉求成为必然，<code>Github</code> 就这样诞生了。</p></blockquote><a id="more"></a><h2 id="如何在-Github-高效的搜索项目"><a href="#如何在-Github-高效的搜索项目" class="headerlink" title="如何在 Github 高效的搜索项目"></a>如何在 Github 高效的搜索项目</h2><p>如今 <code>Github</code> 已经非常火爆，也因此被戏称为 “世界最大的同性交友平台”，在 <code>Github</code> 上托管的仓库数量巨大，这对在 <code>Github</code> 上寻找需要的开源项目造成了困扰，其实在 <code>Github</code> 上搜索项目也有一定的技巧，下面我们就来说一下如何高效的找到自己需要的开源项目。</p><p>在登录 <code>Github</code> 后，让搜索项目的搜索框获取焦点并敲下回车键，会跳转到一个搜索页面，这个页面上点击 <code>Advanced search</code>（高级搜索）就会跳转到高级搜索页面。</p><ul><li><code>From these owners</code>：按照作者名搜索，格式 <code>user:username</code>；</li><li><code>In these repositories</code>：按照仓库名称搜索，格式 <code>repo:username/reponame</code>；</li><li><code>Created on the dates</code>：按照创建日期搜索，格式 <code>created:&lt;YYYY-MM-DD</code>；</li><li><code>Written in this language</code>：按照语言进行搜索，格式 <code>language:JavaScript</code>；</li><li><code>With this many stars</code>：按照星星数查找，格式 <code>stars:&gt;1000</code>；</li></ul><blockquote class="pullquote info"><p>上面列举只是常用的部分搜索方式和格式，具体可以查看 <a target="_blank" href="https://github.com/search/advanced">https://github.com/search/advanced</a>，也可以不通过高级搜索的页面直接将规则写在 <code>Github</code> 主页的搜索框内，多个搜索规则可同时使用，格式之间用空格隔开，当然也可以按照内容是否在哪一个文件中来搜索，如 <code>partcontent in readme</code>。</p></blockquote><h2 id="Organizations（组织）"><a href="#Organizations（组织）" class="headerlink" title="Organizations（组织）"></a>Organizations（组织）</h2><p>在 <code>Github</code> 中的仓库可以创建在个人仓库中，也可以创建在组织中，创建在个人仓库时项目的管理者只有项目的所有者，不方便团队层面的管理和协作，如果想要多人共同的管理项目可以通过组织的形式进行。</p><p><strong>创建组织步骤如下：</strong></p><ul><li>个人信息 <code>setting</code>；</li><li>进入界面点击左侧 <code>Organizations</code>；</li><li>点击右上角 <code>new organization</code>；</li><li>填好组织信息后点击下方 <code>Create organization</code>。</li></ul><p>添加后的组织会出现在用户 <code>setting</code> 页面的 <code>Organizations</code> 选项中，点击进入某个组织，可以添加 <code>Github</code> 中可以搜索到的成员进行协同开发，可以在组织下新建仓库，可以创建团队对仓库做更精细化的管理，也可以对团队里的每个成员针对仓库设置读写权限。</p><h2 id="怎样选择适合团队的工作流"><a href="#怎样选择适合团队的工作流" class="headerlink" title="怎样选择适合团队的工作流"></a>怎样选择适合团队的工作流</h2><p>一个团队在协作的时候一定会分工到所有人完成的工作变成一个产品的过程，“工作流” 对于研发团队来讲，可以理解成分支管理的流程。</p><h3 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h3><p>主干开发是围绕着一条主开发分支进行开发，团队所有成员的 <code>commit</code> 都及时的集成在这条主分支，让团队其他成员第一时间知道。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/master-flow.png" alt="主分支开发工作流" title="">                </div>                <div class="image-caption">主分支开发工作流</div>            </figure><p><br></p><blockquote class="pullquote warning"><p><strong>适用团队：</strong></p><ul><li><strong>适用于开发团队系统设计和开发能力强，有快速迭代场景，并且有一套有效的特性切换的实施机制（发布系统），保证上线后无序修改代码就能够修改系统行为；</strong></li><li><strong>适用于组件开发的团队（一些基础服务的部门，专门造轮子），成员能力强，人员少，沟通顺畅，用户升级、切换组件成本低。</strong></li></ul></blockquote><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p><code>Git Flow</code> 工作流定义了一个围绕项目发布的严格分支模型，工作流虽然复杂，但提供了一个健壮的用于管理大型项目的框架，具体的工作流程如下图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/git-flow.png" alt="Git Flow 工作流" title="">                </div>                <div class="image-caption">Git Flow 工作流</div>            </figure><p><br></p><ul><li><code>master</code>：专门用来存储正式发布的历史；</li><li><code>develop</code>：作为功能的集成分支，可以多团队同时在 <code>develop</code> 分支集成；</li><li><code>feature</code>：专门用来开发某一个新功能，仅仅只和 <code>develop</code> 交互；</li><li><code>release</code>：发布（提测）分支，当快要到达发既定发布时间，从 <code>develop</code> 分支分出用来 <code>bugfix</code>，上线和 <code>master</code> 进行合并，同时和 <code>develop</code> 进行合并；</li><li><code>hotfix</code>：上线后从 <code>master</code> 分出用来修复线上 <code>Bug</code>。</li></ul><blockquote class="pullquote success"><p><strong>适用团队：</strong></p><ul><li><strong>适用于对项目质量要求较高，不具备主干开发能力，有预定发布周期且需要严格执行发布流程的团队。</strong></li></ul></blockquote><h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p><code>Github Flow</code> 工作流就是基于 <code>master</code> 的某一个 <code>commit</code> 拉一条特性分支进行开发，在开发完毕后在重新集成到 <code>master</code> 的工作流。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/github-flow.png" alt="Github 工作流" title="">                </div>                <div class="image-caption">Github 工作流</div>            </figure><p><br></p><blockquote class="pullquote primary"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，随时集成随时发布，分支集成时经历代码评审和自动化测试，通过后就可立即发布的应用。</strong></li></ul></blockquote><h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><p><code>Github Flow</code> 是在 <code>Github Flow</code> 的基础上做了一些优化，新增了平行的 <code>production</code> 分支，用于随时准备发布上线，也可以多一些针对不同测试环境的待测试分支。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/27/20190327025116/gitlab-flow.png" alt="Gitlab 工作流" title="">                </div>                <div class="image-caption">Gitlab 工作流</div>            </figure><p><br></p><blockquote class="pullquote danger"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，需要逐个通过测试环境的验证才能发布的应用；</strong></li><li><strong>适用同一个时间节点项目发布出去会有多个版本同时存在的情况，如通信类型的项目不同版本配合不同的硬件。</strong></li></ul></blockquote><h2 id="Create-pull-request"><a href="#Create-pull-request" class="headerlink" title="Create pull request"></a>Create pull request</h2><p>在多人开发的项目或开源项目中，其他人拉出一条分支进行开发，在上线之前需要合并到 <code>master</code> 主分支，需要提交 <code>pull request</code>，在 <code>Github</code> 项目页面点击上面的 <code>Pull requests</code> 按钮，上面有两个选项：</p><ul><li><code>base</code>：目标分支；</li><li><code>compare</code>：合并的特性分支。</li></ul><p>在选好 <code>base</code>（目标分支） 和 <code>compare</code>（合并的特性分支） 后，点击下方 <code>Create pull request</code>，填写提交的描述信息后再次点击 <code>Create pull request</code>，此时会在下方显示与目标分支相比新增的提交信息并自动检查冲突。</p><blockquote class="pullquote info"><p><strong><code>pull request</code> 有三种模式：</strong></p><ul><li><strong><code>Create a merge commit</code>：直接将某一个特性分支通过 <code>merge</code> 的方式合并到 <code>master</code>；</strong></li><li><strong><code>Squash and merge</code>：会将特性分支的所有变更集组合成一个 <code>commit</code> 合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立；</strong></li><li><strong><code>Rebase and merge</code>：会将特性分支变更集直接合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立。</strong></li></ul></blockquote><p>选择 <code>pull request</code> 模式后，需要对这个 <code>pull request</code> 进行再次确认，填写确认信息并点击 <code>Confirm merge</code> 确认合并，在完成合并后 <code>Github</code> 会给我们提供删除特性分支的快捷按钮 <code>Delete branch</code>，一般会等到项目稳定后才会删除特性分支。</p><h2 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h2><p><code>Issues</code> 用于追踪需求和任务，在开源项目中使用者发现 <code>Bug</code> 或有新的需求都是通过 <code>Issues</code> 提出，在 <code>Issues</code> 的 <code>Labels</code> 中有开发者设置的代表当前处理状态的标签，通过 <code>Issue</code> 上的状态标签可以知道 <code>Issue</code> 的处理进度。</p><h3 id="创建-Issue"><a href="#创建-Issue" class="headerlink" title="创建 Issue"></a>创建 Issue</h3><p><strong>创建 <code>Issue</code> 的步骤：</strong></p><ul><li>点击项目的 <code>Issues</code> 进入 <code>Issues</code> 页面；</li><li>点击 <code>New Issue</code>;</li><li>填写 <code>Issues</code> 的标题及内容；</li><li>点击 <code>Submit new issue</code> 创建 <code>Issue</code>。</li></ul><h3 id="创建-Issue-模版"><a href="#创建-Issue-模版" class="headerlink" title="创建 Issue 模版"></a>创建 Issue 模版</h3><p><strong><code>Issues</code> 的类型不是单一的，项目的所有者是可以给项目的 <code>Issues</code> 添加分类模版的，操作如下：</strong></p><ul><li>进入项目的 <code>Setting</code> 页面；</li><li>点击 <code>Issues</code> 选项的 <code>Set up templates</code> 按钮进入设置页面；</li><li><p>通过下拉框选择 <code>Issues</code> 模版的类型，分类如下：</p><ul><li><code>Bug report</code>：用来提出项目中的 <code>Bug</code>；</li><li><code>Feature request</code>：用来提出新的需求和功能；</li><li><code>Custom issue template</code>：自定义的模版类型，由项目所有者创建时决定具体用途。</li></ul></li><li>点击 <code>Preview and edit</code> 对添加的 <code>Issue</code> 模版进行编辑，编辑后点击 <code>Close preview</code> 保存编辑的内容；</li><li>添加 <code>Issues</code> 模版后点击 <code>Propose changes</code>；</li><li>添加本次修改的记录，同时可以选择用 <code>master</code> 分支还是新创建分支来管理这些 <code>Issues</code>；</li><li>点击 <code>Commit changes</code> 则会生成模版，再次执行创建 <code>Issues</code> 的步骤时可以看到设置的模版，点击模版对应的 <code>Get started</code> 快速生成对应的模版。</li></ul><blockquote class="pullquote default"><p>在编辑模版后，模版会生成对应 <code>markdown</code> 文件被保存在项目中的 <code>.github/ISSUE_TEMPLATE</code> 路径下。</p></blockquote><p><code>Issues</code> 更大的好处是，在追踪需求和任务的同时，任何人都可以在下面对这个 <code>Issue</code> 中的内容进行评论交流，甚至可以直接 <code>@</code> 评论者、项目所有者、开发者、甚至是项目的整个团队，有助于快速解决 <code>Issue</code> 中提出的问题。</p><h2 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h2><p>在开源项目开发时可以为当前项目的某个正在进行的迭代创建 <code>Project</code>，创建的 <code>Project</code> 类似于一个看板的形式，可以非常便捷的管理正在进行修复的 <code>Issue</code> 和 <code>pull request</code>（需要在创建 <code>Issue</code> 和 <code>pull request</code> 时选中关联这个 <code>Project</code>）。</p><p><strong>创建 <code>Project</code> 步骤如下：</strong></p><ul><li>进入项目的 <code>Projects</code> 页面；</li><li>点击 <code>Create a project</code>；</li><li>填写项目的名称和描述并点击下方 <code>Create project</code>。</li></ul><p><strong>在看板中分别对应四个区域如下：</strong></p><ul><li><code>To do</code>：将要完成的任务；</li><li><code>In progress</code>：正在进行中的任务；</li><li><code>Needs review</code>：需要复盘的任务；</li><li><code>Reviewer approved</code>：已经审核通过的任务。</li></ul><p>任务可以通过拖动来改变当前的进度和状态，可以非常便捷的实现项目的任务进度监控和管理，有效的推进项目进程。</p><h2 id="分支保护"><a href="#分支保护" class="headerlink" title="分支保护"></a>分支保护</h2><p>在 <code>Github</code> 的项目中，可以对指定的分支定义规则来进行保护，防止强制推送、以及分支被删除等操作，目的是为了防止误操作对重要分支造成无法挽回的后果。</p><p>可以通过项目的 <code>Setting</code> 进入，选中左侧的 <code>Branches</code> 选项，点击 <code>Add rule</code> 来添加保护规则，<code>Branch name pattern</code> 内制定要保护的分支名字，<code>Rule settings</code> 中可以设置分支保护规则。</p><p><strong>可选规则（可根据需求多选）如下：</strong></p><ul><li><p><code>Require pull request reviews before merging</code>：选中该项后所有的提交合并都必须通过 <code>pull request</code> 进行，下面有三个子选项如下：</p><ul><li><code>Required approving reviews</code>：同意 <code>pull request</code> 的人数，就是说设置后必须有对应设置的人数的相关人员批准，才可以合并；</li><li><code>Dismiss stale pull request approvals when new commits are pushed</code>：勾选后在有新的 <code>pull request</code> 时会撤销旧的 <code>pull request</code>；</li><li><code>Require review from Code Owners</code>：勾选该项后，<code>pull request</code> 必须通过项目所有者的通过才能进行合并。</li></ul></li><li><p><code>Require status checks to pass before merging</code>：在合并前必须通过状态检查才能合并，状态检查如下：</p><ul><li><code>Require branches to be up to date before merging</code>：要求分支在合并之前是最新的。</li></ul></li><li><code>Require signed commits</code>：勾选该项后要求在提交时验证签名；</li><li><code>Include administrators</code>：加入管理员执行所有限制的配置。</li></ul><blockquote class="pullquote success"><p>上面的配置我们通过要保护分支的安全级别自行选择。</p></blockquote><h2 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h2><p><code>Wiki</code> 是 <code>Github</code> 提供的说明文档功能，点击项目上的 <code>Wiki</code> 选项进入文档页面，在项目从来没有编辑过稳当页面时，会默认出现 <code>Create the first page</code> 按钮，点击则会跳转编辑 <code>Wiki</code> 的页面，可以输入 <code>Wiki</code> 标题、内容和提交信息，内容支持 <code>Markdown</code> 语法编写。</p><p>当已经创建过一个 <code>Wiki page</code> 后再次进入项目的 <code>Wiki</code> 页面，会在右上角显示 <code>Edit</code> 和 <code>New page</code> 按钮，分别用于修改和新增 <code>Wiki page</code>，在左侧有所有 <code>Wiki page</code> 的列表，最下面是 <code>Wiki</code> 的仓库地址，也可以通过编辑器在本地创建 <code>Wiki page</code>，编写后通过 <code>Git</code> 推送到 <code>Wiki</code> 仓库。</p><p>在 <code>Wiki</code> 页面还有两个扩展功能，分别为 <code>Add a custom footer</code> 和 <code>Add a custom sidebar</code>，用于创建自定义底部和侧边栏（如编写目录等）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote warning"><p><code>Github</code> 管理项目实现协同开发是非常便捷的，在 <code>Github</code> 中每一个的操作的参与者和被参与者都会收到 <code>Github</code> 邮件进行通知，进入邮件链接也可以直接对项目变化进行 <code>code review</code>，在企业级项目中目前 <code>Gitlab</code> 的私有仓库更火爆，基本功能与 <code>Github</code> 大同小异，在基本功能的基础上增加了更高级的功能和内置的持续集成插件，有兴趣可以尝试探究一下。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/27/20190327025116/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之实战技及巧注意事项总结</title>
      <link>https://www.overtaking.top/2019/03/15/20190315115008/</link>
      <guid>https://www.overtaking.top/2019/03/15/20190315115008/</guid>
      <pubDate>Fri, 15 Mar 2019 03:50:08 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/03/15/20190315115008/git.png&quot; title=&quot;Git 实战技及注意事项&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 &lt;code&gt;Git&lt;/code&gt; 的基础上来详细总结一下这些注意事项。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/15/20190315115008/git.png" title="Git 实战技及注意事项"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><code>Git</code> 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 <code>Git</code> 的基础上来详细总结一下这些注意事项。</p></blockquote><a id="more"></a><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><p>在日常开发时，我们经常都是在某一个分支下进行的，<code>commit</code> 操作也是在某些分支上进行，换句话说我们的每一个提交一般来讲都是与分支挂钩的，在 <code>Git</code> 中有一种情况，我们所修改的代码不与任何一个分支有关连，这种情况下叫做分离头指针。</p><p>那么如何操作才能实现分离头指针呢，在开发时我们可能会对某一个 <code>commit</code> 非常的感兴趣，并希望在这个 <code>commit</code> 下去做一些事情，可以执行下面命令实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br></pre></td></tr></table></figure><p>当切换分支后对某些文件做一些修改，并重新 <code>commit</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'分离头指针测试'</span></span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>执行上面命令后我们发现新的 <code>commit</code> 信息后面不在对应某一个分支，而是 <code>HEAD</code>，这种情况下就代表着我们的 <code>Git</code> 目前已经处于分离头指针的状态了。</p><p>分离头指针是 “双刃剑” 有好处也有坏处，在分离头指针的状态下所有的 <code>commit</code> 在重新切换分支时，会被 <code>Git</code> 当作无用提交回收掉，因为这些提交没有跟任何分支有所联系。</p><blockquote class="pullquote warning"><p><em><strong>优点：尝试性的 <code>commit</code> 可以在分离头指针的状态下进行；</strong></em><br><em><strong>缺点：当发布需要到其他分支修复问题或紧急发布时，切分支后会导致分离头指针状态下的 <code>commit</code> 丢失。</strong></em></p></blockquote><p>在切换分支后，如果还想保留分离头指针状态下的提交，可以为这个提交创建一个新的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名 分离头指针状态的提交（哈希值）</span><br></pre></td></tr></table></figure><h2 id="修改本地-commit"><a href="#修改本地-commit" class="headerlink" title="修改本地 commit"></a>修改本地 commit</h2><h3 id="修改最近一次提交"><a href="#修改最近一次提交" class="headerlink" title="修改最近一次提交"></a>修改最近一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><code>--amend</code> 可以将暂存区新存入的内容同时提交到最近的一次 <code>commit</code> 中，而不会生成新的 <code>commit</code>，同时也可以修改 <code>commit</code> 时的提交信息。</p></blockquote><h3 id="修改任意一次提交"><a href="#修改任意一次提交" class="headerlink" title="修改任意一次提交"></a>修改任意一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i a4d56bb</span><br></pre></td></tr></table></figure><p>该操作为 <code>git rebase</code> 命令的交互模式，即输入 <code>-i</code> 命令，后面所输入的 <code>commit</code> 哈希值并不是要修改的 <code>commit</code>，而是要修改的 <code>commit</code> 的父级 <code>commit</code> 哈希值，在执行命令后会弹出修改的交互界面如下。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pick 52f3935 add css file</span><br><span class="line"><span class="deletion">- pick 91bd053 change css</span></span><br><span class="line"><span class="addition">+ reword 91bd053 change css</span></span><br><span class="line"></span><br><span class="line"># Rebase a4d56bb..91bd053 onto a4d56bb (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>从上面的信息来看第一条代表当前要修改的 <code>commit</code>，第二条代表该分支最新的 <code>commit</code>，下面注释为修改参数，由于要修改提交信息，所以此处将第一行的 <code>pick</code> 修改成 <code>reword</code> 并保存，保存后会弹出下一个修改提交信息的界面如下。</p><figure class="highlight diff"><figcaption><span>第二个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- css content</span></span><br><span class="line"><span class="addition">+ add css content</span></span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto a4d56bb</span><br><span class="line"># Last command done (1 command done):</span><br><span class="line">#    reword 9e4f711 add css content</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick c220cf2 change css</span><br><span class="line"># You are currently editing a commit while rebasing branch 'test' on 'a4d56bb'.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.css</span><br></pre></td></tr></table></figure><p>该界面上为 <code>commit</code> 的 <code>message</code>，修改后保存，就完成了对该 <code>commit</code> 的修改，值得注意的是，使用 <code>git log</code> 查看历史可以发现，修改 <code>commit</code> 时指定的父级 <code>commit</code> 后所有的 <code>commit</code> 哈希值都会发生变化。</p><figure class="highlight plain"><figcaption><span>commit 后的提示信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[detached HEAD de48b04] add css content</span><br><span class="line"> Date: Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 index.css</span><br><span class="line">Successfully rebased and updated refs/heads/test.</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>可以看出，其实使用 <code>git rebase</code> 命令修改 <code>commit</code> 的原理也是分离头指针，只是在分离头指针修改 <code>commit</code> 后又重新将当前分支的指针指回了最新的 <code>commit</code>。</p></blockquote><h3 id="将多个连续的-commit-合并成一个"><a href="#将多个连续的-commit-合并成一个" class="headerlink" title="将多个连续的 commit 合并成一个"></a>将多个连续的 commit 合并成一个</h3><p>将多个 <code>commit</code> 合并成一个的原理与修改任意一个 <code>commit</code> 的原理相同，都是通过 <code>git rebase</code> 命令的交互模式实现的（<code>-i</code>），参数为合并几个 <code>commit</code> 的父级 <code>commit</code> 哈希值。</p><figure class="highlight bash"><figcaption><span>查看历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># edd2400 (HEAD -&gt; test) add content to readme</span></span><br><span class="line"><span class="comment"># 50a015c add background css</span></span><br><span class="line"><span class="comment"># 15237d2 change css</span></span><br><span class="line"><span class="comment"># 4a8fd80 add css content</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><p>现在我们尝试将 <code>50a015c</code>、<code>15237d2</code> 和 <code>4a8fd80</code> 这三个 <code>commit</code> 合并成一个，与修改 <code>commit</code> 唯一不同的是被修改的 <code>commit</code> 参数不再是 <code>reword</code>，而是 <code>squash</code>，多个要合并的 <code>commit</code> 之中有一个目标 <code>commit</code>，这个 <code>commit</code> 的参数必须是 <code>pick</code>。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pick 4a8fd80 add css content</span><br><span class="line"><span class="deletion">- pick 15237d2 change css</span></span><br><span class="line"><span class="deletion">- pick 50a015c add background css</span></span><br><span class="line"><span class="addition">+ squash 15237d2 change css</span></span><br><span class="line"><span class="addition">+ squash 50a015c add background css</span></span><br><span class="line">pick edd2400 add content to readme</span><br><span class="line"></span><br><span class="line"># Rebase 5149bad..edd2400 onto 5149bad (4 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>对上面的交互界面保存后同样会弹出第二个交互界面，合并多个 <code>commit</code> 与修改单个 <code>commit</code> 不同的是，第二个界面会展示所有被合并 <code>commit</code> 的信息，我们可以为合并后的 <code>commit</code> 添加一个新的 <code>message</code>。</p><figure class="highlight diff"><figcaption><span>第二个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+ css changes</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"># This is the 1st commit message:</span><br><span class="line"></span><br><span class="line">add css content</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line"></span><br><span class="line">change css</span><br><span class="line"></span><br><span class="line"># This is the commit message #3:</span><br><span class="line"></span><br><span class="line">add background css</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Mar 19 14:48:22 2019 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 5149bad</span><br><span class="line"># Last commands done (3 commands done):</span><br><span class="line">#    squash 15237d2 change css</span><br><span class="line">#    squash 50a015c add background css</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick edd2400 add content to readme</span><br><span class="line"># You are currently rebasing branch 'test' on '5149bad'.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   index.css</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看合并提交后的历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2c84584 (HEAD -&gt; test) add content to readme</span></span><br><span class="line"><span class="comment"># ac001bc css changes</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><h3 id="将多个间隔的-commit-合并成一个"><a href="#将多个间隔的-commit-合并成一个" class="headerlink" title="将多个间隔的 commit 合并成一个"></a>将多个间隔的 commit 合并成一个</h3><p>上面的 <code>commit</code> 合并方式可能满足不了需求，有些时候我们想把对同一个文件的提交或同一类操作的提交合并成一个，但是在历史 <code>commit</code> 中要合并的树是间隔的，使用 <code>git rebase</code> 命令同样可以做到。</p><figure class="highlight bash"><figcaption><span>查看历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 23d6939 (HEAD -&gt; test) append content into readme</span></span><br><span class="line"><span class="comment"># 178ea29 link css in html</span></span><br><span class="line"><span class="comment"># 2c84584 add content to readme</span></span><br><span class="line"><span class="comment"># ac001bc css changes</span></span><br><span class="line"><span class="comment"># 5149bad new READ.md</span></span><br><span class="line"><span class="comment"># 7f73a76 new html</span></span><br></pre></td></tr></table></figure><p>在之前使用 <code>git rebase</code> 命令时都是将操作 <code>commit</code> 的父级 <code>commit</code> 作为参数，如果我们要操作的 <code>commit</code> 已经没有父级 <code>commit</code>，接下来在合并多个间隔的 <code>commit</code> 时来测试一下这样的情况，接下来将 <code>7f73a76</code> 和 <code>178ea29</code> 两个关于 <code>html</code> 文件的操作合并成一个。</p><figure class="highlight bash"><figcaption><span>执行命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f73a76</span><br></pre></td></tr></table></figure><p>由于我们要操作的 <code>commit</code> 已经没有了父级，所以我们就在执行命令时传入这个 <code>commit</code>，在弹出的第一个交互界面我么明显能看到其实上面是少了我们要操作的 <code>commit</code>，所以需要手动补上，而间隔的 <code>commit</code> 要移动到和合并的目标 <code>commit</code> 连续的位置。</p><figure class="highlight diff"><figcaption><span>第一个交互界面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ pick 7f73a76</span></span><br><span class="line"><span class="addition">+ squash 178ea29 link css in html</span></span><br><span class="line">pick 4a8fd80 add css content</span><br><span class="line">pick 5149bad new READ.md</span><br><span class="line">pick ac001bc css changes</span><br><span class="line">pick 2c84584 add content to readme</span><br><span class="line"><span class="deletion">- pick 178ea29 link css in html</span></span><br><span class="line">pick 23d6939 append content into readme</span><br><span class="line"></span><br><span class="line"># Rebase 7f73a76..23d6939 onto 7f73a76 (5 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>在保存后出现如下报错信息，是因为 <code>commit</code> 的父节点是我们新增上去导致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">The previous cherry-pick is now empty, possibly due to conflict resolution.</span><br><span class="line">If you wish to commit it anyway, use:</span><br><span class="line"></span><br><span class="line">    git commit --allow-empty</span><br><span class="line"></span><br><span class="line">Otherwise, please use &apos;git reset&apos;</span><br><span class="line">interactive rebase in progress; onto 7f73a76</span><br><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 7f73a76</span><br><span class="line">Next commands to do (5 remaining commands):</span><br><span class="line">   squash 178ea29 link css in html</span><br><span class="line">   pick 5149bad new READ.md</span><br><span class="line">You are currently rebasing branch &apos;test&apos; on &apos;7f73a76&apos;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">Could not apply 7f73a76...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>git status 提示信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Last command done (1 command done):</span><br><span class="line">   pick 7f73a76</span><br><span class="line">Next commands to do (5 remaining commands):</span><br><span class="line">   squash 178ea29 link css in html</span><br><span class="line">   pick 5149bad new READ.md</span><br><span class="line">  (use &quot;git rebase --edit-todo&quot; to view and edit)</span><br><span class="line">You are currently rebasing branch &apos;test&apos; on &apos;7f73a76&apos;.</span><br><span class="line">  (all conflicts fixed: run &quot;git rebase --continue&quot;)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>想继续合并</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>想还原回合并之前</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><p>如果在继续合并后没有出现第二个交互界面（与合并连续 <code>commit</code> 类似，用来新增合并后 <code>commit</code> 的信息），说明合并时出现冲突，此时需要解决冲突后将新的变更提交到暂存区，再重新执行合并命令。</p><figure class="highlight bash"><figcaption><span>查看合并后的历史</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4d4f771 (HEAD -&gt; test) append content into readme</span></span><br><span class="line"><span class="comment"># a83f526 add content to readme</span></span><br><span class="line"><span class="comment"># 463fd85 css changes</span></span><br><span class="line"><span class="comment"># 7e44e19 new READ.md</span></span><br><span class="line"><span class="comment"># 753ebcd about html changes</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：当前对 <code>commit</code> 的变更和合并操作只是对 <code>commit</code> 做了整理，并没有改变文件内容，并且这些操作仅限于要修改或合并的 <code>commit</code> 还没有共享到集成分支上去，如果已经推送到远端，进行上面操作会对其他协同开发的人员造成麻烦和困扰。</strong></em></p></blockquote><h3 id="删除后提交的-commit"><a href="#删除后提交的-commit" class="headerlink" title="删除后提交的 commit"></a>删除后提交的 commit</h3><p>在开发中有这样一种情景，就是我们在修改代码时提交了一个或者几个新的 <code>commit</code>，但是发现有更好的方案，想要删除这些 <code>commit</code>，这时可以通过将 <code>HEAD</code> 指针重新指向这些 <code>commit</code> 之前的提交，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>这样的操作会导致工作区、暂存区的代码都会到这个 <code>commit</code> 的状态，当然也有 “后悔药”，可以使用 <code>git reflog</code> 找到所有的 <code>commit</code> 版本号 包含已删除），再通过同样的方式将 <code>HEAD</code> 的指针指回去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard 已删除的版本号</span><br></pre></td></tr></table></figure><h2 id="忽略上传的文件"><a href="#忽略上传的文件" class="headerlink" title="忽略上传的文件"></a>忽略上传的文件</h2><p>在开发过程中，有些文件是不需要我们上传到远端的，可能因为这个文件对于开发项目来讲是无用的，如编辑器自动生成的 <code>.idea</code> 等，或者这个文件夹非常的大，如 <code>node_modules</code>，我们可以通过 <code>.gitignore</code> 文件来配置。</p><p>在 <code>.gitignore</code> 文件中有很多规则，在此不去讨论，在这里我们要说的是如果某些想要忽略的文件由于失误没有被写进 <code>.gitignore</code>，被推送到远端后，想忽略这个文件，并在下次推送的时候让远端不再有这个文件该怎么做。</p><figure class="highlight bash"><figcaption><span>先将要忽略的文件添加到 .gitignore，然后执行下面命令对之前添加的文件进行删除操作</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件名/文件夹</span><br></pre></td></tr></table></figure><h2 id="在开发当中处理紧急发布（CR）任务"><a href="#在开发当中处理紧急发布（CR）任务" class="headerlink" title="在开发当中处理紧急发布（CR）任务"></a>在开发当中处理紧急发布（CR）任务</h2><p>在开发时经常有这样一种场景，在上一版本代码上线以后，突然发现线上出现 <code>Bug</code> 需要修复并紧急上线，而这个时候刚好又在同一个分支上已经有了其他的新代码，此时需要将代码还原到线上版本，并保证当前开发代码不丢失，待问题修复后，将新开发的代码合并到修复后的代码上继续开发，当然根据实际情况的不同，复杂程度也会有所差别，下面是一些思路。</p><figure class="highlight bash"><figcaption><span>当前代码跟要修复代码在同一条分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复代码后合并到 dev 发布测试环境验证，通过后发布</span></span><br><span class="line"></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续开发</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>当前代码跟要修复的代码不在同一条分支</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 master 分支创建一条新分支</span></span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git checkout -b 修复问题分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复问题并提测</span></span><br><span class="line"></span><br><span class="line">git checkout 测试分支</span><br><span class="line">git merge 修复问题分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证通过后合并到 master 发布，继续回到开发新功能分支将修复代码集成进来并继续开发</span></span><br><span class="line"></span><br><span class="line">git checkout 开发分支</span><br><span class="line">git rebase 测试分支</span><br></pre></td></tr></table></figure><p>当然上面的思路仅供参考，因为不同的团队规则有所差异，问题的复杂度也不尽相同，在某些特殊时候可能要本地代码回退版本，需要借助 <code>git reset</code> 命令实现。</p><h2 id="non-fast-forwards-和-fast-forwards"><a href="#non-fast-forwards-和-fast-forwards" class="headerlink" title="non-fast-forwards 和 fast-forwards"></a>non-fast-forwards 和 fast-forwards</h2><p>在实际项目开发中我们将本地代码推送到远端的时候可能会遇到下面这样的报错信息。</p><figure class="highlight bash"><figcaption><span>推送代码时的错误信息</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to <span class="string">'git@github.yourRepository.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p><code>fast-forwards</code> 是指将本地分支推送到远端，<code>tree</code> 上两个分支拥有共同的 “祖先”，可以自动合并成一个 <code>tree</code>，而 <code>non-fast-forwards</code> 正好相反，两个分支的 <code>tree</code> 是完全独立的，没有任何联系，一般会造成这种现象的原因是推送的目标分支和我们当前分支拥有不同的代码，所以我们需要将推送的目标分支和本地分支的 <code>tree</code> 整理成 <code>fast-forwards</code> 的状态。</p><p>实现方式就是先拉取远端分支在本地进行处理（如果有冲突先处理冲突），变成 <code>fast-forwards</code> 状态后再进行推送，拉取远端分支可以使用 <code>fetch</code> 或 <code>pull</code>，区别在于 <code>fetch</code> 拉取回来的代码仍然是 <code>non-fast-forwards</code> 状态，需要手动 <code>merge</code> 进行合并或 <code>rebase</code> 操作（因为有些团队比较喜欢线性的提交记录以便追溯），而 <code>pull</code> 将 <code>fetch</code> 和 <code>merge</code> 这两个步骤合二为一。</p><blockquote class="pullquote info"><p><em><strong>注意：使用 <code>fetch</code> 拉取代码在进行 <code>merge</code> 时存在一种特殊情况，就是这个仓库的代码是第一次被拉取到本地（与本地分支没有共同的提交），且与本地代码的差异是新建仓库时添加 <code>README.md</code> 等文件造成的，则需要在 <code>merge</code> 时加上 <code>--allow-unrelated-histories</code> 参数去允许历史上完全独立的两棵树进行合并，达到 <code>fast-forwards</code> 的状态。</strong></em></p></blockquote><figure class="highlight bash"><figcaption><span>合并不相关的树</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 本地分支 --allow-unrelated-histories 远端分支</span><br></pre></td></tr></table></figure><p>执行命令后会弹出交互界面可以修改本次合并的 <code>message</code>。</p><h2 id="Git-多人单分支集成协作"><a href="#Git-多人单分支集成协作" class="headerlink" title="Git 多人单分支集成协作"></a>Git 多人单分支集成协作</h2><h3 id="多人协同开发时本地仓库与远端的同步"><a href="#多人协同开发时本地仓库与远端的同步" class="headerlink" title="多人协同开发时本地仓库与远端的同步"></a>多人协同开发时本地仓库与远端的同步</h3><p>在项目的开发迭代中，我们习惯每一个版本迭代都新建一个分支开发，并推送到远端，如果多个人同时要在这个分支开发该迭代的新功能，而以前又已经克隆过这个项目到本地，此时除了这条分支的创建者以外，其他人查看远端分支时是看不见这个新建分支的，需要执行以下命令对仓库进行同步并开发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步新分支信息</span></span><br><span class="line">git fetch 地址别名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新分支</span></span><br><span class="line">git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取新分支到本地</span></span><br><span class="line">git checkout -b 新分支名 地址别名/新分支名</span><br></pre></td></tr></table></figure><p>还有一种场景也需要通过上面的方式来同步仓库信息，就是在 <code>Github</code> 中帮助别人的项目修复 <code>Issue</code> 或贡献代码时，首先需要 <code>Fork</code> 别人的仓库，但是 <code>Fork</code> 过来的仓库代码并不会随着原作者仓库的代码更新而更新，为了在开发之前使 <code>Fork</code> 的仓库和原作者仓库代码及分支保持一致，执行上面命令，开发完毕后再通过给原作者提交 <code>push request</code> 的方式让原作者进行代码审核并合并到原始仓库。</p><h3 id="不同人修改不同文件的处理方式"><a href="#不同人修改不同文件的处理方式" class="headerlink" title="不同人修改不同文件的处理方式"></a>不同人修改不同文件的处理方式</h3><p>在实际开发中，两个人在一条分支开发，当 <code>A</code> 同学修改了 <code>a</code> 文件，<code>B</code> 同学修改了 <code>b</code> 文件时，此时 <code>B</code> 同学先进行了提交，<code>A</code> 同学并不知道的情况下，在 <code>A</code> 同学推送代码到远端时会变成 <code>non-fast-forwards</code> 状态（推送失败），并提示超前一个版本，落后一个版本，意思是本地代码有一个提交远端没有，远端代码有一个提交本地没有，一般情况下大多数的处理是选择先拉去远端代码进行合并，再推送到远端。</p><p>由于两个人修改的是不同文件，在拉取远端代码后合并会比较顺利，并不会产生冲突，但同时产生新的问题，就是多了一条关于合并的提交记录，如果想让提交的历史树更干净整洁，也有另一种做法，就是推送失败的一方主动将本地 <code>commit</code> 回退到与远端完全一致的 <code>commit</code> 版本，主动拉取代码与工作区合并，再重新提交到本地版本库并推送到远端。</p><figure class="highlight bash"><figcaption><span>撤销本地新的提交</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset 与远端相同的提交</span><br></pre></td></tr></table></figure><h3 id="不同的人修改相同文件不同区域的处理方式"><a href="#不同的人修改相同文件不同区域的处理方式" class="headerlink" title="不同的人修改相同文件不同区域的处理方式"></a>不同的人修改相同文件不同区域的处理方式</h3><p>我们将上面 <code>A</code>、<code>B</code> 两个同学的操作场景稍微做些改动，就是两个人同时操作了同一个文件的不同区域，此时如果 <code>B</code> 先提交到远端，<code>A</code> 不知情的情况下推送代码到远端，一样会变成 <code>non-fast-forwards</code>，同样可以通过上面的方式处理，<code>Git</code> 比较智能，可以将两个平行的修改过不同区域的文件进行合并，变成 <code>fast-forwards</code> 状态。</p><h3 id="不同的人修改相同文件相同区域的处理方式"><a href="#不同的人修改相同文件相同区域的处理方式" class="headerlink" title="不同的人修改相同文件相同区域的处理方式"></a>不同的人修改相同文件相同区域的处理方式</h3><p>依然沿用上面 <code>A</code>、<code>B</code> 同学的操作场景，不同的是这次两人修改了相同文件的相同区域，<code>B</code> 先提交到远端，<code>A</code> 在提交到远端时有因为状态为 <code>non-fast-forwards</code> 被拒绝，同样的方式处理时发现了新的问题，代码虽然成功拉合并，但是控制台报错了。</p><figure class="highlight bash"><figcaption><span>合并后报错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Auto-merging yourfile</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> yourfile</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>由于两个人操作了同一个区域导致 <code>Git</code> 无法判断两个内容应该怎样去保留或替换，所以将合并失败的错误抛出让开发者认为的介入。</p><blockquote class="pullquote danger"><p><strong>在解决冲突时可能存在的情况：</strong></p><ul><li><em><strong>两人将都要保留的功能代码写在了相同文件的相同区域，这种情况需要都保留；</strong></em></li><li><em><strong>两个人开发功能重复了，需要进行沟通协商决定保留哪一个。</strong></em></li></ul></blockquote><p>在手动处理冲突对文件进行合并时，可以通过 <code>git status</code> 查看合并后的状态，如果这个人为的合并是需要的可以创建一个新的提交推送到远端，如果觉得没有处理好，可以执行下面命令还原到合并之前。</p><figure class="highlight bash"><figcaption><span>撤销合并</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><h3 id="不同的人同时变更文件名的处理方式"><a href="#不同的人同时变更文件名的处理方式" class="headerlink" title="不同的人同时变更文件名的处理方式"></a>不同的人同时变更文件名的处理方式</h3><p>在不同人同时修改同一个文件名时，<code>Git</code> 时无法处理的，当然会变成 <code>non-fast-forwards</code> 状态，在通过常规的处理后，本地会出现两个文件，分别为两人所更改的文件名，这时需要两个人进行协商，保留协商后的文件名，删除多余的文件并推送到远端让其他人进行同步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm oldfilename</span><br><span class="line">git add newfilename</span><br><span class="line">git commit -m <span class="string">'merge message'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>在一个人修改文件名，其他人修改内容的情况下，<code>Git</code> 的文件内容都是通过 <a href="https://www.overtaking.top/2019/03/10/20190310233856/#tree%E3%80%81commit%E3%80%81blob-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank">blob</a> 对象进行存储，而非文件的形式，所以当多人协同某个人对文件名进行变更时 <code>Git</code> 可以非常智能的检测并同步。</p></blockquote><h3 id="禁止在已共享的集成分支使用强推"><a href="#禁止在已共享的集成分支使用强推" class="headerlink" title="禁止在已共享的集成分支使用强推"></a>禁止在已共享的集成分支使用强推</h3><p>“强推” 是指使用 <code>git push -f</code> 将本地分支推送到远端，之前在多人写作中远程分支拒绝推送的原因都是因为 <code>non-fast-forwards</code> 状态，我们可以理解为这是 <code>Git</code> 防止代码被推送到远端而产生冲突的一种保护机制，而 “强推” 就是忽略了 <code>non-fast-forwards</code> 状态强行将代码推送到远端。</p><blockquote class="pullquote danger"><p>在大部分团队中都是禁止在集成分支使用这条命令的，可能会在远端产生冲突只是原因之一，操作不正确也可能导致远端集成分支整个团队的提交历史丢失的严重后果，比如当前本地分支版本远远落后于远端，此时直接推送会进入 <code>non-fast-forwards</code> 状态，远端拒绝推送，而向远端 “强推”，远端在这个本地版本库 <code>HEAD</code> 指向的 <code>commit</code> 之后所有的提交历史都将丢失。</p></blockquote><h3 id="禁止在已共享的集成分支上做变基操作"><a href="#禁止在已共享的集成分支上做变基操作" class="headerlink" title="禁止在已共享的集成分支上做变基操作"></a>禁止在已共享的集成分支上做变基操作</h3><p>还记得前面 <a href="https://www.overtaking.top/2019/03/15/20190315115008/#修改本地-commit">修改本地 commit</a> 一节中强调 <code>rebase</code> 操作只适用于修改本地还未同步到远端的 <code>commit</code>，这是因为如果对已经同步到远端的进行了变基操作会导致 <code>commit</code> 的版本号发生变化，如果推送到远端，此时协同开发的人是基于远端旧的 <code>commit</code> 之上在做新的开发，会导致无法将本地代码推送到远端。</p><blockquote class="pullquote warning"><p>有些团队严令禁止对集成分支做变基操作，被称作 “<code>rebase</code> 黄金定律”，如果一定要对集成分支做变基操作的，一定要在当前远端最后的 <code>commit</code> 之后做变基操作。</p></blockquote><p>如果不幸真的有同事这样去做了，我们虽然会很恼火，但也还是有办法去解决这样的问题，可以直接执行下面命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>或者分为两步走，把远端变基后的分支 <code>fetch</code> 到本地，再再把本地的当前分支基于 <code>fetch</code> 下来的远端分支做 <code>rebase</code> 操作，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase 地址别名/分支名</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p>本文内容是自己在对 <code>Git</code> 的学习和工作中总结的笔记，另外想了解 <code>rebase</code> 和 <code>merge</code> 更详细的信息推荐阅读 <a href="https://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank">git rebase vs git merge 详解</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/15/20190315115008/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之 .git 内部刨析</title>
      <link>https://www.overtaking.top/2019/03/10/20190310233856/</link>
      <guid>https://www.overtaking.top/2019/03/10/20190310233856/</guid>
      <pubDate>Sun, 10 Mar 2019 15:38:56 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2019/03/10/20190310233856/git.jpg&quot; title=&quot;.git 内部刨析&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;HEAD-文件&quot;&gt;&lt;a href=&quot;#HEAD-文件&quot; class=&quot;headerlink&quot; title=&quot;HEAD 文件&quot;&gt;&lt;/a&gt;HEAD 文件&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;文件内容&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ref: refs/heads/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;code&gt;ref&lt;/code&gt; 代表引用，&lt;code&gt;refs/heads/master&lt;/code&gt; 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支时，&lt;code&gt;HEAD&lt;/code&gt; 文件中的 &lt;code&gt;ref&lt;/code&gt; 值会随着切换的分支变化。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2019/03/10/20190310233856/git.jpg" title=".git 内部刨析"><p><br></p><h2 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h2><figure class="highlight plain"><figcaption><span>文件内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><code>ref</code> 代表引用，<code>refs/heads/master</code> 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支时，<code>HEAD</code> 文件中的 <code>ref</code> 值会随着切换的分支变化。</p></blockquote><a id="more"></a><h2 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h2><figure class="highlight bash"><figcaption><span>config 文件基本内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = <span class="literal">true</span></span><br><span class="line">bare = <span class="literal">false</span></span><br><span class="line">logallrefupdates = <span class="literal">true</span></span><br><span class="line">ignorecase = <span class="literal">true</span></span><br><span class="line">precomposeunicode = <span class="literal">true</span></span><br><span class="line">[user]</span><br><span class="line">name = yourname</span><br><span class="line">email = youremail</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><code>[core]</code> 代表当前 <code>Git</code> 管理中的主要配置，<code>[user]</code> 代表用户配置，随着 <code>Git</code> 管理的不断复杂，所有的配置项都将被存放在 <code>config</code> 文件中。</p></blockquote><h2 id="refs-文件夹"><a href="#refs-文件夹" class="headerlink" title="refs 文件夹"></a>refs 文件夹</h2><h3 id="分支-heads"><a href="#分支-heads" class="headerlink" title="分支 heads"></a>分支 heads</h3><p><code>heads</code> 文件夹存储的是本地所有分支文件，文件名与分之名一一对应，文件内容为当前分支所在的提交历史记录的 <code>commit</code> 对象。</p><figure class="highlight bash"><figcaption><span>查看 heads 文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/refs/heads</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  3 systemname  staff   96  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..</span></span><br><span class="line"><span class="comment"># -rw-r--r--  1 systemname  staff   41  2 24 17:31 master</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看分支文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/tags/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># ef5aaed0707989ebc069efcd842424f6315ab4e2</span></span><br><span class="line"></span><br><span class="line">git cat-file -t ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p>其实使用 <code>git checkout</code> 命令切换分支时，就是在更改 <code>HEAD</code> 文件的引用内容，即上面提到的 <code>ref: refs/heads/branchname</code>，进而找到 <code>heads</code> 文件夹内对应的分支文件内的提交记录，将工作区代码还原到该提交记录的版本。</p></blockquote><h3 id="标签-tags"><a href="#标签-tags" class="headerlink" title="标签 tags"></a>标签 tags</h3><p>在项目开发中，经常会在某些阶段达到某一个 “里程碑”，比如版本从 <code>v0.0.1</code> 开发到 <code>v1.0.0</code>，可以专门为这个版本的 <code>commit</code> 打上一个标签，而 <code>refs/tags</code> 文件夹就是用来存放这些标签的（文件名与标签名相同），每一个标签文件内存储的是这个 “里程碑” 提交的历史记录的 <code>tag</code> 对象，<code>tag</code> 对象中存储着当前标签对应历史版本的 <code>commit</code> 对象。</p><figure class="highlight bash"><figcaption><span>查看 tags 文件夹</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/refs/tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  6 systemname  staff  192  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..</span></span><br><span class="line"><span class="comment"># -rw-r--r--  1 systemname  staff   41  2 15 18:33 1.0.0</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>查看标签文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/tags/1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ef5aaed0707989ebc069efcd842424f6315ab4e2</span></span><br><span class="line"></span><br><span class="line">git cat-file -p ef5aaed0707989ebc069efcd842424f6315ab4e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># object bcadbfea5e937e9b5eaed113dd8149c86124d72a</span></span><br><span class="line"><span class="comment"># type commit</span></span><br><span class="line"><span class="comment"># tag 1.0.0</span></span><br><span class="line"><span class="comment"># tagger yourusername &lt;youruseremail&gt; 1550212832 +0800</span></span><br><span class="line"></span><br><span class="line">git cat-file -t bcadbfea5e937e9b5eaed113dd8149c86124d72a</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p>我们可以使用 <code>git cat-file</code> 命令查看。</p></blockquote><h2 id="objects-文件夹"><a href="#objects-文件夹" class="headerlink" title="objects 文件夹"></a>objects 文件夹</h2><h3 id="查看-objects-内部"><a href="#查看-objects-内部" class="headerlink" title="查看 objects 内部"></a>查看 objects 内部</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -al .git/objects</span><br><span class="line"></span><br><span class="line"><span class="comment"># drwxr-xr-x  72 systemname  staff  2304  2 24 17:31 .</span></span><br><span class="line"><span class="comment"># drwxr-xr-x  13 systemname  staff   416  3 14 15:43 ..</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   4 systemname  staff   128  2 24 17:29 00</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   3 systemname  staff    96  2 24 17:29 f9</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   2 systemname  staff    64  2 12 16:59 info</span></span><br><span class="line"><span class="comment"># drwxr-xr-x   2 systemname  staff    64  2 12 16:59 pack</span></span><br></pre></td></tr></table></figure><p>在 <code>objects</code> 文件夹中，除了 <code>info</code> 和 <code>pack</code> 存储的都是十六进制命名的文件夹，在文件夹内部存储着以哈希值命名的文件，在 <code>Git</code> 中的策略是将十六进制文件名和哈希值的文件名进行组合，使用 <code>git cat-file</code> 可以查看该完整哈希值的对象类型，肯能为 <code>tree</code>、<code>blob</code>、<code>commit</code>。</p><blockquote class="pullquote default"><p><code>Git</code> 对象：</p><ul><li><code>tree</code>：树对象，存储内容为 <code>blob</code> 对象的哈希值和对应的文件名称；</li><li><code>blob</code>：存储文件内容，只要文件内容相同，则始终生成唯一一个 <code>blob</code> 对象；</li><li><code>commit</code>：存储提交的相关信息。</li></ul></blockquote><h3 id="tree、commit、blob-对象的关系"><a href="#tree、commit、blob-对象的关系" class="headerlink" title="tree、commit、blob 对象的关系"></a>tree、commit、blob 对象的关系</h3><p>在 <code>Git</code> 中最重要的就是这三个对象，以及他们之间的关系，这对于理解 <code>Git</code> 的原理非常有帮助，下面有一张关系图。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/10/20190310233856/git-objects.png" alt="tree、commit、blob 关系图" title="">                </div>                <div class="image-caption">tree、commit、blob 关系图</div>            </figure><p><br></p><p><code>commit</code> 对象中，<code>tree</code> 代表提交时所在的树，一个 <code>commit</code> 对象只会对应一棵树，<code>tree</code> 对象存储的只是当前 <code>commit</code> 时，所有文件目录的一个 “快照”，<code>tree</code> 对象中的 <code>tree</code> 对象代表该文件夹中还有文件夹，<code>tree</code> 中的 <code>blob</code> 对象代表文件，<code>blob</code> 对象中存储的是文件内容，<code>Git</code> 在这里存储时忽略文件名，只要文件内容一样就只会存储一份，大大的节约了存储空间。</p><blockquote class="pullquote info"><p><code>blob</code> 对象是在将文件增加到暂存区后创建的，<code>commit</code> 和 <code>tree</code> 对象在进行提交操作后创建。</p></blockquote><h2 id="hooks-文件夹"><a href="#hooks-文件夹" class="headerlink" title="hooks 文件夹"></a>hooks 文件夹</h2><p><code>hooks</code> 文件夹，默认存储了一系列的 <code>hook</code> 文件，用于在执行某些特定的 <code>Git</code> 命令时，在某个声明周期执行，内部可以编写 <code>shell</code> 脚本，也可以通过 <code>hasky</code> 等 <code>npm</code> 包来介入。</p><figure class="highlight bash"><figcaption><span>例如下面文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">pre-commit.sample <span class="comment"># 提交前执行</span></span><br><span class="line">pre-push.sample <span class="comment"># 推送前执行</span></span><br><span class="line">pre-rebase.sample <span class="comment"># 变基前执行</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><em><strong>上面的文件默认扩展名为 <code>sample</code>，即默认不生效，要想在某个 <code>Git</code> 操作时可以执行对应的 <code>hook</code> 文件，只需要去掉对应 <code>hook</code> 文件的扩展名即可。</strong></em></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2019/03/10/20190310233856/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Webpack4 —— 多页面打包通用方案</title>
      <link>https://www.overtaking.top/2018/11/15/20181115105656/</link>
      <guid>https://www.overtaking.top/2018/11/15/20181115105656/</guid>
      <pubDate>Thu, 15 Nov 2018 02:56:56 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;多页面应用简介&quot;&gt;&lt;a href=&quot;#多页面应用简介&quot; class=&quot;headerlink&quot; title=&quot;多页面应用简介&quot;&gt;&lt;/a&gt;多页面应用简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;多页面（&lt;code&gt;MPA&lt;/code&gt;）和单页面（&lt;code&gt;SPA&lt;/code&gt;）是对应用两种不同的处理方式，单页面应用一般是只有一个主页面，其他的页面切换都是靠路由和组件切换来实现，多页应用是每次跳转的时候服务端会返回一个新的 &lt;code&gt;.html&lt;/code&gt; 页面，每一个页面是一个独立的应用，只是多个应用之间共用了同一个域名。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="多页面应用简介"><a href="#多页面应用简介" class="headerlink" title="多页面应用简介"></a>多页面应用简介</h2><blockquote class="pullquote info"><p>多页面（<code>MPA</code>）和单页面（<code>SPA</code>）是对应用两种不同的处理方式，单页面应用一般是只有一个主页面，其他的页面切换都是靠路由和组件切换来实现，多页应用是每次跳转的时候服务端会返回一个新的 <code>.html</code> 页面，每一个页面是一个独立的应用，只是多个应用之间共用了同一个域名。</p></blockquote><a id="more"></a><p><strong>多页面的优势是页面与页面之间是相互解耦的，对 <code>SEO</code> 更加友好，缺点是每次新增或删除页面都需要更改构建的配置。</strong></p><h2 id="基础的多页面配置"><a href="#基础的多页面配置" class="headerlink" title="基础的多页面配置"></a>基础的多页面配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    admin: path.resolve(__dirname. <span class="string">'src/pages/search/index.js'</span>),</span><br><span class="line">    search: path.resolve(__dirname. <span class="string">'src/pages/search/index.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name][chunkhash:8].js'</span>,</span><br><span class="line">    path: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>, <span class="comment">// 模板文件路径</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 输出文件名称</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个基础的多页面配置，如果开发过程成页面的增加非常快速，且多人同时开发，这样每增加一个页面都需要在 <code>entry</code> 中增加一个入口，在 <code>plugins</code> 中增加一个 <code>HtmlWebpackPlugin</code> 插件的实例，这样的维护方式并不优雅。</p><p>我们更希望增加页面时不需要更改 <code>Webpack</code> 配置文件，而是可以动态的向 <code>entry</code> 和 <code>plugins</code> 中添加配置。</p><h2 id="动态的多页面配置"><a href="#动态的多页面配置" class="headerlink" title="动态的多页面配置"></a>动态的多页面配置</h2><p>按照上面的优化思路，我们需要在 <code>Webpack</code> 配置中读取本地某一个固定目录的文件，以知道有哪些页面需要配置，当然我们可以使用 <code>fs</code> 模块自己实现，在这里更推荐使用 <code>glob</code> 模块，<code>glob</code> 模块可以通过通配符的方式按照定义的规则去匹配文件目录。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install glob html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p><strong>动态生成页面配置：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlPlugins = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pathMatch = path.resolve(__dirname, <span class="string">'./src/pages/*/index.js'</span>)</span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(pathMatch);</span><br><span class="line"></span><br><span class="line">  entryFiles.map(<span class="function">(<span class="params">pagePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pageName = pagePath.match(<span class="regexp">/.*\/(.*)\/index.js/</span>)[<span class="number">1</span>];</span><br><span class="line">    entry[pageName] = pagePath;</span><br><span class="line"></span><br><span class="line">    htmlPlugins.push(<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">`./src/pages/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>, <span class="comment">// 模板文件路径</span></span><br><span class="line">      filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">// 输出文件名称</span></span><br><span class="line">      chunks: [pageName], <span class="comment">// 使用的 chunk 名称</span></span><br><span class="line">      inject: <span class="literal">true</span>, <span class="comment">// 将 js 资源放在 body 底部</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 是否删除空白符与换行符</span></span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span>, <span class="comment">// 是否移除引号</span></span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩 CSS</span></span><br><span class="line">        minifyJS: <span class="literal">true</span>, <span class="comment">// 压缩 JS</span></span><br><span class="line">        removeComments: <span class="literal">true</span> <span class="comment">// 是否移除 HTML 中的注释</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry,</span><br><span class="line">    htmlPlugins</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = setMPA();</span><br></pre></td></tr></table></figure><p>首先我们创建一个模块，模块中创建 <code>setMPA</code> 函数专门用来对页面进行动态化处理，函数返回 <code>entry</code> 和 <code>HtmlWebpackPlugin</code> 的实例，首先通过 <code>glob</code> 的 <code>sync</code> 同步读取本地目录 <code>pages</code> 下的文件，获取页面文件的绝对路径（数组），循环的过程中匹配页面名称，并根据页面名称动态的创建 <code>entry</code> 和 <code>HtmlWebpackPlugin</code>。</p><p><strong>动态化配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;entry, htmlPlugins&#125; = <span class="built_in">require</span>(<span class="string">'./setMPA'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name][chunkhash:8].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...htmlPlugins</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Webpack</code> 配置中只需要引入 <code>setMPA</code> 模块并解构出 <code>entry</code> 和 <code>HtmlWebpackPlugin</code> 的集合，并写在对应的配置上，这样就化解了有人新增页面就要增加对应配置的尴尬。</p>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/11/15/20181115105656/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Webpack4 —— 优化篇</title>
      <link>https://www.overtaking.top/2018/11/10/20181110203121/</link>
      <guid>https://www.overtaking.top/2018/11/10/20181110203121/</guid>
      <pubDate>Sat, 10 Nov 2018 12:31:21 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;文件指纹&quot;&gt;&lt;a href=&quot;#文件指纹&quot; class=&quot;headerlink&quot; title=&quot;文件指纹&quot;&gt;&lt;/a&gt;文件指纹&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;“文件指纹” 就是打包后的文件名的后缀，文件指纹的好处如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本管理，文件发生变化，文件指纹发生变化，只将发生变化的文件进行发布；&lt;/li&gt;
&lt;li&gt;没有修改文件指纹的文件可以继续使用浏览器缓存，减少网络带宽，加速页面访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;“文件指纹” 的种类：&lt;/strong&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h2><p><strong>“文件指纹” 就是打包后的文件名的后缀，文件指纹的好处如下：</strong></p><ul><li>版本管理，文件发生变化，文件指纹发生变化，只将发生变化的文件进行发布；</li><li>没有修改文件指纹的文件可以继续使用浏览器缓存，减少网络带宽，加速页面访问。</li></ul><p><strong>“文件指纹” 的种类：</strong></p><a id="more"></a><ul><li><code>Hash</code>：和整个项目的构建有关，只要项目中有文件发生变化，使用该配置的文件名的 “指纹” 就会发生变化；</li><li><code>ChunkHash</code>：和 <code>Webpack</code> 打包的 <code>chunk</code> 有关，不同的 <code>entry</code>（多页应用时）会生成不同的 “指纹”，页面对应的文件发生变化才会影响该页面的 “指纹”。</li><li><code>ContentHash</code>：根据具体文件的内容生成 “指纹”，在具体某一个页面下引用的多个文件中，如果使用 <code>ChunkHash</code> 会导致一个文件变化其他的文件 “指纹” 也发生变化，使用 <code>ContentHash</code> 可以保证文件内容不变不会 “指纹” 不会发生变化。</li></ul><p><strong>合理使用 “文件指纹”：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./pages/app.js'</span>,</span><br><span class="line">    appAdmin: <span class="string">'./pages/appAdmin.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name][chunkhash:8].js'</span>, <span class="comment">// 不同页面出口文件使用 chunkhash</span></span><br><span class="line">    path: __dirname + <span class="string">'dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: <span class="string">'[name].[hash:8].[ext]'</span> <span class="comment">// MD5 根据文件内容生成，字体文件同理</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 使用该插件将 CSS 文件单独提取</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name][contenthash:8].css'</span> <span class="comment">// 该 contenthash 同图片的 hash</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote danger"><p><strong>“指纹” 配置不能和热更新插件 <code>HotModuleReplacementPlugin</code> 同时使用，因此也突出了 <code>Webpack</code> 配置根据环境（<code>mode</code>）区分的重要性。</strong></p></blockquote><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><p>在项目正式上线时，代码压缩是非常必要的，因为代码压缩后资源的字节会更少，文件大小会更小，这样在文件传输过程中也会节约带宽进而加快文件的访问速度。</p><h3 id="JS-压缩"><a href="#JS-压缩" class="headerlink" title="JS 压缩"></a>JS 压缩</h3><p>在 <code>Webpack4</code> 中内置了 <code>uglifyjs-webpacl-plugin</code> 插件，在 <code>mode</code> 配置为 <code>production</code> 时会默认实现 <code>.js</code> 文件的压缩，也可以手动安装该插件去配置关于压缩的其他参数，如并行压缩等（非必要）。</p><h3 id="CSS-压缩"><a href="#CSS-压缩" class="headerlink" title="CSS 压缩"></a>CSS 压缩</h3><p>在 <code>Webpack</code> 旧版本中可以通过 <code>css-loader</code> 中配置参数来实现压缩，但是后来 <code>css-loader</code> 去掉了这个配置，所以在 <code>Webpack4</code> 中可以通过 <code>OptimizeCssAssetsWebpackPlugin</code> 插件来实现对 <code>.css</code> 文件的压缩。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cssnano optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure><p><strong>配置示例：</strong></p><figure class="highlight js"><figcaption><span>在 plugins 中配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCssPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> Cssnano = <span class="built_in">require</span>(<span class="string">'cssnano'</span>); <span class="comment">// 用于匹配 CSS 文件的处理器（默认）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssPlugin(&#123;</span><br><span class="line">      assetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: Cssnano,</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        discardComments: &#123; <span class="comment">// 注释处理</span></span><br><span class="line">          removeAll: <span class="literal">true</span> <span class="comment">// 移除所有注释</span></span><br><span class="line">        &#125;,</span><br><span class="line">        normalizeUnicode: <span class="literal">false</span> <span class="comment">// 防止 unicode-range 时产生乱码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>在 optimization 中配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCssPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> Cssnano = <span class="built_in">require</span>(<span class="string">'cssnano'</span>); <span class="comment">// 用于匹配 CSS 文件的处理器（默认）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> OptimizeCssPlugin(&#123;</span><br><span class="line">        assetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">        cssProcessor: Cssnano,</span><br><span class="line">        cssProcessorOptions: &#123;</span><br><span class="line">          discardComments: &#123; <span class="comment">// 注释处理</span></span><br><span class="line">            removeAll: <span class="literal">true</span> <span class="comment">// 移除所有注释</span></span><br><span class="line">          &#125;,</span><br><span class="line">          normalizeUnicode: <span class="literal">false</span> <span class="comment">// 防止 unicode-range 时产生乱码</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Html-压缩"><a href="#Html-压缩" class="headerlink" title="Html 压缩"></a>Html 压缩</h3><p>压缩 <code>.html</code> 文件主要还是依靠 <code>HtmlWebpackPlugin</code> 插件，通过生产环境构建时配置一些参数来实现。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p><strong>配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>, <span class="comment">// 模板文件路径</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 输出文件名称</span></span><br><span class="line">      inject: <span class="literal">true</span>, <span class="comment">// 将 js 资源放在 body 底部</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 是否删除空白符与换行符</span></span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span>, <span class="comment">// 是否移除引号</span></span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩 CSS</span></span><br><span class="line">        minifyJS: <span class="literal">true</span>, <span class="comment">// 压缩 JS</span></span><br><span class="line">        removeComments: <span class="literal">true</span> <span class="comment">// 是否移除 HTML 中的注释</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资源内联"><a href="#资源内联" class="headerlink" title="资源内联"></a>资源内联</h2><p>资源内联就是将资源的代码放在 <code>.html</code> 文件中一起请求回来，资源内联优化的意义大致可以分为两个层面，代码层面和网络层面。</p><ul><li>在代码层面可以内联一些 <code>meta</code> 标签，便于维护管理文件，也可以内联一些页面框架的初始化脚本、上报埋点相关的脚本，也可以将首屏使用的 <code>CSS</code> 内联，防止网络不好的情况下页面闪动；</li><li>从网络层面，对一些小图片和字体资源进行内联可以减少请求次数，增加页面的响应速度。</li></ul><h3 id="Html-和-JS-的内联"><a href="#Html-和-JS-的内联" class="headerlink" title="Html 和 JS 的内联"></a>Html 和 JS 的内联</h3><p>内联 <code>Html</code> 和 <code>JS</code> 文件需要依赖 <code>raw-loader</code> 加载器，<code>raw-loader</code> 的功能其实就是读取一个文件，然后把文件读取的内容以字符串形式返回并插入到对应的位置。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><figcaption><span>0.5.1 版本比较稳定</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install raw-loader@0.5.1 -D</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- html 可以直接放在对应位置 --&gt;</span></span><br><span class="line">  $&#123; require('raw-loader!./meta.html') &#125;</span><br><span class="line">  <span class="comment">&lt;!-- js 需要包裹在 script 标签中，防止存在 ES6 代码需要添加 babel-loader --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">$&#123; <span class="built_in">require</span>(<span class="string">'raw-loader!babel-loader!./xxx.js'</span>) &#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>注入 Html 和 JS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>由于 <code>Webpack</code> 使用编译模板的插件是 <code>HtmlWebpackPlugin</code>，默认模板使用的是 <code>ejs</code>，所以支持上面 <code>${}</code> 的模板语法。</strong></p></blockquote><h3 id="CSS-内联"><a href="#CSS-内联" class="headerlink" title="CSS 内联"></a>CSS 内联</h3><p><code>CSS</code> 内联的前提是构建后需要生成 <code>.css</code> 文件，如果直接使用 <code>style-loader</code> 会把所有打包后的 <code>CSS</code> 样式都动态的注入 <code>.html</code> 文件中，所以需要使用 <code>MiniCssExtractPlugin</code> 插件优先对 <code>CSS</code> 进行抽取，而将抽取后的首屏的 <code>.css</code> 文件注入到 <code>.html</code> 文件中需要借助 <code>HtmlInlineCssWebpackPlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br><span class="line">npm install html-webpack-plugin -D</span><br><span class="line">npm install html-inline-css-webpack-plugin -D</span><br></pre></td></tr></table></figure><p><strong>配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlInlineCssWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-inline-css-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name][contenthash:8].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlInlineCssWebpackPlugin()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>需要注意的是 <code>HtmlWebpackPlugin</code> 插件应该在 <code>HtmlInlineCssWebpackPlugin</code> 之前，因为这两个插件的执行顺序有顺序依赖，必须先产生 <code>index.html</code> 文件后才能对 <code>CSS</code> 进行注入。</strong></p></blockquote><h3 id="图片、字体的内联"><a href="#图片、字体的内联" class="headerlink" title="图片、字体的内联"></a>图片、字体的内联</h3><p>一些小图标和字体如果体积非常小的情况下发出多个请求是没有必要的，所以最好是转换成 <code>Base64</code> 直接内联在 <code>.html</code> 和 <code>.css</code> 文件中，可以通过 <code>url-loader</code> 在构建中实现。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader -D</span><br></pre></td></tr></table></figure><p><strong>配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span> <span class="comment">// 图片小于 10k 转为 Base64</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>, <span class="comment">// 字体小于 10k 转为 Base64</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong>这样的方式最大的问题是只能根据图片大小控制所有满足条件的图片和字体资源，而不能单独控制某一个资源，想要单独控制某一个资源可以通过自己实现 <code>Webpack</code> 或使用他人开发的同功能插件。</strong></p></blockquote><h2 id="抽取公共依赖"><a href="#抽取公共依赖" class="headerlink" title="抽取公共依赖"></a>抽取公共依赖</h2><p>在开发中的很多页面使用了相同的基础库，或者这些基础库之间引用了相同的依赖，或不同的组件中使用了相同的模块，以及 <code>node_modules</code> 中有些模块使用相同的依赖，这样直接打包会对公共部分重复打包，造成打包后的文件体积非常的大，这也是一个可以优化的点，可以将公共的部分按照优先级、权重、同步异步的方式进行抽取，进而对文件进行拆分，减小打包后的体积。</p><h3 id="基础库分离"><a href="#基础库分离" class="headerlink" title="基础库分离"></a>基础库分离</h3><p>假如我们是做 <code>React</code> 开发，默认情况下是会对 <code>react</code> 和 <code>react-dom</code> 构建并打包到 <code>bundle</code> 中去，可以通过 <code>CDN</code> 的方式进行引入，在打包的时候每一次都忽略 <code>react</code> 和 <code>react-dom</code> 文件，以减小 <code>bundle</code> 的体积，我们可以通过 <code>HtmlWebpackExternalsPlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-externals-plugin -D</span><br></pre></td></tr></table></figure><p><strong>配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">module</span>: <span class="string">'react'</span>, <span class="comment">// 模块名称</span></span><br><span class="line">          entry: <span class="string">'//xxcnd.com/boudle/react.min.js'</span>, <span class="comment">// cdn 地址</span></span><br><span class="line">          global: <span class="string">'React'</span> <span class="comment">// 全局变量名</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">          entry: <span class="string">'//xxcnd.com/boudle/react-dom.min.js'</span>,</span><br><span class="line">          global: <span class="string">'ReactDom'</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>在 <code>Webpack4</code> 中内置了代码分割的功能插件，非常强大，可以通过将公共依赖抽离成单独文件的方式减小 <code>bundle</code> 的体积，这也是官方建议使用的方式。</p><p><strong>配置示例：</strong></p><figure class="highlight js"><figcaption><span>默认参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitalRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>splitChunks</code> 参数详解：</strong></p><ul><li><code>chunks</code>：<ul><li><code>async</code>：异步引入的库进行分离（默认）；</li><li><code>inital</code>：同步引入的库进行分离；</li><li><code>all</code>：所有引入的库进行分离（推荐）。</li></ul></li><li><code>minSize</code>：抽离公共包最小大小（字节）；</li><li><code>maxSize</code>：抽离公共包最大大小（字节）；</li><li><code>minChunks</code>：抽离公共包最小使用次数；</li><li><code>maxAsyncRequests</code>：浏览器同时请求同步资源的个数；</li><li><code>maxInitalRequests</code>：浏览器同时请求异步资源的个数；</li><li><code>automaticNameDelimiter</code>：抽离插件的文件的间隔符；</li><li><code>name</code>：值为 <code>true</code> 根据模块名称和缓存组键自动选择名称；</li></ul><p><strong>使用自定义缓存组 <code>cacheGroups</code> 配置示例：</strong></p><figure class="highlight js"><figcaption><span>自定义缓存组拆分同步异步模块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'commons'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          minSize: <span class="number">0</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">          priority: <span class="number">-5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'async-commons'</span>: &#123;</span><br><span class="line">          chunks: <span class="string">'async'</span>,</span><br><span class="line">          name: <span class="string">'async-commons'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          minSize: <span class="number">0</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">          priority: <span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">10</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'async-vendors'</span>: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          chunks: <span class="string">'async'</span>,</span><br><span class="line">          name: <span class="string">'async-vendors'</span>,</span><br><span class="line">          priority: <span class="number">15</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>cacheGroups</code> 参数详解：</strong></p><ul><li><code>commons</code>：所有代码中的公共依赖（同步）；<ul><li><code>test</code>：匹配依赖代码的文件夹，通常匹配 <code>node_modules</code>；</li><li><code>reuseExistingChunk</code>：允许重用现有模块，而不是在模块完全匹配时创建新块；</li><li><code>priority</code>：权重，当被多个规则重用时会根据权重打包到对应策略的文件中；</li><li><code>enforce</code>：设置为 <code>true</code> 强制按照该规则拆分出一个文件，忽略文件大小；</li></ul></li><li><code>async-commons</code>：所有代码中的公共依赖（异步）；</li><li><code>vendors</code>：依赖代码（<code>node_modules</code>）中的公共依赖（同步）；</li><li><code>async-vendors</code>：依赖代码（<code>node_modules</code>）中的公共依赖（异步）；</li></ul><blockquote class="pullquote warning"><p><strong>注意：在使用 <code>cacheGroups</code> 属性进行代码分割后，产生的新 <code>chunks</code> 名称必须配置在页面对应的 <code>HtmlWebpackPlugin</code> 实例的 <code>chunks</code> 属性中进行配置。</strong></p></blockquote><p><strong><code>HtmlWebpackPlugin</code> 配置：</strong></p><figure class="highlight js"><figcaption><span>HtmlWebpackPlugin 使用前需安装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebPackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      chunks: [</span><br><span class="line">        <span class="string">'commons'</span>,</span><br><span class="line">        <span class="string">'async-commons'</span>,</span><br><span class="line">        <span class="string">'vendors'</span>,</span><br><span class="line">        <span class="string">'async-vendors'</span>,</span><br><span class="line">        <span class="string">'index'</span></span><br><span class="line">      ]</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/11/10/20181110203121/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 策略模式</title>
      <link>https://www.overtaking.top/2018/10/06/20181006014812/</link>
      <guid>https://www.overtaking.top/2018/10/06/20181006014812/</guid>
      <pubDate>Fri, 05 Oct 2018 17:48:12 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/10/06/20181006014812/strategy.jpg&quot; title=&quot;策略模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/10/06/20181006014812/strategy.jpg" title="策略模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li><li><a href="https://www.overtaking.top/2018/10/04/20181004114907/" target="_blank">《设计模式 JS 表现 —— 发布/订阅和观察者模式》</a></li><li><a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">《设计模式 JS 表现 —— 状态模式》</a></li></ul><h2 id="策略模式简介"><a href="#策略模式简介" class="headerlink" title="策略模式简介"></a>策略模式简介</h2><p>“策略模式” 是将定义的一组算法封装起来，使其可以相互替换，封装的算法具有一定的独立性，让算法独立于客户端而变化，可以大大减少 <code>if...else</code> 和 <code>switch...case</code> 等判断。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/10/06/20181006014812/strategy-uml.jpg" alt="策略模式 UML 图" title="">                </div>                <div class="image-caption">策略模式 UML 图</div>            </figure><p><br></p><h2 id="策略模式的实现"><a href="#策略模式的实现" class="headerlink" title="策略模式的实现"></a>策略模式的实现</h2><p>下面是一个关于会员打折的逻辑，根据顾客身份不同输出不同的支付金额，是未使用 “策略模式” 的实现。</p><figure class="highlight js"><figcaption><span>未使用策略模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  pay(amount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'member'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> amount * <span class="number">0.9</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'vip'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> amount * <span class="number">0.8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="keyword">new</span> Customer(<span class="string">'normal'</span>);</span><br><span class="line"><span class="keyword">let</span> c2 = <span class="keyword">new</span> Customer(<span class="string">'member'</span>);</span><br><span class="line"><span class="keyword">let</span> c3 = <span class="keyword">new</span> Customer(<span class="string">'vip'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c1.pay(<span class="number">100</span>)); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.pay(<span class="number">100</span>)); <span class="comment">// 90</span></span><br><span class="line"><span class="built_in">console</span>.log(c3.pay(<span class="number">100</span>)); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure><p>上面的代码与 <a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">状态模式</a> 一节中的问题类似，违反开放封闭原则和单一职责原则，代码冗余且判断条件过多，“状态模式” 虽然可以解决状态不同时不同复杂逻辑的抽离和解耦，但是并不能解决过多条件判断的问题，下面就是用 “策略模式” 来对这个点进行优化。</p><figure class="highlight js"><figcaption><span>使用策略模式优化 —— 策略类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(kind) &#123;</span><br><span class="line">    <span class="keyword">this</span>.kind = kind;</span><br><span class="line">  &#125;</span><br><span class="line">  pay(amount) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.kind.pay(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normal</span> </span>&#123;</span><br><span class="line">  pay(amount) &#123;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  pay(amount) &#123;</span><br><span class="line">    <span class="keyword">return</span> amount * <span class="number">0.9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VIP</span> </span>&#123;</span><br><span class="line">  pay(amount) &#123;</span><br><span class="line">    <span class="keyword">return</span> amount * <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="keyword">new</span> Customer(<span class="keyword">new</span> Normal());</span><br><span class="line"><span class="keyword">let</span> c2 = <span class="keyword">new</span> Customer(<span class="keyword">new</span> Member());</span><br><span class="line"><span class="keyword">let</span> c3 = <span class="keyword">new</span> Customer(<span class="keyword">new</span> VIP());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c1.pay(<span class="number">100</span>)); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.pay(<span class="number">100</span>)); <span class="comment">// 90</span></span><br><span class="line"><span class="built_in">console</span>.log(c3.pay(<span class="number">100</span>)); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure><p>上面是使用策略类对复杂判断逻辑的内容进行了抽象，并将原本 <code>if...else</code> 中的逻辑分别放在了不同的策略类中维护，如果每一个策略类中要维护的逻辑并不是很复杂，也可以使用第二种方案，即使用策略对象维护不同的逻辑。</p><figure class="highlight js"><figcaption><span>使用策略模式优化 —— 策略对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 策略对象</span></span><br><span class="line">    <span class="keyword">this</span>.kinds = &#123;</span><br><span class="line">      normal(amount) &#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">      &#125;,</span><br><span class="line">      member(amount) &#123;</span><br><span class="line">        <span class="keyword">return</span> amount * <span class="number">0.9</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      vip(amount) &#123;</span><br><span class="line">        <span class="keyword">return</span> amount * <span class="number">0.8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  pay(kind, amount) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.kinds[kind](amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="keyword">new</span> Customer();</span><br><span class="line"><span class="keyword">let</span> c2 = <span class="keyword">new</span> Customer();</span><br><span class="line"><span class="keyword">let</span> c3 = <span class="keyword">new</span> Customer();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c1.pay(<span class="string">'normal'</span>, <span class="number">100</span>)); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.pay(<span class="string">'member'</span>, <span class="number">100</span>)); <span class="comment">// 90</span></span><br><span class="line"><span class="built_in">console</span>.log(c3.pay(<span class="string">'vip'</span>, <span class="number">100</span>)); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure><h2 id="策略模式的应用"><a href="#策略模式的应用" class="headerlink" title="策略模式的应用"></a>策略模式的应用</h2><h3 id="jQuery-的-animate-动画"><a href="#jQuery-的-animate-动画" class="headerlink" title="jQuery 的 animate 动画"></a>jQuery 的 animate 动画</h3><p>在 <code>jQuery</code> 的源码实现中，<code>animate</code> 方法就用到了 “策略模式”，通过不同的状态定义了动画不同的行为，使用代码如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery-animate<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    #content&#123;</span></span><br><span class="line"><span class="undefined">        width: 100px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        background-color: pink;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"bigger"</span>&gt;</span>变大<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/jquery/2.0.0/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#bigger'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'#content'</span>).animate(&#123;</span></span><br><span class="line"><span class="javascript">        width: <span class="string">'200px'</span>,</span></span><br><span class="line"><span class="javascript">        height: <span class="string">'200px'</span></span></span><br><span class="line"><span class="javascript">      &#125;, <span class="number">1000</span>, <span class="string">'linear'</span>); <span class="comment">// linear 参数为动画策略的一种类型</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>在 <a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">装饰器模式</a> 一节中也有表单校验的应用，代码如下。</p><figure class="highlight html"><figcaption><span>表单校验应用装饰器模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">  密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit-btn"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submit-btn'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 添加切面函数</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> result = beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">      result &amp;&amp; _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 表单提交事件</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'提交表单'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 验证用户名</span></span></span><br><span class="line"><span class="javascript">  submit = submit.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!username) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> alert(<span class="string">'请输入用户名'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 验证</span></span></span><br><span class="line"><span class="javascript">  submit = submit.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!password) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> alert(<span class="string">'请输入密码'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  submitBtn.addEventListener(<span class="string">'click'</span>, submit);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>“装饰器模式” 是将对每个表单校验逻辑，通过增加切面（<code>AOP</code>）的方式插入在了 <code>submit</code> 事件之前，如果有一个校验不通过则不会执行下一个切面的校验操作或提交表单，但是这样的表单校验有局限性，如果页面表单校验非常多需要对校验逻辑进行统一管理，并且大多数场景下是所有的表单都校验后对所有的表单进行错误提示，这是就需要 “策略模式” 的策略对象来管理所有的校验逻辑。</p><figure class="highlight html"><figcaption><span>表单校验应用策略模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"userform"</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">  密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">  手机号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"mobile"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'userform'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> validator = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> rules = &#123;</span></span><br><span class="line"><span class="undefined">      noEmpty(val, msg) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (val === <span class="string">''</span>) <span class="keyword">return</span> msg;</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      minLength(val, min, msg)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (val === <span class="string">''</span> || val.length &lt; min) <span class="keyword">return</span> msg;</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      isMobile(val, msg) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!<span class="regexp">/1\d&#123;10&#125;/</span>.test(val)) <span class="keyword">return</span> msg;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 存储</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> checks = [];</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 增加校验的项目</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">element, rule</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      checks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// ['minLength', 6, '密码长度不能少于 6 位']</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> name = rule.shift();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// [val, 6, '密码长度不能少于 6 位']</span></span></span><br><span class="line"><span class="undefined">        rule.unshift(element.value);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> rules[name] &amp;&amp; rules[name].apply(element, rule);</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 给策略对象增加新的功能</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">addRule</span>(<span class="params">name, rule</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">      rules[name] = rule;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 开始校验</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; checks.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> msg = checks[i]();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (msg) <span class="keyword">return</span> msg;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123; add, addRule, start &#125;;</span></span><br><span class="line"><span class="undefined">  &#125;)();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 添加自定义规则</span></span></span><br><span class="line"><span class="javascript">  validator.addRule(<span class="string">'maxLength'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val, max, msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (val === <span class="string">''</span> || val.length &gt; max) <span class="keyword">return</span> msg;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  form.onsubmit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    validator.add(form.username, [<span class="string">'noEmpty'</span>, <span class="string">'用户名不能为空'</span>]);</span></span><br><span class="line"><span class="javascript">    validator.add(form.password, [<span class="string">'minLength'</span>, <span class="number">6</span>, <span class="string">'密码长度不能少于 6 位'</span>]);</span></span><br><span class="line"><span class="javascript">    validator.add(form.password, [<span class="string">'maxLength'</span>, <span class="number">12</span>, <span class="string">'密码长度不能大于 12 位'</span>]);</span></span><br><span class="line"><span class="javascript">    validator.add(form.mobile, [<span class="string">'isMobile'</span>, <span class="string">'必须输入合法的手机号'</span>]);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> msg = validator.start();</span></span><br><span class="line"><span class="javascript">    alert(msg || <span class="string">'校验通过'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> !msg;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过对比两段代码可以显而易见的看出 “策略模式” 在对于表单校验的功能上比 “装饰器模式” 更加健壮，可以在保证可维护性的基础上支持更多复杂的功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“策略模式” 和 “状态模式” 都有上下文、策略和状态类，上下文把这些请求委托给这些类来执行，“策略模式” 中，各个类是平等的，没有关系，客户端需要知道算法主动切换，“状态模式” 中，状态的切换和行为被封装好了，客户端不需要了解细节，所以 “策略模式” 真正意义的解决了状态过多时条件判断过多的问题，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/10.strategy" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/10/06/20181006014812/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 状态模式</title>
      <link>https://www.overtaking.top/2018/10/05/20181005161213/</link>
      <guid>https://www.overtaking.top/2018/10/05/20181005161213/</guid>
      <pubDate>Fri, 05 Oct 2018 08:12:13 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/10/05/20181005161213/state.jpg&quot; title=&quot;状态模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote danger&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/10/05/20181005161213/state.jpg" title="状态模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote danger"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li><li><a href="https://www.overtaking.top/2018/10/04/20181004114907/" target="_blank">《设计模式 JS 表现 —— 发布/订阅和观察者模式》</a></li><li><a href="https://www.overtaking.top/2018/10/06/20181006014812/" target="_blank">《设计模式 JS 表现 —— 策略模式》</a></li></ul><h2 id="状态模式简介"><a href="#状态模式简介" class="headerlink" title="状态模式简介"></a>状态模式简介</h2><p>有些情况下一个对象的行为取决于一个或者多个动态变化的属性，这样的属性叫做状态，这个对象叫做有状态的对象，这种情况下通常有很多的判断来处理状态不同时代码的执行逻辑，执行逻辑可能会非常复杂，让代码变得难以维护，“状态模式” 就是将这些逻辑委托给外面的对象或类来单独维护，来减少状态对象的逻辑，增强代码的维护性。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/10/05/20181005161213/state-uml.jpg" alt="状态模式 UML 图" title="">                </div>                <div class="image-caption">状态模式 UML 图</div>            </figure><p><br></p><h2 id="状态模式的实现"><a href="#状态模式的实现" class="headerlink" title="状态模式的实现"></a>状态模式的实现</h2><p>下面是一个类，功能为根据电池不同状态打印当前不同的颜色，下面是正常的实现方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.amount = <span class="string">'high'</span>; <span class="comment">// 电量高</span></span><br><span class="line">  &#125;</span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.amount === <span class="string">'high'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'显示绿色'</span>);</span><br><span class="line">      <span class="keyword">this</span>.amount = <span class="string">'middle'</span>; <span class="comment">// 电量中等</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.amount === <span class="string">'middle'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'显示黄色'</span>);</span><br><span class="line">      <span class="keyword">this</span>.amount = <span class="string">'low'</span>; <span class="comment">// 电量低</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.amount === <span class="string">'low'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'显示红色'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> battery = <span class="keyword">new</span> Battery();</span><br><span class="line"></span><br><span class="line">battery.show(); <span class="comment">// 显示绿色</span></span><br><span class="line">battery.show(); <span class="comment">// 显示黄色</span></span><br><span class="line">battery.show(); <span class="comment">// 显示红色</span></span><br></pre></td></tr></table></figure><p>上面的代码虽然实现了我们想要的功能，但是代码中 <code>show</code> 方法违反了开放封闭原则和单一职责原则，状态切换逻辑不明显，判断条件太多，维护性和扩展性差，下面使用状态模式进行优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.amount = <span class="string">'high'</span>; <span class="comment">// 电量高</span></span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">new</span> SuccessState(); <span class="comment">// 绿色状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="comment">// 把显示逻辑委托给状态对象</span></span><br><span class="line">    <span class="keyword">this</span>.state.show();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.amount === <span class="string">'high'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.amount = <span class="string">'middle'</span>; <span class="comment">// 电量中等</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="keyword">new</span> WarningState(); <span class="comment">// 黄色状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.amount === <span class="string">'middle'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.amount = <span class="string">'low'</span>; <span class="comment">// 电量低</span></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="keyword">new</span> ErrorState(); <span class="comment">// 红色状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuccessState</span> </span>&#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'显示绿色'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarningState</span> </span>&#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'显示黄色'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorState</span> </span>&#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'显示红色'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> battery = <span class="keyword">new</span> Battery();</span><br><span class="line"></span><br><span class="line">battery.show(); <span class="comment">// 显示绿色</span></span><br><span class="line">battery.show(); <span class="comment">// 显示黄色</span></span><br><span class="line">battery.show(); <span class="comment">// 显示红色</span></span><br></pre></td></tr></table></figure><p>经过 “状态模式” 的优化，我们将状态拆分成三个类，无论关于状态操作的多复杂的逻辑都在拆分出的类中实现，而不再需要在状态对象 <code>Battery</code> 中。</p><h2 id="状态模式的应用"><a href="#状态模式的应用" class="headerlink" title="状态模式的应用"></a>状态模式的应用</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>点赞是我们在项目开发中经常见到的功能，点赞后也可以取消点赞，这就出现了按钮关于点赞状态的切换和按钮文案的切换，下面是使用 “状态模式” 来实现的点赞功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 维护点赞渲染逻辑的对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> likeState = &#123;</span></span><br><span class="line"><span class="undefined">    render(element) &#123;</span></span><br><span class="line"><span class="javascript">      element.innerHTML = <span class="string">'赞'</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 维护取消点赞渲染逻辑的对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> likedState = &#123;</span></span><br><span class="line"><span class="undefined">    render(element) &#123;</span></span><br><span class="line"><span class="javascript">      element.innerHTML = <span class="string">'取消'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">constructor</span>(container) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.liked = <span class="literal">false</span>; <span class="comment">// 默认为未点赞状态</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.state = likeState; <span class="comment">// 设置当前的状态为未点赞</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.element = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span></span><br><span class="line"><span class="javascript">      container.appendChild(<span class="keyword">this</span>.element);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.render(); <span class="comment">// 初始化渲染</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    setState(state) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.state = state; <span class="comment">// 修改渲染状态</span></span></span><br><span class="line"><span class="javascript">      button.liked = !button.liked; <span class="comment">// 修改状态属性</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.render(); <span class="comment">// 重新渲染</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    render() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.state.render(<span class="keyword">this</span>.element);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取按钮对象并添加点击事件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> button = <span class="keyword">new</span> Button(<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span></span><br><span class="line"><span class="javascript">  button.element.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="undefined">    button.setState(button.liked ? likeState : likedState);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码使用 “状态模式” 统一封装了按钮的类 <code>Button</code>，传入的参数为渲染按钮的容器元素，按钮类的内部创建按钮并添加到容器元素中，统一管理了点赞状态，点赞渲染对象，如果想要切换状态只需要执行 <code>button</code> 对象提供的 <code>setState</code> 方法通过传入的不同状态对象进行状态切换和页面渲染。</p><h3 id="React-组件显示隐藏"><a href="#React-组件显示隐藏" class="headerlink" title="React 组件显示隐藏"></a>React 组件显示隐藏</h3><p>在 <code>React</code> 中，经常会出现通过事件切换组件的显示隐藏，最简单的方式是通过类组件状态来控制，但其实也可以使用 “状态模式” 在组件外编写对状态更改的逻辑，这样可以使组件的逻辑更清晰，代码更精简。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态管理对象</span></span><br><span class="line"><span class="keyword">const</span> States = &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'显示 Banner'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isShow</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  hide() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'隐藏 Banner'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isShow</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banner</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">isShow</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  toggle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = <span class="keyword">this</span>.setState.isShow;</span><br><span class="line">    States[currentState] &amp;&amp; States[currentState].apply(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          isShow &amp;&amp; (</span><br><span class="line">            &lt;nav&gt;导航&lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">          )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        &lt;button&gt;toggle&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Banner /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>在上面代码中组件外部的 <code>States</code> 就是管理切换状态逻辑的对象，就是说 “状态模式” 也可以在框架中单独使用。</p><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>其实 “状态模式” 来源一个有限状态机的概念，有限状态机是指一个事物拥有多种状态，但是同一时间只会处于一种状态，可以通过动作来改变当前的状态，在 <code>JavaScript</code> 中拥有第三方模块 <code>javascript-state-machine</code> 专门帮我们来做这件事。</p><h3 id="javascript-state-machine-使用"><a href="#javascript-state-machine-使用" class="headerlink" title="javascript-state-machine 使用"></a>javascript-state-machine 使用</h3><p><code>javascript-state-machine</code> 提供一个类，创建实例时传入的参数为一个 <code>options</code> 对象，属性 <code>init</code> 用来定义初始状态值，属性 <code>transitions</code> 用来定义属性变化，<code>methods</code> 用来定义属性发生变化时所触发的钩子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有限状态机对象</span></span><br><span class="line"><span class="keyword">const</span> StateMachine = <span class="built_in">require</span>(<span class="string">'javascript-state-machine'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fsm = <span class="keyword">new</span> StateMachine(&#123;</span><br><span class="line">  init: <span class="string">'solid'</span>, <span class="comment">// 初始状态（固态）</span></span><br><span class="line">  transitions: [</span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="string">'solid'</span>, <span class="attr">to</span>: <span class="string">'liquid'</span>, <span class="attr">name</span>: <span class="string">'melt'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="string">'liquid'</span>, <span class="attr">to</span>: <span class="string">'solid'</span>, <span class="attr">name</span>: <span class="string">'freeze'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="string">'liquid'</span>, <span class="attr">to</span>: <span class="string">'gas'</span>, <span class="attr">name</span>: <span class="string">'vaporize'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="string">'gas'</span>, <span class="attr">to</span>: <span class="string">'liquid'</span>, <span class="attr">name</span>: <span class="string">'condense'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onMelt() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'melt'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    onFreeze() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'freeze'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    onVaporize() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'vaporize'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    onCondense() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'condense'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fsm.state); <span class="comment">// solid</span></span><br><span class="line"><span class="built_in">console</span>.log(fsm.can(<span class="string">'gas'</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(fsm.cannot(<span class="string">'gas'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fsm.transitions()); <span class="comment">// [ 'melt' ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fsm.allTransitions());</span><br><span class="line"><span class="comment">// [ 'init', 'melt', 'freeze', 'vaporize', 'condense' ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fsm.allStates()); <span class="comment">// [ 'none', 'solid', 'liquid', 'gas' ]</span></span><br><span class="line"></span><br><span class="line">fsm.melt(); <span class="comment">// melt</span></span><br><span class="line"><span class="built_in">console</span>.log(fsm.state); <span class="comment">// liquid</span></span><br><span class="line"><span class="built_in">console</span>.log(fsm.transitions()); <span class="comment">// [ 'freeze', 'vaporize' ]</span></span><br></pre></td></tr></table></figure><ul><li><code>fsm.state</code>：当前状态；</li><li><code>fsm.can</code>：查看是否可直接转换到某个状态，参数为要转换的状态值；</li><li><code>fsm.cannot</code>：查看是否不能直接转换到某个状态，参数为要转换的状态值；</li><li><code>fsm.transitions</code>：返回可转换状态的方法列表；</li><li><code>fsm.allTransitions</code>：返回所有状态转换方法列表；</li><li><code>fsm.allStates</code>：返回定义的所有状态。</li></ul><h3 id="javascript-state-machine-原理"><a href="#javascript-state-machine-原理" class="headerlink" title="javascript-state-machine 原理"></a>javascript-state-machine 原理</h3><p>根据 <code>javascript-state-machine</code> 的用法我们模拟实现最基本的逻辑，构建一个有限状态机，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateMachine</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      init = <span class="string">'none'</span>,</span><br><span class="line">      transitions = [],</span><br><span class="line">      methods = &#123;&#125;</span><br><span class="line">    &#125; = options;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = init;</span><br><span class="line"></span><br><span class="line">    transitions.forEach(<span class="function"><span class="params">transition</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; <span class="keyword">from</span>, to, name &#125; = transition;</span><br><span class="line">      <span class="keyword">this</span>[name] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="keyword">from</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.state = to;</span><br><span class="line">          <span class="keyword">let</span> method = <span class="string">`on<span class="subst">$&#123;name.slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase()&#125;</span><span class="subst">$&#123;name.slice(<span class="number">1</span>)&#125;</span>`</span>;</span><br><span class="line">          methods[method] &amp;&amp; methods[method]();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“状态模式” 实现的有限状态机可以更大限度的让状态变化与状态对象进行解耦，更减少了大量的判断逻辑，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/9.state" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/10/05/20181005161213/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 发布/订阅和观察者模式</title>
      <link>https://www.overtaking.top/2018/10/04/20181004114907/</link>
      <guid>https://www.overtaking.top/2018/10/04/20181004114907/</guid>
      <pubDate>Thu, 04 Oct 2018 03:49:07 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/10/04/20181004114907/observer.jpg&quot; title=&quot;观察者模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/10/04/20181004114907/observer.jpg" title="观察者模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li><li><a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">《设计模式 JS 表现 —— 状态模式》</a></li><li><a href="https://www.overtaking.top/2018/10/06/20181006014812/" target="_blank">《设计模式 JS 表现 —— 策略模式》</a></li></ul><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><h3 id="发布-订阅模式实现"><a href="#发布-订阅模式实现" class="headerlink" title="发布/订阅模式实现"></a>发布/订阅模式实现</h3><p>在说 “观察者模式” 之前一定要说一下 “发布/订阅模式”，因为这两个模式非常相似又有些不同，最重要的是都是使用频繁的设计模式。</p><figure class="highlight js"><figcaption><span>发布/订阅的类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  on(type, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.events[type]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type] = [ fn ];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type].push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  emit(type) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[type]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的类有一个基本属性 <code>events</code>，值为对象，用来存储不同类型的事件集合，原型方法 <code>on</code> 是用来订阅事件，第一个参数 <code>type</code> 为订阅事件的类型，<code>fn</code> 是要被执行的事件，<code>emit</code> 方法用来执行某个类型所有的事件。</p><figure class="highlight js"><figcaption><span>发布/订阅的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> Event();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">event.on(<span class="string">'say'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'hello'</span>));</span><br><span class="line">event.on(<span class="string">'say'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'world'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">event.emit(<span class="string">'say'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><h3 id="发布-订阅模式的应用"><a href="#发布-订阅模式的应用" class="headerlink" title="发布/订阅模式的应用"></a>发布/订阅模式的应用</h3><p><strong>浏览器事件监听：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"><span class="javascript">  btn.addEventListener(<span class="string">'click'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="number">1</span>));</span></span><br><span class="line"><span class="javascript">  btn.addEventListener(<span class="string">'click'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="number">2</span>));</span></span><br><span class="line"><span class="javascript">  btn.addEventListener(<span class="string">'click'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="number">3</span>));</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当点击按钮触发事件时，三个回调函数会按照添加的顺序依次执行。</p><p><strong>Promise 的异步调用的回调管理：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'res'</span>), <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>, data));</span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>, data));</span><br></pre></td></tr></table></figure><p>上面给同一个 <code>Promise</code> 实例的 <code>then</code> 方法中添加了两个回调函数，因为在创建 <code>Promise</code> 实例时内部使用了定时器，所以状态的变化延后了 <code>3s</code>，其实在 <code>Promise</code> 内部也是通过队列来对 <code>then</code> 的回调进行统一管理，在状态发生变化后立即循环执行。</p><blockquote class="pullquote primary"><p><strong>在 NodeJS 中，有一个核心模块 <code>events</code> 提供类 <code>EventEmitter</code>，几乎所有的事件都是基于这个模块实现的，如流的 <code>data</code> 和 <code>end</code> 事件、<code>http</code> 的 <code>request</code> 事件，而 <code>EventEmitter</code> 的内部原理就是 “发布/订阅模式”。</strong></p></blockquote><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="观察者模式的简单实现"><a href="#观察者模式的简单实现" class="headerlink" title="观察者模式的简单实现"></a>观察者模式的简单实现</h3><p>下面我们是 “观察者模式” 的案例，通过上面 “发布/订阅模式” 的实现来对比一下异同。</p><figure class="highlight js"><figcaption><span>观察者模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  getState() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">  &#125;</span><br><span class="line">  setState(state) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">    <span class="keyword">this</span>.notify(); <span class="comment">// 更新状态后通知</span></span><br><span class="line">  &#125;</span><br><span class="line">  attach(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer); <span class="comment">// 添加观察者</span></span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// 订阅状态的观察者更新修改后的状态</span></span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer.update());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fan</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, star) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.star = star;</span><br><span class="line">    <span class="keyword">this</span>.star.attach(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我喜欢的明星喜欢<span class="subst">$&#123;<span class="keyword">this</span>.star.getState()&#125;</span>，我也喜欢。`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 “观察者模式” 中有两个基本的类，观察者和被观察者，被观察者提供状态 <code>state</code>，观察者去使用这个状态，当被观察者更新状态时会主动发布到订阅了状态的观察中，实现同步更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> star = <span class="keyword">new</span> Star(<span class="string">'Angular Baby'</span>);</span><br><span class="line"><span class="keyword">let</span> fan = <span class="keyword">new</span> Fan(<span class="string">'张三'</span>, star);</span><br><span class="line"></span><br><span class="line">star.setState(<span class="string">'绿色'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我喜欢的明星喜欢绿色，我也喜欢。</span></span><br></pre></td></tr></table></figure><h3 id="观察者模式的应用"><a href="#观察者模式的应用" class="headerlink" title="观察者模式的应用"></a>观察者模式的应用</h3><p><strong>Vue 框架的数据响应式原理及 watch 方法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>FullName: &#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    FirstName:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    LastName:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#root'</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="javascript">      firstName: <span class="string">'张'</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">'三'</span>,</span></span><br><span class="line"><span class="javascript">      fullName: <span class="string">'张三'</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    watch: &#123;</span></span><br><span class="line"><span class="undefined">      firstName(newName, oldName) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.fullName = <span class="string">`<span class="subst">$&#123;newName&#125;</span><span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>Vue 2.x</code> 版本的数据响应式和 <code>watch</code> 监听的底层，就使用了 “观察者模式”，在模板解析过程中为变量添加观察者（<code>watcher</code>），在使用 <code>Object.defineProperty</code> 的 <code>getter</code> 和 <code>setter</code> 进行劫持数据，数据获取和更改会触发 <code>get</code> 和 <code>set</code> 方法，进而执行订阅和通知的逻辑，而通知的过程中调用了被统一管理的观察者的 <code>update</code> 方法，实现了视图层与数据层的同步。</p><p><strong>redux 的 createStore 方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 store</span></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅方法</span></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">    listeners.push(fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消订阅方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">listener</span> =&gt;</span> listener !== fn);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 派发动作</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    state = reducer(state, action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">'@INIT'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    subscribe,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>redux</code> 的实现思想中也包含了 “观察者模式”，例如在 <code>redux</code> 与 <code>React</code> 的配合使用，<code>redux</code> 提供了订阅的方法 <code>subscribe</code> 和派发动作更新 <code>store</code> 的方法 <code>dispatch</code>，<code>React</code> 组件会使用 <code>store</code> 中提供的状态数据，这个 <code>store</code> 就是被观察者，而观察者就是 <code>React</code> 的各个组件，当使用 <code>dispatch</code> 派发动作更新数据时，会执行所有的观察者中的监听函数，实现组件数据与 <code>store</code> 的同步。</p><h2 id="观察者模式和发布-订阅模式"><a href="#观察者模式和发布-订阅模式" class="headerlink" title="观察者模式和发布/订阅模式"></a>观察者模式和发布/订阅模式</h2><p>观察者模式是由 “发布/订阅模式” 演变过来的，都存在订阅、通知的事件机制，“发布/订阅模式” 是对订阅的事件进行统一管理，主动触发通知，依次执行订阅的事件，而 “观察者模式” 是通过一个单独类去订阅观察者，当状态发生变化时通知到各个 “观察者” 实现状态的更新同步。</p><blockquote class="pullquote warning"><p><strong>“观察者模式” 事件是被观察者调度，而 “发布/订阅模式” 事件是统一由调度中心调度；</strong><br><strong>“观察者模式” 的订阅与发布是存在依赖的，而 “发布/订阅模式” 订阅发布不存在依赖。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“观察者模式” 的意义就在于可以使多个对象数据重合的部分进行复用，同时还可以对各个对象之间解耦，最重要的是数据更新可以及时通知所有数据的使用者进行数据同步，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/8.observe" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/10/04/20181004114907/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Webpack4 —— 基础篇</title>
      <link>https://www.overtaking.top/2018/10/02/20181002041434/</link>
      <guid>https://www.overtaking.top/2018/10/02/20181002041434/</guid>
      <pubDate>Mon, 01 Oct 2018 20:14:34 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;为什么需要构建工具？&quot;&gt;&lt;a href=&quot;#为什么需要构建工具？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要构建工具？&quot;&gt;&lt;/a&gt;为什么需要构建工具？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;转换 &lt;code&gt;ES6+&lt;/code&gt; 语法&lt;/li&gt;
&lt;li&gt;转换 &lt;code&gt;JSX&lt;/code&gt; 语法 / &lt;code&gt;Vue&lt;/code&gt; 指令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CSS&lt;/code&gt; 私有前缀补全 / 预处理器（&lt;code&gt;less&lt;/code&gt;，&lt;code&gt;sass&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;压缩混淆 / 图片压缩&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="为什么需要构建工具？"><a href="#为什么需要构建工具？" class="headerlink" title="为什么需要构建工具？"></a>为什么需要构建工具？</h2><ul><li>转换 <code>ES6+</code> 语法</li><li>转换 <code>JSX</code> 语法 / <code>Vue</code> 指令</li><li><code>CSS</code> 私有前缀补全 / 预处理器（<code>less</code>，<code>sass</code>）</li><li>压缩混淆 / 图片压缩</li></ul><a id="more"></a><h2 id="为什么选择-Webpack？"><a href="#为什么选择-Webpack？" class="headerlink" title="为什么选择 Webpack？"></a>为什么选择 Webpack？</h2><p>早期的打包工具有 <code>Grount</code>，是本质的的方式把打包构建分成一个一个的任务，队列式的处理每一个任务，如解析 <code>Html</code> 任务、解析 <code>CSS</code> 任务、解析 <code>JS</code> 任务、图片压缩任务、代码压缩任务等等，每一个任务处理完成之后会将任务结果存放在本地磁盘的 <code>.temp</code> 目录，由于产生了 <code>IO</code> 操作，会导致打包速度比较慢。</p><p>后来产生了 <code>Glup</code>，原理与 <code>Grount</code> 类似，管道式的处理打包任务，不同的是 <code>Gulp</code> 有文件流的概念，每一个任务构建后的结果不会存放磁盘，而是存在内存中，在下一个步骤中可以直接使用上一个步骤内存中的结果，提高了打包速度。</p><p>目前最火爆的打包工具是 <code>Webpack</code>，在打包性能优于上面工具的基础上，更归功于丰富的生态社区、配置灵活的 <code>Loader</code> 和 <code>Plugin</code>，可以通过很灵活的配置完成团队项目个性化的打包需求，并且拥有强大的官方团队进行更新迭代，维护了众多稳定的 <code>Loader</code> 和 <code>Plugin</code>，更新速度非常快。</p><h2 id="安装-Webpack-及打包命令"><a href="#安装-Webpack-及打包命令" class="headerlink" title="安装 Webpack 及打包命令"></a>安装 Webpack 及打包命令</h2><figure class="highlight bash"><figcaption><span>安装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>使用 <code>Webpack</code> 进行打包执行的其实是 <code>./node_modules/.bin</code> 目录的 <code>webpack</code> 文件。</p><figure class="highlight bash"><figcaption><span>打包命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack</span><br></pre></td></tr></table></figure><p>为了方便项目中通常将打包命令配置在 <code>package.json</code> 的 <code>scripts</code> 中。</p><figure class="highlight json"><figcaption><span>打包命令配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>执行配置后的打包命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h2 id="Webpack-基础配置"><a href="#Webpack-基础配置" class="headerlink" title="Webpack 基础配置"></a>Webpack 基础配置</h2><h3 id="零配置"><a href="#零配置" class="headerlink" title="零配置"></a>零配置</h3><p>在 <code>Webpack4</code> 中，在不编写配置文件也可以进行打包，这就是 <code>4.x</code> 版本号称的 “零配置”，其实内部默认对入口文件（<code>entry</code>）和出口文件（<code>output</code>）进行了配置。</p><figure class="highlight js"><figcaption><span>零配置默认值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: <span class="string">'./dist/main.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p><code>mode</code> 是 <code>Webpack4</code> 新提出的概念，用来指定当前构建环境是开发环境（<code>production</code>）、生产环境（<code>development</code>）或 <code>none</code>，默认为 <code>production</code>，设置 <code>mode</code> 可以使用 <code>Webpack</code> 的一些参数值和内置的函数，也可以在打包时针对不同的环境配置不同的打包和优化策略。</p><p><strong><code>mode</code> 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置为 <code>development</code> 开启的参数如下：</strong></p><ul><li>设置 <code>process.env.NODE_ENV</code> 值为 <code>development</code>；</li><li>开启 <code>NamedChunksPlugin</code>、<code>NamedModulesPlugin</code>，在代码热更新阶段标识更新的 <code>chunk</code> 和具体模块。</li></ul><p><strong>设置为 <code>production</code> 开启的参数如下：</strong></p><ul><li>设置 <code>process.env.NODE_ENV</code> 值为 <code>production</code>；</li><li>开启 <code>FlagDependencyUsagePlugin</code>、<code>FlagIncludedChunksPlugin</code>、<code>NoEmitOnErrorsPlugin</code>、<code>ModuleConcatenationPlugin</code>、<code>OccurrenceOrderPlugin</code>、<code>SideEffectsFlagPlugin</code>、<code>TerserPlugin</code>，开启这些插件 <code>Webpack</code> 会对 <code>JS</code> 压缩，识别 <code>package.json</code> 文件中标识代码是否存在副作用的参数等。</li></ul><blockquote class="pullquote info"><p><strong>将 <code>mode</code> 设置为 <code>none</code> 不开启任何优化选项。</strong></p></blockquote><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p><code>entry</code> 用于配置打包文件的入口，这个文件中会存在一些依赖关系，依赖的模块又存在依赖关系，最后形成一棵依赖树，<code>Webpack</code> 则将这些模块根据依赖关系，最后打包成多个静态资源，<code>entry</code> 主要有两种应用场景（单页应用和多页应用），配置如下。</p><figure class="highlight js"><figcaption><span>单入口（SPA）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>多入口（多页应用）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/pages/app.js'</span>,</span><br><span class="line">    adminApp: <span class="string">'./src/pages/adminApp.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><code>entry</code> 配置是用于指定的是源代码，那 <code>output</code> 就是用于指定 <code>Webpack</code> 打包后的结果代码，即用来告诉 <code>Webpack</code> 如何将编译后的文件输出到磁盘。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>output</code> 属性值为对象，其中 <code>filename</code> 属性用于指定打包输出后的文件名，<code>path</code> 用于指定打包输出的目录，如果是多页应用，可以使用占位符保证打包后输出多个出口文件名字的唯一性。</p><figure class="highlight js"><figcaption><span>多页应用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/pages/app.js'</span>,</span><br><span class="line">    adminApp: <span class="string">'./src/pages/adminApp.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>[name]</code> 打包后最后输出的出口文件与入口配置的文件名对应，即 <code>app.js</code> 和 <code>adminApp.js</code>。</p><h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p><code>Webpack</code> 默认情况下只支持 <code>js</code> 和 <code>json</code> 两种文件类型，<code>loader</code> （加载器）是专门用来支持其他文件类型并把其他文件转换成有效的模块添加到依赖树中，每一个 <code>loader</code> 都默认导出一个函数，接受源文件作为参数，并返回转换的结果，<code>loaders</code> 选项是专门用来配置这些加载器的。</p><p><strong>常见 loader 表：</strong></p><table><thead><tr><th style="text-align:center; width: 30%;">名称</th><th style="text-align:center;" colspan="3">描述</th></tr></thead><tbody><tr><td style="text-align:center;">babel-loader</td><td style="text-align:center;">转化 <code>ES6</code>、<code>ES7</code> 等 <code>JS</code> 新特性</td></tr><tr><td style="text-align:center;">css-loader</td><td style="text-align:center;">支持 <code>.css</code> 文件的加载和解析</td></tr><tr><td style="text-align:center;">less-loader</td><td style="text-align:center;">将 <code>less</code> 文件转换成 <code>css</code></td></tr><tr><td style="text-align:center;">ts-loader</td><td style="text-align:center;">将 <code>TS</code> 转换成 <code>JS</code></td></tr><tr><td style="text-align:center;">file-loader</td><td style="text-align:center;">对图片、字体等文件的打包</td></tr><tr><td style="text-align:center;">raw-loader</td><td style="text-align:center;">将文件以字符串的形式导入</td></tr><tr><td style="text-align:center;">thread-loader</td><td style="text-align:center;">多进程打包 <code>JS</code> 和 <code>CSS</code></td></tr></tbody></table><p><strong>loader 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.txt$/</span>, <span class="comment">// 指定匹配规则（文件后缀名）</span></span><br><span class="line">        use: <span class="string">'raw-loader'</span> <span class="comment">// 指定使用的 loader 名称</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析-ES6-语法"><a href="#解析-ES6-语法" class="headerlink" title="解析 ES6+ 语法"></a>解析 ES6+ 语法</h4><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel/preset-env -D</span><br></pre></td></tr></table></figure><p><strong><code>loader</code> 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote success"><p><strong>在工程中添加 <code>.babelrc</code> 文件来对解析的 <code>ES6+</code> 语法进行配置。</strong></p></blockquote><p><strong><code>loader</code> 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>.babelrc</code> 配置示例：</strong></p><figure class="highlight json"><figcaption><span>以 babel7 为例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/preset-env"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/proposal-class-properties"</span></span><br><span class="line">    // ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote primary"><p><strong><code>babel</code> 配置主要包含两部分，<code>preset</code> 和 <code>plugins</code>，<code>plugins</code> 中配置的每一项都为解析的一个功能，而 <code>presets</code> 配置的是这些功能的集合。</strong></p></blockquote><h4 id="解析-React-的-JSX-语法"><a href="#解析-React-的-JSX-语法" class="headerlink" title="解析 React 的 JSX 语法"></a>解析 React 的 JSX 语法</h4><p>由于 <code>React</code> 是在 <code>.js</code> 或 <code>.jsx</code> 的文件中使用 <code>JSX</code> 语法，所以解析 <code>JSX</code> 语法也是解析 <code>JS</code> 工作的一部分，同样需要 <code>babel-loader</code>，需要在 <code>Webpack</code> 配置文件的 <code>loader</code> 配置中增加识别 <code>.jsx</code> 文件以及在 <code>.babelrc</code> 配置文件的 <code>presets</code> 中专门增加解析 <code>JSX</code> 功能的集合。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel/preset-env @babel/preset-react -D</span><br></pre></td></tr></table></figure><p><strong><code>loader</code> 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jsx?)$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>.babelrc</code> 配置示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">    <span class="string">"@babel/preset-react"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/proposal-class-properties"</span></span><br><span class="line">    // ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h4><p>解析 <code>CSS</code> 主要靠 <code>css-loader</code> 和 <code>style-loader</code>：</p><ul><li><code>css-loader</code>：用于加载 <code>.css</code> 文件，并转换成 <code>CommonJS</code> 对象；</li><li><code>style-loader</code>：将样式通过 <code>&lt;style&gt;&lt;/style&gt;</code> 标签插入到 <code>html</code> 文件的 <code>head</code> 中。</li></ul><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader style-loader -D</span><br></pre></td></tr></table></figure><p><strong><code>loader</code> 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>值得注意的是，在处理同一个类型文件使用多个 <code>loader</code> 时，是链式调用的，<code>loader</code> 的执行顺序是从右向左的，所以在编写解析 <code>CSS</code> 加载器配置时应该 <code>style-loader</code> 在前，<code>css-loader</code> 在后，即先通过 <code>css-loader</code> 解析 <code>.css</code> 文件，将解析好的结果传递给 <code>style-loader</code> 处理并插入到页面的 <code>head</code> 中。</strong></p></blockquote><h4 id="解析-Less-和-Sass"><a href="#解析-Less-和-Sass" class="headerlink" title="解析 Less 和 Sass"></a>解析 Less 和 Sass</h4><p><code>Less</code> 和 <code>Sass</code> 作为 <code>CSS</code> 的预编译语言，加入了很多编程的特性，功能更强，对样式的组织也更加的灵活，但是浏览器依然不识别，所以也需要 <code>Webpack</code> 进行编译转换。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><figcaption><span>Less</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader style-loader less-loader less -D</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>Sass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader style-loader sass-loader node-sass -D</span><br></pre></td></tr></table></figure><p><strong><code>loader</code> 配置示例：</strong></p><figure class="highlight js"><figcaption><span>less 配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>sass 配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析图片和字体资源"><a href="#解析图片和字体资源" class="headerlink" title="解析图片和字体资源"></a>解析图片和字体资源</h4><p><strong>安装依赖：</strong></p><p><code>Webpack</code> 对其他类型的文件进行打包编译需要依赖 <code>file-loader</code>（专门用于处理文件）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader -D</span><br></pre></td></tr></table></figure><p><strong><code>file-loader</code> 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>, <span class="comment">// 解析图片</span></span><br><span class="line">        use: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)$/</span>, <span class="comment">// 解析字体</span></span><br><span class="line">        use: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong>也可以使用 <code>url-loader</code> 来实现对图片和字体资源的解析，<code>url-loader</code> 相比 <code>file-loader</code> 而言，支持更颗粒化的解析方式，可以配置解析后出口文件的具体目录，也可以根据资源大小设置将资源转换成 <code>base64</code>。</strong></p></blockquote><p><strong><code>url-loader</code> 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|gif|jpe?g)$/</span>, <span class="comment">// 解析图片</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span>, <span class="comment">// 资源小于该数值转为 base64</span></span><br><span class="line">              name: <span class="string">'img/[name].[ext]'</span> <span class="comment">// 打包后的输出路径</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 字体资源同理...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PostCSS-对-CSS-的增强"><a href="#PostCSS-对-CSS-的增强" class="headerlink" title="PostCSS 对 CSS 的增强"></a>PostCSS 对 CSS 的增强</h4><p>在开发 <code>CSS</code> 时，存在着很多让我们头疼的的问题，比如有些 <code>CSS3</code> 的属性由于各浏览器的实现标准不同要加上不同的私有前缀，也比如为了在移动端进行页面适配使用的 <code>rem</code>、<code>vw</code> 单位与 <code>px</code> 的转换问题等等，其中的一部分问题其实是可以在 <code>Webpack</code> 构建的过程中直接解决的。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer postcss-px2rem -D</span><br></pre></td></tr></table></figure><p><strong>配置示例：</strong></p><figure class="highlight js"><figcaption><span>配置在 Webpack 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>, <span class="comment">// 使用 postcss-loader</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: [</span><br><span class="line">                <span class="comment">// 添加私有前缀</span></span><br><span class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                  <span class="comment">// 兼容浏览器版本（最后两个版本、使用率大于 1%，ios 7 以上）</span></span><br><span class="line">                  browers: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="comment">// px 自动转换 rem</span></span><br><span class="line">                <span class="built_in">require</span>(<span class="string">'postcss-px2rem'</span>)(&#123;</span><br><span class="line">                  remUnit: <span class="number">75</span>, <span class="comment">// 75 px 等于 1 rem</span></span><br><span class="line">                  remPrecision: <span class="number">8</span> <span class="comment">// 换算结果小数点后面保留几位小数</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>在 postcss.config.js 中配置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">      browers: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-px2rem'</span>)(&#123;</span><br><span class="line">      remUnit: <span class="number">75</span>,</span><br><span class="line">      remPrecision: <span class="number">8</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用其他 <code>PostCSS</code> 的功能也是类似的，需要先下载对应的 <code>PostCSS</code> 插件，然后在配置文件中进行配置。</p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p><code>plugins</code> 通常用来对 <code>Webpack</code> 打包功能的增强，对打包过程和出口文件大小的优化、资源管理和环境变量的注入，可以作用域整个构建过程。</p><p><strong>常见 plugin 表：</strong></p><table><thead><tr><th style="text-align:center; width: 35%;">名称</th><th style="text-align:center;" colspan="3">描述</th></tr></thead><tbody><tr><td style="text-align:center;">CommonsChunkPlugin</td><td style="text-align:center;">将 <code>chunks</code> 相同的模块代码提取成公共 <code>js</code></td></tr><tr><td style="text-align:center;">CleanWebpackPlugin</td><td style="text-align:center;">清理构建目录</td></tr><tr><td style="text-align:center;">ExtracTextWebpackPlugin</td><td style="text-align:center;">将 <code>CSS</code> 从 <code>bundle</code> 文件里提取成一个独立的 <code>CSS</code> 文件</td></tr><tr><td style="text-align:center;">CopyWebpackPlugin</td><td style="text-align:center;">将文件或者文件夹拷贝到构建的输出目录</td></tr><tr><td style="text-align:center;">HtmlWebpackPlugin</td><td style="text-align:center;">创建 html 文件并注入 <code>bundle</code> 文件</td></tr><tr><td style="text-align:center;">UglifyjsWebpackPlugin</td><td style="text-align:center;">压缩 <code>JS</code> 文件</td></tr><tr><td style="text-align:center;">ZipWebpackPlugin</td><td style="text-align:center;">将打包出的资源生成一个 <code>zip</code> 包</td></tr></tbody></table><h4 id="自动生成-index-html"><a href="#自动生成-index-html" class="headerlink" title="自动生成 index.html"></a>自动生成 index.html</h4><p>自动生成 <code>index.html</code> 文件主要通过 <code>HtmlWebpackPlugin</code> 插件实现。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p><strong>plugin 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 创建插件的实例</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>, <span class="comment">// 模板文件路径</span></span><br><span class="line">      filename: <span class="string">'index.html'</span> <span class="comment">// 输出文件名称</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽取-CSS-文件"><a href="#抽取-CSS-文件" class="headerlink" title="抽取 CSS 文件"></a>抽取 CSS 文件</h4><p><code>Webpack</code> 在上面对 <code>CSS</code> 的解析中，使用了 <code>css-loader</code> 和 <code>style-loader</code>，通过构建后的结果发现 <code>CSS</code> 文件被注入到了 <code>JS</code> 文件中，在生产环境通常会为了减小出口文件的体积对 <code>CSS</code> 文件进行抽离，在 <code>Webpack4</code> 中使用 <code>MiniCssExtractPlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p><strong>配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, <span class="comment">// 用于将 CSS 抽离的加载器</span></span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].css'</span> <span class="comment">// 抽离的文件名</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote info"><p><strong>解析 <code>CSS</code> 文件无论哪种方式需要使用 <code>css-loader</code>，但 <code>MiniCssExtractPlugin</code> 提供的 <code>loader</code> 与 <code>style-loader</code> 的功能是互斥的，<code>style-loader</code> 用于将解析的 <code>CSS</code> 注入，而 <code>MiniCssExtractPlugin.loader</code> 意在抽离。</strong></p></blockquote><h4 id="自动清理构建目录"><a href="#自动清理构建目录" class="headerlink" title="自动清理构建目录"></a>自动清理构建目录</h4><p>如果输出的文件配置了 <code>hash</code> 且在每次构建时没有及时删除指定的输出目录（如 <code>dist</code>），会导致输出目录中的文件越来越多，不容易区分哪些是新构建出来的文件，所以应该让 <code>Webpack</code> 在每次构建之前清除输出的目录。</p><p>当然清除的方式可以多种，比如手动删除，或者在 <code>package.json</code> 中配置的构建命令中增加前置命令如下。</p><figure class="highlight json"><figcaption><span>不优雅的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"rm -rf ./dist &amp;&amp; webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式并不优雅，完全可以通过 <code>Webpack</code> 配置中增加 <code>CleanWebpackPlugin</code> 插件来解决这个问题，这样在每次构建之前就会自动清除输出目录。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p><strong>配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name][chunkhash:8].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>Webpack</code> 中，文件监听是指发现源文件发生变化时，自动重新构建出新的输出文件，<code>Webpack</code> 开启监听模式有两种方式：</p><ul><li>启动 <code>Webpack</code> 命令时带上 <code>--watch</code> 参数，可以在 <code>package.json</code> 中进行配置；</li><li>在 <code>Webpack</code> 配置文件中进行设置；</li></ul><p><strong>添加参数：</strong></p><figure class="highlight json"><figcaption><span>配置命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="attr">"watch"</span>: <span class="string">"webpack --watch"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>执行命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run watch</span><br></pre></td></tr></table></figure><p><strong><code>Webpack</code> 配置文件：</strong></p><figure class="highlight js"><figcaption><span>webpack 配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  watch: <span class="literal">true</span>, <span class="comment">// 开启监听</span></span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    <span class="comment">// 忽略监听的文件目录</span></span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    <span class="comment">// 监听到发生变化会等待 300ms 去重新构建（防止多次保存），默认 300ms</span></span><br><span class="line">    aggregateTimeout: <span class="number">300</span>，</span><br><span class="line">    <span class="comment">// 每秒检查 1000 次</span></span><br><span class="line">    poll: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>watch</code> 监听原理分析：</strong></p><p><code>Webpack</code> 会轮询的判断文件的最后编辑时间是否发生变化，如果某个文件发生变化不会立即重新构建，而是会将变化缓存起来，等待 <code>aggregateTimeout</code> 配置的时间后重新构建，这样做是为了防止短时间的多次变化或产生了新的变化文件，在该时间到达时将变化的文件列表进行统一构建，以提高性能。</p><blockquote class="pullquote warning"><p><strong>这样的监听方式的缺陷是浏览器不会自动刷新，需要手动刷新查看文件修改后的效果。</strong></p></blockquote><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p><code>webpack-dev-server</code> 是在本地启动服务来监听文件的变化，不是以输出文件的形式更新，而是即时将重新构建的结果放在内存中。</p><p><strong>安装依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure><p><strong><code>devServer</code> 配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mode: <span class="string">'development'</span>, <span class="comment">// 由于 webpack-dev-server 在开发环境中使用</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>, <span class="comment">// 本地服务的域名</span></span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// server 作用的目录</span></span><br><span class="line">    port: <span class="number">8080</span>, <span class="comment">// 端口号</span></span><br><span class="line">    compress: <span class="literal">true</span> <span class="comment">// 是否启动服务器压缩</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置服务启动命令：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --open"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h3><p>在 <code>Webpack</code> 构建后的代码中，经过了压缩、混淆等，会出现一个新的问题，就是代码执行出错后不容定位错误是在源代码中哪一个位置产生的，而 <code>devtool</code> 的配置的作用就是让我们更容易定位错误的位置。</p><p><strong><code>devtool</code> 的关键词：</strong></p><table><thead><tr><th style="text-align:center; width: 30%;">关键词</th><th style="text-align:center;" colspan="3">作用</th></tr></thead><tbody><tr><td style="text-align:center;">evel</td><td style="text-align:center;">使用 <code>evel</code> 函数包裹代码</td></tr><tr><td style="text-align:center;">source-map</td><td style="text-align:center;">产生 <code>.map</code> 文件</td></tr><tr><td style="text-align:center;">cheap</td><td style="text-align:center;">不含列信息</td></tr><tr><td style="text-align:center;">inline</td><td style="text-align:center;">将 <code>.map</code> 内容作为 <code>DataURI</code> 嵌入，不单独生成 <code>.map</code> 文件</td></tr><tr><td style="text-align:center;">module</td><td style="text-align:center;">包含 <code>loader</code> 的 <code>source-map</code></td></tr></tbody></table><p><code>devtool</code> 属性的值就是又上面的关键词组成的，不同的名字会使用不同的调试策略，而名字中的关键词则包含了上面特性，下面是 <code>Webpcak</code> 官网给出的不同构建策略对应的信息。</p><table><thead><tr><th style="text-align:center; width: 36%;">devtool</th><th style="text-align:center; width: 9%;">首次构建</th><th style="text-align:center; width: 9%;">二次构建</th><th style="text-align:center; width: 14%;">是否适合生产环境</th><th style="text-align:center;">可以定位的代码</th></tr></thead><tbody><tr><td style="text-align:center;">（none）</td><td style="text-align:center;">+++</td><td style="text-align:center;">+++</td><td style="text-align:center;">yes</td><td style="text-align:center;">最终输出的代码</td></tr><tr><td style="text-align:center;">eval</td><td style="text-align:center;">+++</td><td style="text-align:center;">+++</td><td style="text-align:center;">no</td><td style="text-align:center;"><code>Webpack</code> 生成的代码（一个个的模块）</td></tr><tr><td style="text-align:center;">cheap-eval-source-map</td><td style="text-align:center;">+</td><td style="text-align:center;">++</td><td style="text-align:center;">no</td><td style="text-align:center;">经过 <code>loader</code> 转换后的代码（只能看到行）</td></tr><tr><td style="text-align:center;">cheap-module-eval-source-map</td><td style="text-align:center;">o</td><td style="text-align:center;">++</td><td style="text-align:center;">no</td><td style="text-align:center;">源代码（只能看到行）</td></tr><tr><td style="text-align:center;">eval-source-map</td><td style="text-align:center;">–</td><td style="text-align:center;">+</td><td style="text-align:center;">no</td><td style="text-align:center;">源代码</td></tr><tr><td style="text-align:center;">cheap-source-map</td><td style="text-align:center;">+</td><td style="text-align:center;">o</td><td style="text-align:center;">no</td><td style="text-align:center;">经过 <code>loader</code> 转换后的代码（只能看到行）</td></tr><tr><td style="text-align:center;">cheap-module-source-map</td><td style="text-align:center;">o</td><td style="text-align:center;">-</td><td style="text-align:center;">no</td><td style="text-align:center;">源代码（只能看到行）</td></tr><tr><td style="text-align:center;">inline-cheap-source-map</td><td style="text-align:center;">+</td><td style="text-align:center;">o</td><td style="text-align:center;">no</td><td style="text-align:center;">经过 <code>loader</code> 转换后的代码（只能看到行）</td></tr><tr><td style="text-align:center;">inline-cheap-module-source-map</td><td style="text-align:center;">o</td><td style="text-align:center;">-</td><td style="text-align:center;">no</td><td style="text-align:center;">源代码（只能看到行）</td></tr><tr><td style="text-align:center;">source-map</td><td style="text-align:center;">–</td><td style="text-align:center;">–</td><td style="text-align:center;">yes</td><td style="text-align:center;">源代码</td></tr><tr><td style="text-align:center;">inline-source-map</td><td style="text-align:center;">–</td><td style="text-align:center;">–</td><td style="text-align:center;">no</td><td style="text-align:center;">源代码</td></tr><tr><td style="text-align:center;">hidden-source-map</td><td style="text-align:center;">–</td><td style="text-align:center;">–</td><td style="text-align:center;">yes</td><td style="text-align:center;">源代码</td></tr><tr><td style="text-align:center;">nosources-source-map</td><td style="text-align:center;">–</td><td style="text-align:center;">–</td><td style="text-align:center;">yes</td><td style="text-align:center;">无源代码</td></tr></tbody></table><blockquote class="pullquote info"><p><strong><code>+++</code> 非常快速，<code>++</code> 快速，<code>+</code> 比较快，<code>o</code> 中等，<code>-</code> 比较慢，<code>--</code> 慢</strong></p></blockquote><p><strong>配置示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  devtool: <span class="string">'evel'</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用不同的 <code>devtool</code> 会带来不同的效果，如是用 <code>evel</code> 不安全，使用 <code>inline</code> 注入会增加打包文件的大小、线上环境生成 <code>.map</code> 文件会容易被人反编译进而暴露业务逻辑等等，所以在 <code>devtool</code> 使用时还是根据自己的需要和安全考虑来权衡。</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><h3 id="配置热更新的方式"><a href="#配置热更新的方式" class="headerlink" title="配置热更新的方式"></a>配置热更新的方式</h3><p><code>webpack-dev-server</code> 可以配合自带的插件实现热更新，即文件修改后，不刷新浏览器的情况下自动构建并在浏览器中响应。</p><figure class="highlight js"><figcaption><span>使用 webpack-dev-server</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    compress: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要颗粒度更细致的控制 <code>Webpack</code> 的热更新，也可以使用另一种方式，即借助 <code>Express</code> 或 <code>Koa</code> 自己创建一个服务，并借助 <code>webpack-dev-middleware</code> 来实现热更新，这种方式更适合灵活的定制化场景。</p><figure class="highlight js"><figcaption><span>使用 webpack-dev-middleware</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  publicPath: config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="热更新原理简介"><a href="#热更新原理简介" class="headerlink" title="热更新原理简介"></a>热更新原理简介</h3><p>热更新的实现分为服务端和浏览器两个部分：</p><p><strong>Webpack Dev Server</strong></p><ul><li><code>Webpack Compile</code>：<code>Webpack</code> 的编译器，作用是将 <code>JS</code> 编译成 <code>Bundle</code>；</li><li><code>HMR Server</code>：将热更新的文件输出给 <code>HMR Runtime</code>；</li><li><code>Bundle Server</code>：提供文件在浏览器以服务器的方式访问。</li></ul><p><strong>Browser</strong></p><ul><li><code>HMR Runtime</code>：开发阶段打包过程中，会被注入到浏览器，使浏览器的 <code>bundle.js</code> 和服务器建立 <code>websocket</code> 链接，以更新文件的变化；</li><li><code>bundle.js</code>：构建输出的文件。</li></ul><blockquote class="pullquote success"><p><strong><code>Webpack</code> 在将本地文件显示在浏览器其实有两个阶段，第一个阶段为启动阶段，通过 <code>Webpack Compile</code> 将文件系统中的文件进行构建，然后将文件传递给 <code>Bundle Server</code>，<code>Bundle Server</code> 将 <code>bundle.js</code> 响应给浏览器，第二个阶段为热更新阶段，依然通过 <code>Webpack Compile</code> 对文件系统中修改的文件进行构建，将构建后的结果传递给 <code>HMR Server</code>，<code>HMR Server</code> 通过 <code>Websocket</code> 协议将文件变化的结果通知浏览器端的 <code>HMR Runtime</code>，执行代码并刷新页面。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/10/02/20181002041434/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 外观模式</title>
      <link>https://www.overtaking.top/2018/10/01/20181001165125/</link>
      <guid>https://www.overtaking.top/2018/10/01/20181001165125/</guid>
      <pubDate>Mon, 01 Oct 2018 08:51:25 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/10/01/20181001165125/facade.jpg&quot; title=&quot;外观模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/10/01/20181001165125/facade.jpg" title="外观模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/04/20181004114907/" target="_blank">《设计模式 JS 表现 —— 发布/订阅和观察者模式》</a></li><li><a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">《设计模式 JS 表现 —— 状态模式》</a></li><li><a href="https://www.overtaking.top/2018/10/06/20181006014812/" target="_blank">《设计模式 JS 表现 —— 策略模式》</a></li></ul><h2 id="外观模式简介"><a href="#外观模式简介" class="headerlink" title="外观模式简介"></a>外观模式简介</h2><p>“外观模式” 就是把一些复杂的流程封装成一个接口，提供给外部更简单的使用，在外观模式中存在三种角色如下。</p><ul><li>门面角色（<code>Facade</code>）：是 “外观模式” 的核心，它熟悉子系统的功能，并被客户角色调用，内部实现了客户角色需求功能的组合；</li><li>子系统角色（<code>System</code>）：实现了子系统的功能（多个），对于客户角色是未知的；</li><li>客户角色（<code>Client</code>）：通过调用 <code>Facede</code> 来完成要实现的功能。</li></ul><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/10/01/20181001165125/facade-uml.jpg" alt="外观模式 UML 图" title="">                </div>                <div class="image-caption">外观模式 UML 图</div>            </figure><p><br></p><h2 id="外观模式的实现"><a href="#外观模式的实现" class="headerlink" title="外观模式的实现"></a>外观模式的实现</h2><p>上面已经介绍了 “外观模式” 的各个角色，下面是简单的代码实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统角色 Sum</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">  sum(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Minus</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minus</span> </span>&#123;</span><br><span class="line">  minus(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Multipy</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Multipy</span> </span>&#123;</span><br><span class="line">  multipy(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Divide</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Divide</span> </span>&#123;</span><br><span class="line">  divide(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门面角色 Calculator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sumObj = <span class="keyword">new</span> Sum();</span><br><span class="line">    <span class="keyword">this</span>.minusObj = <span class="keyword">new</span> Minus();</span><br><span class="line">    <span class="keyword">this</span>.multipyObj = <span class="keyword">new</span> Multipy();</span><br><span class="line">    <span class="keyword">this</span>.divideObj = <span class="keyword">new</span> Divide();</span><br><span class="line">  &#125;</span><br><span class="line">  sum(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sumObj.sum(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  minus(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minusObj.minus(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  multipy(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.multipyObj.multipy(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  divide(...args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.divideObj.divide(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户角色</span></span><br><span class="line"><span class="keyword">let</span> calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"><span class="built_in">console</span>.log(calculator.sum(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(calculator.minus(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(calculator.multipy(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(calculator.divide(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 0.5</span></span><br></pre></td></tr></table></figure><p>我们在上面代码中实现了一个计算器功能，计算器具备的功能为加、减、乘、除，我们把这四个功能分别拆分成为四个子系统，用门面类 <code>Calculator</code> 来进行连接，这样只需要调用 <code>Calculator</code> 的实例（客户角色）就可以调用四个子系统模块分别提供的功能，但是上面的代码实现功能比较简洁，并没达到 “外观模式” 的真正作用，就是可以随意组合各个子系统的功能。</p><figure class="highlight js"><figcaption><span>组合子系统功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统角色 CPU</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CPU 启动'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Memory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内存启动'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统角色 Disk</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span> </span>&#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'硬盘启动'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门面角色 Computer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">    <span class="keyword">this</span>.memory = <span class="keyword">new</span> Memory();</span><br><span class="line">    <span class="keyword">this</span>.disk = <span class="keyword">new</span> Disk();</span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="comment">// 组合子系统功能</span></span><br><span class="line">    <span class="keyword">this</span>.cpu.start();</span><br><span class="line">    <span class="keyword">this</span>.memory.start();</span><br><span class="line">    <span class="keyword">this</span>.disk.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户角色</span></span><br><span class="line"><span class="keyword">let</span> computer = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">computer.start();</span><br><span class="line"><span class="comment">// CPU 启动</span></span><br><span class="line"><span class="comment">// 内存启动</span></span><br><span class="line"><span class="comment">// 硬盘启动</span></span><br></pre></td></tr></table></figure><p>上面代码打印了一个计算机的启动过程，功能来自于各个子系统，也可以通过门面角色实现子系统功能的多种组合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“外观模式” 的作用是可以对复杂功能解耦合，分散到各个子系统，使子系统与子系统互相独立，并对各个子系统提供外界访问的功能组合模块，这样既提高了子系统的维护性，又增加了外界访问功能的扩展性，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/7.facade" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/10/01/20181001165125/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 代理模式</title>
      <link>https://www.overtaking.top/2018/09/29/20180929025641/</link>
      <guid>https://www.overtaking.top/2018/09/29/20180929025641/</guid>
      <pubDate>Fri, 28 Sep 2018 18:56:41 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/29/20180929025641/proxy.jpg&quot; title=&quot;代理模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/29/20180929025641/proxy.jpg" title="代理模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li><li><a href="https://www.overtaking.top/2018/10/04/20181004114907/" target="_blank">《设计模式 JS 表现 —— 发布/订阅和观察者模式》</a></li><li><a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">《设计模式 JS 表现 —— 状态模式》</a></li><li><a href="https://www.overtaking.top/2018/10/06/20181006014812/" target="_blank">《设计模式 JS 表现 —— 策略模式》</a></li></ul><h2 id="代理模式概念"><a href="#代理模式概念" class="headerlink" title="代理模式概念"></a>代理模式概念</h2><p>由于某些情况下一个对象不能直接引用另一个对象，所以需要代理对象在这两个对象之间起到中介作用或者实现控制，这样的模式叫 “代理模式”。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/29/20180929025641/proxy-uml.jpg" alt="代理模式 UML 图" title="">                </div>                <div class="image-caption">代理模式 UML 图</div>            </figure><p><br></p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设无法客户端无法直接使用这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Google</span> </span>&#123;</span><br><span class="line">  get(url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span> is google`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能通过代理操作 Google 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.google = <span class="keyword">new</span> Google();</span><br><span class="line">  &#125;</span><br><span class="line">  get(url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.google.get(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>();</span><br><span class="line"><span class="keyword">let</span> result = proxy.get(<span class="string">'http://www.google.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// http://www.google.com is google</span></span><br></pre></td></tr></table></figure><p>假设 <code>Google</code> 类我们无法直接使用，只有 <code>Proxy</code> 可以使用 <code>Google</code>，我们可以通过 <code>Proxy</code> 类去操作使用 <code>Google</code> 类，此时 <code>Proxy</code> 类就是一个代理。</p><h2 id="ES6-的-Proxy"><a href="#ES6-的-Proxy" class="headerlink" title="ES6 的 Proxy"></a>ES6 的 Proxy</h2><p>在 <code>ES6</code> 标准以后，<code>JavaScript</code> 提供了原生的代理模式 <code>Proxy</code> 类，可以代理其他对象，并在对象属性的获取和赋值时增加拦截。</p><figure class="highlight js"><figcaption><span>ES6 Proxy 的使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lucy = &#123;</span><br><span class="line">  name: <span class="string">'lucy'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  height: <span class="number">165</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lucyMother = <span class="keyword">new</span> <span class="built_in">Proxy</span>(lucy, &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.age - <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'height'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.height + <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'boyfriend'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val.age &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'太老了'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val.salary &lt; <span class="number">20000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'太穷了'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.name); <span class="comment">// lucy</span></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(lucyMother.height); <span class="comment">// 170</span></span><br><span class="line"></span><br><span class="line">lucyMother.boyfriend = &#123;</span><br><span class="line">  age: <span class="number">42</span>,</span><br><span class="line">  salary: <span class="number">25000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 太老了</span></span><br><span class="line"></span><br><span class="line">lucyMother.boyfriend = &#123;</span><br><span class="line">  age: <span class="number">36</span>,</span><br><span class="line">  salary: <span class="number">18000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 太穷了</span></span><br></pre></td></tr></table></figure><p>上面是一个接地气的案例，创建一个对象存储 <code>lucy</code> 的基本信息，使用代理创建 <code>lucyMother</code> 为 <code>lucy</code> 找男朋友，通过代理对象获取 <code>lucy</code> 的基本信息时会虚报年龄和身高，而在设置男朋友对象时会检查是否符合要求。</p><h2 id="代理模式、适配器模式和装饰器模式"><a href="#代理模式、适配器模式和装饰器模式" class="headerlink" title="代理模式、适配器模式和装饰器模式"></a>代理模式、适配器模式和装饰器模式</h2><p>从代码实现来看，代理模式、适配器模式、装饰器模式非常的相似，非常容易混淆，但其实是有本质区别的。</p><blockquote class="pullquote info"><ul><li><strong>代理模式和适配器模式：代理模式不会改变原有的接口，代理类和被代理的类属性方法使用方式完全一致，而适配器模式是因为旧的接口无法使用，通过适配器创建新的接口去兼容旧的接口；</strong></li><li><strong>代理模式和装饰器模式：装饰器功能会保证被装饰类功能正常使用的情况下新增功能，而代理模式保证原有接口，但会改变原来的接口的功能；</strong></li><li><strong>适配器模式和装饰器模式：装饰器是对一个类的包装，而适配器更多是去建立提供接口的类与无法适配的类之间的联系。</strong></li></ul></blockquote><h2 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是浏览器事件注册的一种优化手段，如果同类型的元素非常多，且都有相同的事件，如列表，则不必给每一个元素注册这个事件，而是将事件注册给父元素，即将事件委托给父元素，避免了相同事件的重复注册，这种优化利用了 “代理模式”，又称事件代理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件委托<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ulList = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    ulList.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event.target.innerHTML);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中，委托给父元素的事件触发后，可以通过事件对象的属性 <code>target</code> 获取到具体触发事件的子元素。</p><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>图片懒加载是一个提高用户体验的功能，也是非常常见的，原因是浏览器向服务器请求资源图片是需要等待的，由于网络等因素的影响会导致等待的时间更长，此时我们需要一个 <code>loading</code> 图片来过渡，这就是图片懒加载的基本需求。</p><figure class="highlight js"><figcaption><span>node 服务器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/loading.gif'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendFile(path.resolve(<span class="string">'img'</span>, <span class="string">'loading.gif'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/img/:name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    res.sendFile(path.join(__dirname, req.path));</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面服务器模拟了懒加载图片响应慢的场景，<code>loading</code> 图片立即响应，其他图片则延迟 <code>3s</code> 响应。</p><figure class="highlight html"><figcaption><span>Dom 结构</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-src</span>=<span class="string">"/img/bg1.jpg"</span>&gt;</span>图片1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-src</span>=<span class="string">"/img/bg2.jpg"</span>&gt;</span>图片2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bgimg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>没有实现懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'menu'</span>);</span><br><span class="line"><span class="keyword">let</span> bgimg = <span class="built_in">document</span>.getElementById(<span class="string">'bgimg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> background = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  bgimg.appendChild(img)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">menu.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> src = event.target.dataset.src;</span><br><span class="line">  background.setSrc(src);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码是没有实现懒加载的，当点击按钮向服务器请求图片时，并没有加入 <code>loading</code> 图片过渡，之所以说图片懒加载应用了 “代理模式” 并不是指懒加载功能本身，而是我们的实现方式，编写的代码质量要高至少要遵循单一职责原则和开放封闭原则，就是说最好不要直接在上面伙计的函数中增加 <code>loading</code> 过渡的逻辑，而是把这个过渡功能交给代理对象去处理。</p><figure class="highlight js"><figcaption><span>使用代理对象实现 loading 过渡</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'menu'</span>);</span><br><span class="line"><span class="keyword">let</span> bgimg = <span class="built_in">document</span>.getElementById(<span class="string">'bgimg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求图片的对象</span></span><br><span class="line"><span class="keyword">let</span> background = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  bgimg.appendChild(img)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 loading 过度的代理对象</span></span><br><span class="line"><span class="keyword">let</span> proxyBackground = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    background.setSrc(<span class="keyword">this</span>.src);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc(src) &#123;</span><br><span class="line">      background.setSrc(<span class="string">'./img/loading.gif'</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听获取图片的事件中使用的是代理对象 proxyBackground</span></span><br><span class="line">menu.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> src = event.target.dataset.src;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止缓存</span></span><br><span class="line">  proxyBackground.setSrc(<span class="string">`<span class="subst">$&#123;src&#125;</span>?time=<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的实现方式就符合 “代理模式”，<code>background</code> 对象是提供基本功能，而<code>proxyBackground</code>（代理对象）增强了基本功能，却并没有改变接口的使用方式，依然通过 <code>setSrc</code> 方法去请求图片。</p><h3 id="防抖代理"><a href="#防抖代理" class="headerlink" title="防抖代理"></a>防抖代理</h3><p>防抖的作用是在做一个操作时不需要很频繁，如搜索查询，在连续输入时如果每次触发输入事件都向后端发送请求，性能是极差的，我们希望的是连续输入只在最后一次统一发送请求，这种处理叫做防抖处理，是前端优化的手段。</p><figure class="highlight html"><figcaption><span>未使用防抖代理处理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"ipt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">'ipt'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'发送请求了'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    ipt.addEventListener(<span class="string">'input'</span>, post);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码未使用防抖代理，每次输入都会打印 “发送请求了”。</p><figure class="highlight html"><figcaption><span>使用防抖代理优化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"ipt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">'ipt'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'发送请求了'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 代理函数去执行 post</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> debouncePost = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      clearInterval(timer);</span></span><br><span class="line"><span class="javascript">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        post();</span></span><br><span class="line"><span class="undefined">      &#125;, 500);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;)();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  ipt.addEventListener(<span class="string">'input'</span>, debouncePost);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用防抖代理函数优化后，保留了原有功能的基础上进行了增强，实现了连续输入停止 <code>500ms</code> 后统一发送一次请求，防抖的实现方式有很多种，包括并不限于函数式编程等，而上面代码使用了 “代理模式” 实现 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>使用 “代理模式” 的场景在后端会更多，比如代理跨域，<code>Nginx</code> 代理等等，还有一点需要注意的是，“代理模式” 并非单一的，对于同一个对象，可以有多个代理对象去增强不同的功能，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/6.proxy" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/29/20180929025641/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 装饰器模式</title>
      <link>https://www.overtaking.top/2018/09/28/20180928030105/</link>
      <guid>https://www.overtaking.top/2018/09/28/20180928030105/</guid>
      <pubDate>Thu, 27 Sep 2018 19:01:05 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/28/20180928030105/decorator.jpg&quot; title=&quot;装饰器模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/28/20180928030105/decorator.jpg" title="装饰器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li><li><a href="https://www.overtaking.top/2018/10/04/20181004114907/" target="_blank">《设计模式 JS 表现 —— 发布/订阅和观察者模式》</a></li><li><a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">《设计模式 JS 表现 —— 状态模式》</a></li><li><a href="https://www.overtaking.top/2018/10/06/20181006014812/" target="_blank">《设计模式 JS 表现 —— 策略模式》</a></li></ul><h2 id="装饰器模式概念"><a href="#装饰器模式概念" class="headerlink" title="装饰器模式概念"></a>装饰器模式概念</h2><p>“装饰器模式” 是结构型模式之一，在不改变原有对象结构的前提下，给对象添加新功能，也可以理解 “装饰器模式” 是将一个对象嵌入另一个对象之中，相当于一个对象被另一个对象包装，包装其他对象的对象被称为 “装饰器”。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/28/20180928030105/decorator-uml.jpg" alt="装饰器模式 UML 图" title="">                </div>                <div class="image-caption">装饰器模式 UML 图</div>            </figure><p><br></p><h2 id="装饰器模式和适配器模式"><a href="#装饰器模式和适配器模式" class="headerlink" title="装饰器模式和适配器模式"></a>装饰器模式和适配器模式</h2><figure class="highlight js"><figcaption><span>装饰器模式案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Duck</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat(food) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>吃<span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器类 TangDuck，装饰 Duck 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TangDuck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duck = <span class="keyword">new</span> Duck(name);</span><br><span class="line">  &#125;</span><br><span class="line">  eat(food) &#123;</span><br><span class="line">    <span class="keyword">this</span>.duck.eat(food);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'说谢谢'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tangDuck = <span class="keyword">new</span> TangDuck(<span class="string">'唐老鸭'</span>);</span><br><span class="line">tangDuck.eat(<span class="string">'苹果'</span>);</span><br><span class="line"><span class="comment">// 唐老鸭吃苹果</span></span><br><span class="line"><span class="comment">// 说谢谢</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>适配器模式案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Power</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line">  charge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'220V'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.power = <span class="keyword">new</span> Power();</span><br><span class="line">  &#125;</span><br><span class="line">  chargeTransform() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">this</span>.power.charge();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;v&#125;</span> =&gt; 12V`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 Power 的使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.adaptor = <span class="keyword">new</span> Adaptor(Power);</span><br><span class="line">  &#125;</span><br><span class="line">  use() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.adaptor.chargeTransform());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面分别是 “装饰器模式” 和 “适配器模式” 的案例，但直接看代码可能会将两者混淆，原因是 “适配器” 和 “装饰器” 的类都存在了一个被装饰或者适配转换的类的引用，不同的是，“装饰器” 仅仅是对某一个类进行包装，并不会改变原来类的结构，而 “适配器” 的作用更多是去建立一个类和另一个类之间的关系和转换。</p><h2 id="装饰器模式和继承"><a href="#装饰器模式和继承" class="headerlink" title="装饰器模式和继承"></a>装饰器模式和继承</h2><p>通过上一节，我们已经知道了什么是 “装饰器模式”，下面有一个更直观的例子，我们有一个基础类 <code>Coffee</code>，组成是咖啡加水，这个基础上可以加奶、糖、冰，希求是可以组合加入上面的其他原料，并计算出对应的价格，大家可能第一时间想到的是继承的方式实现。</p><figure class="highlight js"><figcaption><span>继承的实现方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;water&#125;</span> + 咖啡`</span></span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加奶咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加糖咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加糖加奶咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarMilkCoffee</span> <span class="keyword">extends</span> <span class="title">SugarCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加奶加糖咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkSugarCoffee</span> <span class="keyword">extends</span> <span class="title">MilkCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从继承的代码看，虽然可以实现给咖啡任意加入其他原料，但是每一种不同的排列组合都需要单独创建类，当原料种类众多时，则难以管理代码，下面是 “装饰器模式” 的实现。</p><figure class="highlight js"><figcaption><span>装饰器模式的实现方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;water&#125;</span> + 咖啡`</span></span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 奶`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugarCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 糖`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCoffee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  make(water) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span> + 冰`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost() + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line"><span class="keyword">let</span> milkCoffee = <span class="keyword">new</span> MilkCoffee(coffee);</span><br><span class="line"><span class="keyword">let</span> sugarCoffee = <span class="keyword">new</span> SugarCoffee(milkCoffee);</span><br><span class="line"><span class="keyword">let</span> iceCoffee = <span class="keyword">new</span> IceCoffee(sugarCoffee);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(milkCoffee.make(<span class="string">'水'</span>), milkCoffee.cost());</span><br><span class="line"><span class="built_in">console</span>.log(sugarCoffee.make(<span class="string">'水'</span>), sugarCoffee.cost());</span><br><span class="line"><span class="built_in">console</span>.log(iceCoffee.make(<span class="string">'水'</span>), iceCoffee.cost());</span><br></pre></td></tr></table></figure><p>从 “装饰器模式” 的实现代码来看，我们只需要创建和原料相同多的类就可以了，其他的方式加料只需要对上一个类进行包装即可，部分加料的顺序，当类的种类越多时，“装饰器” 的意义则体现的越明显。</p><blockquote class="pullquote info"><p><strong>装饰器模式有时候会优于继承，尤其是很多的类通过继承存在排列组合的关系时，则使用 “装饰器模式” 可以更好更高效的解决问题。</strong></p></blockquote><h2 id="装饰器模式和-AOP-编程"><a href="#装饰器模式和-AOP-编程" class="headerlink" title="装饰器模式和 AOP 编程"></a>装饰器模式和 AOP 编程</h2><p>在软件业，<code>AOP</code> 为 <code>Aspect Oriented Programming</code> 的缩写，意为面向切面编程，通过预编译方式和运行其动态代理实现程序功能统一维护的一种技术。</p><p>在 <code>JavaScript</code> 中的 <code>AOP</code> 就是在函数之前或之后添加一些额外的逻辑，而不需要修改函数本身逻辑。</p><figure class="highlight js"><figcaption><span>AOP 编程的案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给函数扩展 before 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给函数扩展 after 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params">money, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`花 <span class="subst">$&#123;money&#125;</span> 元钱买 <span class="subst">$&#123;goods&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 before 方法给函数增加前切面</span></span><br><span class="line">buy = buy.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'向媳妇要 1 元钱'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 before 方法给函数增加后切面</span></span><br><span class="line">buy = buy.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'还给媳妇 0.2 元钱'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0.8</span>, <span class="string">'盐'</span>);</span><br><span class="line"><span class="comment">// 向媳妇要 1 元钱</span></span><br><span class="line"><span class="comment">// 花 0.8 元钱买 盐</span></span><br><span class="line"><span class="comment">// 还给媳妇 0.2 元钱</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote default"><p><strong><code>AOP</code> 编程是由 “装饰器模式” 进化而来，或者说 “装饰器模式” 属于 <code>AOP</code> 编程的一种。</strong></p></blockquote><h2 id="装饰器模式的应用"><a href="#装饰器模式的应用" class="headerlink" title="装饰器模式的应用"></a>装饰器模式的应用</h2><h3 id="监控埋点"><a href="#监控埋点" class="headerlink" title="监控埋点"></a>监控埋点</h3><p>埋点分析，是网站分析的一种常用的数据采集方法，埋点主要分为服务器层面的埋点和客户端层面的埋点，服务器层面的埋点主要是通过客户端的请求进行分析，客户端层面的埋点分为代码埋点、自动化埋点，第三方埋点（百度、友盟等）。</p><figure class="highlight html"><figcaption><span>一个埋点的简单案例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>埋点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-name</span>=<span class="string">"wetermelon"</span> <span class="attr">id</span>=<span class="string">"wetermelon"</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-name</span>=<span class="string">"apple"</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> wetermelon = <span class="built_in">document</span>.getElementById(<span class="string">'wetermelon'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> apple = <span class="built_in">document</span>.getElementById(<span class="string">'apple'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加切面</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">        afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 事件处理函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">`你点击了<span class="subst">$&#123;<span class="keyword">this</span>.dataset.name&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    click = click.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 向服务器发送统计数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="javascript">      img.src = <span class="string">`http://localhost:3000/report?name=<span class="subst">$&#123;<span class="keyword">this</span>.dataset.name&#125;</span>`</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 给所有的</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'button'</span>)).forEach(<span class="function"><span class="params">button</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      button.addEventListener(<span class="string">'click'</span>, click);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>负责统计点击次数的服务</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储按钮的点击次数</span></span><br><span class="line"><span class="keyword">const</span> goods = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/report'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = req.query.name;</span><br><span class="line">  <span class="keyword">if</span> (goods[name]) &#123;</span><br><span class="line">    goods[name]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    goods[name] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.json(goods);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的埋点就是通过 <code>AOP</code> 的方式在点击事件后添加了切面，用来向服务器发送请求，符合 “单一职责原则”，可以使点击事件和埋点逻辑进行 “解耦”，服务器在接收到请求之后立即对点击次数进行统计并储存，也可以通过调用 <code>report</code> 接口来获取当前各个按钮的点击次数。</p><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>“装饰器模式” 的思想同样可以用在表单校验，通常表单校验逻辑是在 <code>submit</code> 事件触发时提交之前发生的，我们经常会将校验逻辑和提交逻辑写在一起，形成 “强耦合”，下面我们使用 <code>AOP</code> 的方式来实现表单校验，对校验逻辑和提交逻辑进行 “解耦”。</p><figure class="highlight html"><figcaption><span>应用于表单校验</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单校验<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">  密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit-btn"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submit-btn'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加切面函数</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> result = beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">        result &amp;&amp; _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 表单提交事件</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'提交表单'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 验证用户名</span></span></span><br><span class="line"><span class="javascript">    submit = submit.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>).value;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!username) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> alert(<span class="string">'请输入用户名'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 验证</span></span></span><br><span class="line"><span class="javascript">    submit = submit.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>).value;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!password) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> alert(<span class="string">'请输入密码'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    submitBtn.addEventListener(<span class="string">'click'</span>, submit);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>在 <code>JavaScript</code> 中 “装饰器模式” 和 <code>AOP</code> 编程非常相似，应用也非常多，如 <code>axios</code> 中对请求、响应的拦截方法，<code>Koa</code> 中间件，都包含这样的编程思想，而在 <code>ES6</code> 之后 <code>JavaScript</code> 已经支持了原生的 “装饰器” 语法，使用起来更方便，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/5.decorator" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/28/20180928030105/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 适配器模式</title>
      <link>https://www.overtaking.top/2018/09/27/20180927230432/</link>
      <guid>https://www.overtaking.top/2018/09/27/20180927230432/</guid>
      <pubDate>Thu, 27 Sep 2018 15:04:32 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/27/20180927230432/adapter.jpg&quot; title=&quot;适配器模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/27/20180927230432/adapter.jpg" title="适配器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li><li><a href="https://www.overtaking.top/2018/10/04/20181004114907/" target="_blank">《设计模式 JS 表现 —— 发布/订阅和观察者模式》</a></li><li><a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">《设计模式 JS 表现 —— 状态模式》</a></li><li><a href="https://www.overtaking.top/2018/10/06/20181006014812/" target="_blank">《设计模式 JS 表现 —— 策略模式》</a></li></ul><h2 id="适配器模式的概念"><a href="#适配器模式的概念" class="headerlink" title="适配器模式的概念"></a>适配器模式的概念</h2><p>“适配器模式” 是指类的使用者和类的接口定义格式不符合时，通过一个中间类进行转换。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/27/20180927230432/adapter-uml.jpg" alt="适配器模式 UML 图" title="">                </div>                <div class="image-caption">适配器模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 Power</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line">  charge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'220V'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.power = <span class="keyword">new</span> Power();</span><br><span class="line">  &#125;</span><br><span class="line">  chargeTransform() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">this</span>.power.charge();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;v&#125;</span> =&gt; 12V`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 Power 的使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(Power) &#123;</span><br><span class="line">    <span class="keyword">this</span>.adaptor = <span class="keyword">new</span> Adaptor(Power);</span><br><span class="line">  &#125;</span><br><span class="line">  use() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.adaptor.chargeTransform());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> notepad = <span class="keyword">new</span> Notepad(Power);</span><br><span class="line">notepad.use(); <span class="comment">// 220V =&gt; 12V</span></span><br></pre></td></tr></table></figure><p>上面代码中有三个类，<code>Power</code> 类为电源，提供 <code>220V</code> 电压，<code>Notepad</code> 为我们的电子设备，使用电压 <code>22V</code>，明显两个类是不匹配的，此时的 <code>Adaptor</code> 就是一个适配器，作用是连接 <code>Power</code> 与 <code>Notepad</code>，将 <code>220V</code> 转换为 <code>22V</code>。</p><blockquote class="pullquote warning"><p><strong>适配器模式中，通常作为适配器的类内部会存储被转换类实例的引用。</strong></p></blockquote><h2 id="适配器模式的应用"><a href="#适配器模式的应用" class="headerlink" title="适配器模式的应用"></a>适配器模式的应用</h2><h3 id="适配参数和返回数据"><a href="#适配参数和返回数据" class="headerlink" title="适配参数和返回数据"></a>适配参数和返回数据</h3><p>在浏览器通过 <code>Ajax</code> 与服务端交互时，封装的请求方法会有默认参数，如果传入了参数则使用传入的参数，如果没有传入，则使用默认的参数，这是参数的适配。</p><p>在请求响应后，后端会返回给我们 <code>JSON</code> 格式的数据，我们在使用时希望转换成对象使用，这个转换的适配是数据接口的适配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    dataType: <span class="string">'JSON'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  initParams(options, defaultOptions); <span class="comment">// 适配参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数适配器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initParams</span>(<span class="params">options, defaultOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> options) &#123;</span><br><span class="line">    defaultOptions[attr] = options[attr] || defaultOptions[attr];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> defaultOptions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据适配器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tranformData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器</span></span><br><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">'www.pandashen.com'</span>,</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  success(json) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = tranformData(json); <span class="comment">// 适配返回数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="适配转换-Promise"><a href="#适配转换-Promise" class="headerlink" title="适配转换 Promise"></a>适配转换 Promise</h3><p>在 <code>NodeJS</code> 的 <code>fs</code> 模块中有很多异步的方法，比如 <code>readFile</code>，读取文件获取结果后想要继续读取下一个文件，以此类推就产生了 “回调地狱”，代码的可读性和维护性会变差，我们可以通过 “适配器模式” 将这些方法转化为 <code>Promise</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配成 Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="literal">null</span>, ...args, (err, data) =&gt; &#123;</span><br><span class="line">        err ? reject(err) : resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配后的方法</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line">readFile(<span class="string">'index.txt'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// Hello world</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="适配技术栈变更后的旧代码"><a href="#适配技术栈变更后的旧代码" class="headerlink" title="适配技术栈变更后的旧代码"></a>适配技术栈变更后的旧代码</h3><p>在一些老项目是 <code>jQuery</code> 的技术栈，请求也使用的是自带的 <code>$.ajax</code>，如果一天项目中决定移除 <code>jQuery</code>，请求方法 <code>$.ajax</code> 自然也跟着移除了，假设我们想使用 <code>fetch</code> 来代替 <code>$.ajax</code>，则要修改大量的代码，这时 “适配器模式” 可以对 <code>fetch</code> 进行适配，让我们继续沿用 <code>$.ajax</code> 的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="built_in">window</span>.$ = &#123;</span><br><span class="line">  ajax(options) &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(options.url, &#123;</span><br><span class="line">      method: options.type || <span class="string">'GET'</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringifily(options.data || &#123;&#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $.ajax 的旧代码</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'pandashen.com/info'</span>,</span><br><span class="line">  type: <span class="string">'POST'</span>,</span><br><span class="line">  dataType: <span class="string">'json'</span>,</span><br><span class="line">  data: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“适配器模式” 是很常用的设计模式之一，<code>Vue</code> 的 <code>computed</code> 计算属性和 <code>Koa</code> 兼容 <code>1.x</code> 版本和 <code>2.x</code> 版本中间件插件 <code>koa-convert</code> 都应用了 “适配器模式”，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/4.adapter" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/27/20180927230432/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 单例模式</title>
      <link>https://www.overtaking.top/2018/09/26/20180926201447/</link>
      <guid>https://www.overtaking.top/2018/09/26/20180926201447/</guid>
      <pubDate>Wed, 26 Sep 2018 12:14:47 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/26/20180926201447/single.jpg&quot; title=&quot;单例模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/26/20180926201447/single.jpg" title="单例模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/25/20180925190503/" target="_blank">《设计模式 JS 表现 —— 工厂模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li><li><a href="https://www.overtaking.top/2018/10/04/20181004114907/" target="_blank">《设计模式 JS 表现 —— 发布/订阅和观察者模式》</a></li><li><a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">《设计模式 JS 表现 —— 状态模式》</a></li><li><a href="https://www.overtaking.top/2018/10/06/20181006014812/" target="_blank">《设计模式 JS 表现 —— 策略模式》</a></li></ul><h2 id="普通单例模式"><a href="#普通单例模式" class="headerlink" title="普通单例模式"></a>普通单例模式</h2><p>“单例模式” 就是通过类创建实例后，每次创建和获取都返回同一个实例，下面是 “单例模式” 最基本的实现。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/26/20180926201447/singleton-uml.jpg" alt="单例模式 UML 图" title="">                </div>                <div class="image-caption">单例模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>ES6 写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getInstance(name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>.instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = Person.getInstance(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = Person.getInstance(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>ES5 写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = Person.getInstance(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = Person.getInstance(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面分别用 <code>ES6</code> 和 <code>ES5</code> 的方式实现了一个基本的单例模式，创建 <code>Person</code> 的实例时需要通过 <code>getInstance</code> 静态方法，这样第一次会创建一个实例，再次调用时会将之前创建的实例返回，达到单例的目的。</p><blockquote class="pullquote danger"><p><strong>上面单例模式的缺点：</strong></p><p><strong>1、类的使用者必须要知道这是一个单例的类，创建和获取实例必须通过调用 <code>getInstance</code> 方法实现；</strong><br><strong>2、并不能真正阻止类的使用者通过 <code>new</code> 关键字创建出新的实例。</strong></p></blockquote><h2 id="透明单例模式"><a href="#透明单例模式" class="headerlink" title="透明单例模式"></a>透明单例模式</h2><p>“透明单例模式” 可以解决上面普通 “单例模式” 的不足，希望可以直接使用 <code>new</code> 关键字来创建类的实例，如果已经创建，再次通过 <code>new</code> 创建，则会返回之前创建的实例。</p><figure class="highlight js"><figcaption><span>透明单例模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> Person(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> Person(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>“透明单例模式” 的原理是创建一个自执行函数，内部创建一个私有变量 <code>instance</code> 用来存储创建的实例，并通过闭包返回一个构造函数，用变量 <code>Person</code> 接收，当使用 <code>new</code> 创建实例时，先检测私有变量 <code>instance</code> 是否有值，如果没值则创建实例，如果有值则直接返回 <code>instance</code>（利用 <code>new</code> 关键字和构造创建实例的原理实现）。</p><blockquote class="pullquote info"><p><strong>缺点：违反了单一职责原则（一个函数只做一件事），自执行函数返回的构造函数已经不止单纯用作构建实例，同时处理了单例的判断逻辑。</strong></p></blockquote><h2 id="单例与构建分离"><a href="#单例与构建分离" class="headerlink" title="单例与构建分离"></a>单例与构建分离</h2><p>针对上面 “透明单例模式” 的缺点，下面将构造函数单例处理与构建逻辑进行分离。</p><figure class="highlight js"><figcaption><span>单例逻辑与构建逻辑分离</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的构造函数</span></span><br><span class="line"><span class="keyword">const</span> CreatePerson = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> CreatePerson(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> CreatePerson(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码将单例的逻辑与构造函数的逻辑进行了分离，真正用于构造实例的类是 <code>Person</code>，用于处理单例逻辑的是自执行函数返回的函数，使用 <code>CreatePerson</code> 变量接收，这个函数也同时约定好被当做构造函数使用（通过 <code>new</code> 关键字调用和直接执行效果相同）。</p><blockquote class="pullquote primary"><p><strong>缺点：生成的新构造函数名字（<code>CreatePerson</code>）是固定的，用来创建实例的这个类（<code>Person</code>）也是固定的，不够灵活。</strong></p></blockquote><h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>下面支持不同的构造函数创建实例，并且可以使用原本构造函数的对应方法，就是把上面案例不灵活的地方变得灵活。</p><figure class="highlight js"><figcaption><span>封装变化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CreateSingle = <span class="function"><span class="keyword">function</span> (<span class="params">Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> SingleConstructor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      Constructor.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现原型继承</span></span><br><span class="line">  SingleConstructor.prototype = <span class="built_in">Object</span>.create(Constructor.prototype);</span><br><span class="line">  <span class="keyword">return</span> SingleConstructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dailog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'：'</span> + <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dailog.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的构造函数并生成实例</span></span><br><span class="line"><span class="keyword">const</span> CreatePerson = CreateSingle(Person);</span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> CreatePerson(<span class="string">'hello'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> CreatePerson(<span class="string">'world'</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CreateDailog = CreateSingle(Dailog);</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> CreateDailog(<span class="string">'model'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> CreateDailog(<span class="string">'view'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(w1 === w2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面我们把创建单例的逻辑进行了封装变成了一个通用的逻辑，对于不同构造函数所创建实例，只需要传入这个构造函数并生成新的构造函数，需要注意的是，新的构造函数无法继承原构造函数的原型方法，所以通过继承实现的。</p><h2 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在编写代码时，我们有时候需要人为的创建命名空间，以防止变量的相互污染，这是可以使用 “单例模式” 来实现。</p><figure class="highlight js"><figcaption><span>创建命名空间的方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储工具方法</span></span><br><span class="line"><span class="keyword">const</span> utils = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名空间</span></span><br><span class="line">utils.define = <span class="function"><span class="keyword">function</span> (<span class="params">namespace, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取命名空间的数组</span></span><br><span class="line">  <span class="keyword">const</span> namespaces = namespace.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后一项为设定方法的属性名</span></span><br><span class="line">  <span class="keyword">const</span> methodName = namespaces.pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量存储当前命名空间的引用，默认为 utils（根命名空间）</span></span><br><span class="line">  <span class="keyword">let</span> current = utils;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; namespaces.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentNamespace = namespaces[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当某一个命名空间没有时，则创建这个命名空间（单例模式）</span></span><br><span class="line">    <span class="keyword">if</span> (!current[currentNamespace]) &#123;</span><br><span class="line">      current[currentNamespace] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则让当前命名空间指向已有的命名空间</span></span><br><span class="line">    current = current[currentNamespace];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将传入的函数设定给最后一级命名空间的属性上</span></span><br><span class="line">  current[methodName] = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>命名空间的创建和使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过命名空间定义方法</span></span><br><span class="line">utils.define(<span class="string">'dom.class.addClass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dom.class.addClass'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.define(<span class="string">'string.trim'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'string.trim'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.define(<span class="string">'event.prevent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'event.prevent'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">utils.dom.class.addClass(<span class="string">'title'</span>); <span class="comment">// dom.class.addClass</span></span><br><span class="line">utils.string.trim(<span class="string">' hello '</span>); <span class="comment">// string.trim</span></span><br><span class="line">utils.event.prevent(); <span class="comment">// event.prevent</span></span><br></pre></td></tr></table></figure><p>上面代码的设计希望通过 <code>utils</code> 对象的 <code>define</code> 方法按照传入的表示命名空间的字符串去创建方法，基本实现思路和逻辑是，当一个属性是第一次出现时，创建一个对象作为该命名空间，当再次出现时则不会重复创建命名空间（因为会出现覆盖的问题），而是沿用之前创建的命名空间。</p><h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p><code>LRU</code> 全称为 <code>Least Recently Used</code>，为最近使用的意思，缓存的方式为访问一个元素时，则将其标记为活跃，当存储时，如果超出容量则删除最不常用的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(capacity) &#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="keyword">this</span>.members = [];</span><br><span class="line">  &#125;</span><br><span class="line">  put(key, val) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldestIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> oldestAge = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.members.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> member = <span class="keyword">this</span>.members[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.age &gt; oldestAge) &#123;</span><br><span class="line">        oldestAge = member.age;</span><br><span class="line">        oldestIndex = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.key === key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.members[i] = &#123; key, val, <span class="attr">age</span>: <span class="number">0</span> &#125;;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        member.age++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.members.length &gt;= <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.members.splice(oldestIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.members.push(&#123; key, val, <span class="attr">age</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.members.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> member = <span class="keyword">this</span>.members[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (member.key === key) &#123;</span><br><span class="line">        member.age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> member.val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个创建 <code>LRU</code> 缓存的类，用数组管理成员，<code>put</code> 方法用于新增成员，<code>get</code> 方法用于访问成员，当访问成员时，成员的 <code>age</code> 清零，代表最近活跃，当新增元素时，如果该元素已存在，则做覆盖操作，如果不存在，则推入数组中，<code>age</code> 设置为零，其他成员 <code>age</code> 自增，若数组超出容量时，先找到 <code>age</code> 最大的元素删除，再讲新的元素推入数组，上面是一个直观但性能较差的实现，如果有兴趣可以使用链表进行优化。</p><figure class="highlight js"><figcaption><span>使用 LRU 缓存</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'1'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '1', val: 1, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'2'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '1', val: 1, age: 1 &#125;, &#123; key: '2', val: 2, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'3'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '2', val: 2, age: 1 &#125;, &#123; key: '3', val: 3, age: 0 &#125; ]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">'2'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache.members);</span><br><span class="line"><span class="comment">// [ &#123; key: '2', val: 'hello', age: 0 &#125;, &#123; key: '3', val: 3, age: 1 &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>“单例模式” 是设计模式中非常好理解的一个，使用还是非常广泛的，在 <code>Redux</code> 等众多的第三方库中也有所体现，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/3.single" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/26/20180926201447/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 工厂模式</title>
      <link>https://www.overtaking.top/2018/09/25/20180925190503/</link>
      <guid>https://www.overtaking.top/2018/09/25/20180925190503/</guid>
      <pubDate>Tue, 25 Sep 2018 11:05:03 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/25/20180925190503/factory.jpg&quot; title=&quot;工厂模式&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/25/20180925190503/factory.jpg" title="工厂模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</p></blockquote><a id="more"></a><p><strong>其他文章链接如下：</strong></p><ul><li><a href="https://www.overtaking.top/2018/09/26/20180926201447/" target="_blank">《设计模式 JS 表现 —— 单例模式》</a></li><li><a href="https://www.overtaking.top/2018/09/27/20180927230432/" target="_blank">《设计模式 JS 表现 —— 适配器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/28/20180928030105/" target="_blank">《设计模式 JS 表现 —— 装饰器模式》</a></li><li><a href="https://www.overtaking.top/2018/09/29/20180929025641/" target="_blank">《设计模式 JS 表现 —— 代理模式》</a></li><li><a href="https://www.overtaking.top/2018/10/01/20181001165125/" target="_blank">《设计模式 JS 表现 —— 外观模式》</a></li><li><a href="https://www.overtaking.top/2018/10/04/20181004114907/" target="_blank">《设计模式 JS 表现 —— 发布/订阅和观察者模式》</a></li><li><a href="https://www.overtaking.top/2018/10/05/20181005161213/" target="_blank">《设计模式 JS 表现 —— 状态模式》</a></li><li><a href="https://www.overtaking.top/2018/10/06/20181006014812/" target="_blank">《设计模式 JS 表现 —— 策略模式》</a></li></ul><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>“简单工厂模式” 是由一个工厂对象决定创建出哪一种产品类的实例。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/simple-factory-uml.jpg" alt="简单工厂模式 UML 图" title="">                </div>                <div class="image-caption">简单工厂模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>直接创建子类实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  grow() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am growing!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建子类的实例</span></span><br><span class="line"><span class="keyword">let</span> apple = <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line"><span class="keyword">let</span> orange = <span class="keyword">new</span> Orange(<span class="string">'橘子'</span>, <span class="string">'酸'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>上面创建子类实例的方式是直接使用 <code>new</code> 关键字直接创建，这种创建方式使产生的实例和具体的类紧紧的耦合在一起，并依赖于类的具体实现，如果在子类可能随时发生变化的代码中，将对维护造成麻烦，使用 “简单工厂模式” 可以对产生的实例和具体的类进行解耦，且不必关心子类的具体实现和在未来是否发生变化。</p><figure class="highlight js"><figcaption><span>使用简单工厂模式创建子类的实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  grow() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am growing!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create(type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'apple'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'orange'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'no constructor!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简单工厂创建子类实例</span></span><br><span class="line"><span class="keyword">let</span> apple = Factory.create(<span class="string">'apple'</span>);</span><br><span class="line"><span class="keyword">let</span> orange = Factory.create(<span class="string">'orange'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>从上面代码看，我们只需要通过类型就可以得到某一个子类的实例，不需要知道子类是谁，以及具体实现，并在工厂 <code>Factory</code> 中做了错误处理，可以不必担心未来某一个子类发生变化或者被删除的问题。</p><figure class="highlight js"><figcaption><span>简单工厂经典案例 —— jQuery</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery 的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JQuery</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (selector) &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    <span class="keyword">let</span> elements = <span class="built_in">document</span>.querySelectorAll(selector);</span><br><span class="line">    <span class="keyword">this</span>.length = elements.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>[i] = elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>].innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂函数</span></span><br><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 li 标签并调用 html 方法</span></span><br><span class="line"><span class="keyword">let</span> html = $(<span class="string">'li'</span>).html();</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>简单工厂经典案例 —— React 虚拟 DOM</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟 DOM 的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(tagName, attrs, children) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tagName = tagName;</span><br><span class="line">    <span class="keyword">this</span>.attrs = attrs;</span><br><span class="line">    <span class="keyword">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在 React 对象上的简单工厂函数</span></span><br><span class="line">React.createElement = <span class="function"><span class="keyword">function</span> (<span class="params">tagName, attrs, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(tagName, attrs, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><strong>简单工厂模式的缺点：不满足开放封闭原则，内部可以随意修改，新增、修改子类都需要修改工厂类内部代码，在扩展的过程中工厂类的代码将会越来越臃肿。</strong></p></blockquote><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>“工厂方法模式” 可以规避 “简单工厂模式” 的缺点，又称为多态性工厂模式，核心的工厂类不再负责创建出哪一种产品类的实例，而是将具体创建的工作交给子类去做。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/factory-method-uml.jpg" alt="工厂方法模式 UML 图" title="">                </div>                <div class="image-caption">工厂方法模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><figcaption><span>基本的工厂方法模式使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  create () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— OrangeFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrangeFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">let</span> apple = AppleFactory.create();</span><br><span class="line"><span class="keyword">let</span> orange = OrangeFactory.create();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>上面是一个基础的 “工厂方法模式” 使用，解决了 “简单工厂模式” 扩展的问题（遵循开放封闭原则），创建实例虽然不耦合具体的类，但是耦合工厂的子类，下面可以通过文件拆分进行解耦。</p><figure class="highlight js"><figcaption><span>plant.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Plant;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>factory.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  create () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Factory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>apple.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plant = <span class="built_in">require</span>(<span class="string">'./plant'</span>);</span><br><span class="line"><span class="keyword">const</span> Factory = <span class="built_in">require</span>(<span class="string">'./factory'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Apple</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="string">'苹果'</span>, <span class="string">'甜'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = AppleFactory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>orange.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plant = <span class="built_in">require</span>(<span class="string">'./plant'</span>);</span><br><span class="line"><span class="keyword">const</span> Factory = <span class="built_in">require</span>(<span class="string">'./factory'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— Orange</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, flavour) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.flavour = flavour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— OrangeFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrangeFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Orange(<span class="string">'桔子'</span>, <span class="string">'酸'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = OrangeFactory;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>setting.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置文件，将要创建实例的类型与对应的工厂关联起来</span></span><br><span class="line"><span class="keyword">const</span> setting = &#123;</span><br><span class="line">  apple: <span class="string">'./apple'</span>,</span><br><span class="line">  orange: <span class="string">'./orange'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = setting;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>use.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setting = <span class="built_in">require</span>(<span class="string">'./setting'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apple = <span class="built_in">require</span>(setting[<span class="string">'apple'</span>]).create();</span><br><span class="line"><span class="keyword">let</span> orange = <span class="built_in">require</span>(setting[<span class="string">'orange'</span>]).create();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.flavour); <span class="comment">// 甜</span></span><br><span class="line"><span class="built_in">console</span>.log(orange.flavour); <span class="comment">// 酸</span></span><br></pre></td></tr></table></figure><p>使用上面这样的 “工厂方法模式”，扩展时只需要新增一个文件，在文件中定义具体创建实例的类和工厂类就可以了，一般会有一个配置文件将要创建实例的类型和对应的工厂关联起来，创建对应的实例只需通过类型和配置文件找到对应的工厂执行 <code>create</code> 方法即可。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>“抽象工厂模式” 是指当有多个抽象角色时，可以提供一个接口，不必指定 “产品” 具体的情况下，创建多个产品族中的产品对象。</p><p><br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/25/20180925190503/abatract-factory-uml.jpg" alt="抽象工厂模式 UML 图" title="">                </div>                <div class="image-caption">抽象工厂模式 UML 图</div>            </figure><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 —— Icon</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类 —— Button</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— AppleIcon 苹果图标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleIcon</span> <span class="keyword">extends</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Mac 的图标'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— AppleButton 苹果按钮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleButton</span> <span class="keyword">extends</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Mac 的按钮'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— WindowsIcon Windows 图标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsIcon</span> <span class="keyword">extends</span> <span class="title">Icon</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Windows 的图标'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 —— WindowsButton Windows 按钮</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsButton</span> <span class="keyword">extends</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'绘制 Windows 的按钮'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;&#125; <span class="comment">// 创建图标</span></span><br><span class="line">  createButton() &#123;&#125; <span class="comment">// 创建按钮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— AppleFactory 用于创建苹果族产品实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppleIcon();</span><br><span class="line">  &#125;</span><br><span class="line">  createButton() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppleButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂 —— WindowsFactory 用于创建 Windows 族产品实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  createIcon() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowsIcon();</span><br><span class="line">  &#125;</span><br><span class="line">  createButton() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowsButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建苹果工厂实例</span></span><br><span class="line"><span class="keyword">let</span> appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建苹果族产品</span></span><br><span class="line">appleFactory.createIcon().render(); <span class="comment">// 绘制 Mac 的图标</span></span><br><span class="line">appleFactory.createButton().render(); <span class="comment">// 绘制 Mac 的按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Windows 工厂实例</span></span><br><span class="line"><span class="keyword">let</span> wondowsFactory = <span class="keyword">new</span> WindowsFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Windows 族产品</span></span><br><span class="line">wondowsFactory.createIcon().render(); <span class="comment">// 绘制 Windows 的图标</span></span><br><span class="line">wondowsFactory.createButton().render(); <span class="comment">// 绘制 Windows 的按钮</span></span><br></pre></td></tr></table></figure><p>在上面案例中，按照 “抽象工厂模式” 的说法，多个抽象角色指的是 <code>Apple</code> 和 <code>Windows</code>，<code>Icon</code> 和 <code>Button</code>，工厂分为 <code>AppleFactory</code> 和 <code>WindowsFactory</code> 两类，可以分别创建对应产品的 <code>Icon</code> 和 <code>Button</code> 实例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>上面几种工厂模式中，“简单工厂模式” 在框架开发中使用居多，“工厂方法模式” 更多在一些比较老的且复杂的项目中用作业务模块封装和抽象，“抽象工厂模式” 在前端并不常用，应用于后端偏多，最后附上 <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/2.factory" target="_blank">案例地址</a>。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/25/20180925190503/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— Router 4.0 的基本使用</title>
      <link>https://www.overtaking.top/2018/09/21/20180921182754/</link>
      <guid>https://www.overtaking.top/2018/09/21/20180921182754/</guid>
      <pubDate>Fri, 21 Sep 2018 10:27:54 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;/2018/09/21/20180921182754/react-router.png&quot; title=&quot;React Router&quot;&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-路由简介&quot;&gt;&lt;a href=&quot;#React-路由简介&quot; class=&quot;headerlink&quot; title=&quot;React 路由简介&quot;&gt;&lt;/a&gt;React 路由简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，&lt;code&gt;React&lt;/code&gt; 全家桶中也有配套的路由系统，在路由 &lt;code&gt;2.0&lt;/code&gt; 版本时叫做 &lt;code&gt;react-router&lt;/code&gt;，在路由 &lt;code&gt;4.0&lt;/code&gt; 时更名为 &lt;code&gt;react-router-dom&lt;/code&gt;，我们本次就针对较新版本的 &lt;code&gt;Router&lt;/code&gt; 系统进行介绍。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img src="/2018/09/21/20180921182754/react-router.png" title="React Router"><p><br></p><h2 id="React-路由简介"><a href="#React-路由简介" class="headerlink" title="React 路由简介"></a>React 路由简介</h2><blockquote class="pullquote info"><p>在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，<code>React</code> 全家桶中也有配套的路由系统，在路由 <code>2.0</code> 版本时叫做 <code>react-router</code>，在路由 <code>4.0</code> 时更名为 <code>react-router-dom</code>，我们本次就针对较新版本的 <code>Router</code> 系统进行介绍。</p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>为了方便演示如何 <code>Router</code>，我们使用 <code>create-react-app</code> 创建一个 <code>React</code> 项目，并删除 <code>src</code> 文件夹内多余文件，创建我们需要的文件 <code>index.js</code>，目录结构如下。</p><p><pre>react-router<br>  |- public<br>  | |- favicon.ico<br>  | |- index.html<br>  | |- manifest.json<br>  |- src<br>  | |- pages<br>  | | |- Add.js<br>  | | |- Detail.js<br>  | | |- Home.js<br>  | | |- Index.js<br>  | | |- List.js<br>  | | |- Login.js<br>  | | |- Logo.js<br>  | | |- MenuLink.js<br>  | | |- Profile.js<br>  | | |- Protected.js<br>  | | |- User.js<br>  | |- App.js<br>  | |- index.css<br>  | |- index.js<br>  |- .gitignore<br>  |- package.json<br>  |- README.md<br>  |- yarn.lock</pre></p><p>其中主组件为 <code>App</code>，在 <code>index.js</code> 中渲染，<code>index.js</code> 代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>而 <code>App</code> 组件主要用来渲染菜单导航和路由组件，我们将在下面完善代码。</p><h2 id="HashRouter-和-BrowserRouter"><a href="#HashRouter-和-BrowserRouter" class="headerlink" title="HashRouter 和 BrowserRouter"></a>HashRouter 和 BrowserRouter</h2><p>在 <code>React Router</code> 中，给我们提供了一些路由相关的组件，其中最重要的就是实现路由的 <code>HashRouter</code> 和 <code>BrowserRouter</code>，我们知道浏览器的 <code>hash</code> 值发生变化会阻止页面的跳转，而 <code>HashRouter</code> 就是利用这个特性实现的，通过监听 <code>onhanshchange</code> 事件在 <code>hash</code> 值改变的时候做出响应，<code>BrowserRouter</code> 则是利用 <code>H5</code> 的新 <code>History API</code> 的 <code>pushState</code> 方法构造的的历史记录集合来实现的。</p><p>通常情况下，在开发的时候使用 <code>HashRouter</code> 更多，而在真正上线时替换成 <code>BrowserRouter</code>，两种 <code>Router</code> 在地址栏上的表现上区别只是是否含有 <code>#</code>，两种 <code>Router</code> 的使用如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— HashRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* 路由相关代码 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— BrowserRouter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* 路由相关代码 */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>其实就是使用 <code>React Router</code> 中提供的这两种类型的路由组件对路由相关的 <code>JSX</code> 进行包裹。</p><h2 id="Route-和-Link-组件"><a href="#Route-和-Link-组件" class="headerlink" title="Route 和 Link 组件"></a>Route 和 Link 组件</h2><p><code>Route</code> 组件是用来定义路由跳转的切换组件的区域，通过 <code>path</code> 属性定义匹配的路由，<code>component</code> 属性来定义渲染的组件，渲染后就是一个 <code>div</code> 标签，<code>Link</code> 是用来点击跳转路由的，通常用来定义导航栏内容，通过 <code>to</code> 属性设置匹配的路由，需要与 <code>Route</code> 的 <code>path</code> 一一对应，点击后可切换到对应的路由组件，渲染后为一个 <code>a</code> 标签。</p><h3 id="创建路由跳转的组件"><a href="#创建路由跳转的组件" class="headerlink" title="创建路由跳转的组件"></a>创建路由跳转的组件</h3><p>下面我们来创建三个路由对应的组件，分别为首页、用户、个人中心，对应的组件分别为 <code>Home.js</code>、<code>User.js</code>、<code>Profile.js</code></p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Home.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;主页&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;用户&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Profile.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Profile</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;个人中心&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="配合使用-Route-和-Link"><a href="#配合使用-Route-和-Link" class="headerlink" title="配合使用 Route 和 Link"></a>配合使用 Route 和 Link</h3><p>使用 <code>Link</code> 和 <code>Route</code> 配合使用如下，点击 <code>Link</code> 会在类名 <code>container</code> 的元素种加载路由路径对应的组件。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ul className=<span class="string">"nav"</span>&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/profile"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div className="container"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/</span>home<span class="string">" component=&#123;Home&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user<span class="string">" component=&#123;User&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/profile<span class="string">" component=&#123;Profile&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/HashRouter&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>启动项目后上面的代码已经可以帮助我们实现页面路由的切换，但是上面的代码 <code>Link</code> 和 <code>Route</code> 组件混在一起，我们其实可以将 <code>App</code> 拆分成两个组件，一个用来存放 <code>Link</code> 部分，一个用来存放 <code>Route</code> 部分，创建 <code>Index</code> 组件，将 <code>Link</code> 的部分抽取出去，代码修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Index&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;a className=<span class="string">"navbar-brand"</span>&gt;管理系统&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;ul className=<span class="string">"nav"</span>&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/profile"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="container"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修改之后 <code>Index</code> 组件专门用来维护导航组件 <code>Link</code>，<code>App</code> 组件专门用来维护路由组件 <code>Route</code>，这样代码看起来就不那么混乱了。</p><h3 id="Route-组件的-exact-属性"><a href="#Route-组件的-exact-属性" class="headerlink" title="Route 组件的 exact 属性"></a>Route 组件的 exact 属性</h3><p>上面我们所定义的路由为一级路由，在路由匹配并成功加载对应组件后，如果组件又由多个组件组成，并有类似导航的操作（当然不仅限于导航）来控制其他的组件视图的切换，则需要匹配二级路由，这就出现了一个问题，我们以 <code>/user</code> 为例，假设添加一个新的路由 <code>/user/add</code>，那么 <code>React</code> 会由上到下依次匹配，<code>/user/add</code> 中包含 <code>/user</code>，因此会同时渲染两个组件，这不是我们希望的。</p><p>在 <code>React</code> 内部给我们提供了解决方案，就是给路由设置严格匹配，我们只需要让 <code>/user</code> 对应的 <code>Route</code> 组件添加 <code>exact</code> 属性，并将值设置为 <code>true</code> 即可，所以匹配 <code>/user/add</code> 时就不会出现 <code>/user</code> 对应的路由组件也被渲染的情况，当然也可以将 <code>exact</code> 简写到 <code>Route</code> 组件上省略赋值为 <code>true</code> 的过程。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 exact</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Index&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Switch-组件"><a href="#Switch-组件" class="headerlink" title="Switch 组件"></a>Switch 组件</h2><p>因为 <code>React</code> 的路由是由上至下依次进行匹配的，如果有两个同名路由进行匹配，会同时加载两个组件，这也是我们需要优化的，<code>React Router</code> 的 <code>Switch</code> 组件就是来做这件事的，只需要将多个 <code>Route</code> 组件包裹起来，就可以实现只要成功匹配一个路由就不再继续匹配。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Switch 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user/add"</span> component=&#123;User&#125;/&gt; &#123;<span class="comment">/* 同名路由 */</span>&#125;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 <code>Switch</code> 组件优化后，启动项目就可以发现只渲染了一个 <code>User</code> 组件。</p><h2 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a>Redirect 组件</h2><p>在 <code>React</code> 开发中经常遇到路径输入错误的情况，通常情况有两种处理方式，第一种是跳转到一个 <code>404</code> 页面，第二种方式是将页面路由重定向到主页，而 <code>React Router</code> 提供的 <code>Redirect</code> 组件就是帮助我们在所有路由都匹配失败时重定向的，使用时通常放在最后一个 <code>Route</code> 组件的下面用来 “兜底”，使用 <code>to</code> 属性来定义重定向的路由。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Redirect 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt; &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>注意：不能放在 <code>Route</code> 组件的上面，因为放在上面不会匹配任何的路由，而会直接重定向到设置的页面。</strong></em></p></blockquote><p>对于路由都没有匹配而返回 <code>404</code> 页面我们这里也简单说一下，但是这样的用法非常少，使用 <code>Redirect</code> 重定向到指定页面的方式会更多一些。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 匹配失败跳转 404 页面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> component=&#123;<span class="built_in">Error</span>&#125;/&gt; &#123;<span class="comment">/* Error 组件代表 404 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>由于其他的路由都匹配失败，最后会和 <code>/</code> 匹配，所以会显示 <code>Error</code> 组件，这里的 <code>Route</code> 的组件也必须放在最下面来 “兜底”。</p><h2 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h2><h3 id="实现二级路由"><a href="#实现二级路由" class="headerlink" title="实现二级路由"></a>实现二级路由</h3><p>在了解 <code>React Router</code> 的基本使用后，我们用同样的知识点来给 <code>User</code> 组件写一个二级路由，<code>User</code> 中有一个子导航，分别对应用户列表 <code>List</code> 组件和添加用户 <code>Add</code> 组件，代码的套路与之前相同。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="解决默认路径不匹配的问题"><a href="#解决默认路径不匹配的问题" class="headerlink" title="解决默认路径不匹配的问题"></a>解决默认路径不匹配的问题</h3><p>当通过 <code>React Router</code> 访问 <code>/user</code> 的时候，会先加载 <code>User</code> 组件，再加载 <code>User</code> 内部的组件包括子导航，但是 <code>/user</code> 的路径既没有和 <code>/user/add</code> 匹配，也没有和 <code>/user/list</code> 匹配，这样渲染了一个空的类名为 <code>sub-containe</code> 的 <code>div</code> 标签，我们应该让 <code>User</code> 组件加载时子路由默认可以匹配一个路由组件，解决方式如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— Redirect 组件重定向的方式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Redirect to="</span>/user/list<span class="string">"/&gt; &#123;/* 重定向到 List 组件 */&#125;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的方式是使用 <code>Redirect</code> 组件重定向的方式实现的，但是这样访问的 <code>/user</code>，路径会自动改变为 <code>/user/list</code>，感觉上有一些奇怪，当然还有另外的解决方式。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— Route 组件严格匹配</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser<span class="string">" exact component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的方式是当匹配到了 <code>/user</code> 的路由也加载默认要渲染的 <code>List</code> 组件实现的，但是为了防止向下继续匹配，可以添加 <code>exact</code> 设置严格匹配，进一步优化可以使用 <code>Switch</code> 组件，让路由成功匹配一次后不再向下匹配。</p><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>我们经常会遇到一个场景，就是在某些交互之后实现页面的自动跳转，而对于 <code>React</code> 搭建的单页面应用来说就是路由切换，在 <code>React</code> 中都最初是通过 <code>Link</code> 组件的点击手动实现的路由切换，那么怎么通过纯编程的方式在某些交互后自动切换路由呢，其实 <code>React Router</code> 的 <code>Route</code> 组件会给内部渲染的组件传递路由相关的三个参数 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>三个属性值均为对象，<code>history</code> 上存储了 <code>length</code> 属性代表当前支持存入历史记录的数量，也同样存储了 <code>location</code>，用来存储路由路径的相关信息，还有用来操作路由跳转的方法 <code>go</code>（传入数字代表前进或后退几页）、<code>goBack</code>（后退）、<code>goForward</code>（前进）、<code>replace</code>（用其他路由替换当前历史）、<code>push</code>，其中最常用的就是 <code>push</code> 方法，下面会着重介绍，<code>match</code> 中存储了一些路由匹配的相关信息，如 <code>url</code>，即浏览器输入的路径，真正匹配的路径 <code>path</code> 属性以及是代表否严格匹配的 <code>isExact</code> 属性，在 <code>match</code> 中最重要的是 <code>params</code> 属性，值为对象，用来存储路由参数，这个我们放在后面来说。</p><p>下面在 <code>Add</code> 组件中添加一输入框和按钮，当点击按钮是将输入框的数据存入 <code>localStorage</code> 中，并自动将路由跳转到 <code>/user/list</code>，即渲染 <code>List</code> 组件，然后将数据取出渲染到 <code>List</code> 组件中，这是一个很常见的需求，添加数据然后跳到详情页的场景，下面是 <code>Add</code> 组件中的实现。</p><figure class="highlight js"><figcaption><span>路径：&#126;react-router/src/pages/Add.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  input = React.createRef() <span class="comment">// 非受控组件取值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单提交事件</span></span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault(); <span class="comment">// 取消默认的页面跳转事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从 localStorage 获取已有数据</span></span><br><span class="line">    <span class="keyword">const</span> lists = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新数据</span></span><br><span class="line">    lists.push(&#123;</span><br><span class="line">      id: lists.length + <span class="number">1</span>,</span><br><span class="line">      username: <span class="keyword">this</span>.input.current.value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入 localStorage</span></span><br><span class="line">    localStorage.setItem(<span class="string">'lists'</span>, <span class="built_in">JSON</span>.stringify(lists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编程式导航，自动跳转到 List</span></span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/user/list'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;form className=<span class="string">"form"</span> onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">          &lt;label htmlFor=<span class="string">"username"</span> className=<span class="string">"control-label"</span>&gt;用户名&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input</span></span><br><span class="line"><span class="regexp">            className="form-control"</span></span><br><span class="line"><span class="regexp">            type="text"</span></span><br><span class="line"><span class="regexp">            id="username"</span></span><br><span class="line"><span class="regexp">            ref=&#123;this.input&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          &lt;br/&gt;</span><br><span class="line">          &lt;input type=<span class="string">"submit"</span> className=<span class="string">"btn btn-success"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们通过 <code>Route</code> 传递给渲染组件的 <code>history</code> 的 <code>push</code> 方法实现了路由的自动跳转，<code>push</code> 方法接收的参数就是将要跳转的路径字符串，<code>List</code> 组件代码如下。</p><figure class="highlight js"><figcaption><span>路径：&#126;react-router/src/pages/List.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">    <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                  &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;td&gt;&#123;username&#125;&lt;/</span>td&gt;</span><br><span class="line">                &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">              )</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tbody&gt;</span><br><span class="line">      &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>取出 <code>localStorage</code> 中的数据在 <code>List</code> 中渲染时有两点注意，第一是取出数据和设置状态应该在 <code>render</code> 渲染 <code>JSX</code> 之前，这样在没有执行 <code>render</code> 时会合并状态并只渲染一次，也就是说 <code>componentWillMount</code> “钩子” 和 <code>render</code> “钩子” 的 <code>return</code> 语句前更新状态都是可以的，如果在 <code>componentDidMount</code> “钩子” 中更新会导致组件渲染两次，在 <code>React</code> 开发中如果获取数据的过程是同步的（<code>localStorage</code> 取值是同步的），不需要渲染两次。</p><p>第二点是在使用表格元素 <code>table</code> 渲染时，必须要含有 <code>thead</code> 和 <code>tbody</code>，这是 <code>React</code> 规定的，不可以省略。</p><h2 id="路由参数的传递"><a href="#路由参数的传递" class="headerlink" title="路由参数的传递"></a>路由参数的传递</h2><p>现在在我们的 <code>List</code> 组件表格中，点击每一行都可以跳转到学生 <code>ID</code> 对应的详情 <code>Detail</code> 组件中，由于每一个学生的 <code>ID</code> 不同渲染的详情也不相同，此时需要将学生 <code>ID</code> 作为路由参数进行传递，并在 <code>Detail</code> 内渲染对应的内容，由于 <code>Detail</code> 组件的渲染与 <code>List</code> 组件是同一区域，所以仍然是二级路由，我们需要在 <code>User</code> 组件中进行添加。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/User.js —— 增加 Detail 二级路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Add <span class="keyword">from</span> <span class="string">'./Add'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>;</span><br><span class="line"><span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">'./Detail'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"sub-nav"</span>&gt;</span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/list"</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/user/add"</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="sub-container"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route path="/u</span>ser<span class="string">" exact component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/list<span class="string">" component=&#123;List&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/add<span class="string">" component=&#123;Add&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/user/detail/:id<span class="string">" component=&#123;Detail&#125;/&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>React Router</code> 中，我们通过给路由后面添加 <code>/:paramname</code> 的方式添加参数，也可以通过 <code>/:paramname/:paramname</code> 传递多个参数（形参），由于在 <code>List</code> 中点击表格的的某行的单元格跳转路由，所以 <code>List</code> 组件修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">    <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                  &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                    &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;td&gt;&lt;Link to=&#123;`/u</span>ser/detail/$&#123;id&#125;<span class="string">`&#125;&gt;&#123;username&#125;&lt;/Link&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                  &lt;/tr&gt;</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">              &#125;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &lt;/tbody&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>List</code> 组件中，同样使用 <code>Link</code> 组件对要点击切换路由的节点进行包裹，并用 <code>to</code> 属性设置跳转的路由和路由参数（实参），现在点击就可以实现从 <code>List</code> 组件到 <code>Detail</code> 组件的切换，如果我们有些 <code>List</code> 的数据想在跳转到 <code>Detail</code> 组件时直接带过去，则可以使用另一种写法如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数和数据</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">      <span class="comment">// 取出 localStorage 数据并更新状态</span></span><br><span class="line">      <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; users &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;用户 ID&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;用户名&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">this</span>.state.users.map(<span class="function">(<span class="params">&#123; id, username &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;tr key=&#123;id&#125;&gt;</span><br><span class="line">                  &lt;td&gt;&#123;id&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;td&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;Link to=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                      pathname: `/u</span>ser/detail/$&#123;id&#125;<span class="string">`,</span></span><br><span class="line"><span class="string">                      state: username</span></span><br><span class="line"><span class="string">                    &#125;&#125;&gt;&#123;username&#125;&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                  &lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;/tr&gt;</span></span><br><span class="line"><span class="string">              )</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &lt;/tbody&gt;</span></span><br><span class="line"><span class="string">      &lt;/table&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>不同的是给 <code>to</code> 属性传入的值从一个代表路由的字符串变成了一个对象，而把路由的字符串作为了 <code>pathname</code> 属性的值，<code>state</code> 属性则代表了路由跳转传给渲染组件的数据，还记得渲染的组件使用 <code>Route</code> 组件包裹的，会传入 <code>history</code>、<code>loacltion</code> 和 <code>match</code> 三个属性，同样的，通过点击 <code>Link</code> 传递的路由参数和数据都可以在 <code>props</code> 上获取到，前者通过 <code>location.state</code> 或者 <code>history.location.state</code> 上获取到，后者可以通过 <code>match.params</code> 上获取到，那么 <code>Detail</code> 组件将传递过来的参数渲染，代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Detail.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Detail</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">user</span>: &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="comment">// 有值说明是点击过来的，否则是地址栏输入的</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">this</span>.props.location.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由参数</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.match.params.id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是点击过来的直接将数据设置给 state，否则去 localStorage 取值设置给 state</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: &#123; id, <span class="attr">username</span>: data &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> users = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'lists'</span>)) || [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> user = users.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: &#123; id, <span class="attr">username</span>: user.username &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.user.id&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt; ------- &lt;/</span>span&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.user.username&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote warning"><p><em><strong>这里有两点注意点，首先通过组件 <code>props.match.params</code> 获取的路由参数都是字符串格式，如果原本类型为数字，使用时应转换成数字类型，其次是传递的数据，也就是组件通过 <code>props.location.state</code> 获取的数据，只有在通过 <code>Link</code>组件点击过去才会存在，在地址栏输入为 <code>undefined</code>，所以防止用户刷新页面导致数据丢失，应该在两种情况下处理不同的获取数据的逻辑。</strong></em></p></blockquote><h2 id="withRouter-函数"><a href="#withRouter-函数" class="headerlink" title="withRouter 函数"></a>withRouter 函数</h2><p>在之前的编程式导航中我们使用了 <code>Route</code> 传递给渲染组件的 <code>props.history.push</code> 方法实现的，现在假设我们要对一个不是路由跳转的组件，通过点击事件来获取 <code>history</code>、<code>location</code> 和 <code>match</code> 属性，并使用 <code>history</code> 上的路由设置方法进行跳转路由，这应该如何实现呢？</p><p>其实 <code>React Route</code> 给我们提供了一个函数 <code>withRouter</code> 方法，在调用该方法时，则会返回一个新的组件，当然其实这是一个高阶组件的应用，<code>withRouter</code> 方法内部帮我们在传入的组件外层包装了一层 <code>Route</code> 组件，并传入了 <code>history</code>、<code>location</code> 和 <code>match</code> 属性作为参数，所以当我们使用返回的组件时可以通过 <code>props</code> 属性获取 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>下面针对我们之前的 <code>Index</code> 组件的内的 “管理系统” 的标签抽出一个新的组件，并将这个组件添加点击可以跳转到登录页 <code>Login</code> 组件的功能，<code>Login</code> 组件为一级路由，所以我们应该修改 <code>App</code> 组件，添加一个 <code>/login</code> 的路由，<code>Login</code> 和修改后的 <code>App</code> 组件如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加 Login 组件路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/Login'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;/&gt; &#123;<span class="comment">/* 添加登录页路由 */</span>&#125;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt; &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Login.js —— 添加登录和退出功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'login'</span>, <span class="string">'ok'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.removeItem(<span class="string">'login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>Login</code> 中顺便添加了两个按钮来模拟 “登录” 和 “退出”，并给按钮添加了事件，在登录时向 <code>localStorage</code> 中添加 <code>login</code> 属性，在退出时清除这个属性，以模拟登录状态。</p><p>抽取出 <code>Logo</code> 后的 <code>Index</code> 组件也应该添加一个新的导航为 “登录”，<code>Login</code> 组件和修改后的 <code>Index</code> 组件如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 抽出 Logo 组件并添加登录导航</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;Link to="/</span>home<span class="string">"&gt;首页&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/user<span class="string">"&gt;用户&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/profile<span class="string">"&gt;个人中心&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="</span>/login<span class="string">"&gt;登录&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Logo.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  change = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"navbar-brand"</span> onClick=&#123;<span class="keyword">this</span>.change&#125;&gt;管理系统&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Logo);</span></span><br></pre></td></tr></table></figure><p>通过 <code>Logo</code> 案例的代码我们可以看出，其实最后导出的并不是 <code>Logo</code> 组件，而是使用 <code>withRouter</code> 函数包装后返回的高阶组件，<code>withRouter</code> 方法内部帮我们搞定了 <code>Logo</code> 组件的 <code>props</code> 没有 <code>history</code>、<code>location</code> 和 <code>match</code> 属性的问题。</p><h2 id="受保护的路由"><a href="#受保护的路由" class="headerlink" title="受保护的路由"></a>受保护的路由</h2><p>以前在点击个人中心时会直接渲染 <code>Profile</code> 组件，在给 <code>Login</code> 组件添加 “登录” 和 “退出” 之后，再次点击个人中心时，应该先对登录状态进行验证，如果 <code>localStorage</code> 中存在 <code>login</code> 属性，则渲染 <code>Profile</code> 的 <code>Route</code> 组件，否则重定向到登录页，如果在登录页点击登录后再重新跳回个人中心（从哪来回哪去）。</p><p>这就需要我对 <code>App</code> 组件路由部分的代码进行修改，使用高阶组件来添加登录验证逻辑，当然，这个高阶组件不是 <code>React Router</code> 提供的，需要我们自己来实现，这种做法被官方称作 “受保护的路由”。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/App.js —— 添加受保护的路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./pages/Index'</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/Login'</span>;</span><br><span class="line"><span class="keyword">import</span> Protected <span class="keyword">from</span> <span class="string">'./pages/Protected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Index&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/user"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;User&#125;/&gt;</span><br><span class="line">            &#123;<span class="comment">/* 添加受保护的路由 */</span>&#125;</span><br><span class="line">            &lt;Protected path=<span class="string">"/profile"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;/&gt;</span><br><span class="line">            &#123;<span class="comment">/* 无法匹配路由时重定向 */</span>&#125;</span><br><span class="line">            &lt;Redirect to=<span class="string">"/home"</span>/&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Index&gt;</span><br><span class="line">      &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们重写了 <code>App</code> 组件中个人中心对应的路由，将原来的 <code>Route</code> 组件用高阶组件 <code>Protected</code> 代替，也就等于是将原本传入的参数 <code>path</code> 和 <code>component</code> 传入了高阶组件 <code>Protected</code>，下面来看一下高阶组件 <code>Protected</code> 的实现。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Protected.js —— 添加受保护的路由</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Protected</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> login = localStorage.getItem(<span class="string">'login'</span>);</span><br><span class="line">    <span class="keyword">return</span> login ?</span><br><span class="line">    &lt;Route &#123;...this.props&#125;/&gt; :</span><br><span class="line">    &lt;Redirect to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">'/login'</span>, <span class="attr">state</span>: &#123; <span class="string">'from'</span>: <span class="string">'/profile'</span> &#125;&#125;&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Protected</code> 获取登录状态，存在时直接渲染了 <code>Route</code> 组件，并将 <code>path</code> 和 <code>component</code> 参数传入，如果不存在则渲染 <code>Redirect</code> 组件重定向到登录页，传入的参数同 <code>Link</code> 组件的规则相同，<code>pathname</code> 代表重定向的路径，<code>state</code> 代表带过去的数据，我们这里添加了一个 <code>from</code> 属性，用来记录渲染登录页的来源，即个人中心。</p><p>接下来就是 <code>Login</code> 组件中在点击登录后验证是否存在 <code>state</code>，如果存在则返回存储的 <code>from</code> 对应的路由，即个人中心，不存在则跳回首页，<code>Login</code> 修改如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Login.js —— 完善登录功能</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'login'</span>, <span class="string">'ok'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一个路由传递的 state</span></span><br><span class="line">    <span class="keyword">const</span> prevPathDate = <span class="keyword">this</span>.props.location.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在 state 则返回来源对应的页面，否则回主页</span></span><br><span class="line">    <span class="keyword">if</span> (prevPathDate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(prevPathDate.from);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(<span class="string">'/home'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localStorage.removeItem(<span class="string">'login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.exit&#125;&gt;退出&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样 “受保护的路由” 功能就实现了，其实就是在跳转路由之前起到了一个 “拦截” 的作用，经常的使用场景是权限管理，这是一个路由的应用，也是一个高阶组件的应用，这样的应用在大型复杂的 <code>React</code> 中会频繁使用，还是比较重要的。</p><h2 id="NavLink-组件"><a href="#NavLink-组件" class="headerlink" title="NavLink 组件"></a>NavLink 组件</h2><p>在实际项目开发中，我们经常遇到导航标签被选中时被添加一个代表 “激活” 的类名，用于添加与其他导航选项不同的样式，<code>React Router</code> 已经给我们提供了 <code>NavLink</code> 组件用于实现这个功能，<code>NavLink</code> 组件具备 <code>Link</code> 组件所有的功能，唯一不同的就是 <code>NavLink</code> 组件在被选中时不止发生路由跳转，还会给渲染后的 <code>a</code> 标签添加一个名为 <code>active</code> 的 <code>class</code> 属性，而我们只需要通过 <code>css</code> 去给类名 <code>active</code> 设置样式即可。</p><figure class="highlight css"><figcaption><span>路径：&#126;react-router/src/index.css —— 激活样式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好激活样式以后，我们只需要在 <code>Index</code> 组件中引入激活样式的 <code>css</code> 文件并将 <code>Link</code> 组件替换成 <code>NavLink</code> 组件即可。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入激活样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;NavLink to="/</span>home<span class="string">"&gt;首页&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/user<span class="string">"&gt;用户&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/profile<span class="string">"&gt;个人中心&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;NavLink to="</span>/login<span class="string">"&gt;登录&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="自定义导航组件实现激活"><a href="#自定义导航组件实现激活" class="headerlink" title="自定义导航组件实现激活"></a>自定义导航组件实现激活</h2><p><code>React Router</code> 在给我们提供的导航组件 <code>NavLink</code> 功能有限，只会给内部的 <code>a</code> 标签在选中时添加 <code>active</code> 类名，如果我们想实现给一个 <code>li</code> 标签添加 <code>active</code> 就需要我们自己封装一个组件来实现这个功能，其实还是通过高阶组件来实现的，首先我们定义这个高阶组件的名字为 <code>MenuLink</code>，将 <code>Index</code> 组件中的 <code>li</code> 标签和 <code>NavLink</code> 组件统一替换成 <code>MenuLink</code> 组件，代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/Index.js —— 将 Link 修改为 NavLink</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./Logo'</span>;</span><br><span class="line"><span class="keyword">import</span> MenuLink <span class="keyword">from</span> <span class="string">'./MenuLink'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Logo&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul className="nav"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;MenuLink to="/</span>home<span class="string">"&gt;首页&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/user<span class="string">"&gt;用户&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/profile<span class="string">"&gt;个人中心&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">        &lt;MenuLink to="</span>/login<span class="string">"&gt;登录&lt;/MenuLink&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;div className="</span>container<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在实现 <code>MenuLink</code> 组件之前我们分析一下实现思路，首先我们依然模拟 <code>NavLink</code> 的方式给 <code>MenuLink</code> 传入了 <code>to</code> 属性，值为将要跳转的路由，所以我们应该在 <code>MenuLink</code> 组件中来接收这个路由，而 <code>MenuLink</code> 内部一定是包含 <code>li</code> 和 <code>Link</code> 组件的，我们可以将这个 <code>to</code> 属性传递给 <code>Link</code> 组件，如果想要通过激活状态给外层的 <code>li</code> 标签设置状态我们需要知道是否匹配了路由，并可以通过 <code>match</code> 属性获得，所以在 <code>li</code> 的外层应该有 <code>Route</code> 组件配合，因为只有 <code>Route</code> 组件才会将 <code>history</code>、<code>location</code> 和 <code>match</code> 作为参数传递给其内部渲染的组件。</p><p>这就要说到 <code>Route</code> 组件的渲染模式，在传入 <code>component</code> 属性时，只有匹配组件才会渲染内部组件，我们显然是需要时时刻刻都渲染内部的 <code>li</code> 和 <code>Link</code>，并通过点击 <code>Link</code> 渲染真正的路由组件，所以我们需要用到第二种渲染方式，就是通过 <code>children</code> 属性指定时刻需要渲染的组件，实现代码如下。</p><figure class="highlight jsx"><figcaption><span>路径：&#126;react-router/src/pages/MenuLink.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Route path=&#123;<span class="keyword">this</span>.props.to&#125; children=&#123;(&#123; match &#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;li className=&#123;match ? <span class="string">'active'</span> : <span class="string">''</span>&#125;&gt;</span><br><span class="line">            &lt;Link to=&#123;<span class="keyword">this</span>.props.to&#125;&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>li&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中由于 <code>children</code> 组件并不需要操作状态和使用生命周期 “钩子”，所以我们直接使用了函数组件实现，因为 <code>active</code> 类名添加给了 <code>li</code>，所以我们需要在 <code>MenuLink</code> 组件中引入样式文件 <code>index.css</code> 并将修改，代码如下。</p><figure class="highlight css"><figcaption><span>路径：&#126;react-router/src/index.css —— 激活样式修改后</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-class">.active</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p>本篇通过一个简单的案例使用了由 <code>React Router</code> 所提供的，开发中常用的功能，但美中不足的是并没有使用一些 <code>UI</code> 库或者 <code>CSS</code> 样式来美化，为了更明显的看到 <code>React Router</code> 各个功能使用后的效果，建议大家在实现上面代码的同时自己添加一些 <code>CSS</code> 样式。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/2018/09/21/20180921182754/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
